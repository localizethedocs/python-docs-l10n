# SOME DESCRIPTIVE TITLE.
# Copyright (C) 1990-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.1\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-11 04:41+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../library/pickle.rst:2
msgid ":mod:`pickle` --- Python object serialization"
msgstr ""

#: ../../../library/pickle.rst:18
msgid ""
"The :mod:`pickle` module implements a fundamental, but powerful algorithm "
"for serializing and de-serializing a Python object structure.  \"Pickling\" "
"is the process whereby a Python object hierarchy is converted into a byte "
"stream, and \"unpickling\" is the inverse operation, whereby a byte stream "
"is converted back into an object hierarchy.  Pickling (and unpickling) is "
"alternatively known as \"serialization\", \"marshalling,\" [#]_ or "
"\"flattening\", however, to avoid confusion, the terms used here are "
"\"pickling\" and \"unpickling\".."
msgstr ""

#: ../../../library/pickle.rst:28
msgid ""
"The :mod:`pickle` module is not intended to be secure against erroneous or "
"maliciously constructed data.  Never unpickle data received from an "
"untrusted or unauthenticated source."
msgstr ""

#: ../../../library/pickle.rst:34
msgid "Relationship to other Python modules"
msgstr ""

#: ../../../library/pickle.rst:36
msgid ""
"The :mod:`pickle` module has an transparent optimizer (:mod:`_pickle`) "
"written in C.  It is used whenever available.  Otherwise the pure Python "
"implementation is used."
msgstr ""

#: ../../../library/pickle.rst:40
msgid ""
"Python has a more primitive serialization module called :mod:`marshal`, but "
"in general :mod:`pickle` should always be the preferred way to serialize "
"Python objects.  :mod:`marshal` exists primarily to support Python's :file:`."
"pyc` files."
msgstr ""

#: ../../../library/pickle.rst:45
msgid ""
"The :mod:`pickle` module differs from :mod:`marshal` in several significant "
"ways:"
msgstr ""

#: ../../../library/pickle.rst:47
msgid ""
"The :mod:`pickle` module keeps track of the objects it has already "
"serialized, so that later references to the same object won't be serialized "
"again. :mod:`marshal` doesn't do this."
msgstr ""

#: ../../../library/pickle.rst:51
msgid ""
"This has implications both for recursive objects and object sharing.  "
"Recursive objects are objects that contain references to themselves.  These "
"are not handled by marshal, and in fact, attempting to marshal recursive "
"objects will crash your Python interpreter.  Object sharing happens when "
"there are multiple references to the same object in different places in the "
"object hierarchy being serialized.  :mod:`pickle` stores such objects only "
"once, and ensures that all other references point to the master copy.  "
"Shared objects remain shared, which can be very important for mutable "
"objects."
msgstr ""

#: ../../../library/pickle.rst:60
msgid ""
":mod:`marshal` cannot be used to serialize user-defined classes and their "
"instances.  :mod:`pickle` can save and restore class instances "
"transparently, however the class definition must be importable and live in "
"the same module as when the object was stored."
msgstr ""

#: ../../../library/pickle.rst:65
msgid ""
"The :mod:`marshal` serialization format is not guaranteed to be portable "
"across Python versions.  Because its primary job in life is to support :file:"
"`.pyc` files, the Python implementers reserve the right to change the "
"serialization format in non-backwards compatible ways should the need arise. "
"The :mod:`pickle` serialization format is guaranteed to be backwards "
"compatible across Python releases."
msgstr ""

#: ../../../library/pickle.rst:72
msgid ""
"Note that serialization is a more primitive notion than persistence; "
"although :mod:`pickle` reads and writes file objects, it does not handle the "
"issue of naming persistent objects, nor the (even more complicated) issue of "
"concurrent access to persistent objects.  The :mod:`pickle` module can "
"transform a complex object into a byte stream and it can transform the byte "
"stream into an object with the same internal structure.  Perhaps the most "
"obvious thing to do with these byte streams is to write them onto a file, "
"but it is also conceivable to send them across a network or store them in a "
"database.  The module :mod:`shelve` provides a simple interface to pickle "
"and unpickle objects on DBM-style database files."
msgstr ""

#: ../../../library/pickle.rst:85
msgid "Data stream format"
msgstr ""

#: ../../../library/pickle.rst:91
msgid ""
"The data format used by :mod:`pickle` is Python-specific.  This has the "
"advantage that there are no restrictions imposed by external standards such "
"as XDR (which can't represent pointer sharing); however it means that non-"
"Python programs may not be able to reconstruct pickled Python objects."
msgstr ""

#: ../../../library/pickle.rst:96
msgid ""
"By default, the :mod:`pickle` data format uses a compact binary "
"representation. The module :mod:`pickletools` contains tools for analyzing "
"data streams generated by :mod:`pickle`."
msgstr ""

#: ../../../library/pickle.rst:100
msgid ""
"There are currently 4 different protocols which can be used for pickling."
msgstr ""

#: ../../../library/pickle.rst:102
msgid ""
"Protocol version 0 is the original human-readable protocol and is backwards "
"compatible with earlier versions of Python."
msgstr ""

#: ../../../library/pickle.rst:105
msgid ""
"Protocol version 1 is the old binary format which is also compatible with "
"earlier versions of Python."
msgstr ""

#: ../../../library/pickle.rst:108
msgid ""
"Protocol version 2 was introduced in Python 2.3.  It provides much more "
"efficient pickling of :term:`new-style class`\\es."
msgstr ""

#: ../../../library/pickle.rst:111
msgid ""
"Protocol version 3 was added in Python 3.0.  It has explicit support for "
"bytes and cannot be unpickled by Python 2.x pickle modules.  This is the "
"current recommended protocol, use it whenever it is possible."
msgstr ""

#: ../../../library/pickle.rst:115
msgid ""
"Refer to :pep:`307` for information about improvements brought by protocol "
"2.  See :mod:`pickletools`'s source code for extensive comments about "
"opcodes used by pickle protocols."
msgstr ""

#: ../../../library/pickle.rst:121
msgid "Module Interface"
msgstr ""

#: ../../../library/pickle.rst:123
msgid ""
"To serialize an object hierarchy, you first create a pickler, then you call "
"the pickler's :meth:`dump` method.  To de-serialize a data stream, you first "
"create an unpickler, then you call the unpickler's :meth:`load` method.  "
"The :mod:`pickle` module provides the following constant:"
msgstr ""

#: ../../../library/pickle.rst:131
msgid ""
"The highest protocol version available.  This value can be passed as a "
"*protocol* value."
msgstr ""

#: ../../../library/pickle.rst:136
msgid ""
"The default protocol used for pickling.  May be less than HIGHEST_PROTOCOL. "
"Currently the default protocol is 3; a backward-incompatible protocol "
"designed for Python 3.0."
msgstr ""

#: ../../../library/pickle.rst:141
msgid ""
"The :mod:`pickle` module provides the following functions to make the "
"pickling process more convenient:"
msgstr ""

#: ../../../library/pickle.rst:146
msgid ""
"Write a pickled representation of *obj* to the open :term:`file object` "
"*file*. This is equivalent to ``Pickler(file, protocol).dump(obj)``."
msgstr ""

#: ../../../library/pickle.rst:149 ../../../library/pickle.rst:171
#: ../../../library/pickle.rst:255
msgid ""
"The optional *protocol* argument tells the pickler to use the given "
"protocol; supported protocols are 0, 1, 2, 3.  The default protocol is 3; a "
"backward-incompatible protocol designed for Python 3.0."
msgstr ""

#: ../../../library/pickle.rst:153 ../../../library/pickle.rst:175
#: ../../../library/pickle.rst:259
msgid ""
"Specifying a negative protocol version selects the highest protocol version "
"supported.  The higher the protocol used, the more recent the version of "
"Python needed to read the pickle produced."
msgstr ""

#: ../../../library/pickle.rst:157 ../../../library/pickle.rst:263
msgid ""
"The *file* argument must have a write() method that accepts a single bytes "
"argument.  It can thus be an on-disk file opened for binary writing, a :"
"class:`io.BytesIO` instance, or any other custom object that meets this "
"interface."
msgstr ""

#: ../../../library/pickle.rst:162 ../../../library/pickle.rst:179
#: ../../../library/pickle.rst:267
msgid ""
"If *fix_imports* is True and *protocol* is less than 3, pickle will try to "
"map the new Python 3.x names to the old module names used in Python 2.x, so "
"that the pickle data stream is readable with Python 2.x."
msgstr ""

#: ../../../library/pickle.rst:168
msgid ""
"Return the pickled representation of the object as a :class:`bytes` object, "
"instead of writing it to a file."
msgstr ""

#: ../../../library/pickle.rst:185
msgid ""
"Read a pickled object representation from the open :term:`file object` "
"*file* and return the reconstituted object hierarchy specified therein.  "
"This is equivalent to ``Unpickler(file).load()``."
msgstr ""

#: ../../../library/pickle.rst:189 ../../../library/pickle.rst:211
msgid ""
"The protocol version of the pickle is detected automatically, so no protocol "
"argument is needed.  Bytes past the pickled object's representation are "
"ignored."
msgstr ""

#: ../../../library/pickle.rst:193
msgid ""
"The argument *file* must have two methods, a read() method that takes an "
"integer argument, and a readline() method that requires no arguments.  Both "
"methods should return bytes.  Thus *file* can be an on-disk file opened for "
"binary reading, a :class:`io.BytesIO` object, or any other custom object "
"that meets this interface."
msgstr ""

#: ../../../library/pickle.rst:199 ../../../library/pickle.rst:215
#: ../../../library/pickle.rst:312
msgid ""
"Optional keyword arguments are *fix_imports*, *encoding* and *errors*, which "
"are used to control compatibility support for pickle stream generated by "
"Python 2.x.  If *fix_imports* is True, pickle will try to map the old Python "
"2.x names to the new names used in Python 3.x.  The *encoding* and *errors* "
"tell pickle how to decode 8-bit string instances pickled by Python 2.x; "
"these default to 'ASCII' and 'strict', respectively."
msgstr ""

#: ../../../library/pickle.rst:208
msgid ""
"Read a pickled object hierarchy from a :class:`bytes` object and return the "
"reconstituted object hierarchy specified therein"
msgstr ""

#: ../../../library/pickle.rst:223
msgid "The :mod:`pickle` module defines three exceptions:"
msgstr ""

#: ../../../library/pickle.rst:227
msgid ""
"Common base class for the other pickling exceptions.  It inherits :exc:"
"`Exception`."
msgstr ""

#: ../../../library/pickle.rst:232
msgid ""
"Error raised when an unpicklable object is encountered by :class:`Pickler`. "
"It inherits :exc:`PickleError`."
msgstr ""

#: ../../../library/pickle.rst:235
msgid ""
"Refer to :ref:`pickle-picklable` to learn what kinds of objects can be "
"pickled."
msgstr ""

#: ../../../library/pickle.rst:240
msgid ""
"Error raised when there a problem unpickling an object, such as a data "
"corruption or a security violation.  It inherits :exc:`PickleError`."
msgstr ""

#: ../../../library/pickle.rst:243
msgid ""
"Note that other exceptions may also be raised during unpickling, including "
"(but not necessarily limited to) AttributeError, EOFError, ImportError, and "
"IndexError."
msgstr ""

#: ../../../library/pickle.rst:248
msgid ""
"The :mod:`pickle` module exports two classes, :class:`Pickler` and :class:"
"`Unpickler`:"
msgstr ""

#: ../../../library/pickle.rst:253
msgid "This takes a binary file for writing a pickle data stream."
msgstr ""

#: ../../../library/pickle.rst:273
msgid ""
"Write a pickled representation of *obj* to the open file object given in the "
"constructor."
msgstr ""

#: ../../../library/pickle.rst:278
msgid "Do nothing by default.  This exists so a subclass can override it."
msgstr ""

#: ../../../library/pickle.rst:280
msgid ""
"If :meth:`persistent_id` returns ``None``, *obj* is pickled as usual.  Any "
"other value causes :class:`Pickler` to emit the returned value as a "
"persistent ID for *obj*.  The meaning of this persistent ID should be "
"defined by :meth:`Unpickler.persistent_load`.  Note that the value returned "
"by :meth:`persistent_id` cannot itself have a persistent ID."
msgstr ""

#: ../../../library/pickle.rst:286 ../../../library/pickle.rst:333
msgid "See :ref:`pickle-persistent` for details and examples of uses."
msgstr ""

#: ../../../library/pickle.rst:290
msgid ""
"Deprecated. Enable fast mode if set to a true value.  The fast mode disables "
"the usage of memo, therefore speeding the pickling process by not generating "
"superfluous PUT opcodes.  It should not be used with self-referential "
"objects, doing otherwise will cause :class:`Pickler` to recurse infinitely."
msgstr ""

#: ../../../library/pickle.rst:296
msgid "Use :func:`pickletools.optimize` if you need more compact pickles."
msgstr ""

#: ../../../library/pickle.rst:301
msgid "This takes a binary file for reading a pickle data stream."
msgstr ""

#: ../../../library/pickle.rst:303
msgid ""
"The protocol version of the pickle is detected automatically, so no protocol "
"argument is needed."
msgstr ""

#: ../../../library/pickle.rst:306
msgid ""
"The argument *file* must have two methods, a read() method that takes an "
"integer argument, and a readline() method that requires no arguments.  Both "
"methods should return bytes.  Thus *file* can be an on-disk file object "
"opened for binary reading, a :class:`io.BytesIO` object, or any other custom "
"object that meets this interface."
msgstr ""

#: ../../../library/pickle.rst:321
msgid ""
"Read a pickled object representation from the open file object given in the "
"constructor, and return the reconstituted object hierarchy specified "
"therein.  Bytes past the pickled object's representation are ignored."
msgstr ""

#: ../../../library/pickle.rst:327
msgid "Raise an :exc:`UnpickingError` by default."
msgstr ""

#: ../../../library/pickle.rst:329
msgid ""
"If defined, :meth:`persistent_load` should return the object specified by "
"the persistent ID *pid*.  If an invalid persistent ID is encountered, an :"
"exc:`UnpickingError` should be raised."
msgstr ""

#: ../../../library/pickle.rst:337
msgid ""
"Import *module* if necessary and return the object called *name* from it, "
"where the *module* and *name* arguments are :class:`str` objects.  Note, "
"unlike its name suggests, :meth:`find_class` is also used for finding "
"functions."
msgstr ""

#: ../../../library/pickle.rst:342
msgid ""
"Subclasses may override this to gain control over what type of objects and "
"how they can be loaded, potentially reducing security risks. Refer to :ref:"
"`pickle-restrict` for details."
msgstr ""

#: ../../../library/pickle.rst:350
msgid "What can be pickled and unpickled?"
msgstr ""

#: ../../../library/pickle.rst:352
msgid "The following types can be pickled:"
msgstr ""

#: ../../../library/pickle.rst:354
msgid "``None``, ``True``, and ``False``"
msgstr ""

#: ../../../library/pickle.rst:356
msgid "integers, floating point numbers, complex numbers"
msgstr ""

#: ../../../library/pickle.rst:358
msgid "strings, bytes, bytearrays"
msgstr ""

#: ../../../library/pickle.rst:360
msgid "tuples, lists, sets, and dictionaries containing only picklable objects"
msgstr ""

#: ../../../library/pickle.rst:362
msgid "functions defined at the top level of a module"
msgstr ""

#: ../../../library/pickle.rst:364
msgid "built-in functions defined at the top level of a module"
msgstr ""

#: ../../../library/pickle.rst:366
msgid "classes that are defined at the top level of a module"
msgstr ""

#: ../../../library/pickle.rst:368
msgid ""
"instances of such classes whose :attr:`__dict__` or :meth:`__setstate__` is "
"picklable  (see section :ref:`pickle-inst` for details)"
msgstr ""

#: ../../../library/pickle.rst:371
msgid ""
"Attempts to pickle unpicklable objects will raise the :exc:`PicklingError` "
"exception; when this happens, an unspecified number of bytes may have "
"already been written to the underlying file.  Trying to pickle a highly "
"recursive data structure may exceed the maximum recursion depth, a :exc:"
"`RuntimeError` will be raised in this case.  You can carefully raise this "
"limit with :func:`sys.setrecursionlimit`."
msgstr ""

#: ../../../library/pickle.rst:378
msgid ""
"Note that functions (built-in and user-defined) are pickled by \"fully "
"qualified\" name reference, not by value.  This means that only the function "
"name is pickled, along with the name of module the function is defined in.  "
"Neither the function's code, nor any of its function attributes are "
"pickled.  Thus the defining module must be importable in the unpickling "
"environment, and the module must contain the named object, otherwise an "
"exception will be raised. [#]_"
msgstr ""

#: ../../../library/pickle.rst:385
msgid ""
"Similarly, classes are pickled by named reference, so the same restrictions "
"in the unpickling environment apply.  Note that none of the class's code or "
"data is pickled, so in the following example the class attribute ``attr`` is "
"not restored in the unpickling environment::"
msgstr ""

#: ../../../library/pickle.rst:395
msgid ""
"These restrictions are why picklable functions and classes must be defined "
"in the top level of a module."
msgstr ""

#: ../../../library/pickle.rst:398
msgid ""
"Similarly, when class instances are pickled, their class's code and data are "
"not pickled along with them.  Only the instance data are pickled.  This is "
"done on purpose, so you can fix bugs in a class or add methods to the class "
"and still load objects that were created with an earlier version of the "
"class.  If you plan to have long-lived objects that will see many versions "
"of a class, it may be worthwhile to put a version number in the objects so "
"that suitable conversions can be made by the class's :meth:`__setstate__` "
"method."
msgstr ""

#: ../../../library/pickle.rst:410
msgid "Pickling Class Instances"
msgstr ""

#: ../../../library/pickle.rst:412
msgid ""
"In this section, we describe the general mechanisms available to you to "
"define, customize, and control how class instances are pickled and unpickled."
msgstr ""

#: ../../../library/pickle.rst:415
msgid ""
"In most cases, no additional code is needed to make instances picklable.  By "
"default, pickle will retrieve the class and the attributes of an instance "
"via introspection. When a class instance is unpickled, its :meth:`__init__` "
"method is usually *not* invoked.  The default behaviour first creates an "
"uninitialized instance and then restores the saved attributes.  The "
"following code shows an implementation of this behaviour::"
msgstr ""

#: ../../../library/pickle.rst:430
msgid ""
"Classes can alter the default behaviour by providing one or several special "
"methods:"
msgstr ""

#: ../../../library/pickle.rst:435
msgid ""
"In protocol 2 and newer, classes that implements the :meth:`__getnewargs__` "
"method can dictate the values passed to the :meth:`__new__` method upon "
"unpickling.  This is often needed for classes whose :meth:`__new__` method "
"requires arguments."
msgstr ""

#: ../../../library/pickle.rst:443
msgid ""
"Classes can further influence how their instances are pickled; if the class "
"defines the method :meth:`__getstate__`, it is called and the returned "
"object is pickled as the contents for the instance, instead of the contents "
"of the instance's dictionary.  If the :meth:`__getstate__` method is absent, "
"the instance's :attr:`__dict__` is pickled as usual."
msgstr ""

#: ../../../library/pickle.rst:452
msgid ""
"Upon unpickling, if the class defines :meth:`__setstate__`, it is called "
"with the unpickled state.  In that case, there is no requirement for the "
"state object to be a dictionary.  Otherwise, the pickled state must be a "
"dictionary and its items are assigned to the new instance's dictionary."
msgstr ""

#: ../../../library/pickle.rst:459
msgid ""
"If :meth:`__getstate__` returns a false value, the :meth:`__setstate__` "
"method will not be called upon unpickling."
msgstr ""

#: ../../../library/pickle.rst:463
msgid ""
"Refer to the section :ref:`pickle-state` for more information about how to "
"use the methods :meth:`__getstate__` and :meth:`__setstate__`."
msgstr ""

#: ../../../library/pickle.rst:468
msgid ""
"At unpickling time, some methods like :meth:`__getattr__`, :meth:"
"`__getattribute__`, or :meth:`__setattr__` may be called upon the instance.  "
"In case those methods rely on some internal invariant being true, the type "
"should implement :meth:`__getnewargs__` to establish such an invariant; "
"otherwise, neither :meth:`__new__` nor :meth:`__init__` will be called."
msgstr ""

#: ../../../library/pickle.rst:477
msgid ""
"As we shall see, pickle does not use directly the methods described above.  "
"In fact, these methods are part of the copy protocol which implements the :"
"meth:`__reduce__` special method.  The copy protocol provides a unified "
"interface for retrieving the data necessary for pickling and copying "
"objects. [#]_"
msgstr ""

#: ../../../library/pickle.rst:483
msgid ""
"Although powerful, implementing :meth:`__reduce__` directly in your classes "
"is error prone.  For this reason, class designers should use the high-level "
"interface (i.e., :meth:`__getnewargs__`, :meth:`__getstate__` and :meth:"
"`__setstate__`) whenever possible.  We will show, however, cases where "
"using :meth:`__reduce__` is the only option or leads to more efficient "
"pickling or both."
msgstr ""

#: ../../../library/pickle.rst:492
msgid ""
"The interface is currently defined as follows.  The :meth:`__reduce__` "
"method takes no argument and shall return either a string or preferably a "
"tuple (the returned object is often referred to as the \"reduce value\")."
msgstr ""

#: ../../../library/pickle.rst:496
msgid ""
"If a string is returned, the string should be interpreted as the name of a "
"global variable.  It should be the object's local name relative to its "
"module; the pickle module searches the module namespace to determine the "
"object's module.  This behaviour is typically useful for singletons."
msgstr ""

#: ../../../library/pickle.rst:501
msgid ""
"When a tuple is returned, it must be between two and five items long. "
"Optional items can either be omitted, or ``None`` can be provided as their "
"value.  The semantics of each item are in order:"
msgstr ""

#: ../../../library/pickle.rst:507
msgid ""
"A callable object that will be called to create the initial version of the "
"object."
msgstr ""

#: ../../../library/pickle.rst:510
msgid ""
"A tuple of arguments for the callable object.  An empty tuple must be given "
"if the callable does not accept any argument."
msgstr ""

#: ../../../library/pickle.rst:513
msgid ""
"Optionally, the object's state, which will be passed to the object's :meth:"
"`__setstate__` method as previously described.  If the object has no such "
"method then, the value must be a dictionary and it will be added to the "
"object's :attr:`__dict__` attribute."
msgstr ""

#: ../../../library/pickle.rst:518
msgid ""
"Optionally, an iterator (and not a sequence) yielding successive items. "
"These items will be appended to the object either using ``obj.append(item)`` "
"or, in batch, using ``obj.extend(list_of_items)``. This is primarily used "
"for list subclasses, but may be used by other classes as long as they have :"
"meth:`append` and :meth:`extend` methods with the appropriate signature.  "
"(Whether :meth:`append` or :meth:`extend` is used depends on which pickle "
"protocol version is used as well as the number of items to append, so both "
"must be supported.)"
msgstr ""

#: ../../../library/pickle.rst:527
msgid ""
"Optionally, an iterator (not a sequence) yielding successive key-value "
"pairs.  These items will be stored to the object using ``obj[key] = "
"value``.  This is primarily used for dictionary subclasses, but may be used "
"by other classes as long as they implement :meth:`__setitem__`."
msgstr ""

#: ../../../library/pickle.rst:535
msgid ""
"Alternatively, a :meth:`__reduce_ex__` method may be defined.  The only "
"difference is this method should take a single integer argument, the "
"protocol version.  When defined, pickle will prefer it over the :meth:"
"`__reduce__` method.  In addition, :meth:`__reduce__` automatically becomes "
"a synonym for the extended version.  The main use for this method is to "
"provide backwards-compatible reduce values for older Python releases."
msgstr ""

#: ../../../library/pickle.rst:545
msgid "Persistence of External Objects"
msgstr ""

#: ../../../library/pickle.rst:551
msgid ""
"For the benefit of object persistence, the :mod:`pickle` module supports the "
"notion of a reference to an object outside the pickled data stream.  Such "
"objects are referenced by a persistent ID, which should be either a string "
"of alphanumeric characters (for protocol 0) [#]_ or just an arbitrary object "
"(for any newer protocol)."
msgstr ""

#: ../../../library/pickle.rst:557
msgid ""
"The resolution of such persistent IDs is not defined by the :mod:`pickle` "
"module; it will delegate this resolution to the user defined methods on the "
"pickler and unpickler, :meth:`persistent_id` and :meth:`persistent_load` "
"respectively."
msgstr ""

#: ../../../library/pickle.rst:562
msgid ""
"To pickle objects that have an external persistent id, the pickler must have "
"a custom :meth:`persistent_id` method that takes an object as an argument "
"and returns either ``None`` or the persistent id for that object.  When "
"``None`` is returned, the pickler simply pickles the object as normal.  When "
"a persistent ID string is returned, the pickler will pickle that object, "
"along with a marker so that the unpickler will recognize it as a persistent "
"ID."
msgstr ""

#: ../../../library/pickle.rst:569
msgid ""
"To unpickle external objects, the unpickler must have a custom :meth:"
"`persistent_load` method that takes a persistent ID object and returns the "
"referenced object."
msgstr ""

#: ../../../library/pickle.rst:573
msgid ""
"Here is a comprehensive example presenting how persistent ID can be used to "
"pickle external objects by reference."
msgstr ""

#: ../../../library/pickle.rst:582
msgid "Handling Stateful Objects"
msgstr ""

#: ../../../library/pickle.rst:588
msgid ""
"Here's an example that shows how to modify pickling behavior for a class. "
"The :class:`TextReader` class opens a text file, and returns the line number "
"and line contents each time its :meth:`readline` method is called. If a :"
"class:`TextReader` instance is pickled, all attributes *except* the file "
"object member are saved. When the instance is unpickled, the file is "
"reopened, and reading resumes from the last location. The :meth:"
"`__setstate__` and :meth:`__getstate__` methods are used to implement this "
"behavior. ::"
msgstr ""

#: ../../../library/pickle.rst:634
msgid "A sample usage might be something like this::"
msgstr ""

#: ../../../library/pickle.rst:649
msgid "Restricting Globals"
msgstr ""

#: ../../../library/pickle.rst:654
msgid ""
"By default, unpickling will import any class or function that it finds in "
"the pickle data.  For many applications, this behaviour is unacceptable as "
"it permits the unpickler to import and invoke arbitrary code.  Just consider "
"what this hand-crafted pickle data stream does when loaded::"
msgstr ""

#: ../../../library/pickle.rst:664
msgid ""
"In this example, the unpickler imports the :func:`os.system` function and "
"then apply the string argument \"echo hello world\".  Although this example "
"is inoffensive, it is not difficult to imagine one that could damage your "
"system."
msgstr ""

#: ../../../library/pickle.rst:668
msgid ""
"For this reason, you may want to control what gets unpickled by customizing :"
"meth:`Unpickler.find_class`.  Unlike its name suggests, :meth:`find_class` "
"is called whenever a global (i.e., a class or a function) is requested.  "
"Thus it is possible to either forbid completely globals or restrict them to "
"a safe subset."
msgstr ""

#: ../../../library/pickle.rst:673
msgid ""
"Here is an example of an unpickler allowing only few safe classes from the :"
"mod:`builtins` module to be loaded::"
msgstr ""

#: ../../../library/pickle.rst:702
msgid "A sample usage of our unpickler working has intended::"
msgstr ""

#: ../../../library/pickle.rst:721
msgid ""
"As our examples shows, you have to be careful with what you allow to be "
"unpickled.  Therefore if security is a concern, you may want to consider "
"alternatives such as the marshalling API in :mod:`xmlrpc.client` or third-"
"party solutions."
msgstr ""

#: ../../../library/pickle.rst:730
msgid "Examples"
msgstr "範例"

#: ../../../library/pickle.rst:732
msgid ""
"For the simplest code, use the :func:`dump` and :func:`load` functions. ::"
msgstr ""

#: ../../../library/pickle.rst:748
msgid "The following example reads the resulting pickled data. ::"
msgstr ""

#: ../../../library/pickle.rst:765
msgid "Module :mod:`copyreg`"
msgstr ""

#: ../../../library/pickle.rst:765
msgid "Pickle interface constructor registration for extension types."
msgstr ""

#: ../../../library/pickle.rst:768
msgid "Module :mod:`pickletools`"
msgstr ""

#: ../../../library/pickle.rst:768
msgid "Tools for working with and analyzing pickled data."
msgstr ""

#: ../../../library/pickle.rst:771
msgid "Module :mod:`shelve`"
msgstr ""

#: ../../../library/pickle.rst:771
msgid "Indexed databases of objects; uses :mod:`pickle`."
msgstr ""

#: ../../../library/pickle.rst:774
msgid "Module :mod:`copy`"
msgstr ""

#: ../../../library/pickle.rst:774
msgid "Shallow and deep object copying."
msgstr ""

#: ../../../library/pickle.rst:776
msgid "Module :mod:`marshal`"
msgstr ""

#: ../../../library/pickle.rst:777
msgid "High-performance serialization of built-in types."
msgstr ""

#: ../../../library/pickle.rst:781
msgid "Footnotes"
msgstr "腳註"

#: ../../../library/pickle.rst:782
msgid "Don't confuse this with the :mod:`marshal` module"
msgstr ""

#: ../../../library/pickle.rst:784
msgid ""
"The exception raised will likely be an :exc:`ImportError` or an :exc:"
"`AttributeError` but it could be something else."
msgstr ""

#: ../../../library/pickle.rst:787
msgid ""
"The :mod:`copy` module uses this protocol for shallow and deep copying "
"operations."
msgstr ""

#: ../../../library/pickle.rst:790
msgid ""
"The limitation on alphanumeric characters is due to the fact the persistent "
"IDs, in protocol 0, are delimited by the newline character.  Therefore if "
"any kind of newline characters occurs in persistent IDs, the resulting "
"pickle will become unreadable."
msgstr ""

#: ../../../library/pickle.rst:4
msgid "persistence"
msgstr ""

#: ../../../library/pickle.rst:4
msgid "persistent"
msgstr ""

#: ../../../library/pickle.rst:4
msgid "objects"
msgstr ""

#: ../../../library/pickle.rst:4
msgid "serializing"
msgstr ""

#: ../../../library/pickle.rst:4
msgid "marshalling"
msgstr ""

#: ../../../library/pickle.rst:4
msgid "flattening"
msgstr ""

#: ../../../library/pickle.rst:4
msgid "pickling"
msgstr ""

#: ../../../library/pickle.rst:87
msgid "XDR"
msgstr ""

#: ../../../library/pickle.rst:87
msgid "External Data Representation"
msgstr ""

#: ../../../library/pickle.rst:475
msgid "copy"
msgstr ""

#: ../../../library/pickle.rst:475
msgid "protocol"
msgstr ""

#: ../../../library/pickle.rst:547
msgid "persistent_id (pickle protocol)"
msgstr ""

#: ../../../library/pickle.rst:547
msgid "persistent_load (pickle protocol)"
msgstr ""

#: ../../../library/pickle.rst:584
msgid "__getstate__() (copy protocol)"
msgstr ""

#: ../../../library/pickle.rst:584
msgid "__setstate__() (copy protocol)"
msgstr ""

#: ../../../library/pickle.rst:651
msgid "find_class() (pickle protocol)"
msgstr ""

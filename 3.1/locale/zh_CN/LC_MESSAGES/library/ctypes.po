# SOME DESCRIPTIVE TITLE.
# Copyright (C) 1990-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.1\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-10 15:08+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../library/ctypes.rst:2
msgid ":mod:`ctypes` --- A foreign function library for Python"
msgstr ""

#: ../../../library/ctypes.rst:9
msgid ""
":mod:`ctypes` is a foreign function library for Python.  It provides C "
"compatible data types, and allows calling functions in DLLs or shared "
"libraries.  It can be used to wrap these libraries in pure Python."
msgstr ""

#: ../../../library/ctypes.rst:17
msgid "ctypes tutorial"
msgstr ""

#: ../../../library/ctypes.rst:19
msgid ""
"Note: The code samples in this tutorial use :mod:`doctest` to make sure that "
"they actually work.  Since some code samples behave differently under Linux, "
"Windows, or Mac OS X, they contain doctest directives in comments."
msgstr ""

#: ../../../library/ctypes.rst:23
msgid ""
"Note: Some code samples reference the ctypes :class:`c_int` type. This type "
"is an alias for the :class:`c_long` type on 32-bit systems.  So, you should "
"not be confused if :class:`c_long` is printed if you would expect :class:"
"`c_int` --- they are actually the same type."
msgstr ""

#: ../../../library/ctypes.rst:32
msgid "Loading dynamic link libraries"
msgstr ""

#: ../../../library/ctypes.rst:34
msgid ""
":mod:`ctypes` exports the *cdll*, and on Windows *windll* and *oledll* "
"objects, for loading dynamic link libraries."
msgstr ""

#: ../../../library/ctypes.rst:37
msgid ""
"You load libraries by accessing them as attributes of these objects. *cdll* "
"loads libraries which export functions using the standard ``cdecl`` calling "
"convention, while *windll* libraries call functions using the ``stdcall`` "
"calling convention. *oledll* also uses the ``stdcall`` calling convention, "
"and assumes the functions return a Windows :ctype:`HRESULT` error code. The "
"error code is used to automatically raise a :class:`WindowsError` exception "
"when the function call fails."
msgstr ""

#: ../../../library/ctypes.rst:45
msgid ""
"Here are some examples for Windows. Note that ``msvcrt`` is the MS standard "
"C library containing most standard C functions, and uses the cdecl calling "
"convention::"
msgstr ""

#: ../../../library/ctypes.rst:49
msgid ""
">>> from ctypes import *\n"
">>> print(windll.kernel32) \n"
"<WinDLL 'kernel32', handle ... at ...>\n"
">>> print(cdll.msvcrt) \n"
"<CDLL 'msvcrt', handle ... at ...>\n"
">>> libc = cdll.msvcrt \n"
">>>"
msgstr ""

#: ../../../library/ctypes.rst:57
msgid "Windows appends the usual ``.dll`` file suffix automatically."
msgstr ""

#: ../../../library/ctypes.rst:59
msgid ""
"On Linux, it is required to specify the filename *including* the extension "
"to load a library, so attribute access can not be used to load libraries. "
"Either the :meth:`LoadLibrary` method of the dll loaders should be used, or "
"you should load the library by creating an instance of CDLL by calling the "
"constructor::"
msgstr ""

#: ../../../library/ctypes.rst:64
msgid ""
">>> cdll.LoadLibrary(\"libc.so.6\") \n"
"<CDLL 'libc.so.6', handle ... at ...>\n"
">>> libc = CDLL(\"libc.so.6\")     \n"
">>> libc                         \n"
"<CDLL 'libc.so.6', handle ... at ...>\n"
">>>"
msgstr ""

#: ../../../library/ctypes.rst:77
msgid "Accessing functions from loaded dlls"
msgstr ""

#: ../../../library/ctypes.rst:79
msgid "Functions are accessed as attributes of dll objects::"
msgstr ""

#: ../../../library/ctypes.rst:81
msgid ""
">>> from ctypes import *\n"
">>> libc.printf\n"
"<_FuncPtr object at 0x...>\n"
">>> print(windll.kernel32.GetModuleHandleA) \n"
"<_FuncPtr object at 0x...>\n"
">>> print(windll.kernel32.MyOwnFunction) \n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in ?\n"
"  File \"ctypes.py\", line 239, in __getattr__\n"
"    func = _StdcallFuncPtr(name, self)\n"
"AttributeError: function 'MyOwnFunction' not found\n"
">>>"
msgstr ""

#: ../../../library/ctypes.rst:94
msgid ""
"Note that win32 system dlls like ``kernel32`` and ``user32`` often export "
"ANSI as well as UNICODE versions of a function. The UNICODE version is "
"exported with an ``W`` appended to the name, while the ANSI version is "
"exported with an ``A`` appended to the name. The win32 ``GetModuleHandle`` "
"function, which returns a *module handle* for a given module name, has the "
"following C prototype, and a macro is used to expose one of them as "
"``GetModuleHandle`` depending on whether UNICODE is defined or not::"
msgstr ""

#: ../../../library/ctypes.rst:102
msgid ""
"/* ANSI version */\n"
"HMODULE GetModuleHandleA(LPCSTR lpModuleName);\n"
"/* UNICODE version */\n"
"HMODULE GetModuleHandleW(LPCWSTR lpModuleName);"
msgstr ""

#: ../../../library/ctypes.rst:107
msgid ""
"*windll* does not try to select one of them by magic, you must access the "
"version you need by specifying ``GetModuleHandleA`` or ``GetModuleHandleW`` "
"explicitly, and then call it with bytes or string objects respectively."
msgstr ""

#: ../../../library/ctypes.rst:111
msgid ""
"Sometimes, dlls export functions with names which aren't valid Python "
"identifiers, like ``\"??2@YAPAXI@Z\"``. In this case you have to use :func:"
"`getattr` to retrieve the function::"
msgstr ""

#: ../../../library/ctypes.rst:115
msgid ""
">>> getattr(cdll.msvcrt, \"??2@YAPAXI@Z\") \n"
"<_FuncPtr object at 0x...>\n"
">>>"
msgstr ""

#: ../../../library/ctypes.rst:119
msgid ""
"On Windows, some dlls export functions not by name but by ordinal. These "
"functions can be accessed by indexing the dll object with the ordinal "
"number::"
msgstr ""

#: ../../../library/ctypes.rst:122
msgid ""
">>> cdll.kernel32[1] \n"
"<_FuncPtr object at 0x...>\n"
">>> cdll.kernel32[0] \n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in ?\n"
"  File \"ctypes.py\", line 310, in __getitem__\n"
"    func = _StdcallFuncPtr(name, self)\n"
"AttributeError: function ordinal 0 not found\n"
">>>"
msgstr ""

#: ../../../library/ctypes.rst:136
msgid "Calling functions"
msgstr ""

#: ../../../library/ctypes.rst:138
msgid ""
"You can call these functions like any other Python callable. This example "
"uses the ``time()`` function, which returns system time in seconds since the "
"Unix epoch, and the ``GetModuleHandleA()`` function, which returns a win32 "
"module handle."
msgstr ""

#: ../../../library/ctypes.rst:143
msgid ""
"This example calls both functions with a NULL pointer (``None`` should be "
"used as the NULL pointer)::"
msgstr ""

#: ../../../library/ctypes.rst:146
msgid ""
">>> print(libc.time(None)) \n"
"1150640792\n"
">>> print(hex(windll.kernel32.GetModuleHandleA(None))) \n"
"0x1d000000\n"
">>>"
msgstr ""

#: ../../../library/ctypes.rst:152
msgid ""
":mod:`ctypes` tries to protect you from calling functions with the wrong "
"number of arguments or the wrong calling convention.  Unfortunately this "
"only works on Windows.  It does this by examining the stack after the "
"function returns, so although an error is raised the function *has* been "
"called::"
msgstr ""

#: ../../../library/ctypes.rst:157
msgid ""
">>> windll.kernel32.GetModuleHandleA() \n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in ?\n"
"ValueError: Procedure probably called with not enough arguments (4 bytes "
"missing)\n"
">>> windll.kernel32.GetModuleHandleA(0, 0) \n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in ?\n"
"ValueError: Procedure probably called with too many arguments (4 bytes in "
"excess)\n"
">>>"
msgstr ""

#: ../../../library/ctypes.rst:167
msgid ""
"The same exception is raised when you call an ``stdcall`` function with the "
"``cdecl`` calling convention, or vice versa::"
msgstr ""

#: ../../../library/ctypes.rst:170
msgid ""
">>> cdll.kernel32.GetModuleHandleA(None) \n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in ?\n"
"ValueError: Procedure probably called with not enough arguments (4 bytes "
"missing)\n"
">>>\n"
"\n"
">>> windll.msvcrt.printf(b\"spam\") \n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in ?\n"
"ValueError: Procedure probably called with too many arguments (4 bytes in "
"excess)\n"
">>>"
msgstr ""

#: ../../../library/ctypes.rst:182
msgid ""
"To find out the correct calling convention you have to look into the C "
"header file or the documentation for the function you want to call."
msgstr ""

#: ../../../library/ctypes.rst:185
msgid ""
"On Windows, :mod:`ctypes` uses win32 structured exception handling to "
"prevent crashes from general protection faults when functions are called "
"with invalid argument values::"
msgstr ""

#: ../../../library/ctypes.rst:189
msgid ""
">>> windll.kernel32.GetModuleHandleA(32) \n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in ?\n"
"WindowsError: exception: access violation reading 0x00000020\n"
">>>"
msgstr ""

#: ../../../library/ctypes.rst:195
msgid ""
"There are, however, enough ways to crash Python with :mod:`ctypes`, so you "
"should be careful anyway."
msgstr ""

#: ../../../library/ctypes.rst:198
msgid ""
"``None``, integers, bytes objects and (unicode) strings are the only native "
"Python objects that can directly be used as parameters in these function "
"calls. ``None`` is passed as a C ``NULL`` pointer, bytes objects and strings "
"are passed as pointer to the memory block that contains their data (:ctype:"
"`char *` or :ctype:`wchar_t *`).  Python integers are passed as the "
"platforms default C :ctype:`int` type, their value is masked to fit into the "
"C type."
msgstr ""

#: ../../../library/ctypes.rst:205
msgid ""
"Before we move on calling functions with other parameter types, we have to "
"learn more about :mod:`ctypes` data types."
msgstr ""

#: ../../../library/ctypes.rst:212 ../../../library/ctypes.rst:2081
msgid "Fundamental data types"
msgstr ""

#: ../../../library/ctypes.rst:214
msgid ":mod:`ctypes` defines a number of primitive C compatible data types :"
msgstr ""

#: ../../../library/ctypes.rst:217
msgid "ctypes type"
msgstr ""

#: ../../../library/ctypes.rst:217
msgid "C type"
msgstr ""

#: ../../../library/ctypes.rst:217
msgid "Python type"
msgstr ""

#: ../../../library/ctypes.rst:219
msgid ":class:`c_bool`"
msgstr ""

#: ../../../library/ctypes.rst:219
msgid ":ctype:`_Bool`"
msgstr ""

#: ../../../library/ctypes.rst:219
msgid "bool (1)"
msgstr ""

#: ../../../library/ctypes.rst:221
msgid ":class:`c_char`"
msgstr ""

#: ../../../library/ctypes.rst:221 ../../../library/ctypes.rst:225
msgid ":ctype:`char`"
msgstr ""

#: ../../../library/ctypes.rst:221
msgid "1-character bytes object"
msgstr ""

#: ../../../library/ctypes.rst:223
msgid ":class:`c_wchar`"
msgstr ""

#: ../../../library/ctypes.rst:223
msgid ":ctype:`wchar_t`"
msgstr ""

#: ../../../library/ctypes.rst:223
msgid "1-character string"
msgstr ""

#: ../../../library/ctypes.rst:225
msgid ":class:`c_byte`"
msgstr ""

#: ../../../library/ctypes.rst:225 ../../../library/ctypes.rst:227
#: ../../../library/ctypes.rst:229 ../../../library/ctypes.rst:231
#: ../../../library/ctypes.rst:233 ../../../library/ctypes.rst:235
#: ../../../library/ctypes.rst:237 ../../../library/ctypes.rst:239
#: ../../../library/ctypes.rst:241 ../../../library/ctypes.rst:243
msgid "int"
msgstr ""

#: ../../../library/ctypes.rst:227
msgid ":class:`c_ubyte`"
msgstr ""

#: ../../../library/ctypes.rst:227
msgid ":ctype:`unsigned char`"
msgstr ""

#: ../../../library/ctypes.rst:229
msgid ":class:`c_short`"
msgstr ""

#: ../../../library/ctypes.rst:229
msgid ":ctype:`short`"
msgstr ""

#: ../../../library/ctypes.rst:231
msgid ":class:`c_ushort`"
msgstr ""

#: ../../../library/ctypes.rst:231
msgid ":ctype:`unsigned short`"
msgstr ""

#: ../../../library/ctypes.rst:233
msgid ":class:`c_int`"
msgstr ""

#: ../../../library/ctypes.rst:233
msgid ":ctype:`int`"
msgstr ""

#: ../../../library/ctypes.rst:235
msgid ":class:`c_uint`"
msgstr ""

#: ../../../library/ctypes.rst:235
msgid ":ctype:`unsigned int`"
msgstr ""

#: ../../../library/ctypes.rst:237
msgid ":class:`c_long`"
msgstr ""

#: ../../../library/ctypes.rst:237
msgid ":ctype:`long`"
msgstr ""

#: ../../../library/ctypes.rst:239
msgid ":class:`c_ulong`"
msgstr ""

#: ../../../library/ctypes.rst:239
msgid ":ctype:`unsigned long`"
msgstr ""

#: ../../../library/ctypes.rst:241
msgid ":class:`c_longlong`"
msgstr ""

#: ../../../library/ctypes.rst:241
msgid ":ctype:`__int64` or :ctype:`long long`"
msgstr ""

#: ../../../library/ctypes.rst:243
msgid ":class:`c_ulonglong`"
msgstr ""

#: ../../../library/ctypes.rst:243
msgid ":ctype:`unsigned __int64` or :ctype:`unsigned long long`"
msgstr ""

#: ../../../library/ctypes.rst:246
msgid ":class:`c_float`"
msgstr ""

#: ../../../library/ctypes.rst:246
msgid ":ctype:`float`"
msgstr ""

#: ../../../library/ctypes.rst:246 ../../../library/ctypes.rst:248
#: ../../../library/ctypes.rst:250
msgid "float"
msgstr ""

#: ../../../library/ctypes.rst:248
msgid ":class:`c_double`"
msgstr ""

#: ../../../library/ctypes.rst:248
msgid ":ctype:`double`"
msgstr ""

#: ../../../library/ctypes.rst:250
msgid ":class:`c_longdouble`"
msgstr ""

#: ../../../library/ctypes.rst:250
msgid ":ctype:`long double`"
msgstr ""

#: ../../../library/ctypes.rst:252
msgid ":class:`c_char_p`"
msgstr ""

#: ../../../library/ctypes.rst:252
msgid ":ctype:`char *` (NUL terminated)"
msgstr ""

#: ../../../library/ctypes.rst:252
msgid "bytes object or ``None``"
msgstr ""

#: ../../../library/ctypes.rst:254
msgid ":class:`c_wchar_p`"
msgstr ""

#: ../../../library/ctypes.rst:254
msgid ":ctype:`wchar_t *` (NUL terminated)"
msgstr ""

#: ../../../library/ctypes.rst:254
msgid "string or ``None``"
msgstr ""

#: ../../../library/ctypes.rst:256
msgid ":class:`c_void_p`"
msgstr ""

#: ../../../library/ctypes.rst:256
msgid ":ctype:`void *`"
msgstr ""

#: ../../../library/ctypes.rst:256
msgid "int or ``None``"
msgstr ""

#: ../../../library/ctypes.rst:260
msgid "The constructor accepts any object with a truth value."
msgstr ""

#: ../../../library/ctypes.rst:262
msgid ""
"All these types can be created by calling them with an optional initializer "
"of the correct type and value::"
msgstr ""

#: ../../../library/ctypes.rst:265
msgid ""
">>> c_int()\n"
"c_long(0)\n"
">>> c_wchar_p(\"Hello, World\")\n"
"c_wchar_p('Hello, World')\n"
">>> c_ushort(-3)\n"
"c_ushort(65533)\n"
">>>"
msgstr ""

#: ../../../library/ctypes.rst:273
msgid ""
"Since these types are mutable, their value can also be changed afterwards::"
msgstr ""

#: ../../../library/ctypes.rst:275
msgid ""
">>> i = c_int(42)\n"
">>> print(i)\n"
"c_long(42)\n"
">>> print(i.value)\n"
"42\n"
">>> i.value = -99\n"
">>> print(i.value)\n"
"-99\n"
">>>"
msgstr ""

#: ../../../library/ctypes.rst:285
msgid ""
"Assigning a new value to instances of the pointer types :class:`c_char_p`, :"
"class:`c_wchar_p`, and :class:`c_void_p` changes the *memory location* they "
"point to, *not the contents* of the memory block (of course not, because "
"Python bytes objects are immutable)::"
msgstr ""

#: ../../../library/ctypes.rst:290
msgid ""
">>> s = \"Hello, World\"\n"
">>> c_s = c_wchar_p(s)\n"
">>> print(c_s)\n"
"c_wchar_p('Hello, World')\n"
">>> c_s.value = \"Hi, there\"\n"
">>> print(c_s)\n"
"c_wchar_p('Hi, there')\n"
">>> print(s)                 # first object is unchanged\n"
"Hello, World\n"
">>>"
msgstr ""

#: ../../../library/ctypes.rst:301
msgid ""
"You should be careful, however, not to pass them to functions expecting "
"pointers to mutable memory. If you need mutable memory blocks, ctypes has a :"
"func:`create_string_buffer` function which creates these in various ways.  "
"The current memory block contents can be accessed (or changed) with the "
"``raw`` property; if you want to access it as NUL terminated string, use the "
"``value`` property::"
msgstr ""

#: ../../../library/ctypes.rst:308
msgid ""
">>> from ctypes import *\n"
">>> p = create_string_buffer(3)            # create a 3 byte buffer, "
"initialized to NUL bytes\n"
">>> print(sizeof(p), repr(p.raw))\n"
"3 b'\\x00\\x00\\x00'\n"
">>> p = create_string_buffer(b\"Hello\")     # create a buffer containing a "
"NUL terminated string\n"
">>> print(sizeof(p), repr(p.raw))\n"
"6 b'Hello\\x00'\n"
">>> print(repr(p.value))\n"
"b'Hello'\n"
">>> p = create_string_buffer(b\"Hello\", 10) # create a 10 byte buffer\n"
">>> print(sizeof(p), repr(p.raw))\n"
"10 b'Hello\\x00\\x00\\x00\\x00\\x00'\n"
">>> p.value = b\"Hi\"\n"
">>> print(sizeof(p), repr(p.raw))\n"
"10 b'Hi\\x00lo\\x00\\x00\\x00\\x00\\x00'\n"
">>>"
msgstr ""

#: ../../../library/ctypes.rst:325
msgid ""
"The :func:`create_string_buffer` function replaces the :func:`c_buffer` "
"function (which is still available as an alias), as well as the :func:"
"`c_string` function from earlier ctypes releases.  To create a mutable "
"memory block containing unicode characters of the C type :ctype:`wchar_t` "
"use the :func:`create_unicode_buffer` function."
msgstr ""

#: ../../../library/ctypes.rst:335
msgid "Calling functions, continued"
msgstr ""

#: ../../../library/ctypes.rst:337
msgid ""
"Note that printf prints to the real standard output channel, *not* to :data:"
"`sys.stdout`, so these examples will only work at the console prompt, not "
"from within *IDLE* or *PythonWin*::"
msgstr ""

#: ../../../library/ctypes.rst:341
msgid ""
">>> printf = libc.printf\n"
">>> printf(b\"Hello, %s\\n\", b\"World!\")\n"
"Hello, World!\n"
"14\n"
">>> printf(b\"Hello, %S\\n\", \"World!\")\n"
"Hello, World!\n"
"14\n"
">>> printf(b\"%d bottles of beer\\n\", 42)\n"
"42 bottles of beer\n"
"19\n"
">>> printf(b\"%f bottles of beer\\n\", 42.5)\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in ?\n"
"ArgumentError: argument 2: exceptions.TypeError: Don't know how to convert "
"parameter 2\n"
">>>"
msgstr ""

#: ../../../library/ctypes.rst:357
msgid ""
"As has been mentioned before, all Python types except integers, strings, and "
"bytes objects have to be wrapped in their corresponding :mod:`ctypes` type, "
"so that they can be converted to the required C data type::"
msgstr ""

#: ../../../library/ctypes.rst:361
msgid ""
">>> printf(b\"An int %d, a double %f\\n\", 1234, c_double(3.14))\n"
"An int 1234, a double 3.140000\n"
"31\n"
">>>"
msgstr ""

#: ../../../library/ctypes.rst:370
msgid "Calling functions with your own custom data types"
msgstr ""

#: ../../../library/ctypes.rst:372
msgid ""
"You can also customize :mod:`ctypes` argument conversion to allow instances "
"of your own classes be used as function arguments.  :mod:`ctypes` looks for "
"an :attr:`_as_parameter_` attribute and uses this as the function argument.  "
"Of course, it must be one of integer, string, or bytes::"
msgstr ""

#: ../../../library/ctypes.rst:377
msgid ""
">>> class Bottles:\n"
"...     def __init__(self, number):\n"
"...         self._as_parameter_ = number\n"
"...\n"
">>> bottles = Bottles(42)\n"
">>> printf(b\"%d bottles of beer\\n\", bottles)\n"
"42 bottles of beer\n"
"19\n"
">>>"
msgstr ""

#: ../../../library/ctypes.rst:387
msgid ""
"If you don't want to store the instance's data in the :attr:`_as_parameter_` "
"instance variable, you could define a :class:`property` which makes the "
"attribute available on request."
msgstr ""

#: ../../../library/ctypes.rst:395
msgid "Specifying the required argument types (function prototypes)"
msgstr ""

#: ../../../library/ctypes.rst:397
msgid ""
"It is possible to specify the required argument types of functions exported "
"from DLLs by setting the :attr:`argtypes` attribute."
msgstr ""

#: ../../../library/ctypes.rst:400
msgid ""
":attr:`argtypes` must be a sequence of C data types (the ``printf`` function "
"is probably not a good example here, because it takes a variable number and "
"different types of parameters depending on the format string, on the other "
"hand this is quite handy to experiment with this feature)::"
msgstr ""

#: ../../../library/ctypes.rst:405
msgid ""
">>> printf.argtypes = [c_char_p, c_char_p, c_int, c_double]\n"
">>> printf(b\"String '%s', Int %d, Double %f\\n\", b\"Hi\", 10, 2.2)\n"
"String 'Hi', Int 10, Double 2.200000\n"
"37\n"
">>>"
msgstr ""

#: ../../../library/ctypes.rst:411
msgid ""
"Specifying a format protects against incompatible argument types (just as a "
"prototype for a C function), and tries to convert the arguments to valid "
"types::"
msgstr ""

#: ../../../library/ctypes.rst:414
msgid ""
">>> printf(b\"%d %d %d\", 1, 2, 3)\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in ?\n"
"ArgumentError: argument 2: exceptions.TypeError: wrong type\n"
">>> printf(b\"%s %d %f\\n\", b\"X\", 2, 3)\n"
"X 2 3.000000\n"
"13\n"
">>>"
msgstr ""

#: ../../../library/ctypes.rst:423
msgid ""
"If you have defined your own classes which you pass to function calls, you "
"have to implement a :meth:`from_param` class method for them to be able to "
"use them in the :attr:`argtypes` sequence. The :meth:`from_param` class "
"method receives the Python object passed to the function call, it should do "
"a typecheck or whatever is needed to make sure this object is acceptable, "
"and then return the object itself, its :attr:`_as_parameter_` attribute, or "
"whatever you want to pass as the C function argument in this case. Again, "
"the result should be an integer, string, bytes, a :mod:`ctypes` instance, or "
"an object with an :attr:`_as_parameter_` attribute."
msgstr ""

#: ../../../library/ctypes.rst:437
msgid "Return types"
msgstr ""

#: ../../../library/ctypes.rst:439
msgid ""
"By default functions are assumed to return the C :ctype:`int` type.  Other "
"return types can be specified by setting the :attr:`restype` attribute of "
"the function object."
msgstr ""

#: ../../../library/ctypes.rst:443
msgid ""
"Here is a more advanced example, it uses the ``strchr`` function, which "
"expects a string pointer and a char, and returns a pointer to a string::"
msgstr ""

#: ../../../library/ctypes.rst:446
msgid ""
">>> strchr = libc.strchr\n"
">>> strchr(b\"abcdef\", ord(\"d\")) \n"
"8059983\n"
">>> strchr.restype = c_char_p   # c_char_p is a pointer to a string\n"
">>> strchr(b\"abcdef\", ord(\"d\"))\n"
"b'def'\n"
">>> print(strchr(b\"abcdef\", ord(\"x\")))\n"
"None\n"
">>>"
msgstr ""

#: ../../../library/ctypes.rst:456
msgid ""
"If you want to avoid the ``ord(\"x\")`` calls above, you can set the :attr:"
"`argtypes` attribute, and the second argument will be converted from a "
"single character Python bytes object into a C char::"
msgstr ""

#: ../../../library/ctypes.rst:460
msgid ""
">>> strchr.restype = c_char_p\n"
">>> strchr.argtypes = [c_char_p, c_char]\n"
">>> strchr(b\"abcdef\", b\"d\")\n"
"'def'\n"
">>> strchr(b\"abcdef\", b\"def\")\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in ?\n"
"ArgumentError: argument 2: exceptions.TypeError: one character string "
"expected\n"
">>> print(strchr(b\"abcdef\", b\"x\"))\n"
"None\n"
">>> strchr(b\"abcdef\", b\"d\")\n"
"'def'\n"
">>>"
msgstr ""

#: ../../../library/ctypes.rst:474
msgid ""
"You can also use a callable Python object (a function or a class for "
"example) as the :attr:`restype` attribute, if the foreign function returns "
"an integer.  The callable will be called with the *integer* the C function "
"returns, and the result of this call will be used as the result of your "
"function call. This is useful to check for error return values and "
"automatically raise an exception::"
msgstr ""

#: ../../../library/ctypes.rst:480
msgid ""
">>> GetModuleHandle = windll.kernel32.GetModuleHandleA \n"
">>> def ValidHandle(value):\n"
"...     if value == 0:\n"
"...         raise WinError()\n"
"...     return value\n"
"...\n"
">>>\n"
">>> GetModuleHandle.restype = ValidHandle \n"
">>> GetModuleHandle(None) \n"
"486539264\n"
">>> GetModuleHandle(\"something silly\") \n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in ?\n"
"  File \"<stdin>\", line 3, in ValidHandle\n"
"WindowsError: [Errno 126] The specified module could not be found.\n"
">>>"
msgstr ""

#: ../../../library/ctypes.rst:497
msgid ""
"``WinError`` is a function which will call Windows ``FormatMessage()`` api "
"to get the string representation of an error code, and *returns* an "
"exception. ``WinError`` takes an optional error code parameter, if no one is "
"used, it calls :func:`GetLastError` to retrieve it."
msgstr ""

#: ../../../library/ctypes.rst:502
msgid ""
"Please note that a much more powerful error checking mechanism is available "
"through the :attr:`errcheck` attribute; see the reference manual for details."
msgstr ""

#: ../../../library/ctypes.rst:509
msgid "Passing pointers (or: passing parameters by reference)"
msgstr ""

#: ../../../library/ctypes.rst:511
msgid ""
"Sometimes a C api function expects a *pointer* to a data type as parameter, "
"probably to write into the corresponding location, or if the data is too "
"large to be passed by value. This is also known as *passing parameters by "
"reference*."
msgstr ""

#: ../../../library/ctypes.rst:515
msgid ""
":mod:`ctypes` exports the :func:`byref` function which is used to pass "
"parameters by reference.  The same effect can be achieved with the :func:"
"`pointer` function, although :func:`pointer` does a lot more work since it "
"constructs a real pointer object, so it is faster to use :func:`byref` if "
"you don't need the pointer object in Python itself::"
msgstr ""

#: ../../../library/ctypes.rst:521
msgid ""
">>> i = c_int()\n"
">>> f = c_float()\n"
">>> s = create_string_buffer(b'\\000' * 32)\n"
">>> print(i.value, f.value, repr(s.value))\n"
"0 0.0 b''\n"
">>> libc.sscanf(b\"1 3.14 Hello\", b\"%d %f %s\",\n"
"...             byref(i), byref(f), s)\n"
"3\n"
">>> print(i.value, f.value, repr(s.value))\n"
"1 3.1400001049 b'Hello'\n"
">>>"
msgstr ""

#: ../../../library/ctypes.rst:537
msgid "Structures and unions"
msgstr ""

#: ../../../library/ctypes.rst:539
msgid ""
"Structures and unions must derive from the :class:`Structure` and :class:"
"`Union` base classes which are defined in the :mod:`ctypes` module. Each "
"subclass must define a :attr:`_fields_` attribute.  :attr:`_fields_` must be "
"a list of *2-tuples*, containing a *field name* and a *field type*."
msgstr ""

#: ../../../library/ctypes.rst:544
msgid ""
"The field type must be a :mod:`ctypes` type like :class:`c_int`, or any "
"other derived :mod:`ctypes` type: structure, union, array, pointer."
msgstr ""

#: ../../../library/ctypes.rst:547
msgid ""
"Here is a simple example of a POINT structure, which contains two integers "
"named *x* and *y*, and also shows how to initialize a structure in the "
"constructor::"
msgstr ""

#: ../../../library/ctypes.rst:550
msgid ""
">>> from ctypes import *\n"
">>> class POINT(Structure):\n"
"...     _fields_ = [(\"x\", c_int),\n"
"...                 (\"y\", c_int)]\n"
"...\n"
">>> point = POINT(10, 20)\n"
">>> print(point.x, point.y)\n"
"10 20\n"
">>> point = POINT(y=5)\n"
">>> print(point.x, point.y)\n"
"0 5\n"
">>> POINT(1, 2, 3)\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in ?\n"
"ValueError: too many initializers\n"
">>>"
msgstr ""

#: ../../../library/ctypes.rst:567
msgid ""
"You can, however, build much more complicated structures. Structures can "
"itself contain other structures by using a structure as a field type."
msgstr ""

#: ../../../library/ctypes.rst:570
msgid ""
"Here is a RECT structure which contains two POINTs named *upperleft* and "
"*lowerright*::"
msgstr ""

#: ../../../library/ctypes.rst:573
msgid ""
">>> class RECT(Structure):\n"
"...     _fields_ = [(\"upperleft\", POINT),\n"
"...                 (\"lowerright\", POINT)]\n"
"...\n"
">>> rc = RECT(point)\n"
">>> print(rc.upperleft.x, rc.upperleft.y)\n"
"0 5\n"
">>> print(rc.lowerright.x, rc.lowerright.y)\n"
"0 0\n"
">>>"
msgstr ""

#: ../../../library/ctypes.rst:584
msgid ""
"Nested structures can also be initialized in the constructor in several "
"ways::"
msgstr ""

#: ../../../library/ctypes.rst:586
msgid ""
">>> r = RECT(POINT(1, 2), POINT(3, 4))\n"
">>> r = RECT((1, 2), (3, 4))"
msgstr ""

#: ../../../library/ctypes.rst:589
msgid ""
"Field :term:`descriptor`\\s can be retrieved from the *class*, they are "
"useful for debugging because they can provide useful information::"
msgstr ""

#: ../../../library/ctypes.rst:592
msgid ""
">>> print(POINT.x)\n"
"<Field type=c_long, ofs=0, size=4>\n"
">>> print(POINT.y)\n"
"<Field type=c_long, ofs=4, size=4>\n"
">>>"
msgstr ""

#: ../../../library/ctypes.rst:602
msgid "Structure/union alignment and byte order"
msgstr ""

#: ../../../library/ctypes.rst:604
msgid ""
"By default, Structure and Union fields are aligned in the same way the C "
"compiler does it. It is possible to override this behavior be specifying a :"
"attr:`_pack_` class attribute in the subclass definition. This must be set "
"to a positive integer and specifies the maximum alignment for the fields. "
"This is what ``#pragma pack(n)`` also does in MSVC."
msgstr ""

#: ../../../library/ctypes.rst:610
msgid ""
":mod:`ctypes` uses the native byte order for Structures and Unions.  To "
"build structures with non-native byte order, you can use one of the :class:"
"`BigEndianStructure`, :class:`LittleEndianStructure`, :class:"
"`BigEndianUnion`, and :class:`LittleEndianUnion` base classes.  These "
"classes cannot contain pointer fields."
msgstr ""

#: ../../../library/ctypes.rst:620
msgid "Bit fields in structures and unions"
msgstr ""

#: ../../../library/ctypes.rst:622
msgid ""
"It is possible to create structures and unions containing bit fields. Bit "
"fields are only possible for integer fields, the bit width is specified as "
"the third item in the :attr:`_fields_` tuples::"
msgstr ""

#: ../../../library/ctypes.rst:626
msgid ""
">>> class Int(Structure):\n"
"...     _fields_ = [(\"first_16\", c_int, 16),\n"
"...                 (\"second_16\", c_int, 16)]\n"
"...\n"
">>> print(Int.first_16)\n"
"<Field type=c_long, ofs=0:0, bits=16>\n"
">>> print(Int.second_16)\n"
"<Field type=c_long, ofs=0:16, bits=16>\n"
">>>"
msgstr ""

#: ../../../library/ctypes.rst:640
msgid "Arrays"
msgstr ""

#: ../../../library/ctypes.rst:642
msgid ""
"Arrays are sequences, containing a fixed number of instances of the same "
"type."
msgstr ""

#: ../../../library/ctypes.rst:644
msgid ""
"The recommended way to create array types is by multiplying a data type with "
"a positive integer::"
msgstr ""

#: ../../../library/ctypes.rst:647
msgid "TenPointsArrayType = POINT * 10"
msgstr ""

#: ../../../library/ctypes.rst:649
msgid ""
"Here is an example of an somewhat artificial data type, a structure "
"containing 4 POINTs among other stuff::"
msgstr ""

#: ../../../library/ctypes.rst:652
msgid ""
">>> from ctypes import *\n"
">>> class POINT(Structure):\n"
"...    _fields_ = (\"x\", c_int), (\"y\", c_int)\n"
"...\n"
">>> class MyStruct(Structure):\n"
"...    _fields_ = [(\"a\", c_int),\n"
"...                (\"b\", c_float),\n"
"...                (\"point_array\", POINT * 4)]\n"
">>>\n"
">>> print(len(MyStruct().point_array))\n"
"4\n"
">>>"
msgstr ""

#: ../../../library/ctypes.rst:665
msgid "Instances are created in the usual way, by calling the class::"
msgstr ""

#: ../../../library/ctypes.rst:667
msgid ""
"arr = TenPointsArrayType()\n"
"for pt in arr:\n"
"    print(pt.x, pt.y)"
msgstr ""

#: ../../../library/ctypes.rst:671
msgid ""
"The above code print a series of ``0 0`` lines, because the array contents "
"is initialized to zeros."
msgstr ""

#: ../../../library/ctypes.rst:674
msgid "Initializers of the correct type can also be specified::"
msgstr ""

#: ../../../library/ctypes.rst:676
msgid ""
">>> from ctypes import *\n"
">>> TenIntegers = c_int * 10\n"
">>> ii = TenIntegers(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)\n"
">>> print(ii)\n"
"<c_long_Array_10 object at 0x...>\n"
">>> for i in ii: print(i, end=\" \")\n"
"...\n"
"1 2 3 4 5 6 7 8 9 10\n"
">>>"
msgstr ""

#: ../../../library/ctypes.rst:690
msgid "Pointers"
msgstr ""

#: ../../../library/ctypes.rst:692
msgid ""
"Pointer instances are created by calling the :func:`pointer` function on a :"
"mod:`ctypes` type::"
msgstr ""

#: ../../../library/ctypes.rst:695
msgid ""
">>> from ctypes import *\n"
">>> i = c_int(42)\n"
">>> pi = pointer(i)\n"
">>>"
msgstr ""

#: ../../../library/ctypes.rst:700
msgid ""
"Pointer instances have a :attr:`contents` attribute which returns the object "
"to which the pointer points, the ``i`` object above::"
msgstr ""

#: ../../../library/ctypes.rst:703
msgid ""
">>> pi.contents\n"
"c_long(42)\n"
">>>"
msgstr ""

#: ../../../library/ctypes.rst:707
msgid ""
"Note that :mod:`ctypes` does not have OOR (original object return), it "
"constructs a new, equivalent object each time you retrieve an attribute::"
msgstr ""

#: ../../../library/ctypes.rst:710
msgid ""
">>> pi.contents is i\n"
"False\n"
">>> pi.contents is pi.contents\n"
"False\n"
">>>"
msgstr ""

#: ../../../library/ctypes.rst:716
msgid ""
"Assigning another :class:`c_int` instance to the pointer's contents "
"attribute would cause the pointer to point to the memory location where this "
"is stored::"
msgstr ""

#: ../../../library/ctypes.rst:719
msgid ""
">>> i = c_int(99)\n"
">>> pi.contents = i\n"
">>> pi.contents\n"
"c_long(99)\n"
">>>"
msgstr ""

#: ../../../library/ctypes.rst:728
msgid "Pointer instances can also be indexed with integers::"
msgstr ""

#: ../../../library/ctypes.rst:730
msgid ""
">>> pi[0]\n"
"99\n"
">>>"
msgstr ""

#: ../../../library/ctypes.rst:734
msgid "Assigning to an integer index changes the pointed to value::"
msgstr ""

#: ../../../library/ctypes.rst:736
msgid ""
">>> print(i)\n"
"c_long(99)\n"
">>> pi[0] = 22\n"
">>> print(i)\n"
"c_long(22)\n"
">>>"
msgstr ""

#: ../../../library/ctypes.rst:743
msgid ""
"It is also possible to use indexes different from 0, but you must know what "
"you're doing, just as in C: You can access or change arbitrary memory "
"locations. Generally you only use this feature if you receive a pointer from "
"a C function, and you *know* that the pointer actually points to an array "
"instead of a single item."
msgstr ""

#: ../../../library/ctypes.rst:749
msgid ""
"Behind the scenes, the :func:`pointer` function does more than simply create "
"pointer instances, it has to create pointer *types* first. This is done with "
"the :func:`POINTER` function, which accepts any :mod:`ctypes` type, and "
"returns a new type::"
msgstr ""

#: ../../../library/ctypes.rst:754
msgid ""
">>> PI = POINTER(c_int)\n"
">>> PI\n"
"<class 'ctypes.LP_c_long'>\n"
">>> PI(42)\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in ?\n"
"TypeError: expected c_long instead of int\n"
">>> PI(c_int(42))\n"
"<ctypes.LP_c_long object at 0x...>\n"
">>>"
msgstr ""

#: ../../../library/ctypes.rst:765
msgid ""
"Calling the pointer type without an argument creates a ``NULL`` pointer. "
"``NULL`` pointers have a ``False`` boolean value::"
msgstr ""

#: ../../../library/ctypes.rst:768
msgid ""
">>> null_ptr = POINTER(c_int)()\n"
">>> print(bool(null_ptr))\n"
"False\n"
">>>"
msgstr ""

#: ../../../library/ctypes.rst:773
msgid ""
":mod:`ctypes` checks for ``NULL`` when dereferencing pointers (but "
"dereferencing invalid non-\\ ``NULL`` pointers would crash Python)::"
msgstr ""

#: ../../../library/ctypes.rst:776
msgid ""
">>> null_ptr[0]\n"
"Traceback (most recent call last):\n"
"    ....\n"
"ValueError: NULL pointer access\n"
">>>\n"
"\n"
">>> null_ptr[0] = 1234\n"
"Traceback (most recent call last):\n"
"    ....\n"
"ValueError: NULL pointer access\n"
">>>"
msgstr ""

#: ../../../library/ctypes.rst:792
msgid "Type conversions"
msgstr ""

#: ../../../library/ctypes.rst:794
msgid ""
"Usually, ctypes does strict type checking.  This means, if you have "
"``POINTER(c_int)`` in the :attr:`argtypes` list of a function or as the type "
"of a member field in a structure definition, only instances of exactly the "
"same type are accepted.  There are some exceptions to this rule, where "
"ctypes accepts other objects.  For example, you can pass compatible array "
"instances instead of pointer types.  So, for ``POINTER(c_int)``, ctypes "
"accepts an array of c_int::"
msgstr ""

#: ../../../library/ctypes.rst:801
msgid ""
">>> class Bar(Structure):\n"
"...     _fields_ = [(\"count\", c_int), (\"values\", POINTER(c_int))]\n"
"...\n"
">>> bar = Bar()\n"
">>> bar.values = (c_int * 3)(1, 2, 3)\n"
">>> bar.count = 3\n"
">>> for i in range(bar.count):\n"
"...     print(bar.values[i])\n"
"...\n"
"1\n"
"2\n"
"3\n"
">>>"
msgstr ""

#: ../../../library/ctypes.rst:815
msgid "To set a POINTER type field to ``NULL``, you can assign ``None``::"
msgstr ""

#: ../../../library/ctypes.rst:817
msgid ""
">>> bar.values = None\n"
">>>"
msgstr ""

#: ../../../library/ctypes.rst:822
msgid ""
"Sometimes you have instances of incompatible types.  In C, you can cast one "
"type into another type.  :mod:`ctypes` provides a :func:`cast` function "
"which can be used in the same way.  The ``Bar`` structure defined above "
"accepts ``POINTER(c_int)`` pointers or :class:`c_int` arrays for its "
"``values`` field, but not instances of other types::"
msgstr ""

#: ../../../library/ctypes.rst:828
msgid ""
">>> bar.values = (c_byte * 4)()\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in ?\n"
"TypeError: incompatible types, c_byte_Array_4 instance instead of LP_c_long "
"instance\n"
">>>"
msgstr ""

#: ../../../library/ctypes.rst:834
msgid "For these cases, the :func:`cast` function is handy."
msgstr ""

#: ../../../library/ctypes.rst:836
msgid ""
"The :func:`cast` function can be used to cast a ctypes instance into a "
"pointer to a different ctypes data type.  :func:`cast` takes two parameters, "
"a ctypes object that is or can be converted to a pointer of some kind, and a "
"ctypes pointer type.  It returns an instance of the second argument, which "
"references the same memory block as the first argument::"
msgstr ""

#: ../../../library/ctypes.rst:842
msgid ""
">>> a = (c_byte * 4)()\n"
">>> cast(a, POINTER(c_int))\n"
"<ctypes.LP_c_long object at ...>\n"
">>>"
msgstr ""

#: ../../../library/ctypes.rst:847
msgid ""
"So, :func:`cast` can be used to assign to the ``values`` field of ``Bar`` "
"the structure::"
msgstr ""

#: ../../../library/ctypes.rst:850
msgid ""
">>> bar = Bar()\n"
">>> bar.values = cast((c_byte * 4)(), POINTER(c_int))\n"
">>> print(bar.values[0])\n"
"0\n"
">>>"
msgstr ""

#: ../../../library/ctypes.rst:860
msgid "Incomplete Types"
msgstr ""

#: ../../../library/ctypes.rst:862
msgid ""
"*Incomplete Types* are structures, unions or arrays whose members are not "
"yet specified. In C, they are specified by forward declarations, which are "
"defined later::"
msgstr ""

#: ../../../library/ctypes.rst:866
msgid ""
"struct cell; /* forward declaration */\n"
"\n"
"struct {\n"
"    char *name;\n"
"    struct cell *next;\n"
"} cell;"
msgstr ""

#: ../../../library/ctypes.rst:873
msgid ""
"The straightforward translation into ctypes code would be this, but it does "
"not work::"
msgstr ""

#: ../../../library/ctypes.rst:876
msgid ""
">>> class cell(Structure):\n"
"...     _fields_ = [(\"name\", c_char_p),\n"
"...                 (\"next\", POINTER(cell))]\n"
"...\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in ?\n"
"  File \"<stdin>\", line 2, in cell\n"
"NameError: name 'cell' is not defined\n"
">>>"
msgstr ""

#: ../../../library/ctypes.rst:886
msgid ""
"because the new ``class cell`` is not available in the class statement "
"itself. In :mod:`ctypes`, we can define the ``cell`` class and set the :attr:"
"`_fields_` attribute later, after the class statement::"
msgstr ""

#: ../../../library/ctypes.rst:890
msgid ""
">>> from ctypes import *\n"
">>> class cell(Structure):\n"
"...     pass\n"
"...\n"
">>> cell._fields_ = [(\"name\", c_char_p),\n"
"...                  (\"next\", POINTER(cell))]\n"
">>>"
msgstr ""

#: ../../../library/ctypes.rst:898
msgid ""
"Lets try it. We create two instances of ``cell``, and let them point to each "
"other, and finally follow the pointer chain a few times::"
msgstr ""

#: ../../../library/ctypes.rst:901
msgid ""
">>> c1 = cell()\n"
">>> c1.name = \"foo\"\n"
">>> c2 = cell()\n"
">>> c2.name = \"bar\"\n"
">>> c1.next = pointer(c2)\n"
">>> c2.next = pointer(c1)\n"
">>> p = c1\n"
">>> for i in range(8):\n"
"...     print(p.name, end=\" \")\n"
"...     p = p.next[0]\n"
"...\n"
"foo bar foo bar foo bar foo bar\n"
">>>"
msgstr ""

#: ../../../library/ctypes.rst:919
msgid "Callback functions"
msgstr ""

#: ../../../library/ctypes.rst:921
msgid ""
":mod:`ctypes` allows to create C callable function pointers from Python "
"callables. These are sometimes called *callback functions*."
msgstr ""

#: ../../../library/ctypes.rst:924
msgid ""
"First, you must create a class for the callback function, the class knows "
"the calling convention, the return type, and the number and types of "
"arguments this function will receive."
msgstr ""

#: ../../../library/ctypes.rst:928
msgid ""
"The CFUNCTYPE factory function creates types for callback functions using "
"the normal cdecl calling convention, and, on Windows, the WINFUNCTYPE "
"factory function creates types for callback functions using the stdcall "
"calling convention."
msgstr ""

#: ../../../library/ctypes.rst:933
msgid ""
"Both of these factory functions are called with the result type as first "
"argument, and the callback functions expected argument types as the "
"remaining arguments."
msgstr ""

#: ../../../library/ctypes.rst:937
msgid ""
"I will present an example here which uses the standard C library's :cfunc:"
"`qsort` function, this is used to sort items with the help of a callback "
"function.  :cfunc:`qsort` will be used to sort an array of integers::"
msgstr ""

#: ../../../library/ctypes.rst:941
msgid ""
">>> IntArray5 = c_int * 5\n"
">>> ia = IntArray5(5, 1, 7, 33, 99)\n"
">>> qsort = libc.qsort\n"
">>> qsort.restype = None\n"
">>>"
msgstr ""

#: ../../../library/ctypes.rst:947
msgid ""
":func:`qsort` must be called with a pointer to the data to sort, the number "
"of items in the data array, the size of one item, and a pointer to the "
"comparison function, the callback. The callback will then be called with two "
"pointers to items, and it must return a negative integer if the first item "
"is smaller than the second, a zero if they are equal, and a positive integer "
"else."
msgstr ""

#: ../../../library/ctypes.rst:953
msgid ""
"So our callback function receives pointers to integers, and must return an "
"integer. First we create the ``type`` for the callback function::"
msgstr ""

#: ../../../library/ctypes.rst:956
msgid ""
">>> CMPFUNC = CFUNCTYPE(c_int, POINTER(c_int), POINTER(c_int))\n"
">>>"
msgstr ""

#: ../../../library/ctypes.rst:959
msgid ""
"For the first implementation of the callback function, we simply print the "
"arguments we get, and return 0 (incremental development ;-)::"
msgstr ""

#: ../../../library/ctypes.rst:962
msgid ""
">>> def py_cmp_func(a, b):\n"
"...     print(\"py_cmp_func\", a, b)\n"
"...     return 0\n"
"...\n"
">>>"
msgstr ""

#: ../../../library/ctypes.rst:968
msgid "Create the C callable callback::"
msgstr ""

#: ../../../library/ctypes.rst:970
msgid ""
">>> cmp_func = CMPFUNC(py_cmp_func)\n"
">>>"
msgstr ""

#: ../../../library/ctypes.rst:973
msgid "And we're ready to go::"
msgstr ""

#: ../../../library/ctypes.rst:975
msgid ""
">>> qsort(ia, len(ia), sizeof(c_int), cmp_func) \n"
"py_cmp_func <ctypes.LP_c_long object at 0x00...> <ctypes.LP_c_long object at "
"0x00...>\n"
"py_cmp_func <ctypes.LP_c_long object at 0x00...> <ctypes.LP_c_long object at "
"0x00...>\n"
"py_cmp_func <ctypes.LP_c_long object at 0x00...> <ctypes.LP_c_long object at "
"0x00...>\n"
"py_cmp_func <ctypes.LP_c_long object at 0x00...> <ctypes.LP_c_long object at "
"0x00...>\n"
"py_cmp_func <ctypes.LP_c_long object at 0x00...> <ctypes.LP_c_long object at "
"0x00...>\n"
"py_cmp_func <ctypes.LP_c_long object at 0x00...> <ctypes.LP_c_long object at "
"0x00...>\n"
"py_cmp_func <ctypes.LP_c_long object at 0x00...> <ctypes.LP_c_long object at "
"0x00...>\n"
"py_cmp_func <ctypes.LP_c_long object at 0x00...> <ctypes.LP_c_long object at "
"0x00...>\n"
"py_cmp_func <ctypes.LP_c_long object at 0x00...> <ctypes.LP_c_long object at "
"0x00...>\n"
"py_cmp_func <ctypes.LP_c_long object at 0x00...> <ctypes.LP_c_long object at "
"0x00...>\n"
">>>"
msgstr ""

#: ../../../library/ctypes.rst:988
msgid ""
"We know how to access the contents of a pointer, so lets redefine our "
"callback::"
msgstr ""

#: ../../../library/ctypes.rst:990
msgid ""
">>> def py_cmp_func(a, b):\n"
"...     print(\"py_cmp_func\", a[0], b[0])\n"
"...     return 0\n"
"...\n"
">>> cmp_func = CMPFUNC(py_cmp_func)\n"
">>>"
msgstr ""

#: ../../../library/ctypes.rst:997
msgid "Here is what we get on Windows::"
msgstr ""

#: ../../../library/ctypes.rst:999
msgid ""
">>> qsort(ia, len(ia), sizeof(c_int), cmp_func) \n"
"py_cmp_func 7 1\n"
"py_cmp_func 33 1\n"
"py_cmp_func 99 1\n"
"py_cmp_func 5 1\n"
"py_cmp_func 7 5\n"
"py_cmp_func 33 5\n"
"py_cmp_func 99 5\n"
"py_cmp_func 7 99\n"
"py_cmp_func 33 99\n"
"py_cmp_func 7 33\n"
">>>"
msgstr ""

#: ../../../library/ctypes.rst:1012
msgid ""
"It is funny to see that on linux the sort function seems to work much more "
"efficiently, it is doing less comparisons::"
msgstr ""

#: ../../../library/ctypes.rst:1015
msgid ""
">>> qsort(ia, len(ia), sizeof(c_int), cmp_func) \n"
"py_cmp_func 5 1\n"
"py_cmp_func 33 99\n"
"py_cmp_func 7 33\n"
"py_cmp_func 5 7\n"
"py_cmp_func 1 7\n"
">>>"
msgstr ""

#: ../../../library/ctypes.rst:1023
msgid ""
"Ah, we're nearly done! The last step is to actually compare the two items "
"and return a useful result::"
msgstr ""

#: ../../../library/ctypes.rst:1026
msgid ""
">>> def py_cmp_func(a, b):\n"
"...     print(\"py_cmp_func\", a[0], b[0])\n"
"...     return a[0] - b[0]\n"
"...\n"
">>>"
msgstr ""

#: ../../../library/ctypes.rst:1032
msgid "Final run on Windows::"
msgstr ""

#: ../../../library/ctypes.rst:1034
msgid ""
">>> qsort(ia, len(ia), sizeof(c_int), CMPFUNC(py_cmp_func)) \n"
"py_cmp_func 33 7\n"
"py_cmp_func 99 33\n"
"py_cmp_func 5 99\n"
"py_cmp_func 1 99\n"
"py_cmp_func 33 7\n"
"py_cmp_func 1 33\n"
"py_cmp_func 5 33\n"
"py_cmp_func 5 7\n"
"py_cmp_func 1 7\n"
"py_cmp_func 5 1\n"
">>>"
msgstr ""

#: ../../../library/ctypes.rst:1047
msgid "and on Linux::"
msgstr ""

#: ../../../library/ctypes.rst:1049
msgid ""
">>> qsort(ia, len(ia), sizeof(c_int), CMPFUNC(py_cmp_func)) \n"
"py_cmp_func 5 1\n"
"py_cmp_func 33 99\n"
"py_cmp_func 7 33\n"
"py_cmp_func 1 7\n"
"py_cmp_func 5 7\n"
">>>"
msgstr ""

#: ../../../library/ctypes.rst:1057
msgid ""
"It is quite interesting to see that the Windows :func:`qsort` function needs "
"more comparisons than the linux version!"
msgstr ""

#: ../../../library/ctypes.rst:1060
msgid "As we can easily check, our array is sorted now::"
msgstr ""

#: ../../../library/ctypes.rst:1062
msgid ""
">>> for i in ia: print(i, end=\" \")\n"
"...\n"
"1 5 7 33 99\n"
">>>"
msgstr ""

#: ../../../library/ctypes.rst:1067
msgid "**Important note for callback functions:**"
msgstr ""

#: ../../../library/ctypes.rst:1069
msgid ""
"Make sure you keep references to CFUNCTYPE objects as long as they are used "
"from C code. :mod:`ctypes` doesn't, and if you don't, they may be garbage "
"collected, crashing your program when a callback is made."
msgstr ""

#: ../../../library/ctypes.rst:1077
msgid "Accessing values exported from dlls"
msgstr ""

#: ../../../library/ctypes.rst:1079
msgid ""
"Some shared libraries not only export functions, they also export variables. "
"An example in the Python library itself is the :cdata:`Py_OptimizeFlag`, an "
"integer set to 0, 1, or 2, depending on the :option:`-O` or :option:`-OO` "
"flag given on startup."
msgstr ""

#: ../../../library/ctypes.rst:1084
msgid ""
":mod:`ctypes` can access values like this with the :meth:`in_dll` class "
"methods of the type.  *pythonapi* is a predefined symbol giving access to "
"the Python C api::"
msgstr ""

#: ../../../library/ctypes.rst:1088
msgid ""
">>> opt_flag = c_int.in_dll(pythonapi, \"Py_OptimizeFlag\")\n"
">>> print(opt_flag)\n"
"c_long(0)\n"
">>>"
msgstr ""

#: ../../../library/ctypes.rst:1093
msgid ""
"If the interpreter would have been started with :option:`-O`, the sample "
"would have printed ``c_long(1)``, or ``c_long(2)`` if :option:`-OO` would "
"have been specified."
msgstr ""

#: ../../../library/ctypes.rst:1097
msgid ""
"An extended example which also demonstrates the use of pointers accesses "
"the :cdata:`PyImport_FrozenModules` pointer exported by Python."
msgstr ""

#: ../../../library/ctypes.rst:1100
msgid "Quoting the docs for that value:"
msgstr ""

#: ../../../library/ctypes.rst:1102
msgid ""
"This pointer is initialized to point to an array of :ctype:`struct _frozen` "
"records, terminated by one whose members are all *NULL* or zero.  When a "
"frozen module is imported, it is searched in this table.  Third-party code "
"could play tricks with this to provide a dynamically created collection of "
"frozen modules."
msgstr ""

#: ../../../library/ctypes.rst:1107
msgid ""
"So manipulating this pointer could even prove useful. To restrict the "
"example size, we show only how this table can be read with :mod:`ctypes`::"
msgstr ""

#: ../../../library/ctypes.rst:1110
msgid ""
">>> from ctypes import *\n"
">>>\n"
">>> class struct_frozen(Structure):\n"
"...     _fields_ = [(\"name\", c_char_p),\n"
"...                 (\"code\", POINTER(c_ubyte)),\n"
"...                 (\"size\", c_int)]\n"
"...\n"
">>>"
msgstr ""

#: ../../../library/ctypes.rst:1119
msgid ""
"We have defined the :ctype:`struct _frozen` data type, so we can get the "
"pointer to the table::"
msgstr ""

#: ../../../library/ctypes.rst:1122
msgid ""
">>> FrozenTable = POINTER(struct_frozen)\n"
">>> table = FrozenTable.in_dll(pythonapi, \"PyImport_FrozenModules\")\n"
">>>"
msgstr ""

#: ../../../library/ctypes.rst:1126
msgid ""
"Since ``table`` is a ``pointer`` to the array of ``struct_frozen`` records, "
"we can iterate over it, but we just have to make sure that our loop "
"terminates, because pointers have no size. Sooner or later it would probably "
"crash with an access violation or whatever, so it's better to break out of "
"the loop when we hit the NULL entry::"
msgstr ""

#: ../../../library/ctypes.rst:1132
msgid ""
">>> for item in table:\n"
"...    print(item.name, item.size)\n"
"...    if item.name is None:\n"
"...        break\n"
"...\n"
"__hello__ 104\n"
"__phello__ -104\n"
"__phello__.spam 104\n"
"None 0\n"
">>>"
msgstr ""

#: ../../../library/ctypes.rst:1143
msgid ""
"The fact that standard Python has a frozen module and a frozen package "
"(indicated by the negative size member) is not well known, it is only used "
"for testing. Try it out with ``import __hello__`` for example."
msgstr ""

#: ../../../library/ctypes.rst:1151
msgid "Surprises"
msgstr ""

#: ../../../library/ctypes.rst:1153
msgid ""
"There are some edges in :mod:`ctypes` where you may be expect something else "
"than what actually happens."
msgstr ""

#: ../../../library/ctypes.rst:1156
msgid "Consider the following example::"
msgstr ""

#: ../../../library/ctypes.rst:1158
msgid ""
">>> from ctypes import *\n"
">>> class POINT(Structure):\n"
"...     _fields_ = (\"x\", c_int), (\"y\", c_int)\n"
"...\n"
">>> class RECT(Structure):\n"
"...     _fields_ = (\"a\", POINT), (\"b\", POINT)\n"
"...\n"
">>> p1 = POINT(1, 2)\n"
">>> p2 = POINT(3, 4)\n"
">>> rc = RECT(p1, p2)\n"
">>> print(rc.a.x, rc.a.y, rc.b.x, rc.b.y)\n"
"1 2 3 4\n"
">>> # now swap the two points\n"
">>> rc.a, rc.b = rc.b, rc.a\n"
">>> print(rc.a.x, rc.a.y, rc.b.x, rc.b.y)\n"
"3 4 3 4\n"
">>>"
msgstr ""

#: ../../../library/ctypes.rst:1176
msgid ""
"Hm. We certainly expected the last statement to print ``3 4 1 2``. What "
"happened? Here are the steps of the ``rc.a, rc.b = rc.b, rc.a`` line above::"
msgstr ""

#: ../../../library/ctypes.rst:1179
msgid ""
">>> temp0, temp1 = rc.b, rc.a\n"
">>> rc.a = temp0\n"
">>> rc.b = temp1\n"
">>>"
msgstr ""

#: ../../../library/ctypes.rst:1184
msgid ""
"Note that ``temp0`` and ``temp1`` are objects still using the internal "
"buffer of the ``rc`` object above. So executing ``rc.a = temp0`` copies the "
"buffer contents of ``temp0`` into ``rc`` 's buffer.  This, in turn, changes "
"the contents of ``temp1``. So, the last assignment ``rc.b = temp1``, doesn't "
"have the expected effect."
msgstr ""

#: ../../../library/ctypes.rst:1190
msgid ""
"Keep in mind that retrieving sub-objects from Structure, Unions, and Arrays "
"doesn't *copy* the sub-object, instead it retrieves a wrapper object "
"accessing the root-object's underlying buffer."
msgstr ""

#: ../../../library/ctypes.rst:1194
msgid ""
"Another example that may behave different from what one would expect is "
"this::"
msgstr ""

#: ../../../library/ctypes.rst:1196
msgid ""
">>> s = c_char_p()\n"
">>> s.value = \"abc def ghi\"\n"
">>> s.value\n"
"'abc def ghi'\n"
">>> s.value is s.value\n"
"False\n"
">>>"
msgstr ""

#: ../../../library/ctypes.rst:1204
msgid ""
"Why is it printing ``False``?  ctypes instances are objects containing a "
"memory block plus some :term:`descriptor`\\s accessing the contents of the "
"memory. Storing a Python object in the memory block does not store the "
"object itself, instead the ``contents`` of the object is stored.  Accessing "
"the contents again constructs a new Python object each time!"
msgstr ""

#: ../../../library/ctypes.rst:1214
msgid "Variable-sized data types"
msgstr ""

#: ../../../library/ctypes.rst:1216
msgid ""
":mod:`ctypes` provides some support for variable-sized arrays and structures."
msgstr ""

#: ../../../library/ctypes.rst:1218
msgid ""
"The :func:`resize` function can be used to resize the memory buffer of an "
"existing ctypes object.  The function takes the object as first argument, "
"and the requested size in bytes as the second argument.  The memory block "
"cannot be made smaller than the natural memory block specified by the "
"objects type, a :exc:`ValueError` is raised if this is tried::"
msgstr ""

#: ../../../library/ctypes.rst:1224
msgid ""
">>> short_array = (c_short * 4)()\n"
">>> print(sizeof(short_array))\n"
"8\n"
">>> resize(short_array, 4)\n"
"Traceback (most recent call last):\n"
"    ...\n"
"ValueError: minimum size is 8\n"
">>> resize(short_array, 32)\n"
">>> sizeof(short_array)\n"
"32\n"
">>> sizeof(type(short_array))\n"
"8\n"
">>>"
msgstr ""

#: ../../../library/ctypes.rst:1238
msgid ""
"This is nice and fine, but how would one access the additional elements "
"contained in this array?  Since the type still only knows about 4 elements, "
"we get errors accessing other elements::"
msgstr ""

#: ../../../library/ctypes.rst:1242
msgid ""
">>> short_array[:]\n"
"[0, 0, 0, 0]\n"
">>> short_array[7]\n"
"Traceback (most recent call last):\n"
"    ...\n"
"IndexError: invalid index\n"
">>>"
msgstr ""

#: ../../../library/ctypes.rst:1250
msgid ""
"Another way to use variable-sized data types with :mod:`ctypes` is to use "
"the dynamic nature of Python, and (re-)define the data type after the "
"required size is already known, on a case by case basis."
msgstr ""

#: ../../../library/ctypes.rst:1258
msgid "ctypes reference"
msgstr ""

#: ../../../library/ctypes.rst:1264
msgid "Finding shared libraries"
msgstr ""

#: ../../../library/ctypes.rst:1266
msgid ""
"When programming in a compiled language, shared libraries are accessed when "
"compiling/linking a program, and when the program is run."
msgstr ""

#: ../../../library/ctypes.rst:1269
msgid ""
"The purpose of the :func:`find_library` function is to locate a library in a "
"way similar to what the compiler does (on platforms with several versions of "
"a shared library the most recent should be loaded), while the ctypes library "
"loaders act like when a program is run, and call the runtime loader directly."
msgstr ""

#: ../../../library/ctypes.rst:1274
msgid ""
"The :mod:`ctypes.util` module provides a function which can help to "
"determine the library to load."
msgstr ""

#: ../../../library/ctypes.rst:1282
msgid ""
"Try to find a library and return a pathname.  *name* is the library name "
"without any prefix like *lib*, suffix like ``.so``, ``.dylib`` or version "
"number (this is the form used for the posix linker option :option:`-l`).  If "
"no library can be found, returns ``None``."
msgstr ""

#: ../../../library/ctypes.rst:1287 ../../../library/ctypes.rst:1862
msgid "The exact functionality is system dependent."
msgstr ""

#: ../../../library/ctypes.rst:1289
msgid ""
"On Linux, :func:`find_library` tries to run external programs (``/sbin/"
"ldconfig``, ``gcc``, and ``objdump``) to find the library file.  It returns "
"the filename of the library file.  Here are some examples::"
msgstr ""

#: ../../../library/ctypes.rst:1293
msgid ""
">>> from ctypes.util import find_library\n"
">>> find_library(\"m\")\n"
"'libm.so.6'\n"
">>> find_library(\"c\")\n"
"'libc.so.6'\n"
">>> find_library(\"bz2\")\n"
"'libbz2.so.1.0'\n"
">>>"
msgstr ""

#: ../../../library/ctypes.rst:1302
msgid ""
"On OS X, :func:`find_library` tries several predefined naming schemes and "
"paths to locate the library, and returns a full pathname if successful::"
msgstr ""

#: ../../../library/ctypes.rst:1305
msgid ""
">>> from ctypes.util import find_library\n"
">>> find_library(\"c\")\n"
"'/usr/lib/libc.dylib'\n"
">>> find_library(\"m\")\n"
"'/usr/lib/libm.dylib'\n"
">>> find_library(\"bz2\")\n"
"'/usr/lib/libbz2.dylib'\n"
">>> find_library(\"AGL\")\n"
"'/System/Library/Frameworks/AGL.framework/AGL'\n"
">>>"
msgstr ""

#: ../../../library/ctypes.rst:1316
msgid ""
"On Windows, :func:`find_library` searches along the system search path, and "
"returns the full pathname, but since there is no predefined naming scheme a "
"call like ``find_library(\"c\")`` will fail and return ``None``."
msgstr ""

#: ../../../library/ctypes.rst:1320
msgid ""
"If wrapping a shared library with :mod:`ctypes`, it *may* be better to "
"determine the shared library name at development type, and hardcode that "
"into the wrapper module instead of using :func:`find_library` to locate the "
"library at runtime."
msgstr ""

#: ../../../library/ctypes.rst:1328
msgid "Loading shared libraries"
msgstr ""

#: ../../../library/ctypes.rst:1330
msgid ""
"There are several ways to loaded shared libraries into the Python process.  "
"One way is to instantiate one of the following classes:"
msgstr ""

#: ../../../library/ctypes.rst:1336
msgid ""
"Instances of this class represent loaded shared libraries. Functions in "
"these libraries use the standard C calling convention, and are assumed to "
"return :ctype:`int`."
msgstr ""

#: ../../../library/ctypes.rst:1343
msgid ""
"Windows only: Instances of this class represent loaded shared libraries, "
"functions in these libraries use the ``stdcall`` calling convention, and are "
"assumed to return the windows specific :class:`HRESULT` code.  :class:"
"`HRESULT` values contain information specifying whether the function call "
"failed or succeeded, together with additional error code.  If the return "
"value signals a failure, an :class:`WindowsError` is automatically raised."
msgstr ""

#: ../../../library/ctypes.rst:1353
msgid ""
"Windows only: Instances of this class represent loaded shared libraries, "
"functions in these libraries use the ``stdcall`` calling convention, and are "
"assumed to return :ctype:`int` by default."
msgstr ""

#: ../../../library/ctypes.rst:1357
msgid ""
"On Windows CE only the standard calling convention is used, for convenience "
"the :class:`WinDLL` and :class:`OleDLL` use the standard calling convention "
"on this platform."
msgstr ""

#: ../../../library/ctypes.rst:1361
msgid ""
"The Python :term:`global interpreter lock` is released before calling any "
"function exported by these libraries, and reacquired afterwards."
msgstr ""

#: ../../../library/ctypes.rst:1367
msgid ""
"Instances of this class behave like :class:`CDLL` instances, except that the "
"Python GIL is *not* released during the function call, and after the "
"function execution the Python error flag is checked. If the error flag is "
"set, a Python exception is raised."
msgstr ""

#: ../../../library/ctypes.rst:1372
msgid "Thus, this is only useful to call Python C api functions directly."
msgstr ""

#: ../../../library/ctypes.rst:1374
msgid ""
"All these classes can be instantiated by calling them with at least one "
"argument, the pathname of the shared library.  If you have an existing "
"handle to an already loaded shared library, it can be passed as the "
"``handle`` named parameter, otherwise the underlying platforms ``dlopen`` or "
"``LoadLibrary`` function is used to load the library into the process, and "
"to get a handle to it."
msgstr ""

#: ../../../library/ctypes.rst:1381
msgid ""
"The *mode* parameter can be used to specify how the library is loaded.  For "
"details, consult the :manpage:`dlopen(3)` manpage, on Windows, *mode* is "
"ignored."
msgstr ""

#: ../../../library/ctypes.rst:1385
msgid ""
"The *use_errno* parameter, when set to True, enables a ctypes mechanism that "
"allows to access the system :data:`errno` error number in a safe way. :mod:"
"`ctypes` maintains a thread-local copy of the systems :data:`errno` "
"variable; if you call foreign functions created with ``use_errno=True`` then "
"the :data:`errno` value before the function call is swapped with the ctypes "
"private copy, the same happens immediately after the function call."
msgstr ""

#: ../../../library/ctypes.rst:1392
msgid ""
"The function :func:`ctypes.get_errno` returns the value of the ctypes "
"private copy, and the function :func:`ctypes.set_errno` changes the ctypes "
"private copy to a new value and returns the former value."
msgstr ""

#: ../../../library/ctypes.rst:1396
msgid ""
"The *use_last_error* parameter, when set to True, enables the same mechanism "
"for the Windows error code which is managed by the :func:`GetLastError` and :"
"func:`SetLastError` Windows API functions; :func:`ctypes.get_last_error` "
"and :func:`ctypes.set_last_error` are used to request and change the ctypes "
"private copy of the windows error code."
msgstr ""

#: ../../../library/ctypes.rst:1405
msgid ""
"Flag to use as *mode* parameter.  On platforms where this flag is not "
"available, it is defined as the integer zero."
msgstr ""

#: ../../../library/ctypes.rst:1412
msgid ""
"Flag to use as *mode* parameter.  On platforms where this is not available, "
"it is the same as *RTLD_GLOBAL*."
msgstr ""

#: ../../../library/ctypes.rst:1419
msgid ""
"The default mode which is used to load shared libraries.  On OSX 10.3, this "
"is *RTLD_GLOBAL*, otherwise it is the same as *RTLD_LOCAL*."
msgstr ""

#: ../../../library/ctypes.rst:1422
msgid ""
"Instances of these classes have no public methods, however :meth:"
"`__getattr__` and :meth:`__getitem__` have special behavior: functions "
"exported by the shared library can be accessed as attributes of by index.  "
"Please note that both :meth:`__getattr__` and :meth:`__getitem__` cache "
"their result, so calling them repeatedly returns the same object each time."
msgstr ""

#: ../../../library/ctypes.rst:1428
msgid ""
"The following public attributes are available, their name starts with an "
"underscore to not clash with exported function names:"
msgstr ""

#: ../../../library/ctypes.rst:1434
msgid "The system handle used to access the library."
msgstr ""

#: ../../../library/ctypes.rst:1439
msgid "The name of the library passed in the constructor."
msgstr ""

#: ../../../library/ctypes.rst:1441
msgid ""
"Shared libraries can also be loaded by using one of the prefabricated "
"objects, which are instances of the :class:`LibraryLoader` class, either by "
"calling the :meth:`LoadLibrary` method, or by retrieving the library as "
"attribute of the loader instance."
msgstr ""

#: ../../../library/ctypes.rst:1449
msgid ""
"Class which loads shared libraries.  *dlltype* should be one of the :class:"
"`CDLL`, :class:`PyDLL`, :class:`WinDLL`, or :class:`OleDLL` types."
msgstr ""

#: ../../../library/ctypes.rst:1452
msgid ""
":meth:`__getattr__` has special behavior: It allows to load a shared library "
"by accessing it as attribute of a library loader instance.  The result is "
"cached, so repeated attribute accesses return the same library each time."
msgstr ""

#: ../../../library/ctypes.rst:1458
msgid ""
"Load a shared library into the process and return it.  This method always "
"returns a new instance of the library."
msgstr ""

#: ../../../library/ctypes.rst:1462
msgid "These prefabricated library loaders are available:"
msgstr ""

#: ../../../library/ctypes.rst:1467
msgid "Creates :class:`CDLL` instances."
msgstr ""

#: ../../../library/ctypes.rst:1473
msgid "Windows only: Creates :class:`WinDLL` instances."
msgstr ""

#: ../../../library/ctypes.rst:1479
msgid "Windows only: Creates :class:`OleDLL` instances."
msgstr ""

#: ../../../library/ctypes.rst:1485
msgid "Creates :class:`PyDLL` instances."
msgstr ""

#: ../../../library/ctypes.rst:1488
msgid ""
"For accessing the C Python api directly, a ready-to-use Python shared "
"library object is available:"
msgstr ""

#: ../../../library/ctypes.rst:1494
msgid ""
"An instance of :class:`PyDLL` that exposes Python C API functions as "
"attributes.  Note that all these functions are assumed to return C :ctype:"
"`int`, which is of course not always the truth, so you have to assign the "
"correct :attr:`restype` attribute to use these functions."
msgstr ""

#: ../../../library/ctypes.rst:1503
msgid "Foreign functions"
msgstr ""

#: ../../../library/ctypes.rst:1505
msgid ""
"As explained in the previous section, foreign functions can be accessed as "
"attributes of loaded shared libraries.  The function objects created in this "
"way by default accept any number of arguments, accept any ctypes data "
"instances as arguments, and return the default result type specified by the "
"library loader. They are instances of a private class:"
msgstr ""

#: ../../../library/ctypes.rst:1514
msgid "Base class for C callable foreign functions."
msgstr ""

#: ../../../library/ctypes.rst:1516
msgid ""
"Instances of foreign functions are also C compatible data types; they "
"represent C function pointers."
msgstr ""

#: ../../../library/ctypes.rst:1519
msgid ""
"This behavior can be customized by assigning to special attributes of the "
"foreign function object."
msgstr ""

#: ../../../library/ctypes.rst:1524
msgid ""
"Assign a ctypes type to specify the result type of the foreign function. Use "
"``None`` for :ctype:`void`, a function not returning anything."
msgstr ""

#: ../../../library/ctypes.rst:1527
msgid ""
"It is possible to assign a callable Python object that is not a ctypes type, "
"in this case the function is assumed to return a C :ctype:`int`, and the "
"callable will be called with this integer, allowing to do further processing "
"or error checking.  Using this is deprecated, for more flexible post "
"processing or error checking use a ctypes data type as :attr:`restype` and "
"assign a callable to the :attr:`errcheck` attribute."
msgstr ""

#: ../../../library/ctypes.rst:1536
msgid ""
"Assign a tuple of ctypes types to specify the argument types that the "
"function accepts.  Functions using the ``stdcall`` calling convention can "
"only be called with the same number of arguments as the length of this "
"tuple; functions using the C calling convention accept additional, "
"unspecified arguments as well."
msgstr ""

#: ../../../library/ctypes.rst:1542
msgid ""
"When a foreign function is called, each actual argument is passed to the :"
"meth:`from_param` class method of the items in the :attr:`argtypes` tuple, "
"this method allows to adapt the actual argument to an object that the "
"foreign function accepts.  For example, a :class:`c_char_p` item in the :"
"attr:`argtypes` tuple will convert a string passed as argument into a bytes "
"object using ctypes conversion rules."
msgstr ""

#: ../../../library/ctypes.rst:1549
msgid ""
"New: It is now possible to put items in argtypes which are not ctypes types, "
"but each item must have a :meth:`from_param` method which returns a value "
"usable as argument (integer, string, ctypes instance).  This allows to "
"define adapters that can adapt custom objects as function parameters."
msgstr ""

#: ../../../library/ctypes.rst:1556
msgid ""
"Assign a Python function or another callable to this attribute. The callable "
"will be called with three or more arguments:"
msgstr ""

#: ../../../library/ctypes.rst:1563
msgid ""
"*result* is what the foreign function returns, as specified by the :attr:"
"`restype` attribute."
msgstr ""

#: ../../../library/ctypes.rst:1566
msgid ""
"*func* is the foreign function object itself, this allows to reuse the same "
"callable object to check or post process the results of several functions."
msgstr ""

#: ../../../library/ctypes.rst:1570
msgid ""
"*arguments* is a tuple containing the parameters originally passed to the "
"function call, this allows to specialize the behavior on the arguments used."
msgstr ""

#: ../../../library/ctypes.rst:1574
msgid ""
"The object that this function returns will be returned from the foreign "
"function call, but it can also check the result value and raise an exception "
"if the foreign function call failed."
msgstr ""

#: ../../../library/ctypes.rst:1581
msgid ""
"This exception is raised when a foreign function call cannot convert one of "
"the passed arguments."
msgstr ""

#: ../../../library/ctypes.rst:1588
msgid "Function prototypes"
msgstr ""

#: ../../../library/ctypes.rst:1590
msgid ""
"Foreign functions can also be created by instantiating function prototypes. "
"Function prototypes are similar to function prototypes in C; they describe a "
"function (return type, argument types, calling convention) without defining "
"an implementation.  The factory functions must be called with the desired "
"result type and the argument types of the function."
msgstr ""

#: ../../../library/ctypes.rst:1599
msgid ""
"The returned function prototype creates functions that use the standard C "
"calling convention.  The function will release the GIL during the call.  If "
"*use_errno* is set to True, the ctypes private copy of the system :data:"
"`errno` variable is exchanged with the real :data:`errno` value before and "
"after the call; *use_last_error* does the same for the Windows error code."
msgstr ""

#: ../../../library/ctypes.rst:1609
msgid ""
"Windows only: The returned function prototype creates functions that use the "
"``stdcall`` calling convention, except on Windows CE where :func:"
"`WINFUNCTYPE` is the same as :func:`CFUNCTYPE`.  The function will release "
"the GIL during the call.  *use_errno* and *use_last_error* have the same "
"meaning as above."
msgstr ""

#: ../../../library/ctypes.rst:1618
msgid ""
"The returned function prototype creates functions that use the Python "
"calling convention.  The function will *not* release the GIL during the call."
msgstr ""

#: ../../../library/ctypes.rst:1621
msgid ""
"Function prototypes created by these factory functions can be instantiated "
"in different ways, depending on the type and number of the parameters in the "
"call:"
msgstr ""

#: ../../../library/ctypes.rst:1629
msgid ""
"Returns a foreign function at the specified address which must be an integer."
msgstr ""

#: ../../../library/ctypes.rst:1636
msgid ""
"Create a C callable function (a callback function) from a Python *callable*."
msgstr ""

#: ../../../library/ctypes.rst:1643
msgid ""
"Returns a foreign function exported by a shared library. *func_spec* must be "
"a 2-tuple ``(name_or_ordinal, library)``. The first item is the name of the "
"exported function as string, or the ordinal of the exported function as "
"small integer.  The second item is the shared library instance."
msgstr ""

#: ../../../library/ctypes.rst:1653
msgid ""
"Returns a foreign function that will call a COM method. *vtbl_index* is the "
"index into the virtual function table, a small non-negative integer. *name* "
"is name of the COM method. *iid* is an optional pointer to the interface "
"identifier which is used in extended error reporting."
msgstr ""

#: ../../../library/ctypes.rst:1658
msgid ""
"COM methods use a special calling convention: They require a pointer to the "
"COM interface as first argument, in addition to those parameters that are "
"specified in the :attr:`argtypes` tuple."
msgstr ""

#: ../../../library/ctypes.rst:1662
msgid ""
"The optional *paramflags* parameter creates foreign function wrappers with "
"much more functionality than the features described above."
msgstr ""

#: ../../../library/ctypes.rst:1665
msgid "*paramflags* must be a tuple of the same length as :attr:`argtypes`."
msgstr ""

#: ../../../library/ctypes.rst:1667
msgid ""
"Each item in this tuple contains further information about a parameter, it "
"must be a tuple containing one, two, or three items."
msgstr ""

#: ../../../library/ctypes.rst:1670
msgid ""
"The first item is an integer containing a combination of direction flags for "
"the parameter:"
msgstr ""

#: ../../../library/ctypes.rst:1674
msgid "1"
msgstr ""

#: ../../../library/ctypes.rst:1674
msgid "Specifies an input parameter to the function."
msgstr ""

#: ../../../library/ctypes.rst:1677
msgid "2"
msgstr ""

#: ../../../library/ctypes.rst:1677
msgid "Output parameter.  The foreign function fills in a value."
msgstr ""

#: ../../../library/ctypes.rst:1680
msgid "4"
msgstr ""

#: ../../../library/ctypes.rst:1680
msgid "Input parameter which defaults to the integer zero."
msgstr ""

#: ../../../library/ctypes.rst:1682
msgid ""
"The optional second item is the parameter name as string.  If this is "
"specified, the foreign function can be called with named parameters."
msgstr ""

#: ../../../library/ctypes.rst:1685
msgid "The optional third item is the default value for this parameter."
msgstr ""

#: ../../../library/ctypes.rst:1687
msgid ""
"This example demonstrates how to wrap the Windows ``MessageBoxA`` function "
"so that it supports default parameters and named arguments. The C "
"declaration from the windows header file is this::"
msgstr ""

#: ../../../library/ctypes.rst:1691
msgid ""
"WINUSERAPI int WINAPI\n"
"MessageBoxA(\n"
"    HWND hWnd ,\n"
"    LPCSTR lpText,\n"
"    LPCSTR lpCaption,\n"
"    UINT uType);"
msgstr ""

#: ../../../library/ctypes.rst:1698 ../../../library/ctypes.rst:1723
msgid "Here is the wrapping with :mod:`ctypes`::"
msgstr ""

#: ../../../library/ctypes.rst:1700
msgid ""
">>> from ctypes import c_int, WINFUNCTYPE, windll\n"
">>> from ctypes.wintypes import HWND, LPCSTR, UINT\n"
">>> prototype = WINFUNCTYPE(c_int, HWND, LPCSTR, LPCSTR, UINT)\n"
">>> paramflags = (1, \"hwnd\", 0), (1, \"text\", \"Hi\"), (1, \"caption\", "
"None), (1, \"flags\", 0)\n"
">>> MessageBox = prototype((\"MessageBoxA\", windll.user32), paramflags)\n"
">>>"
msgstr ""

#: ../../../library/ctypes.rst:1707
msgid "The MessageBox foreign function can now be called in these ways::"
msgstr ""

#: ../../../library/ctypes.rst:1709
msgid ""
">>> MessageBox()\n"
">>> MessageBox(text=\"Spam, spam, spam\")\n"
">>> MessageBox(flags=2, text=\"foo bar\")\n"
">>>"
msgstr ""

#: ../../../library/ctypes.rst:1714
msgid ""
"A second example demonstrates output parameters.  The win32 "
"``GetWindowRect`` function retrieves the dimensions of a specified window by "
"copying them into ``RECT`` structure that the caller has to supply.  Here is "
"the C declaration::"
msgstr ""

#: ../../../library/ctypes.rst:1718
msgid ""
"WINUSERAPI BOOL WINAPI\n"
"GetWindowRect(\n"
"     HWND hWnd,\n"
"     LPRECT lpRect);"
msgstr ""

#: ../../../library/ctypes.rst:1725
msgid ""
">>> from ctypes import POINTER, WINFUNCTYPE, windll, WinError\n"
">>> from ctypes.wintypes import BOOL, HWND, RECT\n"
">>> prototype = WINFUNCTYPE(BOOL, HWND, POINTER(RECT))\n"
">>> paramflags = (1, \"hwnd\"), (2, \"lprect\")\n"
">>> GetWindowRect = prototype((\"GetWindowRect\", windll.user32), "
"paramflags)\n"
">>>"
msgstr ""

#: ../../../library/ctypes.rst:1732
msgid ""
"Functions with output parameters will automatically return the output "
"parameter value if there is a single one, or a tuple containing the output "
"parameter values when there are more than one, so the GetWindowRect function "
"now returns a RECT instance, when called."
msgstr ""

#: ../../../library/ctypes.rst:1737
msgid ""
"Output parameters can be combined with the :attr:`errcheck` protocol to do "
"further output processing and error checking.  The win32 ``GetWindowRect`` "
"api function returns a ``BOOL`` to signal success or failure, so this "
"function could do the error checking, and raises an exception when the api "
"call failed::"
msgstr ""

#: ../../../library/ctypes.rst:1742
msgid ""
">>> def errcheck(result, func, args):\n"
"...     if not result:\n"
"...         raise WinError()\n"
"...     return args\n"
"...\n"
">>> GetWindowRect.errcheck = errcheck\n"
">>>"
msgstr ""

#: ../../../library/ctypes.rst:1750
msgid ""
"If the :attr:`errcheck` function returns the argument tuple it receives "
"unchanged, :mod:`ctypes` continues the normal processing it does on the "
"output parameters.  If you want to return a tuple of window coordinates "
"instead of a ``RECT`` instance, you can retrieve the fields in the function "
"and return them instead, the normal processing will no longer take place::"
msgstr ""

#: ../../../library/ctypes.rst:1756
msgid ""
">>> def errcheck(result, func, args):\n"
"...     if not result:\n"
"...         raise WinError()\n"
"...     rc = args[1]\n"
"...     return rc.left, rc.top, rc.bottom, rc.right\n"
"...\n"
">>> GetWindowRect.errcheck = errcheck\n"
">>>"
msgstr ""

#: ../../../library/ctypes.rst:1769
msgid "Utility functions"
msgstr ""

#: ../../../library/ctypes.rst:1773
msgid ""
"Returns the address of the memory buffer as integer.  *obj* must be an "
"instance of a ctypes type."
msgstr ""

#: ../../../library/ctypes.rst:1779
msgid ""
"Returns the alignment requirements of a ctypes type. *obj_or_type* must be a "
"ctypes type or instance."
msgstr ""

#: ../../../library/ctypes.rst:1785
msgid ""
"Returns a light-weight pointer to *obj*, which must be an instance of a "
"ctypes type.  *offset* defaults to zero, and must be an integer that will be "
"added to the internal pointer value."
msgstr ""

#: ../../../library/ctypes.rst:1789
msgid "``byref(obj, offset)`` corresponds to this C code::"
msgstr ""

#: ../../../library/ctypes.rst:1791
msgid "(((char *)&obj) + offset)"
msgstr ""

#: ../../../library/ctypes.rst:1793
msgid ""
"The returned object can only be used as a foreign function call parameter. "
"It behaves similar to ``pointer(obj)``, but the construction is a lot faster."
msgstr ""

#: ../../../library/ctypes.rst:1799
msgid ""
"This function is similar to the cast operator in C. It returns a new "
"instance of *type* which points to the same memory block as *obj*.  *type* "
"must be a pointer type, and *obj* must be an object that can be interpreted "
"as a pointer."
msgstr ""

#: ../../../library/ctypes.rst:1807
msgid ""
"This function creates a mutable character buffer. The returned object is a "
"ctypes array of :class:`c_char`."
msgstr ""

#: ../../../library/ctypes.rst:1810
msgid ""
"*init_or_size* must be an integer which specifies the size of the array, or "
"a bytes object which will be used to initialize the array items."
msgstr ""

#: ../../../library/ctypes.rst:1813
msgid ""
"If a bytes object is specified as first argument, the buffer is made one "
"item larger than its length so that the last element in the array is a NUL "
"termination character. An integer can be passed as second argument which "
"allows to specify the size of the array if the length of the bytes should "
"not be used."
msgstr ""

#: ../../../library/ctypes.rst:1818
msgid ""
"If the first parameter is a string, it is converted into a bytes object "
"according to ctypes conversion rules."
msgstr ""

#: ../../../library/ctypes.rst:1824
msgid ""
"This function creates a mutable unicode character buffer. The returned "
"object is a ctypes array of :class:`c_wchar`."
msgstr ""

#: ../../../library/ctypes.rst:1827
msgid ""
"*init_or_size* must be an integer which specifies the size of the array, or "
"a string which will be used to initialize the array items."
msgstr ""

#: ../../../library/ctypes.rst:1830
msgid ""
"If a string is specified as first argument, the buffer is made one item "
"larger than the length of the string so that the last element in the array "
"is a NUL termination character. An integer can be passed as second argument "
"which allows to specify the size of the array if the length of the string "
"should not be used."
msgstr ""

#: ../../../library/ctypes.rst:1836
msgid ""
"If the first parameter is a bytes object, it is converted into an unicode "
"string according to ctypes conversion rules."
msgstr ""

#: ../../../library/ctypes.rst:1842
msgid ""
"Windows only: This function is a hook which allows to implement in-process "
"COM servers with ctypes.  It is called from the DllCanUnloadNow function "
"that the _ctypes extension dll exports."
msgstr ""

#: ../../../library/ctypes.rst:1849
msgid ""
"Windows only: This function is a hook which allows to implement in-process "
"COM servers with ctypes.  It is called from the DllGetClassObject function "
"that the ``_ctypes`` extension dll exports."
msgstr ""

#: ../../../library/ctypes.rst:1857
msgid ""
"Try to find a library and return a pathname.  *name* is the library name "
"without any prefix like ``lib``, suffix like ``.so``, ``.dylib`` or version "
"number (this is the form used for the posix linker option :option:`-l`).  If "
"no library can be found, returns ``None``."
msgstr ""

#: ../../../library/ctypes.rst:1868
msgid ""
"Windows only: return the filename of the VC runtype library used by Python, "
"and by the extension modules.  If the name of the library cannot be "
"determined, ``None`` is returned."
msgstr ""

#: ../../../library/ctypes.rst:1872
msgid ""
"If you need to free memory, for example, allocated by an extension module "
"with a call to the ``free(void *)``, it is important that you use the "
"function in the same library that allocated the memory."
msgstr ""

#: ../../../library/ctypes.rst:1879
msgid ""
"Windows only: Returns a textual description of the error code *code*.  If no "
"error code is specified, the last error code is used by calling the Windows "
"api function GetLastError."
msgstr ""

#: ../../../library/ctypes.rst:1886
msgid ""
"Windows only: Returns the last error code set by Windows in the calling "
"thread. This function calls the Windows `GetLastError()` function directly, "
"it does not return the ctypes-private copy of the error code."
msgstr ""

#: ../../../library/ctypes.rst:1892
msgid ""
"Returns the current value of the ctypes-private copy of the system :data:"
"`errno` variable in the calling thread."
msgstr ""

#: ../../../library/ctypes.rst:1897
msgid ""
"Windows only: returns the current value of the ctypes-private copy of the "
"system :data:`LastError` variable in the calling thread."
msgstr ""

#: ../../../library/ctypes.rst:1902
msgid ""
"Same as the standard C memmove library function: copies *count* bytes from "
"*src* to *dst*. *dst* and *src* must be integers or ctypes instances that "
"can be converted to pointers."
msgstr ""

#: ../../../library/ctypes.rst:1909
msgid ""
"Same as the standard C memset library function: fills the memory block at "
"address *dst* with *count* bytes of value *c*. *dst* must be an integer "
"specifying an address, or a ctypes instance."
msgstr ""

#: ../../../library/ctypes.rst:1916
msgid ""
"This factory function creates and returns a new ctypes pointer type. Pointer "
"types are cached an reused internally, so calling this function repeatedly "
"is cheap. *type* must be a ctypes type."
msgstr ""

#: ../../../library/ctypes.rst:1923
msgid ""
"This function creates a new pointer instance, pointing to *obj*. The "
"returned object is of the type ``POINTER(type(obj))``."
msgstr ""

#: ../../../library/ctypes.rst:1926
msgid ""
"Note: If you just want to pass a pointer to an object to a foreign function "
"call, you should use ``byref(obj)`` which is much faster."
msgstr ""

#: ../../../library/ctypes.rst:1932
msgid ""
"This function resizes the internal memory buffer of *obj*, which must be an "
"instance of a ctypes type.  It is not possible to make the buffer smaller "
"than the native size of the objects type, as given by ``sizeof(type(obj))``, "
"but it is possible to enlarge the buffer."
msgstr ""

#: ../../../library/ctypes.rst:1940
msgid ""
"This function sets the rules that ctypes objects use when converting between "
"bytes objects and (unicode) strings. *encoding* must be a string specifying "
"an encoding, like ``'utf-8'`` or ``'mbcs'``, *errors* must be a string "
"specifying the error handling on encoding/decoding errors. Examples of "
"possible values are ``'strict'``, ``'replace'``, or ``'ignore'``."
msgstr ""

#: ../../../library/ctypes.rst:1946
msgid ""
":func:`set_conversion_mode` returns a 2-tuple containing the previous "
"conversion rules. On windows, the initial conversion rules are ``('mbcs', "
"'ignore')``, on other systems ``('ascii', 'strict')``."
msgstr ""

#: ../../../library/ctypes.rst:1950
msgid ""
"You can set the *encoding* to ``'undefined'`` to completely disable "
"automatic conversions."
msgstr ""

#: ../../../library/ctypes.rst:1956
msgid ""
"Set the current value of the ctypes-private copy of the system :data:`errno` "
"variable in the calling thread to *value* and return the previous value."
msgstr ""

#: ../../../library/ctypes.rst:1963
msgid ""
"Windows only: set the current value of the ctypes-private copy of the "
"system :data:`LastError` variable in the calling thread to *value* and "
"return the previous value."
msgstr ""

#: ../../../library/ctypes.rst:1971
msgid ""
"Returns the size in bytes of a ctypes type or instance memory buffer. Does "
"the same as the C ``sizeof()`` function."
msgstr ""

#: ../../../library/ctypes.rst:1977
msgid ""
"This function returns the C string starting at memory address address as a "
"bytes object. If size is specified, it is used as size, otherwise the string "
"is assumed to be zero-terminated."
msgstr ""

#: ../../../library/ctypes.rst:1984
msgid ""
"Windows only: this function is probably the worst-named thing in ctypes. It "
"creates an instance of WindowsError.  If *code* is not specified, "
"``GetLastError`` is called to determine the error code. If *descr* is not "
"specified, :func:`FormatError` is called to get a textual description of the "
"error."
msgstr ""

#: ../../../library/ctypes.rst:1993
msgid ""
"This function returns the wide character string starting at memory address "
"*address* as a string.  If *size* is specified, it is used as the number of "
"characters of the string, otherwise the string is assumed to be zero-"
"terminated."
msgstr ""

#: ../../../library/ctypes.rst:2002
msgid "Data types"
msgstr ""

#: ../../../library/ctypes.rst:2007
msgid ""
"This non-public class is the common base class of all ctypes data types. "
"Among other things, all ctypes type instances contain a memory block that "
"hold C compatible data; the address of the memory block is returned by the :"
"func:`addressof` helper function. Another instance variable is exposed as :"
"attr:`_objects`; this contains other Python objects that need to be kept "
"alive in case the memory block contains pointers."
msgstr ""

#: ../../../library/ctypes.rst:2014
msgid ""
"Common methods of ctypes data types, these are all class methods (to be "
"exact, they are methods of the :term:`metaclass`):"
msgstr ""

#: ../../../library/ctypes.rst:2019
msgid ""
"This method returns a ctypes instance that shares the buffer of the *source* "
"object.  The *source* object must support the writeable buffer interface.  "
"The optional *offset* parameter specifies an offset into the source buffer "
"in bytes; the default is zero.  If the source buffer is not large enough a :"
"exc:`ValueError` is raised."
msgstr ""

#: ../../../library/ctypes.rst:2028
msgid ""
"This method creates a ctypes instance, copying the buffer from the *source* "
"object buffer which must be readable.  The optional *offset* parameter "
"specifies an offset into the source buffer in bytes; the default is zero.  "
"If the source buffer is not large enough a :exc:`ValueError` is raised."
msgstr ""

#: ../../../library/ctypes.rst:2036
msgid ""
"This method returns a ctypes type instance using the memory specified by "
"*address* which must be an integer."
msgstr ""

#: ../../../library/ctypes.rst:2041
msgid ""
"This method adapts *obj* to a ctypes type.  It is called with the actual "
"object used in a foreign function call when the type is present in the "
"foreign function's :attr:`argtypes` tuple; it must return an object that can "
"be used as a function call parameter."
msgstr ""

#: ../../../library/ctypes.rst:2046
msgid ""
"All ctypes data types have a default implementation of this classmethod that "
"normally returns *obj* if that is an instance of the type.  Some types "
"accept other objects as well."
msgstr ""

#: ../../../library/ctypes.rst:2052
msgid ""
"This method returns a ctypes type instance exported by a shared library. "
"*name* is the name of the symbol that exports the data, *library* is the "
"loaded shared library."
msgstr ""

#: ../../../library/ctypes.rst:2056
msgid "Common instance variables of ctypes data types:"
msgstr ""

#: ../../../library/ctypes.rst:2060
msgid ""
"Sometimes ctypes data instances do not own the memory block they contain, "
"instead they share part of the memory block of a base object.  The :attr:"
"`_b_base_` read-only member is the root ctypes object that owns the memory "
"block."
msgstr ""

#: ../../../library/ctypes.rst:2067
msgid ""
"This read-only variable is true when the ctypes data instance has allocated "
"the memory block itself, false otherwise."
msgstr ""

#: ../../../library/ctypes.rst:2072
msgid ""
"This member is either ``None`` or a dictionary containing Python objects "
"that need to be kept alive so that the memory block contents is kept valid.  "
"This object is only exposed for debugging; never modify the contents of this "
"dictionary."
msgstr ""

#: ../../../library/ctypes.rst:2085
msgid ""
"This non-public class is the base class of all fundamental ctypes data "
"types. It is mentioned here because it contains the common attributes of the "
"fundamental ctypes data types.  :class:`_SimpleCData` is a subclass of :"
"class:`_CData`, so it inherits their methods and attributes. ctypes data "
"types that are not and do not contain pointers can now be pickled."
msgstr ""

#: ../../../library/ctypes.rst:2091
msgid "Instances have a single attribute:"
msgstr ""

#: ../../../library/ctypes.rst:2095
msgid ""
"This attribute contains the actual value of the instance. For integer and "
"pointer types, it is an integer, for character types, it is a single "
"character bytes object or string, for character pointer types it is a Python "
"bytes object or string."
msgstr ""

#: ../../../library/ctypes.rst:2100
msgid ""
"When the ``value`` attribute is retrieved from a ctypes instance, usually a "
"new object is returned each time.  :mod:`ctypes` does *not* implement "
"original object return, always a new object is constructed.  The same is "
"true for all other ctypes object instances."
msgstr ""

#: ../../../library/ctypes.rst:2106
msgid ""
"Fundamental data types, when returned as foreign function call results, or, "
"for example, by retrieving structure field members or array items, are "
"transparently converted to native Python types.  In other words, if a "
"foreign function has a :attr:`restype` of :class:`c_char_p`, you will always "
"receive a Python bytes object, *not* a :class:`c_char_p` instance."
msgstr ""

#: ../../../library/ctypes.rst:2114
msgid ""
"Subclasses of fundamental data types do *not* inherit this behavior. So, if "
"a foreign functions :attr:`restype` is a subclass of :class:`c_void_p`, you "
"will receive an instance of this subclass from the function call. Of course, "
"you can get the value of the pointer by accessing the ``value`` attribute."
msgstr ""

#: ../../../library/ctypes.rst:2119
msgid "These are the fundamental ctypes data types:"
msgstr ""

#: ../../../library/ctypes.rst:2123
msgid ""
"Represents the C :ctype:`signed char` datatype, and interprets the value as "
"small integer.  The constructor accepts an optional integer initializer; no "
"overflow checking is done."
msgstr ""

#: ../../../library/ctypes.rst:2130
msgid ""
"Represents the C :ctype:`char` datatype, and interprets the value as a "
"single character.  The constructor accepts an optional string initializer, "
"the length of the string must be exactly one character."
msgstr ""

#: ../../../library/ctypes.rst:2137
msgid ""
"Represents the C :ctype:`char *` datatype when it points to a zero-"
"terminated string.  For a general character pointer that may also point to "
"binary data, ``POINTER(c_char)`` must be used.  The constructor accepts an "
"integer address, or a bytes object."
msgstr ""

#: ../../../library/ctypes.rst:2145
msgid ""
"Represents the C :ctype:`double` datatype.  The constructor accepts an "
"optional float initializer."
msgstr ""

#: ../../../library/ctypes.rst:2151
msgid ""
"Represents the C :ctype:`long double` datatype.  The constructor accepts an "
"optional float initializer.  On platforms where ``sizeof(long double) == "
"sizeof(double)`` it is an alias to :class:`c_double`."
msgstr ""

#: ../../../library/ctypes.rst:2157
msgid ""
"Represents the C :ctype:`float` datatype.  The constructor accepts an "
"optional float initializer."
msgstr ""

#: ../../../library/ctypes.rst:2163
msgid ""
"Represents the C :ctype:`signed int` datatype.  The constructor accepts an "
"optional integer initializer; no overflow checking is done.  On platforms "
"where ``sizeof(int) == sizeof(long)`` it is an alias to :class:`c_long`."
msgstr ""

#: ../../../library/ctypes.rst:2170
msgid ""
"Represents the C 8-bit :ctype:`signed int` datatype.  Usually an alias for :"
"class:`c_byte`."
msgstr ""

#: ../../../library/ctypes.rst:2176
msgid ""
"Represents the C 16-bit :ctype:`signed int` datatype.  Usually an alias for :"
"class:`c_short`."
msgstr ""

#: ../../../library/ctypes.rst:2182
msgid ""
"Represents the C 32-bit :ctype:`signed int` datatype.  Usually an alias for :"
"class:`c_int`."
msgstr ""

#: ../../../library/ctypes.rst:2188
msgid ""
"Represents the C 64-bit :ctype:`signed int` datatype.  Usually an alias for :"
"class:`c_longlong`."
msgstr ""

#: ../../../library/ctypes.rst:2194
msgid ""
"Represents the C :ctype:`signed long` datatype.  The constructor accepts an "
"optional integer initializer; no overflow checking is done."
msgstr ""

#: ../../../library/ctypes.rst:2200
msgid ""
"Represents the C :ctype:`signed long long` datatype.  The constructor "
"accepts an optional integer initializer; no overflow checking is done."
msgstr ""

#: ../../../library/ctypes.rst:2206
msgid ""
"Represents the C :ctype:`signed short` datatype.  The constructor accepts an "
"optional integer initializer; no overflow checking is done."
msgstr ""

#: ../../../library/ctypes.rst:2212
msgid "Represents the C :ctype:`size_t` datatype."
msgstr ""

#: ../../../library/ctypes.rst:2217
msgid ""
"Represents the C :ctype:`unsigned char` datatype, it interprets the value as "
"small integer.  The constructor accepts an optional integer initializer; no "
"overflow checking is done."
msgstr ""

#: ../../../library/ctypes.rst:2224
msgid ""
"Represents the C :ctype:`unsigned int` datatype.  The constructor accepts an "
"optional integer initializer; no overflow checking is done.  On platforms "
"where ``sizeof(int) == sizeof(long)`` it is an alias for :class:`c_ulong`."
msgstr ""

#: ../../../library/ctypes.rst:2231
msgid ""
"Represents the C 8-bit :ctype:`unsigned int` datatype.  Usually an alias "
"for :class:`c_ubyte`."
msgstr ""

#: ../../../library/ctypes.rst:2237
msgid ""
"Represents the C 16-bit :ctype:`unsigned int` datatype.  Usually an alias "
"for :class:`c_ushort`."
msgstr ""

#: ../../../library/ctypes.rst:2243
msgid ""
"Represents the C 32-bit :ctype:`unsigned int` datatype.  Usually an alias "
"for :class:`c_uint`."
msgstr ""

#: ../../../library/ctypes.rst:2249
msgid ""
"Represents the C 64-bit :ctype:`unsigned int` datatype.  Usually an alias "
"for :class:`c_ulonglong`."
msgstr ""

#: ../../../library/ctypes.rst:2255
msgid ""
"Represents the C :ctype:`unsigned long` datatype.  The constructor accepts "
"an optional integer initializer; no overflow checking is done."
msgstr ""

#: ../../../library/ctypes.rst:2261
msgid ""
"Represents the C :ctype:`unsigned long long` datatype.  The constructor "
"accepts an optional integer initializer; no overflow checking is done."
msgstr ""

#: ../../../library/ctypes.rst:2267
msgid ""
"Represents the C :ctype:`unsigned short` datatype.  The constructor accepts "
"an optional integer initializer; no overflow checking is done."
msgstr ""

#: ../../../library/ctypes.rst:2273
msgid ""
"Represents the C :ctype:`void *` type.  The value is represented as integer. "
"The constructor accepts an optional integer initializer."
msgstr ""

#: ../../../library/ctypes.rst:2279
msgid ""
"Represents the C :ctype:`wchar_t` datatype, and interprets the value as a "
"single character unicode string.  The constructor accepts an optional string "
"initializer, the length of the string must be exactly one character."
msgstr ""

#: ../../../library/ctypes.rst:2286
msgid ""
"Represents the C :ctype:`wchar_t *` datatype, which must be a pointer to a "
"zero-terminated wide character string.  The constructor accepts an integer "
"address, or a string."
msgstr ""

#: ../../../library/ctypes.rst:2293
msgid ""
"Represent the C :ctype:`bool` datatype (more accurately, :ctype:`_Bool` from "
"C99).  Its value can be True or False, and the constructor accepts any "
"object that has a truth value."
msgstr ""

#: ../../../library/ctypes.rst:2300
msgid ""
"Windows only: Represents a :ctype:`HRESULT` value, which contains success or "
"error information for a function or method call."
msgstr ""

#: ../../../library/ctypes.rst:2306
msgid ""
"Represents the C :ctype:`PyObject *` datatype.  Calling this without an "
"argument creates a ``NULL`` :ctype:`PyObject *` pointer."
msgstr ""

#: ../../../library/ctypes.rst:2309
msgid ""
"The :mod:`ctypes.wintypes` module provides quite some other Windows specific "
"data types, for example :ctype:`HWND`, :ctype:`WPARAM`, or :ctype:`DWORD`.  "
"Some useful structures like :ctype:`MSG` or :ctype:`RECT` are also defined."
msgstr ""

#: ../../../library/ctypes.rst:2317
msgid "Structured data types"
msgstr ""

#: ../../../library/ctypes.rst:2322
msgid "Abstract base class for unions in native byte order."
msgstr ""

#: ../../../library/ctypes.rst:2327
msgid "Abstract base class for structures in *big endian* byte order."
msgstr ""

#: ../../../library/ctypes.rst:2332
msgid "Abstract base class for structures in *little endian* byte order."
msgstr ""

#: ../../../library/ctypes.rst:2334
msgid ""
"Structures with non-native byte order cannot contain pointer type fields, or "
"any other data types containing pointer type fields."
msgstr ""

#: ../../../library/ctypes.rst:2340
msgid "Abstract base class for structures in *native* byte order."
msgstr ""

#: ../../../library/ctypes.rst:2342
msgid ""
"Concrete structure and union types must be created by subclassing one of "
"these types, and at least define a :attr:`_fields_` class variable. :mod:"
"`ctypes` will create :term:`descriptor`\\s which allow reading and writing "
"the fields by direct attribute accesses.  These are the"
msgstr ""

#: ../../../library/ctypes.rst:2350
msgid ""
"A sequence defining the structure fields.  The items must be 2-tuples or 3-"
"tuples.  The first item is the name of the field, the second item specifies "
"the type of the field; it can be any ctypes data type."
msgstr ""

#: ../../../library/ctypes.rst:2354
msgid ""
"For integer type fields like :class:`c_int`, a third optional item can be "
"given.  It must be a small positive integer defining the bit width of the "
"field."
msgstr ""

#: ../../../library/ctypes.rst:2358
msgid ""
"Field names must be unique within one structure or union.  This is not "
"checked, only one field can be accessed when names are repeated."
msgstr ""

#: ../../../library/ctypes.rst:2361
msgid ""
"It is possible to define the :attr:`_fields_` class variable *after* the "
"class statement that defines the Structure subclass, this allows to create "
"data types that directly or indirectly reference themselves::"
msgstr ""

#: ../../../library/ctypes.rst:2365
msgid ""
"class List(Structure):\n"
"    pass\n"
"List._fields_ = [(\"pnext\", POINTER(List)),\n"
"                 ...\n"
"                ]"
msgstr ""

#: ../../../library/ctypes.rst:2371
msgid ""
"The :attr:`_fields_` class variable must, however, be defined before the "
"type is first used (an instance is created, :func:`sizeof` is called on it, "
"and so on).  Later assignments to the :attr:`_fields_` class variable will "
"raise an AttributeError."
msgstr ""

#: ../../../library/ctypes.rst:2376
msgid ""
"Structure and union subclass constructors accept both positional and named "
"arguments.  Positional arguments are used to initialize the fields in the "
"same order as they appear in the :attr:`_fields_` definition, named "
"arguments are used to initialize the fields with the corresponding name."
msgstr ""

#: ../../../library/ctypes.rst:2381
msgid ""
"It is possible to defined sub-subclasses of structure types, they inherit "
"the fields of the base class plus the :attr:`_fields_` defined in the sub-"
"subclass, if any."
msgstr ""

#: ../../../library/ctypes.rst:2388
msgid ""
"An optional small integer that allows to override the alignment of structure "
"fields in the instance.  :attr:`_pack_` must already be defined when :attr:"
"`_fields_` is assigned, otherwise it will have no effect."
msgstr ""

#: ../../../library/ctypes.rst:2395
msgid ""
"An optional sequence that lists the names of unnamed (anonymous) fields. :"
"attr:`_anonymous_` must be already defined when :attr:`_fields_` is "
"assigned, otherwise it will have no effect."
msgstr ""

#: ../../../library/ctypes.rst:2399
msgid ""
"The fields listed in this variable must be structure or union type fields. :"
"mod:`ctypes` will create descriptors in the structure type that allows to "
"access the nested fields directly, without the need to create the structure "
"or union field."
msgstr ""

#: ../../../library/ctypes.rst:2404
msgid "Here is an example type (Windows)::"
msgstr ""

#: ../../../library/ctypes.rst:2406
msgid ""
"class _U(Union):\n"
"    _fields_ = [(\"lptdesc\", POINTER(TYPEDESC)),\n"
"                (\"lpadesc\", POINTER(ARRAYDESC)),\n"
"                (\"hreftype\", HREFTYPE)]\n"
"\n"
"class TYPEDESC(Structure):\n"
"    _anonymous_ = (\"u\",)\n"
"    _fields_ = [(\"u\", _U),\n"
"                (\"vt\", VARTYPE)]"
msgstr ""

#: ../../../library/ctypes.rst:2417
msgid ""
"The ``TYPEDESC`` structure describes a COM data type, the ``vt`` field "
"specifies which one of the union fields is valid.  Since the ``u`` field is "
"defined as anonymous field, it is now possible to access the members "
"directly off the TYPEDESC instance. ``td.lptdesc`` and ``td.u.lptdesc`` are "
"equivalent, but the former is faster since it does not need to create a "
"temporary union instance::"
msgstr ""

#: ../../../library/ctypes.rst:2424
msgid ""
"td = TYPEDESC()\n"
"td.vt = VT_PTR\n"
"td.lptdesc = POINTER(some_type)\n"
"td.u.lptdesc = POINTER(some_type)"
msgstr ""

#: ../../../library/ctypes.rst:2429
msgid ""
"It is possible to defined sub-subclasses of structures, they inherit the "
"fields of the base class.  If the subclass definition has a separate :attr:"
"`_fields_` variable, the fields specified in this are appended to the fields "
"of the base class."
msgstr ""

#: ../../../library/ctypes.rst:2434
msgid ""
"Structure and union constructors accept both positional and keyword "
"arguments.  Positional arguments are used to initialize member fields in the "
"same order as they are appear in :attr:`_fields_`.  Keyword arguments in the "
"constructor are interpreted as attribute assignments, so they will "
"initialize :attr:`_fields_` with the same name, or create new attributes for "
"names not present in :attr:`_fields_`."
msgstr ""

#: ../../../library/ctypes.rst:2445
msgid "Arrays and pointers"
msgstr ""

#: ../../../library/ctypes.rst:2447
msgid ""
"Not yet written - please see the sections :ref:`ctypes-pointers` and "
"section :ref:`ctypes-arrays` in the tutorial."
msgstr ""

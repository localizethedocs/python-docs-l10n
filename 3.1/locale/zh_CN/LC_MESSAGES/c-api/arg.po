# SOME DESCRIPTIVE TITLE.
# Copyright (C) 1990-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.1\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-11 04:41+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../c-api/arg.rst:6
msgid "Parsing arguments and building values"
msgstr ""

#: ../../../c-api/arg.rst:8
msgid ""
"These functions are useful when creating your own extensions functions and "
"methods.  Additional information and examples are available in :ref:"
"`extending-index`."
msgstr ""

#: ../../../c-api/arg.rst:12
msgid ""
"The first three of these functions described, :cfunc:`PyArg_ParseTuple`, :"
"cfunc:`PyArg_ParseTupleAndKeywords`, and :cfunc:`PyArg_Parse`, all use "
"*format strings* which are used to tell the function about the expected "
"arguments.  The format strings use the same syntax for each of these "
"functions."
msgstr ""

#: ../../../c-api/arg.rst:19
msgid "Parsing arguments"
msgstr ""

#: ../../../c-api/arg.rst:21
msgid ""
"A format string consists of zero or more \"format units.\"  A format unit "
"describes one Python object; it is usually a single character or a "
"parenthesized sequence of format units.  With a few exceptions, a format "
"unit that is not a parenthesized sequence normally corresponds to a single "
"address argument to these functions.  In the following description, the "
"quoted form is the format unit; the entry in (round) parentheses is the "
"Python object type that matches the format unit; and the entry in [square] "
"brackets is the type of the C variable(s) whose address should be passed."
msgstr ""

#: ../../../c-api/arg.rst:31
msgid "Strings and buffers"
msgstr ""

#: ../../../c-api/arg.rst:33
msgid ""
"These formats allow to access an object as a contiguous chunk of memory. You "
"don't have to provide raw storage for the returned unicode or bytes area.  "
"Also, you won't have to release any memory yourself, except with the ``es``, "
"``es#``, ``et`` and ``et#`` formats."
msgstr ""

#: ../../../c-api/arg.rst:38
msgid ""
"However, when a :ctype:`Py_buffer` structure gets filled, the underlying "
"buffer is locked so that the caller can subsequently use the buffer even "
"inside a :ctype:`Py_BEGIN_ALLOW_THREADS` block without the risk of mutable "
"data being resized or destroyed.  As a result, **you have to call** :cfunc:"
"`PyBuffer_Release` after you have finished processing the data (or in any "
"early abort case)."
msgstr ""

#: ../../../c-api/arg.rst:45
msgid "Unless otherwise stated, buffers are not NUL-terminated."
msgstr ""

#: ../../../c-api/arg.rst:48
msgid ""
"For all ``#`` variants of formats (``s#``, ``y#``, etc.), the type of the "
"length argument (int or :ctype:`Py_ssize_t`) is controlled by defining the "
"macro :cmacro:`PY_SSIZE_T_CLEAN` before including :file:`Python.h`.  If the "
"macro was defined, length is a :ctype:`Py_ssize_t` rather than an :ctype:"
"`int`. This behavior will change in a future Python version to only support :"
"ctype:`Py_ssize_t` and drop :ctype:`int` support. It is best to always "
"define :cmacro:`PY_SSIZE_T_CLEAN`."
msgstr ""

#: ../../../c-api/arg.rst:70
msgid "``s`` (:class:`str`) [const char \\*]"
msgstr ""

#: ../../../c-api/arg.rst:58
msgid ""
"Convert a Unicode object to a C pointer to a character string. A pointer to "
"an existing string is stored in the character pointer variable whose address "
"you pass.  The C string is NUL-terminated. The Python string must not "
"contain embedded NUL bytes; if it does, a :exc:`TypeError` exception is "
"raised. Unicode objects are converted to C strings using ``'utf-8'`` "
"encoding. If this conversion fails, a :exc:`UnicodeError` is raised."
msgstr ""

#: ../../../c-api/arg.rst:67
msgid ""
"This format does not accept bytes-like objects.  If you want to accept "
"filesystem paths and convert them to C character strings, it is preferable "
"to use the ``O&`` format with :cfunc:`PyUnicode_FSConverter` as *converter*."
msgstr ""

#: ../../../c-api/arg.rst:77
msgid ""
"``s*`` (:class:`str`, :class:`bytes`, :class:`bytearray` or buffer "
"compatible object) [Py_buffer]"
msgstr ""

#: ../../../c-api/arg.rst:73
msgid ""
"This format accepts Unicode objects as well as objects supporting the buffer "
"protocol. It fills a :ctype:`Py_buffer` structure provided by the caller. In "
"this case the resulting C string may contain embedded NUL bytes. Unicode "
"objects are converted to C strings using ``'utf-8'`` encoding."
msgstr ""

#: ../../../c-api/arg.rst:84
msgid ""
"``s#`` (:class:`str`, :class:`bytes` or read-only buffer compatible object) "
"[const char \\*, int or :ctype:`Py_ssize_t`]"
msgstr ""

#: ../../../c-api/arg.rst:80
msgid ""
"Like ``s*``, except that it doesn't accept mutable buffer-like objects such "
"as :class:`bytearray`.  The result is stored into two C variables, the first "
"one a pointer to a C string, the second one its length. The string may "
"contain embedded null bytes. Unicode objects are converted to C strings "
"using ``'utf-8'`` encoding."
msgstr ""

#: ../../../c-api/arg.rst:88
msgid "``z`` (:class:`str` or ``None``) [const char \\*]"
msgstr ""

#: ../../../c-api/arg.rst:87
msgid ""
"Like ``s``, but the Python object may also be ``None``, in which case the C "
"pointer is set to *NULL*."
msgstr ""

#: ../../../c-api/arg.rst:92
msgid ""
"``z*`` (:class:`str`, :class:`bytes`, :class:`bytearray`, buffer compatible "
"object or ``None``) [Py_buffer]"
msgstr ""

#: ../../../c-api/arg.rst:91
msgid ""
"Like ``s*``, but the Python object may also be ``None``, in which case the "
"``buf`` member of the :ctype:`Py_buffer` structure is set to *NULL*."
msgstr ""

#: ../../../c-api/arg.rst:96
msgid ""
"``z#`` (:class:`str`, :class:`bytes`, read-only buffer compatible object or "
"``None``) [const char \\*, int]"
msgstr ""

#: ../../../c-api/arg.rst:95
msgid ""
"Like ``s#``, but the Python object may also be ``None``, in which case the C "
"pointer is set to *NULL*."
msgstr ""

#: ../../../c-api/arg.rst:102
msgid "``y`` (:class:`bytes`) [const char \\*]"
msgstr ""

#: ../../../c-api/arg.rst:99
msgid ""
"This format converts a bytes-like object to a C pointer to a character "
"string; it does not accept Unicode objects.  The bytes buffer must not "
"contain embedded NUL bytes; if it does, a :exc:`TypeError` exception is "
"raised."
msgstr ""

#: ../../../c-api/arg.rst:107
msgid ""
"``y*`` (:class:`bytes`, :class:`bytearray` or buffer compatible object) "
"[Py_buffer]"
msgstr ""

#: ../../../c-api/arg.rst:105
msgid ""
"This variant on ``s*`` doesn't accept Unicode objects, only objects "
"supporting the buffer protocol.  **This is the recommended way to accept "
"binary data.**"
msgstr ""

#: ../../../c-api/arg.rst:111
msgid "``y#`` (:class:`bytes`) [const char \\*, int]"
msgstr ""

#: ../../../c-api/arg.rst:110
msgid ""
"This variant on ``s#`` doesn't accept Unicode objects, only bytes-like "
"objects."
msgstr ""

#: ../../../c-api/arg.rst:116
msgid "``S`` (:class:`bytes`) [PyBytesObject \\*]"
msgstr ""

#: ../../../c-api/arg.rst:114
msgid ""
"Requires that the Python object is a :class:`bytes` object, without "
"attempting any conversion.  Raises :exc:`TypeError` if the object is not a "
"bytes object.  The C variable may also be declared as :ctype:`PyObject\\*`."
msgstr ""

#: ../../../c-api/arg.rst:121
msgid "``Y`` (:class:`bytearray`) [PyByteArrayObject \\*]"
msgstr ""

#: ../../../c-api/arg.rst:119
msgid ""
"Requires that the Python object is a :class:`bytearray` object, without "
"attempting any conversion.  Raises :exc:`TypeError` if the object is not a :"
"class:`bytearray` object. The C variable may also be declared as :ctype:"
"`PyObject\\*`."
msgstr ""

#: ../../../c-api/arg.rst:133
msgid "``u`` (:class:`str`) [Py_UNICODE \\*]"
msgstr ""

#: ../../../c-api/arg.rst:124
msgid ""
"Convert a Python Unicode object to a C pointer to a NUL-terminated buffer of "
"Unicode characters.  You must pass the address of a :ctype:`Py_UNICODE` "
"pointer variable, which will be filled with the pointer to an existing "
"Unicode buffer.  Please note that the width of a :ctype:`Py_UNICODE` "
"character depends on compilation options (it is either 16 or 32 bits)."
msgstr ""

#: ../../../c-api/arg.rst:131
msgid ""
"Since ``u`` doesn't give you back the length of the string, and it may "
"contain embedded NUL characters, it is recommended to use ``u#`` or ``U`` "
"instead."
msgstr ""

#: ../../../c-api/arg.rst:137
msgid "``u#`` (:class:`str`) [Py_UNICODE \\*, int]"
msgstr ""

#: ../../../c-api/arg.rst:136
msgid ""
"This variant on ``u`` stores into two C variables, the first one a pointer "
"to a Unicode data buffer, the second one its length."
msgstr ""

#: ../../../c-api/arg.rst:141
msgid "``Z`` (:class:`str` or ``None``) [Py_UNICODE \\*]"
msgstr ""

#: ../../../c-api/arg.rst:140
msgid ""
"Like ``u``, but the Python object may also be ``None``, in which case the :"
"ctype:`Py_UNICODE` pointer is set to *NULL*."
msgstr ""

#: ../../../c-api/arg.rst:145
msgid "``Z#`` (:class:`str` or ``None``) [Py_UNICODE \\*, int]"
msgstr ""

#: ../../../c-api/arg.rst:144
msgid ""
"Like ``u#``, but the Python object may also be ``None``, in which case the :"
"ctype:`Py_UNICODE` pointer is set to *NULL*."
msgstr ""

#: ../../../c-api/arg.rst:150
msgid "``U`` (:class:`str`) [PyUnicodeObject \\*]"
msgstr ""

#: ../../../c-api/arg.rst:148
msgid ""
"Requires that the Python object is a Unicode object, without attempting any "
"conversion.  Raises :exc:`TypeError` if the object is not a Unicode object.  "
"The C variable may also be declared as :ctype:`PyObject\\*`."
msgstr ""

#: ../../../c-api/arg.rst:157
msgid ""
"``t#`` (:class:`bytes`, :class:`bytearray` or read-only character buffer) "
"[char \\*, int]"
msgstr ""

#: ../../../c-api/arg.rst:153
msgid ""
"Like ``s#``, but accepts any object which implements the read-only buffer "
"interface.  The :ctype:`char\\*` variable is set to point to the first byte "
"of the buffer, and the :ctype:`int` is set to the length of the buffer.  "
"Only single-segment buffer objects are accepted; :exc:`TypeError` is raised "
"for all others."
msgstr ""

#: ../../../c-api/arg.rst:163
msgid "``w`` (:class:`bytearray` or read-write character buffer) [char \\*]"
msgstr ""

#: ../../../c-api/arg.rst:160
msgid ""
"Similar to ``y``, but accepts any object which implements the read-write "
"buffer interface.  The caller must determine the length of the buffer by "
"other means, or use ``w#`` instead.  Only single-segment buffer objects are "
"accepted; :exc:`TypeError` is raised for all others."
msgstr ""

#: ../../../c-api/arg.rst:166
msgid ""
"``w*`` (:class:`bytearray` or read-write byte-oriented buffer) [Py_buffer]"
msgstr ""

#: ../../../c-api/arg.rst:166
msgid "This is to ``w`` what ``y*`` is to ``y``."
msgstr ""

#: ../../../c-api/arg.rst:173
msgid ""
"``w#`` (:class:`bytearray` or read-write character buffer) [char \\*, int]"
msgstr ""

#: ../../../c-api/arg.rst:169
msgid ""
"Like ``y#``, but accepts any object which implements the read-write buffer "
"interface.  The :ctype:`char \\*` variable is set to point to the first byte "
"of the buffer, and the :ctype:`int` is set to the length of the buffer. Only "
"single-segment buffer objects are accepted; :exc:`TypeError` is raised for "
"all others."
msgstr ""

#: ../../../c-api/arg.rst:190
msgid "``es`` (:class:`str`) [const char \\*encoding, char \\*\\*buffer]"
msgstr ""

#: ../../../c-api/arg.rst:176
msgid ""
"This variant on ``s`` is used for encoding Unicode into a character buffer. "
"It only works for encoded data without embedded NUL bytes."
msgstr ""

#: ../../../c-api/arg.rst:179
msgid ""
"This format requires two arguments.  The first is only used as input, and "
"must be a :ctype:`const char\\*` which points to the name of an encoding as "
"a NUL-terminated string, or *NULL*, in which case ``'utf-8'`` encoding is "
"used. An exception is raised if the named encoding is not known to Python.  "
"The second argument must be a :ctype:`char\\*\\*`; the value of the pointer "
"it references will be set to a buffer with the contents of the argument "
"text. The text will be encoded in the encoding specified by the first "
"argument."
msgstr ""

#: ../../../c-api/arg.rst:187
msgid ""
":cfunc:`PyArg_ParseTuple` will allocate a buffer of the needed size, copy "
"the encoded data into this buffer and adjust *\\*buffer* to reference the "
"newly allocated storage.  The caller is responsible for calling :cfunc:"
"`PyMem_Free` to free the allocated buffer after use."
msgstr ""

#: ../../../c-api/arg.rst:195
msgid ""
"``et`` (:class:`str`, :class:`bytes` or :class:`bytearray`) [const char "
"\\*encoding, char \\*\\*buffer]"
msgstr ""

#: ../../../c-api/arg.rst:193
msgid ""
"Same as ``es`` except that byte string objects are passed through without "
"recoding them.  Instead, the implementation assumes that the byte string "
"object uses the encoding passed in as parameter."
msgstr ""

#: ../../../c-api/arg.rst:226
msgid ""
"``es#`` (:class:`str`) [const char \\*encoding, char \\*\\*buffer, int "
"\\*buffer_length]"
msgstr ""

#: ../../../c-api/arg.rst:198
msgid ""
"This variant on ``s#`` is used for encoding Unicode into a character buffer. "
"Unlike the ``es`` format, this variant allows input data which contains NUL "
"characters."
msgstr ""

#: ../../../c-api/arg.rst:202
msgid ""
"It requires three arguments.  The first is only used as input, and must be "
"a :ctype:`const char\\*` which points to the name of an encoding as a NUL-"
"terminated string, or *NULL*, in which case ``'utf-8'`` encoding is used. An "
"exception is raised if the named encoding is not known to Python.  The "
"second argument must be a :ctype:`char\\*\\*`; the value of the pointer it "
"references will be set to a buffer with the contents of the argument text. "
"The text will be encoded in the encoding specified by the first argument. "
"The third argument must be a pointer to an integer; the referenced integer "
"will be set to the number of bytes in the output buffer."
msgstr ""

#: ../../../c-api/arg.rst:212
msgid "There are two modes of operation:"
msgstr ""

#: ../../../c-api/arg.rst:214
msgid ""
"If *\\*buffer* points a *NULL* pointer, the function will allocate a buffer "
"of the needed size, copy the encoded data into this buffer and set "
"*\\*buffer* to reference the newly allocated storage.  The caller is "
"responsible for calling :cfunc:`PyMem_Free` to free the allocated buffer "
"after usage."
msgstr ""

#: ../../../c-api/arg.rst:219
msgid ""
"If *\\*buffer* points to a non-*NULL* pointer (an already allocated "
"buffer), :cfunc:`PyArg_ParseTuple` will use this location as the buffer and "
"interpret the initial value of *\\*buffer_length* as the buffer size.  It "
"will then copy the encoded data into the buffer and NUL-terminate it.  If "
"the buffer is not large enough, a :exc:`ValueError` will be set."
msgstr ""

#: ../../../c-api/arg.rst:225
msgid ""
"In both cases, *\\*buffer_length* is set to the length of the encoded data "
"without the trailing NUL byte."
msgstr ""

#: ../../../c-api/arg.rst:231
msgid ""
"``et#`` (:class:`str`, :class:`bytes` or :class:`bytearray`) [const char "
"\\*encoding, char \\*\\*buffer, int \\*buffer_length]"
msgstr ""

#: ../../../c-api/arg.rst:229
msgid ""
"Same as ``es#`` except that byte string objects are passed through without "
"recoding them. Instead, the implementation assumes that the byte string "
"object uses the encoding passed in as parameter."
msgstr ""

#: ../../../c-api/arg.rst:234
msgid "Numbers"
msgstr ""

#: ../../../c-api/arg.rst:238
msgid "``b`` (:class:`int`) [unsigned char]"
msgstr ""

#: ../../../c-api/arg.rst:237
msgid ""
"Convert a nonnegative Python integer to an unsigned tiny int, stored in a C :"
"ctype:`unsigned char`."
msgstr ""

#: ../../../c-api/arg.rst:242
msgid "``B`` (:class:`int`) [unsigned char]"
msgstr ""

#: ../../../c-api/arg.rst:241
msgid ""
"Convert a Python integer to a tiny int without overflow checking, stored in "
"a C :ctype:`unsigned char`."
msgstr ""

#: ../../../c-api/arg.rst:245
msgid "``h`` (:class:`int`) [short int]"
msgstr ""

#: ../../../c-api/arg.rst:245
msgid "Convert a Python integer to a C :ctype:`short int`."
msgstr ""

#: ../../../c-api/arg.rst:249
msgid "``H`` (:class:`int`) [unsigned short int]"
msgstr ""

#: ../../../c-api/arg.rst:248
msgid ""
"Convert a Python integer to a C :ctype:`unsigned short int`, without "
"overflow checking."
msgstr ""

#: ../../../c-api/arg.rst:252
msgid "``i`` (:class:`int`) [int]"
msgstr ""

#: ../../../c-api/arg.rst:252
msgid "Convert a Python integer to a plain C :ctype:`int`."
msgstr ""

#: ../../../c-api/arg.rst:256
msgid "``I`` (:class:`int`) [unsigned int]"
msgstr ""

#: ../../../c-api/arg.rst:255
msgid ""
"Convert a Python integer to a C :ctype:`unsigned int`, without overflow "
"checking."
msgstr ""

#: ../../../c-api/arg.rst:259
msgid "``l`` (:class:`int`) [long int]"
msgstr ""

#: ../../../c-api/arg.rst:259
msgid "Convert a Python integer to a C :ctype:`long int`."
msgstr ""

#: ../../../c-api/arg.rst:263
msgid "``k`` (:class:`int`) [unsigned long]"
msgstr ""

#: ../../../c-api/arg.rst:262
msgid ""
"Convert a Python integer to a C :ctype:`unsigned long` without overflow "
"checking."
msgstr ""

#: ../../../c-api/arg.rst:268
msgid "``L`` (:class:`int`) [PY_LONG_LONG]"
msgstr ""

#: ../../../c-api/arg.rst:266
msgid ""
"Convert a Python integer to a C :ctype:`long long`.  This format is only "
"available on platforms that support :ctype:`long long` (or :ctype:`_int64` "
"on Windows)."
msgstr ""

#: ../../../c-api/arg.rst:273
msgid "``K`` (:class:`int`) [unsigned PY_LONG_LONG]"
msgstr ""

#: ../../../c-api/arg.rst:271
msgid ""
"Convert a Python integer to a C :ctype:`unsigned long long` without overflow "
"checking.  This format is only available on platforms that support :ctype:"
"`unsigned long long` (or :ctype:`unsigned _int64` on Windows)."
msgstr ""

#: ../../../c-api/arg.rst:276
msgid "``n`` (:class:`int`) [Py_ssize_t]"
msgstr ""

#: ../../../c-api/arg.rst:276
msgid "Convert a Python integer to a C :ctype:`Py_ssize_t`."
msgstr ""

#: ../../../c-api/arg.rst:280
msgid "``c`` (:class:`bytes` of length 1) [char]"
msgstr ""

#: ../../../c-api/arg.rst:279
msgid ""
"Convert a Python byte, represented as a :class:`bytes` object of length 1, "
"to a C :ctype:`char`."
msgstr ""

#: ../../../c-api/arg.rst:284
msgid "``C`` (:class:`str` of length 1) [int]"
msgstr ""

#: ../../../c-api/arg.rst:283
msgid ""
"Convert a Python character, represented as a :class:`str` object of length "
"1, to a C :ctype:`int`."
msgstr ""

#: ../../../c-api/arg.rst:287
msgid "``f`` (:class:`float`) [float]"
msgstr ""

#: ../../../c-api/arg.rst:287
msgid "Convert a Python floating point number to a C :ctype:`float`."
msgstr ""

#: ../../../c-api/arg.rst:290
msgid "``d`` (:class:`float`) [double]"
msgstr ""

#: ../../../c-api/arg.rst:290
msgid "Convert a Python floating point number to a C :ctype:`double`."
msgstr ""

#: ../../../c-api/arg.rst:293
msgid "``D`` (:class:`complex`) [Py_complex]"
msgstr ""

#: ../../../c-api/arg.rst:293
msgid "Convert a Python complex number to a C :ctype:`Py_complex` structure."
msgstr ""

#: ../../../c-api/arg.rst:296
msgid "Other objects"
msgstr ""

#: ../../../c-api/arg.rst:301
msgid "``O`` (object) [PyObject \\*]"
msgstr ""

#: ../../../c-api/arg.rst:299
msgid ""
"Store a Python object (without any conversion) in a C object pointer.  The C "
"program thus receives the actual object that was passed.  The object's "
"reference count is not increased.  The pointer stored is not *NULL*."
msgstr ""

#: ../../../c-api/arg.rst:308
msgid "``O!`` (object) [*typeobject*, PyObject \\*]"
msgstr ""

#: ../../../c-api/arg.rst:304
msgid ""
"Store a Python object in a C object pointer.  This is similar to ``O``, but "
"takes two C arguments: the first is the address of a Python type object, the "
"second is the address of the C variable (of type :ctype:`PyObject\\*`) into "
"which the object pointer is stored.  If the Python object does not have the "
"required type, :exc:`TypeError` is raised."
msgstr ""

#: ../../../c-api/arg.rst:331
msgid "``O&`` (object) [*converter*, *anything*]"
msgstr ""

#: ../../../c-api/arg.rst:311
msgid ""
"Convert a Python object to a C variable through a *converter* function.  "
"This takes two arguments: the first is a function, the second is the address "
"of a C variable (of arbitrary type), converted to :ctype:`void \\*`.  The "
"*converter* function in turn is called as follows::"
msgstr ""

#: ../../../c-api/arg.rst:318
msgid ""
"where *object* is the Python object to be converted and *address* is the :"
"ctype:`void\\*` argument that was passed to the :cfunc:`PyArg_Parse\\*` "
"function. The returned *status* should be ``1`` for a successful conversion "
"and ``0`` if the conversion has failed.  When the conversion fails, the "
"*converter* function should raise an exception and leave the content of "
"*address* unmodified."
msgstr ""

#: ../../../c-api/arg.rst:324
msgid ""
"If the *converter* returns ``Py_CLEANUP_SUPPORTED``, it may get called a "
"second time if the argument parsing eventually fails, giving the converter a "
"chance to release any memory that it had already allocated. In this second "
"call, the *object* parameter will be NULL; *address* will have the same "
"value as in the original call."
msgstr ""

#: ../../../c-api/arg.rst:330
msgid "``Py_CLEANUP_SUPPORTED`` was added."
msgstr ""

#: ../../../c-api/arg.rst:336
msgid "``(items)`` (:class:`tuple`) [*matching-items*]"
msgstr ""

#: ../../../c-api/arg.rst:334
msgid ""
"The object must be a Python sequence whose length is the number of format "
"units in *items*.  The C arguments must correspond to the individual format "
"units in *items*.  Format units for sequences may be nested."
msgstr ""

#: ../../../c-api/arg.rst:338
msgid ""
"It is possible to pass \"long\" integers (integers whose value exceeds the "
"platform's :const:`LONG_MAX`) however no proper range checking is done --- "
"the most significant bits are silently truncated when the receiving field is "
"too small to receive the value (actually, the semantics are inherited from "
"downcasts in C --- your mileage may vary)."
msgstr ""

#: ../../../c-api/arg.rst:344
msgid ""
"A few other characters have a meaning in a format string.  These may not "
"occur inside nested parentheses.  They are:"
msgstr ""

#: ../../../c-api/arg.rst:352
msgid "``|``"
msgstr ""

#: ../../../c-api/arg.rst:348
msgid ""
"Indicates that the remaining arguments in the Python argument list are "
"optional. The C variables corresponding to optional arguments should be "
"initialized to their default value --- when an optional argument is not "
"specified, :cfunc:`PyArg_ParseTuple` does not touch the contents of the "
"corresponding C variable(s)."
msgstr ""

#: ../../../c-api/arg.rst:357
msgid "``:``"
msgstr ""

#: ../../../c-api/arg.rst:355
msgid ""
"The list of format units ends here; the string after the colon is used as "
"the function name in error messages (the \"associated value\" of the "
"exception that :cfunc:`PyArg_ParseTuple` raises)."
msgstr ""

#: ../../../c-api/arg.rst:362
msgid "``;``"
msgstr ""

#: ../../../c-api/arg.rst:360
msgid ""
"The list of format units ends here; the string after the semicolon is used "
"as the error message *instead* of the default error message.  ``:`` and ``;"
"`` mutually exclude each other."
msgstr ""

#: ../../../c-api/arg.rst:364
msgid ""
"Note that any Python object references which are provided to the caller are "
"*borrowed* references; do not decrement their reference count!"
msgstr ""

#: ../../../c-api/arg.rst:367
msgid ""
"Additional arguments passed to these functions must be addresses of "
"variables whose type is determined by the format string; these are used to "
"store values from the input tuple.  There are a few cases, as described in "
"the list of format units above, where these parameters are used as input "
"values; they should match what is specified for the corresponding format "
"unit in that case."
msgstr ""

#: ../../../c-api/arg.rst:373
msgid ""
"For the conversion to succeed, the *arg* object must match the format and "
"the format must be exhausted.  On success, the :cfunc:`PyArg_Parse\\*` "
"functions return true, otherwise they return false and raise an appropriate "
"exception. When the :cfunc:`PyArg_Parse\\*` functions fail due to conversion "
"failure in one of the format units, the variables at the addresses "
"corresponding to that and the following format units are left untouched."
msgstr ""

#: ../../../c-api/arg.rst:382
msgid "API Functions"
msgstr ""

#: ../../../c-api/arg.rst:461
msgid "Building values"
msgstr ""

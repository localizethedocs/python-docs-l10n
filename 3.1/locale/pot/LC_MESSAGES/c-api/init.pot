# SOME DESCRIPTIVE TITLE.
# Copyright (C) 1990-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.1\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-10 15:08+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../c-api/init.rst:8
msgid "Initialization, Finalization, and Threads"
msgstr ""

#: ../../../c-api/init.rst:12
msgid "Initializing and finalizing the interpreter"
msgstr ""

#: ../../../c-api/init.rst:89
msgid "Process-wide parameters"
msgstr ""

#: ../../../c-api/init.rst:340
msgid "Thread State and the Global Interpreter Lock"
msgstr ""

#: ../../../c-api/init.rst:347
msgid ""
"The Python interpreter is not fully thread-safe.  In order to support multi-"
"threaded Python programs, there's a global lock, called the :term:`global "
"interpreter lock` or :term:`GIL`, that must be held by the current thread "
"before it can safely access Python objects. Without the lock, even the "
"simplest operations could cause problems in a multi-threaded program: for "
"example, when two threads simultaneously increment the reference count of "
"the same object, the reference count could end up being incremented only "
"once instead of twice."
msgstr ""

#: ../../../c-api/init.rst:357
msgid ""
"Therefore, the rule exists that only the thread that has acquired the :term:"
"`GIL` may operate on Python objects or call Python/C API functions. In order "
"to emulate concurrency of execution, the interpreter regularly tries to "
"switch threads (see :func:`sys.setcheckinterval`).  The lock is also "
"released around potentially blocking I/O operations like reading or writing "
"a file, so that other Python threads can run in the meantime."
msgstr ""

#: ../../../c-api/init.rst:368
msgid ""
"The Python interpreter keeps some thread-specific bookkeeping information "
"inside a data structure called :ctype:`PyThreadState`.  There's also one "
"global variable pointing to the current :ctype:`PyThreadState`: it can be "
"retrieved using :cfunc:`PyThreadState_Get`."
msgstr ""

#: ../../../c-api/init.rst:374
msgid "Releasing the GIL from extension code"
msgstr ""

#: ../../../c-api/init.rst:376
msgid ""
"Most extension code manipulating the :term:`GIL` has the following simple "
"structure::"
msgstr ""

#: ../../../c-api/init.rst:379
msgid ""
"Save the thread state in a local variable.\n"
"Release the global interpreter lock.\n"
"... Do some blocking I/O operation ...\n"
"Reacquire the global interpreter lock.\n"
"Restore the thread state from the local variable."
msgstr ""

#: ../../../c-api/init.rst:385
msgid "This is so common that a pair of macros exists to simplify it::"
msgstr ""

#: ../../../c-api/init.rst:387
msgid ""
"Py_BEGIN_ALLOW_THREADS\n"
"... Do some blocking I/O operation ...\n"
"Py_END_ALLOW_THREADS"
msgstr ""

#: ../../../c-api/init.rst:395
msgid ""
"The :cmacro:`Py_BEGIN_ALLOW_THREADS` macro opens a new block and declares a "
"hidden local variable; the :cmacro:`Py_END_ALLOW_THREADS` macro closes the "
"block.  These two macros are still available when Python is compiled without "
"thread support (they simply have an empty expansion)."
msgstr ""

#: ../../../c-api/init.rst:400
msgid ""
"When thread support is enabled, the block above expands to the following "
"code::"
msgstr ""

#: ../../../c-api/init.rst:402
msgid ""
"PyThreadState *_save;\n"
"\n"
"_save = PyEval_SaveThread();\n"
"...Do some blocking I/O operation...\n"
"PyEval_RestoreThread(_save);"
msgstr ""

#: ../../../c-api/init.rst:412
msgid ""
"Here is how these functions work: the global interpreter lock is used to "
"protect the pointer to the current thread state.  When releasing the lock "
"and saving the thread state, the current thread state pointer must be "
"retrieved before the lock is released (since another thread could "
"immediately acquire the lock and store its own thread state in the global "
"variable). Conversely, when acquiring the lock and restoring the thread "
"state, the lock must be acquired before storing the thread state pointer."
msgstr ""

#: ../../../c-api/init.rst:421
msgid ""
"Calling system I/O functions is the most common use case for releasing the "
"GIL, but it can also be useful before calling long-running computations "
"which don't need access to Python objects, such as compression or "
"cryptographic functions operating over memory buffers.  For example, the "
"standard :mod:`zlib` and :mod:`hashlib` modules release the GIL when "
"compressing or hashing data."
msgstr ""

#: ../../../c-api/init.rst:429
msgid "Non-Python created threads"
msgstr ""

#: ../../../c-api/init.rst:431
msgid ""
"When threads are created using the dedicated Python APIs (such as the :mod:"
"`threading` module), a thread state is automatically associated to them and "
"the code showed above is therefore correct.  However, when threads are "
"created from C (for example by a third-party library with its own thread "
"management), they don't hold the GIL, nor is there a thread state structure "
"for them."
msgstr ""

#: ../../../c-api/init.rst:438
msgid ""
"If you need to call Python code from these threads (often this will be part "
"of a callback API provided by the aforementioned third-party library), you "
"must first register these threads with the interpreter by creating a thread "
"state data structure, then acquiring the GIL, and finally storing their "
"thread state pointer, before you can start using the Python/C API.  When you "
"are done, you should reset the thread state pointer, release the GIL, and "
"finally free the thread state data structure."
msgstr ""

#: ../../../c-api/init.rst:446
msgid ""
"The :cfunc:`PyGILState_Ensure` and :cfunc:`PyGILState_Release` functions do "
"all of the above automatically.  The typical idiom for calling into Python "
"from a C thread is::"
msgstr ""

#: ../../../c-api/init.rst:450
msgid ""
"PyGILState_STATE gstate;\n"
"gstate = PyGILState_Ensure();\n"
"\n"
"/* Perform Python actions here. */\n"
"result = CallSomeFunction();\n"
"/* evaluate result or handle exception */\n"
"\n"
"/* Release the thread. No Python API allowed beyond this point. */\n"
"PyGILState_Release(gstate);"
msgstr ""

#: ../../../c-api/init.rst:460
msgid ""
"Note that the :cfunc:`PyGILState_\\*` functions assume there is only one "
"global interpreter (created automatically by :cfunc:`Py_Initialize`).  "
"Python supports the creation of additional interpreters (using :cfunc:"
"`Py_NewInterpreter`), but mixing multiple interpreters and the :cfunc:"
"`PyGILState_\\*` API is unsupported."
msgstr ""

#: ../../../c-api/init.rst:466
msgid ""
"Another important thing to note about threads is their behaviour in the face "
"of the C :cfunc:`fork` call. On most systems with :cfunc:`fork`, after a "
"process forks only the thread that issued the fork will exist. That also "
"means any locks held by other threads will never be released. Python solves "
"this for :func:`os.fork` by acquiring the locks it uses internally before "
"the fork, and releasing them afterwards. In addition, it resets any :ref:"
"`lock-objects` in the child. When extending or embedding Python, there is no "
"way to inform Python of additional (non-Python) locks that need to be "
"acquired before or reset after a fork. OS facilities such as :cfunc:"
"`pthread_atfork` would need to be used to accomplish the same thing. "
"Additionally, when extending or embedding Python, calling :cfunc:`fork` "
"directly rather than through :func:`os.fork` (and returning to or calling "
"into Python) may result in a deadlock by one of Python's internal locks "
"being held by a thread that is defunct after the fork. :cfunc:"
"`PyOS_AfterFork` tries to reset the necessary locks, but is not always able "
"to."
msgstr ""

#: ../../../c-api/init.rst:485
msgid "High-level API"
msgstr ""

#: ../../../c-api/init.rst:487
msgid ""
"These are the most commonly used types and functions when writing C "
"extension code, or when embedding the Python interpreter:"
msgstr ""

#: ../../../c-api/init.rst:596
msgid ""
"The following functions use thread-local storage, and are not compatible "
"with sub-interpreters:"
msgstr ""

#: ../../../c-api/init.rst:633
msgid ""
"The following macros are normally used without a trailing semicolon; look "
"for example usage in the Python source distribution."
msgstr ""

#: ../../../c-api/init.rst:668
msgid "Low-level API"
msgstr ""

#: ../../../c-api/init.rst:670
msgid ""
"All of the following functions are only available when thread support is "
"enabled at compile time, and must be called only when the global interpreter "
"lock has been created."
msgstr ""

#: ../../../c-api/init.rst:781
msgid "Sub-interpreter support"
msgstr ""

#: ../../../c-api/init.rst:783
msgid ""
"While in most uses, you will only embed a single Python interpreter, there "
"are cases where you need to create several independent interpreters in the "
"same process and perhaps even in the same thread.  Sub-interpreters allow "
"you to do that.  You can switch between sub-interpreters using the :cfunc:"
"`PyThreadState_Swap` function.  You can create and destroy them using the "
"following functions:"
msgstr ""

#: ../../../c-api/init.rst:853
msgid "Bugs and caveats"
msgstr ""

#: ../../../c-api/init.rst:855
msgid ""
"Because sub-interpreters (and the main interpreter) are part of the same "
"process, the insulation between them isn't perfect --- for example, using "
"low-level file operations like  :func:`os.close` they can (accidentally or "
"maliciously) affect each other's open files.  Because of the way extensions "
"are shared between (sub-)interpreters, some extensions may not work "
"properly; this is especially likely when the extension makes use of (static) "
"global variables, or when the extension manipulates its module's dictionary "
"after its initialization.  It is possible to insert objects created in one "
"sub-interpreter into a namespace of another sub-interpreter; this should be "
"done with great care to avoid sharing user-defined functions, methods, "
"instances or classes between sub-interpreters, since import operations "
"executed by such objects may affect the wrong (sub-)interpreter's dictionary "
"of loaded modules."
msgstr ""

#: ../../../c-api/init.rst:869
msgid ""
"Also note that combining this functionality with :cfunc:`PyGILState_\\*` "
"APIs is delicate, because these APIs assume a bijection between Python "
"thread states and OS-level threads, an assumption broken by the presence of "
"sub-interpreters. It is highly recommended that you don't switch sub-"
"interpreters between a pair of matching :cfunc:`PyGILState_Ensure` and :"
"cfunc:`PyGILState_Release` calls. Furthermore, extensions (such as :mod:"
"`ctypes`) using these APIs to allow calling of Python code from non-Python "
"created threads will probably be broken when using sub-interpreters."
msgstr ""

#: ../../../c-api/init.rst:880
msgid "Asynchronous Notifications"
msgstr ""

#: ../../../c-api/init.rst:882
msgid ""
"A mechanism is provided to make asynchronous notifications to the main "
"interpreter thread.  These notifications take the form of a function pointer "
"and a void argument."
msgstr ""

#: ../../../c-api/init.rst:888
msgid ""
"Every check interval, when the global interpreter lock is released and "
"reacquired, Python will also call any such provided functions.  This can be "
"used for example by asynchronous IO handlers.  The notification can be "
"scheduled from a worker thread and the actual call than made at the earliest "
"convenience by the main thread where it has possession of the global "
"interpreter lock and can perform any Python API calls."
msgstr ""

#: ../../../c-api/init.rst:923
msgid "Profiling and Tracing"
msgstr ""

#: ../../../c-api/init.rst:928
msgid ""
"The Python interpreter provides some low-level support for attaching "
"profiling and execution tracing facilities.  These are used for profiling, "
"debugging, and coverage analysis tools."
msgstr ""

#: ../../../c-api/init.rst:932
msgid ""
"This C interface allows the profiling or tracing code to avoid the overhead "
"of calling through Python-level callable objects, making a direct C function "
"call instead.  The essential attributes of the facility have not changed; "
"the interface allows trace functions to be installed per-thread, and the "
"basic events reported to the trace function are the same as had been "
"reported to the Python-level trace functions in previous versions."
msgstr ""

#: ../../../c-api/init.rst:1081
msgid "Advanced Debugger Support"
msgstr ""

#: ../../../c-api/init.rst:1086
msgid ""
"These functions are only intended to be used by advanced debugging tools."
msgstr ""

#: ../../../c-api/init.rst:342
msgid "global interpreter lock"
msgstr ""

#: ../../../c-api/init.rst:342
msgid "interpreter lock"
msgstr ""

#: ../../../c-api/init.rst:342
msgid "lock, interpreter"
msgstr ""

#: ../../../c-api/init.rst:355 ../../../c-api/init.rst:886
msgid "setcheckinterval() (in module sys)"
msgstr ""

#: ../../../c-api/init.rst:364
msgid "PyThreadState"
msgstr ""

#: ../../../c-api/init.rst:391
msgid "Py_BEGIN_ALLOW_THREADS"
msgstr ""

#: ../../../c-api/init.rst:391
msgid "Py_END_ALLOW_THREADS"
msgstr ""

#: ../../../c-api/init.rst:408
msgid "PyEval_RestoreThread()"
msgstr ""

#: ../../../c-api/init.rst:408
msgid "PyEval_SaveThread()"
msgstr ""

# SOME DESCRIPTIVE TITLE.
# Copyright (C) 1990-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.1\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-10 15:08+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../tutorial/inputoutput.rst:5
msgid "Input and Output"
msgstr ""

#: ../../../tutorial/inputoutput.rst:7
msgid ""
"There are several ways to present the output of a program; data can be "
"printed in a human-readable form, or written to a file for future use. This "
"chapter will discuss some of the possibilities."
msgstr ""

#: ../../../tutorial/inputoutput.rst:15
msgid "Fancier Output Formatting"
msgstr ""

#: ../../../tutorial/inputoutput.rst:17
msgid ""
"So far we've encountered two ways of writing values: *expression statements* "
"and the :func:`print` function.  (A third way is using the :meth:`write` "
"method of file objects; the standard output file can be referenced as ``sys."
"stdout``. See the Library Reference for more information on this.)"
msgstr ""

#: ../../../tutorial/inputoutput.rst:22
msgid ""
"Often you'll want more control over the formatting of your output than "
"simply printing space-separated values.  There are two ways to format your "
"output; the first way is to do all the string handling yourself; using "
"string slicing and concatenation operations you can create any layout you "
"can imagine.  The string type has some methods that perform useful "
"operations for padding strings to a given column width; these will be "
"discussed shortly.  The second way is to use the :meth:`str.format` method."
msgstr ""

#: ../../../tutorial/inputoutput.rst:30
msgid ""
"The :mod:`string` module contains a :class:`~string.Template` class which "
"offers yet another way to substitute values into strings."
msgstr ""

#: ../../../tutorial/inputoutput.rst:33
msgid ""
"One question remains, of course: how do you convert values to strings? "
"Luckily, Python has ways to convert any value to a string: pass it to the :"
"func:`repr` or :func:`str` functions."
msgstr ""

#: ../../../tutorial/inputoutput.rst:37
msgid ""
"The :func:`str` function is meant to return representations of values which "
"are fairly human-readable, while :func:`repr` is meant to generate "
"representations which can be read by the interpreter (or will force a :exc:"
"`SyntaxError` if there is not equivalent syntax).  For objects which don't "
"have a particular representation for human consumption, :func:`str` will "
"return the same value as :func:`repr`.  Many values, such as numbers or "
"structures like lists and dictionaries, have the same representation using "
"either function.  Strings and floating point numbers, in particular, have "
"two distinct representations."
msgstr ""

#: ../../../tutorial/inputoutput.rst:46
msgid "Some examples::"
msgstr ""

#: ../../../tutorial/inputoutput.rst:48
msgid ""
">>> s = 'Hello, world.'\n"
">>> str(s)\n"
"'Hello, world.'\n"
">>> repr(s)\n"
"\"'Hello, world.'\"\n"
">>> str(1.0/7.0)\n"
"'0.142857142857'\n"
">>> repr(1.0/7.0)\n"
"'0.14285714285714285'\n"
">>> x = 10 * 3.25\n"
">>> y = 200 * 200\n"
">>> s = 'The value of x is ' + repr(x) + ', and y is ' + repr(y) + '...'\n"
">>> print(s)\n"
"The value of x is 32.5, and y is 40000...\n"
">>> # The repr() of a string adds string quotes and backslashes:\n"
"... hello = 'hello, world\\n'\n"
">>> hellos = repr(hello)\n"
">>> print(hellos)\n"
"'hello, world\\n'\n"
">>> # The argument to repr() may be any Python object:\n"
"... repr((x, y, ('spam', 'eggs')))\n"
"\"(32.5, 40000, ('spam', 'eggs'))\""
msgstr ""

#: ../../../tutorial/inputoutput.rst:71
msgid "Here are two ways to write a table of squares and cubes::"
msgstr ""

#: ../../../tutorial/inputoutput.rst:73
msgid ""
">>> for x in range(1, 11):\n"
"...     print(repr(x).rjust(2), repr(x*x).rjust(3), end=' ')\n"
"...     # Note use of 'end' on previous line\n"
"...     print(repr(x*x*x).rjust(4))\n"
"...\n"
" 1   1    1\n"
" 2   4    8\n"
" 3   9   27\n"
" 4  16   64\n"
" 5  25  125\n"
" 6  36  216\n"
" 7  49  343\n"
" 8  64  512\n"
" 9  81  729\n"
"10 100 1000\n"
"\n"
">>> for x in range(1, 11):\n"
"...     print('{0:2d} {1:3d} {2:4d}'.format(x, x*x, x*x*x))\n"
"...\n"
" 1   1    1\n"
" 2   4    8\n"
" 3   9   27\n"
" 4  16   64\n"
" 5  25  125\n"
" 6  36  216\n"
" 7  49  343\n"
" 8  64  512\n"
" 9  81  729\n"
"10 100 1000"
msgstr ""

#: ../../../tutorial/inputoutput.rst:103
msgid ""
"(Note that in the first example, one space between each column was added by "
"the way :func:`print` works: it always adds spaces between its arguments.)"
msgstr ""

#: ../../../tutorial/inputoutput.rst:106
msgid ""
"This example demonstrates the :meth:`str.rjust` method of string objects, "
"which right-justifies a string in a field of a given width by padding it "
"with spaces on the left.  There are similar methods :meth:`str.ljust` and :"
"meth:`str.center`.  These methods do not write anything, they just return a "
"new string.  If the input string is too long, they don't truncate it, but "
"return it unchanged; this will mess up your column lay-out but that's "
"usually better than the alternative, which would be lying about a value.  "
"(If you really want truncation you can always add a slice operation, as in "
"``x.ljust(n)[:n]``.)"
msgstr ""

#: ../../../tutorial/inputoutput.rst:116
msgid ""
"There is another method, :meth:`str.zfill`, which pads a numeric string on "
"the left with zeros.  It understands about plus and minus signs::"
msgstr ""

#: ../../../tutorial/inputoutput.rst:119
msgid ""
">>> '12'.zfill(5)\n"
"'00012'\n"
">>> '-3.14'.zfill(7)\n"
"'-003.14'\n"
">>> '3.14159265359'.zfill(5)\n"
"'3.14159265359'"
msgstr ""

#: ../../../tutorial/inputoutput.rst:126
msgid "Basic usage of the :meth:`str.format` method looks like this::"
msgstr ""

#: ../../../tutorial/inputoutput.rst:128
msgid ""
">>> print('We are the {} who say \"{}!\"'.format('knights', 'Ni'))\n"
"We are the knights who say \"Ni!\""
msgstr ""

#: ../../../tutorial/inputoutput.rst:131
msgid ""
"The brackets and characters within them (called format fields) are replaced "
"with the objects passed into the :meth:`str.format` method.  A number in the "
"brackets can be used to refer to the position of the object passed into the :"
"meth:`str.format` method. ::"
msgstr ""

#: ../../../tutorial/inputoutput.rst:136
msgid ""
">>> print('{0} and {1}'.format('spam', 'eggs'))\n"
"spam and eggs\n"
">>> print('{1} and {0}'.format('spam', 'eggs'))\n"
"eggs and spam"
msgstr ""

#: ../../../tutorial/inputoutput.rst:141
msgid ""
"If keyword arguments are used in the :meth:`str.format` method, their values "
"are referred to by using the name of the argument. ::"
msgstr ""

#: ../../../tutorial/inputoutput.rst:144
msgid ""
">>> print('This {food} is {adjective}.'.format(\n"
"...       food='spam', adjective='absolutely horrible'))\n"
"This spam is absolutely horrible."
msgstr ""

#: ../../../tutorial/inputoutput.rst:148
msgid "Positional and keyword arguments can be arbitrarily combined::"
msgstr ""

#: ../../../tutorial/inputoutput.rst:150
msgid ""
">>> print('The story of {0}, {1}, and {other}.'.format('Bill', 'Manfred',\n"
"                                                       other='Georg'))\n"
"The story of Bill, Manfred, and Georg."
msgstr ""

#: ../../../tutorial/inputoutput.rst:154
msgid ""
"``'!a'`` (apply :func:`ascii`), ``'!s'`` (apply :func:`str`) and ``'!r'`` "
"(apply :func:`repr`) can be used to convert the value before it is "
"formatted::"
msgstr ""

#: ../../../tutorial/inputoutput.rst:157
msgid ""
">>> import math\n"
">>> print('The value of PI is approximately {}.'.format(math.pi))\n"
"The value of PI is approximately 3.14159265359.\n"
">>> print('The value of PI is approximately {!r}.'.format(math.pi))\n"
"The value of PI is approximately 3.141592653589793."
msgstr ""

#: ../../../tutorial/inputoutput.rst:163
msgid ""
"An optional ``':'`` and format specifier can follow the field name. This "
"allows greater control over how the value is formatted.  The following "
"example truncates Pi to three places after the decimal."
msgstr ""

#: ../../../tutorial/inputoutput.rst:171
msgid ""
"Passing an integer after the ``':'`` will cause that field to be a minimum "
"number of characters wide.  This is useful for making tables pretty. ::"
msgstr ""

#: ../../../tutorial/inputoutput.rst:174
msgid ""
">>> table = {'Sjoerd': 4127, 'Jack': 4098, 'Dcab': 7678}\n"
">>> for name, phone in table.items():\n"
"...     print('{0:10} ==> {1:10d}'.format(name, phone))\n"
"...\n"
"Jack       ==>       4098\n"
"Dcab       ==>       7678\n"
"Sjoerd     ==>       4127"
msgstr ""

#: ../../../tutorial/inputoutput.rst:182
msgid ""
"If you have a really long format string that you don't want to split up, it "
"would be nice if you could reference the variables to be formatted by name "
"instead of by position.  This can be done by simply passing the dict and "
"using square brackets ``'[]'`` to access the keys ::"
msgstr ""

#: ../../../tutorial/inputoutput.rst:187
msgid ""
">>> table = {'Sjoerd': 4127, 'Jack': 4098, 'Dcab': 8637678}\n"
">>> print('Jack: {0[Jack]:d}; Sjoerd: {0[Sjoerd]:d}; '\n"
"          'Dcab: {0[Dcab]:d}'.format(table))\n"
"Jack: 4098; Sjoerd: 4127; Dcab: 8637678"
msgstr ""

#: ../../../tutorial/inputoutput.rst:192
msgid ""
"This could also be done by passing the table as keyword arguments with the "
"'**' notation. ::"
msgstr ""

#: ../../../tutorial/inputoutput.rst:195
msgid ""
">>> table = {'Sjoerd': 4127, 'Jack': 4098, 'Dcab': 8637678}\n"
">>> print('Jack: {Jack:d}; Sjoerd: {Sjoerd:d}; Dcab: {Dcab:d}'."
"format(**table))\n"
"Jack: 4098; Sjoerd: 4127; Dcab: 8637678"
msgstr ""

#: ../../../tutorial/inputoutput.rst:199
msgid ""
"This is particularly useful in combination with the built-in function :func:"
"`vars`, which returns a dictionary containing all local variables."
msgstr ""

#: ../../../tutorial/inputoutput.rst:202
msgid ""
"For a complete overview of string formatting with :meth:`str.format`, see :"
"ref:`formatstrings`."
msgstr ""

#: ../../../tutorial/inputoutput.rst:207
msgid "Old string formatting"
msgstr ""

#: ../../../tutorial/inputoutput.rst:209
msgid ""
"The ``%`` operator can also be used for string formatting. It interprets the "
"left argument much like a :cfunc:`sprintf`\\ -style format string to be "
"applied to the right argument, and returns the string resulting from this "
"formatting operation. For example::"
msgstr ""

#: ../../../tutorial/inputoutput.rst:214
msgid ""
">>> import math\n"
">>> print('The value of PI is approximately %5.3f.' % math.pi)\n"
"The value of PI is approximately 3.142."
msgstr ""

#: ../../../tutorial/inputoutput.rst:218
msgid ""
"Since :meth:`str.format` is quite new, a lot of Python code still uses the "
"``%`` operator. However, because this old style of formatting will "
"eventually be removed from the language, :meth:`str.format` should generally "
"be used."
msgstr ""

#: ../../../tutorial/inputoutput.rst:222
msgid ""
"More information can be found in the :ref:`old-string-formatting` section."
msgstr ""

#: ../../../tutorial/inputoutput.rst:228
msgid "Reading and Writing Files"
msgstr ""

#: ../../../tutorial/inputoutput.rst:234
msgid ""
":func:`open` returns a :term:`file object`, and is most commonly used with "
"two arguments: ``open(filename, mode)``."
msgstr ""

#: ../../../tutorial/inputoutput.rst:239
msgid ">>> f = open('/tmp/workfile', 'w')"
msgstr ""

#: ../../../tutorial/inputoutput.rst:246
msgid ""
"The first argument is a string containing the filename.  The second argument "
"is another string containing a few characters describing the way in which "
"the file will be used.  *mode* can be ``'r'`` when the file will only be "
"read, ``'w'`` for only writing (an existing file with the same name will be "
"erased), and ``'a'`` opens the file for appending; any data written to the "
"file is automatically added to the end.  ``'r+'`` opens the file for both "
"reading and writing. The *mode* argument is optional; ``'r'`` will be "
"assumed if it's omitted."
msgstr ""

#: ../../../tutorial/inputoutput.rst:255
msgid ""
"Normally, files are opened in :dfn:`text mode`, that means, you read and "
"write strings from and to the file, which are encoded in a specific encoding "
"(the default being UTF-8).  ``'b'`` appended to the mode opens the file in :"
"dfn:`binary mode`: now the data is read and written in the form of bytes "
"objects.  This mode should be used for all files that don't contain text."
msgstr ""

#: ../../../tutorial/inputoutput.rst:261
msgid ""
"In text mode, the default is to convert platform-specific line endings "
"(``\\n`` on Unix, ``\\r\\n`` on Windows) to just ``\\n`` on reading and "
"``\\n`` back to platform-specific line endings on writing.  This behind-the-"
"scenes modification to file data is fine for text files, but will corrupt "
"binary data like that in :file:`JPEG` or :file:`EXE` files.  Be very careful "
"to use binary mode when reading and writing such files."
msgstr ""

#: ../../../tutorial/inputoutput.rst:272
msgid "Methods of File Objects"
msgstr ""

#: ../../../tutorial/inputoutput.rst:274
msgid ""
"The rest of the examples in this section will assume that a file object "
"called ``f`` has already been created."
msgstr ""

#: ../../../tutorial/inputoutput.rst:277
msgid ""
"To read a file's contents, call ``f.read(size)``, which reads some quantity "
"of data and returns it as a string or bytes object.  *size* is an optional "
"numeric argument.  When *size* is omitted or negative, the entire contents "
"of the file will be read and returned; it's your problem if the file is "
"twice as large as your machine's memory. Otherwise, at most *size* bytes are "
"read and returned. If the end of the file has been reached, ``f.read()`` "
"will return an empty string (``''``).  ::"
msgstr ""

#: ../../../tutorial/inputoutput.rst:285
msgid ""
">>> f.read()\n"
"'This is the entire file.\\n'\n"
">>> f.read()\n"
"''"
msgstr ""

#: ../../../tutorial/inputoutput.rst:290
msgid ""
"``f.readline()`` reads a single line from the file; a newline character "
"(``\\n``) is left at the end of the string, and is only omitted on the last "
"line of the file if the file doesn't end in a newline.  This makes the "
"return value unambiguous; if ``f.readline()`` returns an empty string, the "
"end of the file has been reached, while a blank line is represented by "
"``'\\n'``, a string containing only a single newline.  ::"
msgstr ""

#: ../../../tutorial/inputoutput.rst:297
msgid ""
">>> f.readline()\n"
"'This is the first line of the file.\\n'\n"
">>> f.readline()\n"
"'Second line of the file\\n'\n"
">>> f.readline()\n"
"''"
msgstr ""

#: ../../../tutorial/inputoutput.rst:304
msgid ""
"``f.readlines()`` returns a list containing all the lines of data in the "
"file. If given an optional parameter *sizehint*, it reads that many bytes "
"from the file and enough more to complete a line, and returns the lines from "
"that.  This is often used to allow efficient reading of a large file by "
"lines, but without having to load the entire file in memory.  Only complete "
"lines will be returned. ::"
msgstr ""

#: ../../../tutorial/inputoutput.rst:311
msgid ""
">>> f.readlines()\n"
"['This is the first line of the file.\\n', 'Second line of the file\\n']"
msgstr ""

#: ../../../tutorial/inputoutput.rst:314
msgid ""
"An alternative approach to reading lines is to loop over the file object. "
"This is memory efficient, fast, and leads to simpler code::"
msgstr ""

#: ../../../tutorial/inputoutput.rst:317
msgid ""
">>> for line in f:\n"
"...     print(line, end='')\n"
"...\n"
"This is the first line of the file.\n"
"Second line of the file"
msgstr ""

#: ../../../tutorial/inputoutput.rst:323
msgid ""
"The alternative approach is simpler but does not provide as fine-grained "
"control.  Since the two approaches manage line buffering differently, they "
"should not be mixed."
msgstr ""

#: ../../../tutorial/inputoutput.rst:327
msgid ""
"``f.write(string)`` writes the contents of *string* to the file, returning "
"the number of characters written. ::"
msgstr ""

#: ../../../tutorial/inputoutput.rst:330
msgid ""
">>> f.write('This is a test\\n')\n"
"15"
msgstr ""

#: ../../../tutorial/inputoutput.rst:333
msgid ""
"To write something other than a string, it needs to be converted to a string "
"first::"
msgstr ""

#: ../../../tutorial/inputoutput.rst:336
msgid ""
">>> value = ('the answer', 42)\n"
">>> s = str(value)\n"
">>> f.write(s)\n"
"18"
msgstr ""

#: ../../../tutorial/inputoutput.rst:341
msgid ""
"``f.tell()`` returns an integer giving the file object's current position in "
"the file, measured in bytes from the beginning of the file.  To change the "
"file object's position, use ``f.seek(offset, from_what)``.  The position is "
"computed from adding *offset* to a reference point; the reference point is "
"selected by the *from_what* argument.  A *from_what* value of 0 measures "
"from the beginning of the file, 1 uses the current file position, and 2 uses "
"the end of the file as the reference point.  *from_what* can be omitted and "
"defaults to 0, using the beginning of the file as the reference point. ::"
msgstr ""

#: ../../../tutorial/inputoutput.rst:350
msgid ""
">>> f = open('/tmp/workfile', 'rb+')\n"
">>> f.write(b'0123456789abcdef')\n"
"16\n"
">>> f.seek(5)     # Go to the 6th byte in the file\n"
"5\n"
">>> f.read(1)\n"
"b'5'\n"
">>> f.seek(-3, 2) # Go to the 3rd byte before the end\n"
"13\n"
">>> f.read(1)\n"
"b'd'"
msgstr ""

#: ../../../tutorial/inputoutput.rst:362
msgid ""
"In text files (those opened without a ``b`` in the mode string), only seeks "
"relative to the beginning of the file are allowed (the exception being "
"seeking to the very file end with ``seek(0, 2)``)."
msgstr ""

#: ../../../tutorial/inputoutput.rst:366
msgid ""
"When you're done with a file, call ``f.close()`` to close it and free up any "
"system resources taken up by the open file.  After calling ``f.close()``, "
"attempts to use the file object will automatically fail. ::"
msgstr ""

#: ../../../tutorial/inputoutput.rst:370
msgid ""
">>> f.close()\n"
">>> f.read()\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in ?\n"
"ValueError: I/O operation on closed file"
msgstr ""

#: ../../../tutorial/inputoutput.rst:376
msgid ""
"It is good practice to use the :keyword:`with` keyword when dealing with "
"file objects.  This has the advantage that the file is properly closed after "
"its suite finishes, even if an exception is raised on the way.  It is also "
"much shorter than writing equivalent :keyword:`try`\\ -\\ :keyword:`finally` "
"blocks::"
msgstr ""

#: ../../../tutorial/inputoutput.rst:381
msgid ""
">>> with open('/tmp/workfile', 'r') as f:\n"
"...     read_data = f.read()\n"
">>> f.closed\n"
"True"
msgstr ""

#: ../../../tutorial/inputoutput.rst:386
msgid ""
"File objects have some additional methods, such as :meth:`~file.isatty` and :"
"meth:`~file.truncate` which are less frequently used; consult the Library "
"Reference for a complete guide to file objects."
msgstr ""

#: ../../../tutorial/inputoutput.rst:394
msgid "The :mod:`pickle` Module"
msgstr ""

#: ../../../tutorial/inputoutput.rst:398
msgid ""
"Strings can easily be written to and read from a file. Numbers take a bit "
"more effort, since the :meth:`read` method only returns strings, which will "
"have to be passed to a function like :func:`int`, which takes a string like "
"``'123'`` and returns its numeric value 123.  However, when you want to save "
"more complex data types like lists, dictionaries, or class instances, things "
"get a lot more complicated."
msgstr ""

#: ../../../tutorial/inputoutput.rst:405
msgid ""
"Rather than have users be constantly writing and debugging code to save "
"complicated data types, Python provides a standard module called :mod:"
"`pickle`. This is an amazing module that can take almost any Python object "
"(even some forms of Python code!), and convert it to a string "
"representation; this process is called :dfn:`pickling`.  Reconstructing the "
"object from the string representation is called :dfn:`unpickling`.  Between "
"pickling and unpickling, the string representing the object may have been "
"stored in a file or data, or sent over a network connection to some distant "
"machine."
msgstr ""

#: ../../../tutorial/inputoutput.rst:414
msgid ""
"If you have an object ``x``, and a file object ``f`` that's been opened for "
"writing, the simplest way to pickle the object takes only one line of code::"
msgstr ""

#: ../../../tutorial/inputoutput.rst:417
msgid "pickle.dump(x, f)"
msgstr ""

#: ../../../tutorial/inputoutput.rst:419
msgid ""
"To unpickle the object again, if ``f`` is a file object which has been "
"opened for reading::"
msgstr ""

#: ../../../tutorial/inputoutput.rst:422
msgid "x = pickle.load(f)"
msgstr ""

#: ../../../tutorial/inputoutput.rst:424
msgid ""
"(There are other variants of this, used when pickling many objects or when "
"you don't want to write the pickled data to a file; consult the complete "
"documentation for :mod:`pickle` in the Python Library Reference.)"
msgstr ""

#: ../../../tutorial/inputoutput.rst:428
msgid ""
":mod:`pickle` is the standard way to make Python objects which can be stored "
"and reused by other programs or by a future invocation of the same program; "
"the technical term for this is a :dfn:`persistent` object.  Because :mod:"
"`pickle` is so widely used, many authors who write Python extensions take "
"care to ensure that new data types such as matrices can be properly pickled "
"and unpickled."
msgstr ""

#: ../../../tutorial/inputoutput.rst:230
msgid "open"
msgstr ""

#: ../../../tutorial/inputoutput.rst:230
msgid "file"
msgstr ""

#: ../../../tutorial/inputoutput.rst:396
msgid "pickle"
msgstr ""

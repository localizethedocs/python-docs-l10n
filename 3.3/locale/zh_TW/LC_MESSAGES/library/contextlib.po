# SOME DESCRIPTIVE TITLE.
# Copyright (C) 1990-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.3\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-11 04:42+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../library/contextlib.rst:2
msgid ""
":mod:`contextlib` --- Utilities for :keyword:`with`\\ -statement contexts"
msgstr ""

#: ../../../library/contextlib.rst:7
msgid "**Source code:** :source:`Lib/contextlib.py`"
msgstr ""

#: ../../../library/contextlib.rst:11
msgid ""
"This module provides utilities for common tasks involving the :keyword:"
"`with` statement. For more information see also :ref:`typecontextmanager` "
"and :ref:`context-managers`."
msgstr ""

#: ../../../library/contextlib.rst:17
msgid "Utilities"
msgstr ""

#: ../../../library/contextlib.rst:19
msgid "Functions and classes provided:"
msgstr ""

#: ../../../library/contextlib.rst:23
msgid ""
"This function is a :term:`decorator` that can be used to define a factory "
"function for :keyword:`with` statement context managers, without needing to "
"create a class or separate :meth:`__enter__` and :meth:`__exit__` methods."
msgstr ""

#: ../../../library/contextlib.rst:27
msgid ""
"A simple example (this is not recommended as a real way of generating "
"HTML!)::"
msgstr ""

#: ../../../library/contextlib.rst:44
msgid ""
"The function being decorated must return a :term:`generator`-iterator when "
"called. This iterator must yield exactly one value, which will be bound to "
"the targets in the :keyword:`with` statement's :keyword:`as` clause, if any."
msgstr ""

#: ../../../library/contextlib.rst:48
msgid ""
"At the point where the generator yields, the block nested in the :keyword:"
"`with` statement is executed.  The generator is then resumed after the block "
"is exited. If an unhandled exception occurs in the block, it is reraised "
"inside the generator at the point where the yield occurred.  Thus, you can "
"use a :keyword:`try`...\\ :keyword:`except`...\\ :keyword:`finally` "
"statement to trap the error (if any), or ensure that some cleanup takes "
"place. If an exception is trapped merely in order to log it or to perform "
"some action (rather than to suppress it entirely), the generator must "
"reraise that exception. Otherwise the generator context manager will "
"indicate to the :keyword:`with` statement that the exception has been "
"handled, and execution will resume with the statement immediately following "
"the :keyword:`with` statement."
msgstr ""

#: ../../../library/contextlib.rst:60
msgid ""
":func:`contextmanager` uses :class:`ContextDecorator` so the context "
"managers it creates can be used as decorators as well as in :keyword:`with` "
"statements. When used as a decorator, a new generator instance is implicitly "
"created on each function call (this allows the otherwise \"one-shot\" "
"context managers created by :func:`contextmanager` to meet the requirement "
"that context managers support multiple invocations in order to be used as "
"decorators)."
msgstr ""

#: ../../../library/contextlib.rst:67
msgid "Use of :class:`ContextDecorator`."
msgstr ""

#: ../../../library/contextlib.rst:73
msgid ""
"Return a context manager that closes *thing* upon completion of the block.  "
"This is basically equivalent to::"
msgstr ""

#: ../../../library/contextlib.rst:85
msgid "And lets you write code like this::"
msgstr ""

#: ../../../library/contextlib.rst:94
msgid ""
"without needing to explicitly close ``page``.  Even if an error occurs, "
"``page.close()`` will be called when the :keyword:`with` block is exited."
msgstr ""

#: ../../../library/contextlib.rst:100
msgid ""
"A base class that enables a context manager to also be used as a decorator."
msgstr ""

#: ../../../library/contextlib.rst:102
msgid ""
"Context managers inheriting from ``ContextDecorator`` have to implement "
"``__enter__`` and ``__exit__`` as normal. ``__exit__`` retains its optional "
"exception handling even when used as a decorator."
msgstr ""

#: ../../../library/contextlib.rst:106
msgid ""
"``ContextDecorator`` is used by :func:`contextmanager`, so you get this "
"functionality automatically."
msgstr ""

#: ../../../library/contextlib.rst:109
msgid "Example of ``ContextDecorator``::"
msgstr ""

#: ../../../library/contextlib.rst:138
msgid ""
"This change is just syntactic sugar for any construct of the following form::"
msgstr ""

#: ../../../library/contextlib.rst:144
msgid "``ContextDecorator`` lets you instead write::"
msgstr ""

#: ../../../library/contextlib.rst:150
msgid ""
"It makes it clear that the ``cm`` applies to the whole function, rather than "
"just a piece of it (and saving an indentation level is nice, too)."
msgstr ""

#: ../../../library/contextlib.rst:153
msgid ""
"Existing context managers that already have a base class can be extended by "
"using ``ContextDecorator`` as a mixin class::"
msgstr ""

#: ../../../library/contextlib.rst:166
msgid ""
"As the decorated function must be able to be called multiple times, the "
"underlying context manager must support use in multiple :keyword:`with` "
"statements. If this is not the case, then the original construct with the "
"explicit :keyword:`with` statement inside the function should be used."
msgstr ""

#: ../../../library/contextlib.rst:176
msgid ""
"A context manager that is designed to make it easy to programmatically "
"combine other context managers and cleanup functions, especially those that "
"are optional or otherwise driven by input data."
msgstr ""

#: ../../../library/contextlib.rst:180
msgid ""
"For example, a set of files may easily be handled in a single with statement "
"as follows::"
msgstr ""

#: ../../../library/contextlib.rst:189
msgid ""
"Each instance maintains a stack of registered callbacks that are called in "
"reverse order when the instance is closed (either explicitly or implicitly "
"at the end of a :keyword:`with` statement). Note that callbacks are *not* "
"invoked implicitly when the context stack instance is garbage collected."
msgstr ""

#: ../../../library/contextlib.rst:194
msgid ""
"This stack model is used so that context managers that acquire their "
"resources in their ``__init__`` method (such as file objects) can be handled "
"correctly."
msgstr ""

#: ../../../library/contextlib.rst:198
msgid ""
"Since registered callbacks are invoked in the reverse order of registration, "
"this ends up behaving as if multiple nested :keyword:`with` statements had "
"been used with the registered set of callbacks. This even extends to "
"exception handling - if an inner callback suppresses or replaces an "
"exception, then outer callbacks will be passed arguments based on that "
"updated state."
msgstr ""

#: ../../../library/contextlib.rst:205
msgid ""
"This is a relatively low level API that takes care of the details of "
"correctly unwinding the stack of exit callbacks. It provides a suitable "
"foundation for higher level context managers that manipulate the exit stack "
"in application specific ways."
msgstr ""

#: ../../../library/contextlib.rst:214
msgid ""
"Enters a new context manager and adds its :meth:`__exit__` method to the "
"callback stack. The return value is the result of the context manager's own :"
"meth:`__enter__` method."
msgstr ""

#: ../../../library/contextlib.rst:218
msgid ""
"These context managers may suppress exceptions just as they normally would "
"if used directly as part of a :keyword:`with` statement."
msgstr ""

#: ../../../library/contextlib.rst:223
msgid "Adds a context manager's :meth:`__exit__` method to the callback stack."
msgstr ""

#: ../../../library/contextlib.rst:225
msgid ""
"As ``__enter__`` is *not* invoked, this method can be used to cover part of "
"an :meth:`__enter__` implementation with a context manager's own :meth:"
"`__exit__` method."
msgstr ""

#: ../../../library/contextlib.rst:229
msgid ""
"If passed an object that is not a context manager, this method assumes it is "
"a callback with the same signature as a context manager's :meth:`__exit__` "
"method and adds it directly to the callback stack."
msgstr ""

#: ../../../library/contextlib.rst:233
msgid ""
"By returning true values, these callbacks can suppress exceptions the same "
"way context manager :meth:`__exit__` methods can."
msgstr ""

#: ../../../library/contextlib.rst:236
msgid ""
"The passed in object is returned from the function, allowing this method to "
"be used as a function decorator."
msgstr ""

#: ../../../library/contextlib.rst:241
msgid ""
"Accepts an arbitrary callback function and arguments and adds it to the "
"callback stack."
msgstr ""

#: ../../../library/contextlib.rst:244
msgid ""
"Unlike the other methods, callbacks added this way cannot suppress "
"exceptions (as they are never passed the exception details)."
msgstr ""

#: ../../../library/contextlib.rst:247
msgid ""
"The passed in callback is returned from the function, allowing this method "
"to be used as a function decorator."
msgstr ""

#: ../../../library/contextlib.rst:252
msgid ""
"Transfers the callback stack to a fresh :class:`ExitStack` instance and "
"returns it. No callbacks are invoked by this operation - instead, they will "
"now be invoked when the new stack is closed (either explicitly or implicitly "
"at the end of a :keyword:`with` statement)."
msgstr ""

#: ../../../library/contextlib.rst:257
msgid ""
"For example, a group of files can be opened as an \"all or nothing\" "
"operation as follows::"
msgstr ""

#: ../../../library/contextlib.rst:271
msgid ""
"Immediately unwinds the callback stack, invoking callbacks in the reverse "
"order of registration. For any context managers and exit callbacks "
"registered, the arguments passed in will indicate that no exception occurred."
msgstr ""

#: ../../../library/contextlib.rst:278
msgid "Examples and Recipes"
msgstr ""

#: ../../../library/contextlib.rst:280
msgid ""
"This section describes some examples and recipes for making effective use of "
"the tools provided by :mod:`contextlib`."
msgstr ""

#: ../../../library/contextlib.rst:285
msgid "Supporting a variable number of context managers"
msgstr ""

#: ../../../library/contextlib.rst:287
msgid ""
"The primary use case for :class:`ExitStack` is the one given in the class "
"documentation: supporting a variable number of context managers and other "
"cleanup operations in a single :keyword:`with` statement. The variability "
"may come from the number of context managers needed being driven by user "
"input (such as opening a user specified collection of files), or from some "
"of the context managers being optional::"
msgstr ""

#: ../../../library/contextlib.rst:302
msgid ""
"As shown, :class:`ExitStack` also makes it quite easy to use :keyword:`with` "
"statements to manage arbitrary resources that don't natively support the "
"context management protocol."
msgstr ""

#: ../../../library/contextlib.rst:308
msgid "Simplifying support for single optional context managers"
msgstr ""

#: ../../../library/contextlib.rst:310
msgid ""
"In the specific case of a single optional context manager, :class:"
"`ExitStack` instances can be used as a \"do nothing\" context manager, "
"allowing a context manager to easily be omitted without affecting the "
"overall structure of the source code::"
msgstr ""

#: ../../../library/contextlib.rst:326
msgid "Catching exceptions from ``__enter__`` methods"
msgstr ""

#: ../../../library/contextlib.rst:328
msgid ""
"It is occasionally desirable to catch exceptions from an ``__enter__`` "
"method implementation, *without* inadvertently catching exceptions from the :"
"keyword:`with` statement body or the context manager's ``__exit__`` method. "
"By using :class:`ExitStack` the steps in the context management protocol can "
"be separated slightly in order to allow this::"
msgstr ""

#: ../../../library/contextlib.rst:343
msgid ""
"Actually needing to do this is likely to indicate that the underlying API "
"should be providing a direct resource management interface for use with :"
"keyword:`try`/:keyword:`except`/:keyword:`finally` statements, but not all "
"APIs are well designed in that regard. When a context manager is the only "
"resource management API provided, then :class:`ExitStack` can make it easier "
"to handle various situations that can't be handled directly in a :keyword:"
"`with` statement."
msgstr ""

#: ../../../library/contextlib.rst:353
msgid "Cleaning up in an ``__enter__`` implementation"
msgstr ""

#: ../../../library/contextlib.rst:355
msgid ""
"As noted in the documentation of :meth:`ExitStack.push`, this method can be "
"useful in cleaning up an already allocated resource if later steps in the :"
"meth:`__enter__` implementation fail."
msgstr ""

#: ../../../library/contextlib.rst:359
msgid ""
"Here's an example of doing this for a context manager that accepts resource "
"acquisition and release functions, along with an optional validation "
"function, and maps them to the context management protocol::"
msgstr ""

#: ../../../library/contextlib.rst:399
msgid "Replacing any use of ``try-finally`` and flag variables"
msgstr ""

#: ../../../library/contextlib.rst:401
msgid ""
"A pattern you will sometimes see is a ``try-finally`` statement with a flag "
"variable to indicate whether or not the body of the ``finally`` clause "
"should be executed. In its simplest form (that can't already be handled just "
"by using an ``except`` clause instead), it looks something like this::"
msgstr ""

#: ../../../library/contextlib.rst:415
msgid ""
"As with any ``try`` statement based code, this can cause problems for "
"development and review, because the setup code and the cleanup code can end "
"up being separated by arbitrarily long sections of code."
msgstr ""

#: ../../../library/contextlib.rst:419
msgid ""
":class:`ExitStack` makes it possible to instead register a callback for "
"execution at the end of a ``with`` statement, and then later decide to skip "
"executing that callback::"
msgstr ""

#: ../../../library/contextlib.rst:431
msgid ""
"This allows the intended cleanup up behaviour to be made explicit up front, "
"rather than requiring a separate flag variable."
msgstr ""

#: ../../../library/contextlib.rst:434
msgid ""
"If a particular application uses this pattern a lot, it can be simplified "
"even further by means of a small helper class::"
msgstr ""

#: ../../../library/contextlib.rst:452
msgid ""
"If the resource cleanup isn't already neatly bundled into a standalone "
"function, then it is still possible to use the decorator form of :meth:"
"`ExitStack.callback` to declare the resource cleanup in advance::"
msgstr ""

#: ../../../library/contextlib.rst:467
msgid ""
"Due to the way the decorator protocol works, a callback function declared "
"this way cannot take any parameters. Instead, any resources to be released "
"must be accessed as closure variables"
msgstr ""

#: ../../../library/contextlib.rst:473
msgid "Using a context manager as a function decorator"
msgstr ""

#: ../../../library/contextlib.rst:475
msgid ""
":class:`ContextDecorator` makes it possible to use a context manager in both "
"an ordinary ``with`` statement and also as a function decorator."
msgstr ""

#: ../../../library/contextlib.rst:478
msgid ""
"For example, it is sometimes useful to wrap functions or groups of "
"statements with a logger that can track the time of entry and time of exit.  "
"Rather than writing both a function decorator and a context manager for the "
"task, inheriting from :class:`ContextDecorator` provides both capabilities "
"in a single definition::"
msgstr ""

#: ../../../library/contextlib.rst:499
msgid "Instances of this class can be used as both a context manager::"
msgstr ""

#: ../../../library/contextlib.rst:505
msgid "And also as a function decorator::"
msgstr ""

#: ../../../library/contextlib.rst:512
msgid ""
"Note that there is one additional limitation when using context managers as "
"function decorators: there's no way to access the return value of :meth:"
"`__enter__`. If that value is needed, then it is still necessary to use an "
"explicit ``with`` statement."
msgstr ""

#: ../../../library/contextlib.rst:520
msgid ":pep:`0343` - The \"with\" statement"
msgstr ""

#: ../../../library/contextlib.rst:520
msgid ""
"The specification, background, and examples for the Python :keyword:`with` "
"statement."
msgstr ""

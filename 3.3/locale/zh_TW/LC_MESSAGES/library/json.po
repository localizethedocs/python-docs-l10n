# SOME DESCRIPTIVE TITLE.
# Copyright (C) 1990-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.3\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-10 15:08+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../library/json.rst:2
msgid ":mod:`json` --- JSON encoder and decoder"
msgstr ""

#: ../../../library/json.rst:9
msgid ""
"`JSON (JavaScript Object Notation) <http://json.org>`_, specified by :rfc:"
"`4627`, is a lightweight data interchange format based on a subset of "
"`JavaScript <http://en.wikipedia.org/wiki/JavaScript>`_ syntax (`ECMA-262 "
"3rd edition <http://www.ecma-international.org/publications/files/ECMA-ST-"
"ARCH/ECMA-262,%203rd%20edition,%20December%201999.pdf>`_)."
msgstr ""

#: ../../../library/json.rst:14
msgid ""
":mod:`json` exposes an API familiar to users of the standard library :mod:"
"`marshal` and :mod:`pickle` modules."
msgstr ""

#: ../../../library/json.rst:17
msgid "Encoding basic Python object hierarchies::"
msgstr ""

#: ../../../library/json.rst:19
msgid ""
">>> import json\n"
">>> json.dumps(['foo', {'bar': ('baz', None, 1.0, 2)}])\n"
"'[\"foo\", {\"bar\": [\"baz\", null, 1.0, 2]}]'\n"
">>> print(json.dumps(\"\\\"foo\\bar\"))\n"
"\"\\\"foo\\bar\"\n"
">>> print(json.dumps('\\u1234'))\n"
"\"\\u1234\"\n"
">>> print(json.dumps('\\\\'))\n"
"\"\\\\\"\n"
">>> print(json.dumps({\"c\": 0, \"b\": 0, \"a\": 0}, sort_keys=True))\n"
"{\"a\": 0, \"b\": 0, \"c\": 0}\n"
">>> from io import StringIO\n"
">>> io = StringIO()\n"
">>> json.dump(['streaming API'], io)\n"
">>> io.getvalue()\n"
"'[\"streaming API\"]'"
msgstr ""

#: ../../../library/json.rst:36
msgid "Compact encoding::"
msgstr ""

#: ../../../library/json.rst:38
msgid ""
">>> import json\n"
">>> json.dumps([1,2,3,{'4': 5, '6': 7}], separators=(',', ':'))\n"
"'[1,2,3,{\"4\":5,\"6\":7}]'"
msgstr ""

#: ../../../library/json.rst:42
msgid "Pretty printing::"
msgstr ""

#: ../../../library/json.rst:44
msgid ""
">>> import json\n"
">>> print(json.dumps({'4': 5, '6': 7}, sort_keys=True,\n"
"...                  indent=4, separators=(',', ': ')))\n"
"{\n"
"    \"4\": 5,\n"
"    \"6\": 7\n"
"}"
msgstr ""

#: ../../../library/json.rst:52
msgid "Decoding JSON::"
msgstr ""

#: ../../../library/json.rst:54
msgid ""
">>> import json\n"
">>> json.loads('[\"foo\", {\"bar\":[\"baz\", null, 1.0, 2]}]')\n"
"['foo', {'bar': ['baz', None, 1.0, 2]}]\n"
">>> json.loads('\"\\\\\"foo\\\\bar\"')\n"
"'\"foo\\x08ar'\n"
">>> from io import StringIO\n"
">>> io = StringIO('[\"streaming API\"]')\n"
">>> json.load(io)\n"
"['streaming API']"
msgstr ""

#: ../../../library/json.rst:64
msgid "Specializing JSON object decoding::"
msgstr ""

#: ../../../library/json.rst:66
msgid ""
">>> import json\n"
">>> def as_complex(dct):\n"
"...     if '__complex__' in dct:\n"
"...         return complex(dct['real'], dct['imag'])\n"
"...     return dct\n"
"...\n"
">>> json.loads('{\"__complex__\": true, \"real\": 1, \"imag\": 2}',\n"
"...     object_hook=as_complex)\n"
"(1+2j)\n"
">>> import decimal\n"
">>> json.loads('1.1', parse_float=decimal.Decimal)\n"
"Decimal('1.1')"
msgstr ""

#: ../../../library/json.rst:79
msgid "Extending :class:`JSONEncoder`::"
msgstr ""

#: ../../../library/json.rst:81
msgid ""
">>> import json\n"
">>> class ComplexEncoder(json.JSONEncoder):\n"
"...     def default(self, obj):\n"
"...         if isinstance(obj, complex):\n"
"...             return [obj.real, obj.imag]\n"
"...         # Let the base class default method raise the TypeError\n"
"...         return json.JSONEncoder.default(self, obj)\n"
"...\n"
">>> json.dumps(2 + 1j, cls=ComplexEncoder)\n"
"'[2.0, 1.0]'\n"
">>> ComplexEncoder().encode(2 + 1j)\n"
"'[2.0, 1.0]'\n"
">>> list(ComplexEncoder().iterencode(2 + 1j))\n"
"['[2.0', ', 1.0', ']']"
msgstr ""

#: ../../../library/json.rst:99
msgid "Using json.tool from the shell to validate and pretty-print::"
msgstr ""

#: ../../../library/json.rst:101
msgid ""
"$ echo '{\"json\":\"obj\"}' | python -mjson.tool\n"
"{\n"
"    \"json\": \"obj\"\n"
"}\n"
"$ echo '{1.2:3.4}' | python -mjson.tool\n"
"Expecting property name enclosed in double quotes: line 1 column 2 (char 1)"
msgstr ""

#: ../../../library/json.rst:112
msgid ""
"JSON is a subset of `YAML <http://yaml.org/>`_ 1.2.  The JSON produced by "
"this module's default settings (in particular, the default *separators* "
"value) is also a subset of YAML 1.0 and 1.1.  This module can thus also be "
"used as a YAML serializer."
msgstr ""

#: ../../../library/json.rst:119
msgid "Basic Usage"
msgstr ""

#: ../../../library/json.rst:126
msgid ""
"Serialize *obj* as a JSON formatted stream to *fp* (a ``.write()``-"
"supporting :term:`file-like object`) using this :ref:`conversion table <py-"
"to-json-table>`."
msgstr ""

#: ../../../library/json.rst:130
msgid ""
"If *skipkeys* is ``True`` (default: ``False``), then dict keys that are not "
"of a basic type (:class:`str`, :class:`int`, :class:`float`, :class:`bool`, "
"``None``) will be skipped instead of raising a :exc:`TypeError`."
msgstr ""

#: ../../../library/json.rst:134
msgid ""
"The :mod:`json` module always produces :class:`str` objects, not :class:"
"`bytes` objects. Therefore, ``fp.write()`` must support :class:`str` input."
msgstr ""

#: ../../../library/json.rst:138 ../../../library/json.rst:384
msgid ""
"If *ensure_ascii* is ``True`` (the default), the output is guaranteed to "
"have all incoming non-ASCII characters escaped.  If *ensure_ascii* is "
"``False``, these characters will be output as-is."
msgstr ""

#: ../../../library/json.rst:142
msgid ""
"If *check_circular* is ``False`` (default: ``True``), then the circular "
"reference check for container types will be skipped and a circular reference "
"will result in an :exc:`OverflowError` (or worse)."
msgstr ""

#: ../../../library/json.rst:146
msgid ""
"If *allow_nan* is ``False`` (default: ``True``), then it will be a :exc:"
"`ValueError` to serialize out of range :class:`float` values (``nan``, "
"``inf``, ``-inf``) in strict compliance of the JSON specification, instead "
"of using the JavaScript equivalents (``NaN``, ``Infinity``, ``-Infinity``)."
msgstr ""

#: ../../../library/json.rst:151 ../../../library/json.rst:403
msgid ""
"If *indent* is a non-negative integer or string, then JSON array elements "
"and object members will be pretty-printed with that indent level.  An indent "
"level of 0, negative, or ``\"\"`` will only insert newlines.  ``None`` (the "
"default) selects the most compact representation. Using a positive integer "
"indent indents that many spaces per level.  If *indent* is a string (such as "
"``\"\\t\"``), that string is used to indent each level."
msgstr ""

#: ../../../library/json.rst:158 ../../../library/json.rst:410
msgid "Allow strings for *indent* in addition to integers."
msgstr ""

#: ../../../library/json.rst:163 ../../../library/json.rst:415
msgid ""
"Since the default item separator is ``', '``,  the output might include "
"trailing whitespace when *indent* is specified.  You can use "
"``separators=(',', ': ')`` to avoid this."
msgstr ""

#: ../../../library/json.rst:167
msgid ""
"If *separators* is an ``(item_separator, dict_separator)`` tuple, then it "
"will be used instead of the default ``(', ', ': ')`` separators.  ``(',', "
"':')`` is the most compact JSON representation."
msgstr ""

#: ../../../library/json.rst:171
msgid ""
"*default(obj)* is a function that should return a serializable version of "
"*obj* or raise :exc:`TypeError`.  The default simply raises :exc:`TypeError`."
msgstr ""

#: ../../../library/json.rst:174
msgid ""
"If *sort_keys* is ``True`` (default: ``False``), then the output of "
"dictionaries will be sorted by key."
msgstr ""

#: ../../../library/json.rst:177
msgid ""
"To use a custom :class:`JSONEncoder` subclass (e.g. one that overrides the :"
"meth:`default` method to serialize additional types), specify it with the "
"*cls* kwarg; otherwise :class:`JSONEncoder` is used."
msgstr ""

#: ../../../library/json.rst:187
msgid ""
"Serialize *obj* to a JSON formatted :class:`str` using this :ref:`conversion "
"table <py-to-json-table>`.  The arguments have the same meaning as in :func:"
"`dump`."
msgstr ""

#: ../../../library/json.rst:193
msgid ""
"Unlike :mod:`pickle` and :mod:`marshal`, JSON is not a framed protocol, so "
"trying to serialize multiple objects with repeated calls to :func:`dump` "
"using the same *fp* will result in an invalid JSON file."
msgstr ""

#: ../../../library/json.rst:199
msgid ""
"Keys in key/value pairs of JSON are always of the type :class:`str`. When a "
"dictionary is converted into JSON, all the keys of the dictionary are "
"coerced to strings. As a result of this, if a dictionary is converted into "
"JSON and then back into a dictionary, the dictionary may not equal the "
"original one. That is, ``loads(dumps(x)) != x`` if x has non-string keys."
msgstr ""

#: ../../../library/json.rst:208
msgid ""
"Deserialize *fp* (a ``.read()``-supporting :term:`file-like object` "
"containing a JSON document) to a Python object using this :ref:`conversion "
"table <json-to-py-table>`."
msgstr ""

#: ../../../library/json.rst:212
msgid ""
"*object_hook* is an optional function that will be called with the result of "
"any object literal decoded (a :class:`dict`).  The return value of "
"*object_hook* will be used instead of the :class:`dict`.  This feature can "
"be used to implement custom decoders (e.g. `JSON-RPC <http://www.jsonrpc."
"org>`_ class hinting)."
msgstr ""

#: ../../../library/json.rst:218
msgid ""
"*object_pairs_hook* is an optional function that will be called with the "
"result of any object literal decoded with an ordered list of pairs.  The "
"return value of *object_pairs_hook* will be used instead of the :class:"
"`dict`.  This feature can be used to implement custom decoders that rely on "
"the order that the key and value pairs are decoded (for example, :func:"
"`collections.OrderedDict` will remember the order of insertion). If "
"*object_hook* is also defined, the *object_pairs_hook* takes priority."
msgstr ""

#: ../../../library/json.rst:226 ../../../library/json.rst:308
msgid "Added support for *object_pairs_hook*."
msgstr ""

#: ../../../library/json.rst:229 ../../../library/json.rst:311
msgid ""
"*parse_float*, if specified, will be called with the string of every JSON "
"float to be decoded.  By default, this is equivalent to ``float(num_str)``. "
"This can be used to use another datatype or parser for JSON floats (e.g. :"
"class:`decimal.Decimal`)."
msgstr ""

#: ../../../library/json.rst:234 ../../../library/json.rst:316
msgid ""
"*parse_int*, if specified, will be called with the string of every JSON int "
"to be decoded.  By default, this is equivalent to ``int(num_str)``.  This "
"can be used to use another datatype or parser for JSON integers (e.g. :class:"
"`float`)."
msgstr ""

#: ../../../library/json.rst:239
msgid ""
"*parse_constant*, if specified, will be called with one of the following "
"strings: ``'-Infinity'``, ``'Infinity'``, ``'NaN'``. This can be used to "
"raise an exception if invalid JSON numbers are encountered."
msgstr ""

#: ../../../library/json.rst:244
msgid "*parse_constant* doesn't get called on 'null', 'true', 'false' anymore."
msgstr ""

#: ../../../library/json.rst:247
msgid ""
"To use a custom :class:`JSONDecoder` subclass, specify it with the ``cls`` "
"kwarg; otherwise :class:`JSONDecoder` is used.  Additional keyword arguments "
"will be passed to the constructor of the class."
msgstr ""

#: ../../../library/json.rst:254
msgid ""
"Deserialize *s* (a :class:`str` instance containing a JSON document) to a "
"Python object using this :ref:`conversion table <json-to-py-table>`."
msgstr ""

#: ../../../library/json.rst:257
msgid ""
"The other arguments have the same meaning as in :func:`load`, except "
"*encoding* which is ignored and deprecated."
msgstr ""

#: ../../../library/json.rst:262
msgid "Encoders and Decoders"
msgstr ""

#: ../../../library/json.rst:266
msgid "Simple JSON decoder."
msgstr ""

#: ../../../library/json.rst:268
msgid "Performs the following translations in decoding by default:"
msgstr ""

#: ../../../library/json.rst:273 ../../../library/json.rst:358
msgid "JSON"
msgstr ""

#: ../../../library/json.rst:273 ../../../library/json.rst:358
msgid "Python"
msgstr ""

#: ../../../library/json.rst:275 ../../../library/json.rst:360
msgid "object"
msgstr ""

#: ../../../library/json.rst:275 ../../../library/json.rst:360
msgid "dict"
msgstr ""

#: ../../../library/json.rst:277 ../../../library/json.rst:362
msgid "array"
msgstr ""

#: ../../../library/json.rst:277
msgid "list"
msgstr ""

#: ../../../library/json.rst:279 ../../../library/json.rst:364
msgid "string"
msgstr ""

#: ../../../library/json.rst:279 ../../../library/json.rst:364
msgid "str"
msgstr ""

#: ../../../library/json.rst:281
msgid "number (int)"
msgstr ""

#: ../../../library/json.rst:281
msgid "int"
msgstr ""

#: ../../../library/json.rst:283
msgid "number (real)"
msgstr ""

#: ../../../library/json.rst:283
msgid "float"
msgstr ""

#: ../../../library/json.rst:285 ../../../library/json.rst:368
msgid "true"
msgstr ""

#: ../../../library/json.rst:285 ../../../library/json.rst:368
msgid "True"
msgstr ""

#: ../../../library/json.rst:287 ../../../library/json.rst:370
msgid "false"
msgstr ""

#: ../../../library/json.rst:287 ../../../library/json.rst:370
msgid "False"
msgstr ""

#: ../../../library/json.rst:289 ../../../library/json.rst:372
msgid "null"
msgstr ""

#: ../../../library/json.rst:289 ../../../library/json.rst:372
msgid "None"
msgstr ""

#: ../../../library/json.rst:292
msgid ""
"It also understands ``NaN``, ``Infinity``, and ``-Infinity`` as their "
"corresponding ``float`` values, which is outside the JSON spec."
msgstr ""

#: ../../../library/json.rst:295
msgid ""
"*object_hook*, if specified, will be called with the result of every JSON "
"object decoded and its return value will be used in place of the given :"
"class:`dict`.  This can be used to provide custom deserializations (e.g. to "
"support JSON-RPC class hinting)."
msgstr ""

#: ../../../library/json.rst:300
msgid ""
"*object_pairs_hook*, if specified will be called with the result of every "
"JSON object decoded with an ordered list of pairs.  The return value of "
"*object_pairs_hook* will be used instead of the :class:`dict`.  This feature "
"can be used to implement custom decoders that rely on the order that the key "
"and value pairs are decoded (for example, :func:`collections.OrderedDict` "
"will remember the order of insertion). If *object_hook* is also defined, the "
"*object_pairs_hook* takes priority."
msgstr ""

#: ../../../library/json.rst:321
msgid ""
"*parse_constant*, if specified, will be called with one of the following "
"strings: ``'-Infinity'``, ``'Infinity'``, ``'NaN'``, ``'null'``, ``'true'``, "
"``'false'``.  This can be used to raise an exception if invalid JSON numbers "
"are encountered."
msgstr ""

#: ../../../library/json.rst:326
msgid ""
"If *strict* is ``False`` (``True`` is the default), then control characters "
"will be allowed inside strings.  Control characters in this context are "
"those with character codes in the 0-31 range, including ``'\\t'`` (tab), "
"``'\\n'``, ``'\\r'`` and ``'\\0'``."
msgstr ""

#: ../../../library/json.rst:331
msgid ""
"If the data being deserialized is not a valid JSON document, a :exc:"
"`ValueError` will be raised."
msgstr ""

#: ../../../library/json.rst:336
msgid ""
"Return the Python representation of *s* (a :class:`str` instance containing "
"a JSON document)"
msgstr ""

#: ../../../library/json.rst:341
msgid ""
"Decode a JSON document from *s* (a :class:`str` beginning with a JSON "
"document) and return a 2-tuple of the Python representation and the index in "
"*s* where the document ended."
msgstr ""

#: ../../../library/json.rst:345
msgid ""
"This can be used to decode a JSON document from a string that may have "
"extraneous data at the end."
msgstr ""

#: ../../../library/json.rst:351
msgid "Extensible JSON encoder for Python data structures."
msgstr ""

#: ../../../library/json.rst:353
msgid "Supports the following objects and types by default:"
msgstr ""

#: ../../../library/json.rst:362
msgid "list, tuple"
msgstr ""

#: ../../../library/json.rst:366
msgid "int, float"
msgstr ""

#: ../../../library/json.rst:366
msgid "number"
msgstr ""

#: ../../../library/json.rst:375
msgid ""
"To extend this to recognize other objects, subclass and implement a :meth:"
"`default` method with another method that returns a serializable object for "
"``o`` if possible, otherwise it should call the superclass implementation "
"(to raise :exc:`TypeError`)."
msgstr ""

#: ../../../library/json.rst:380
msgid ""
"If *skipkeys* is ``False`` (the default), then it is a :exc:`TypeError` to "
"attempt encoding of keys that are not str, int, float or None.  If "
"*skipkeys* is ``True``, such items are simply skipped."
msgstr ""

#: ../../../library/json.rst:388
msgid ""
"If *check_circular* is ``True`` (the default), then lists, dicts, and custom "
"encoded objects will be checked for circular references during encoding to "
"prevent an infinite recursion (which would cause an :exc:`OverflowError`). "
"Otherwise, no such check takes place."
msgstr ""

#: ../../../library/json.rst:393
msgid ""
"If *allow_nan* is ``True`` (the default), then ``NaN``, ``Infinity``, and ``-"
"Infinity`` will be encoded as such.  This behavior is not JSON specification "
"compliant, but is consistent with most JavaScript based encoders and "
"decoders.  Otherwise, it will be a :exc:`ValueError` to encode such floats."
msgstr ""

#: ../../../library/json.rst:399
msgid ""
"If *sort_keys* is ``True`` (default ``False``), then the output of "
"dictionaries will be sorted by key; this is useful for regression tests to "
"ensure that JSON serializations can be compared on a day-to-day basis."
msgstr ""

#: ../../../library/json.rst:419
msgid ""
"If specified, *separators* should be an ``(item_separator, key_separator)`` "
"tuple.  The default is ``(', ', ': ')``.  To get the most compact JSON "
"representation, you should specify ``(',', ':')`` to eliminate whitespace."
msgstr ""

#: ../../../library/json.rst:423
msgid ""
"If specified, *default* is a function that gets called for objects that "
"can't otherwise be serialized.  It should return a JSON encodable version of "
"the object or raise a :exc:`TypeError`."
msgstr ""

#: ../../../library/json.rst:430
msgid ""
"Implement this method in a subclass such that it returns a serializable "
"object for *o*, or calls the base implementation (to raise a :exc:"
"`TypeError`)."
msgstr ""

#: ../../../library/json.rst:434
msgid ""
"For example, to support arbitrary iterators, you could implement default "
"like this::"
msgstr ""

#: ../../../library/json.rst:437
msgid ""
"def default(self, o):\n"
"   try:\n"
"       iterable = iter(o)\n"
"   except TypeError:\n"
"       pass\n"
"   else:\n"
"       return list(iterable)\n"
"   # Let the base class default method raise the TypeError\n"
"   return json.JSONEncoder.default(self, o)"
msgstr ""

#: ../../../library/json.rst:450
msgid ""
"Return a JSON string representation of a Python data structure, *o*.  For "
"example::"
msgstr ""

#: ../../../library/json.rst:453
msgid ""
">>> json.JSONEncoder().encode({\"foo\": [\"bar\", \"baz\"]})\n"
"'{\"foo\": [\"bar\", \"baz\"]}'"
msgstr ""

#: ../../../library/json.rst:459
msgid ""
"Encode the given object, *o*, and yield each string representation as "
"available.  For example::"
msgstr ""

#: ../../../library/json.rst:462
msgid ""
"for chunk in json.JSONEncoder().iterencode(bigobject):\n"
"    mysocket.write(chunk)"
msgstr ""

#: ../../../library/json.rst:467
msgid "Standard Compliance"
msgstr ""

#: ../../../library/json.rst:469
msgid ""
"The JSON format is specified by :rfc:`4627`.  This section details this "
"module's level of compliance with the RFC.  For simplicity, :class:"
"`JSONEncoder` and :class:`JSONDecoder` subclasses, and parameters other than "
"those explicitly mentioned, are not considered."
msgstr ""

#: ../../../library/json.rst:474
msgid ""
"This module does not comply with the RFC in a strict fashion, implementing "
"some extensions that are valid JavaScript but not valid JSON.  In particular:"
msgstr ""

#: ../../../library/json.rst:477
msgid "Top-level non-object, non-array values are accepted and output;"
msgstr ""

#: ../../../library/json.rst:478
msgid "Infinite and NaN number values are accepted and output;"
msgstr ""

#: ../../../library/json.rst:479
msgid ""
"Repeated names within an object are accepted, and only the value of the last "
"name-value pair is used."
msgstr ""

#: ../../../library/json.rst:482
msgid ""
"Since the RFC permits RFC-compliant parsers to accept input texts that are "
"not RFC-compliant, this module's deserializer is technically RFC-compliant "
"under default settings."
msgstr ""

#: ../../../library/json.rst:487
msgid "Character Encodings"
msgstr ""

#: ../../../library/json.rst:489
msgid ""
"The RFC recommends that JSON be represented using either UTF-8, UTF-16, or "
"UTF-32, with UTF-8 being the default."
msgstr ""

#: ../../../library/json.rst:492
msgid ""
"As permitted, though not required, by the RFC, this module's serializer sets "
"*ensure_ascii=True* by default, thus escaping the output so that the "
"resulting strings only contain ASCII characters."
msgstr ""

#: ../../../library/json.rst:496
msgid ""
"Other than the *ensure_ascii* parameter, this module is defined strictly in "
"terms of conversion between Python objects and :class:`Unicode strings "
"<str>`, and thus does not otherwise address the issue of character encodings."
msgstr ""

#: ../../../library/json.rst:503
msgid "Top-level Non-Object, Non-Array Values"
msgstr ""

#: ../../../library/json.rst:505
msgid ""
"The RFC specifies that the top-level value of a JSON text must be either a "
"JSON object or array (Python :class:`dict` or :class:`list`).  This module's "
"deserializer also accepts input texts consisting solely of a JSON null, "
"boolean, number, or string value::"
msgstr ""

#: ../../../library/json.rst:510
msgid ""
">>> just_a_json_string = '\"spam and eggs\"'  # Not by itself a valid JSON "
"text\n"
">>> json.loads(just_a_json_string)\n"
"'spam and eggs'"
msgstr ""

#: ../../../library/json.rst:514
msgid ""
"This module itself does not include a way to request that such input texts "
"be regarded as illegal.  Likewise, this module's serializer also accepts "
"single Python :data:`None`, :class:`bool`, numeric, and :class:`str` values "
"as input and will generate output texts consisting solely of a top-level "
"JSON null, boolean, number, or string value without raising an exception::"
msgstr ""

#: ../../../library/json.rst:520
msgid ""
">>> neither_a_list_nor_a_dict = \"spam and eggs\"\n"
">>> json.dumps(neither_a_list_nor_a_dict)  # The result is not a valid JSON "
"text\n"
"'\"spam and eggs\"'"
msgstr ""

#: ../../../library/json.rst:524
msgid ""
"This module's serializer does not itself include a way to enforce the "
"aforementioned constraint."
msgstr ""

#: ../../../library/json.rst:529
msgid "Infinite and NaN Number Values"
msgstr ""

#: ../../../library/json.rst:531
msgid ""
"The RFC does not permit the representation of infinite or NaN number values. "
"Despite that, by default, this module accepts and outputs ``Infinity``, ``-"
"Infinity``, and ``NaN`` as if they were valid JSON number literal values::"
msgstr ""

#: ../../../library/json.rst:535
msgid ""
">>> # Neither of these calls raises an exception, but the results are not "
"valid JSON\n"
">>> json.dumps(float('-inf'))\n"
"'-Infinity'\n"
">>> json.dumps(float('nan'))\n"
"'NaN'\n"
">>> # Same when deserializing\n"
">>> json.loads('-Infinity')\n"
"-inf\n"
">>> json.loads('NaN')\n"
"nan"
msgstr ""

#: ../../../library/json.rst:546
msgid ""
"In the serializer, the *allow_nan* parameter can be used to alter this "
"behavior.  In the deserializer, the *parse_constant* parameter can be used "
"to alter this behavior."
msgstr ""

#: ../../../library/json.rst:552
msgid "Repeated Names Within an Object"
msgstr ""

#: ../../../library/json.rst:554
msgid ""
"The RFC specifies that the names within a JSON object should be unique, but "
"does not specify how repeated names in JSON objects should be handled.  By "
"default, this module does not raise an exception; instead, it ignores all "
"but the last name-value pair for a given name::"
msgstr ""

#: ../../../library/json.rst:559
msgid ""
">>> weird_json = '{\"x\": 1, \"x\": 2, \"x\": 3}'\n"
">>> json.loads(weird_json)\n"
"{'x': 3}"
msgstr ""

#: ../../../library/json.rst:563
msgid "The *object_pairs_hook* parameter can be used to alter this behavior."
msgstr ""

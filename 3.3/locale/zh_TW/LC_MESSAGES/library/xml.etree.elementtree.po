# SOME DESCRIPTIVE TITLE.
# Copyright (C) 1990-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.3\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-10 15:08+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../library/xml.etree.elementtree.rst:2
msgid ":mod:`xml.etree.ElementTree` --- The ElementTree XML API"
msgstr ""

#: ../../../library/xml.etree.elementtree.rst:8
msgid ""
"The :mod:`xml.etree.ElementTree` module implements a simple and efficient "
"API for parsing and creating XML data."
msgstr ""

#: ../../../library/xml.etree.elementtree.rst:11
msgid ""
"This module will use a fast implementation whenever available. The :mod:`xml."
"etree.cElementTree` module is deprecated."
msgstr ""

#: ../../../library/xml.etree.elementtree.rst:18
msgid ""
"The :mod:`xml.etree.ElementTree` module is not secure against maliciously "
"constructed data.  If you need to parse untrusted or unauthenticated data "
"see :ref:`xml-vulnerabilities`."
msgstr ""

#: ../../../library/xml.etree.elementtree.rst:23
msgid "Tutorial"
msgstr ""

#: ../../../library/xml.etree.elementtree.rst:25
msgid ""
"This is a short tutorial for using :mod:`xml.etree.ElementTree` (``ET`` in "
"short).  The goal is to demonstrate some of the building blocks and basic "
"concepts of the module."
msgstr ""

#: ../../../library/xml.etree.elementtree.rst:30
msgid "XML tree and elements"
msgstr ""

#: ../../../library/xml.etree.elementtree.rst:32
msgid ""
"XML is an inherently hierarchical data format, and the most natural way to "
"represent it is with a tree.  ``ET`` has two classes for this purpose - :"
"class:`ElementTree` represents the whole XML document as a tree, and :class:"
"`Element` represents a single node in this tree.  Interactions with the "
"whole document (reading and writing to/from files) are usually done on the :"
"class:`ElementTree` level.  Interactions with a single XML element and its "
"sub-elements are done on the :class:`Element` level."
msgstr ""

#: ../../../library/xml.etree.elementtree.rst:43
msgid "Parsing XML"
msgstr ""

#: ../../../library/xml.etree.elementtree.rst:45
msgid ""
"We'll be using the following XML document as the sample data for this "
"section:"
msgstr ""

#: ../../../library/xml.etree.elementtree.rst:47
msgid ""
"<?xml version=\"1.0\"?>\n"
"<data>\n"
"    <country name=\"Liechtenstein\">\n"
"        <rank>1</rank>\n"
"        <year>2008</year>\n"
"        <gdppc>141100</gdppc>\n"
"        <neighbor name=\"Austria\" direction=\"E\"/>\n"
"        <neighbor name=\"Switzerland\" direction=\"W\"/>\n"
"    </country>\n"
"    <country name=\"Singapore\">\n"
"        <rank>4</rank>\n"
"        <year>2011</year>\n"
"        <gdppc>59900</gdppc>\n"
"        <neighbor name=\"Malaysia\" direction=\"N\"/>\n"
"    </country>\n"
"    <country name=\"Panama\">\n"
"        <rank>68</rank>\n"
"        <year>2011</year>\n"
"        <gdppc>13600</gdppc>\n"
"        <neighbor name=\"Costa Rica\" direction=\"W\"/>\n"
"        <neighbor name=\"Colombia\" direction=\"E\"/>\n"
"    </country>\n"
"</data>"
msgstr ""

#: ../../../library/xml.etree.elementtree.rst:73
msgid "We can import this data by reading from a file::"
msgstr ""

#: ../../../library/xml.etree.elementtree.rst:75
msgid ""
"import xml.etree.ElementTree as ET\n"
"tree = ET.parse('country_data.xml')\n"
"root = tree.getroot()"
msgstr ""

#: ../../../library/xml.etree.elementtree.rst:79
msgid "Or directly from a string::"
msgstr ""

#: ../../../library/xml.etree.elementtree.rst:81
msgid "root = ET.fromstring(country_data_as_string)"
msgstr ""

#: ../../../library/xml.etree.elementtree.rst:83
msgid ""
":func:`fromstring` parses XML from a string directly into an :class:"
"`Element`, which is the root element of the parsed tree.  Other parsing "
"functions may create an :class:`ElementTree`.  Check the documentation to be "
"sure."
msgstr ""

#: ../../../library/xml.etree.elementtree.rst:87
msgid ""
"As an :class:`Element`, ``root`` has a tag and a dictionary of attributes::"
msgstr ""

#: ../../../library/xml.etree.elementtree.rst:89
msgid ""
">>> root.tag\n"
"'data'\n"
">>> root.attrib\n"
"{}"
msgstr ""

#: ../../../library/xml.etree.elementtree.rst:94
msgid "It also has children nodes over which we can iterate::"
msgstr ""

#: ../../../library/xml.etree.elementtree.rst:96
msgid ""
">>> for child in root:\n"
"...   print(child.tag, child.attrib)\n"
"...\n"
"country {'name': 'Liechtenstein'}\n"
"country {'name': 'Singapore'}\n"
"country {'name': 'Panama'}"
msgstr ""

#: ../../../library/xml.etree.elementtree.rst:103
msgid "Children are nested, and we can access specific child nodes by index::"
msgstr ""

#: ../../../library/xml.etree.elementtree.rst:105
msgid ""
">>> root[0][1].text\n"
"'2008'"
msgstr ""

#: ../../../library/xml.etree.elementtree.rst:109
msgid "Finding interesting elements"
msgstr ""

#: ../../../library/xml.etree.elementtree.rst:111
msgid ""
":class:`Element` has some useful methods that help iterate recursively over "
"all the sub-tree below it (its children, their children, and so on).  For "
"example, :meth:`Element.iter`::"
msgstr ""

#: ../../../library/xml.etree.elementtree.rst:115
msgid ""
">>> for neighbor in root.iter('neighbor'):\n"
"...   print(neighbor.attrib)\n"
"...\n"
"{'name': 'Austria', 'direction': 'E'}\n"
"{'name': 'Switzerland', 'direction': 'W'}\n"
"{'name': 'Malaysia', 'direction': 'N'}\n"
"{'name': 'Costa Rica', 'direction': 'W'}\n"
"{'name': 'Colombia', 'direction': 'E'}"
msgstr ""

#: ../../../library/xml.etree.elementtree.rst:124
msgid ""
":meth:`Element.findall` finds only elements with a tag which are direct "
"children of the current element.  :meth:`Element.find` finds the *first* "
"child with a particular tag, and :attr:`Element.text` accesses the element's "
"text content.  :meth:`Element.get` accesses the element's attributes::"
msgstr ""

#: ../../../library/xml.etree.elementtree.rst:129
msgid ""
">>> for country in root.findall('country'):\n"
"...   rank = country.find('rank').text\n"
"...   name = country.get('name')\n"
"...   print(name, rank)\n"
"...\n"
"Liechtenstein 1\n"
"Singapore 4\n"
"Panama 68"
msgstr ""

#: ../../../library/xml.etree.elementtree.rst:138
msgid ""
"More sophisticated specification of which elements to look for is possible "
"by using :ref:`XPath <elementtree-xpath>`."
msgstr ""

#: ../../../library/xml.etree.elementtree.rst:142
msgid "Modifying an XML File"
msgstr ""

#: ../../../library/xml.etree.elementtree.rst:144
msgid ""
":class:`ElementTree` provides a simple way to build XML documents and write "
"them to files. The :meth:`ElementTree.write` method serves this purpose."
msgstr ""

#: ../../../library/xml.etree.elementtree.rst:147
msgid ""
"Once created, an :class:`Element` object may be manipulated by directly "
"changing its fields (such as :attr:`Element.text`), adding and modifying "
"attributes (:meth:`Element.set` method), as well as adding new children (for "
"example with :meth:`Element.append`)."
msgstr ""

#: ../../../library/xml.etree.elementtree.rst:152
msgid ""
"Let's say we want to add one to each country's rank, and add an ``updated`` "
"attribute to the rank element::"
msgstr ""

#: ../../../library/xml.etree.elementtree.rst:155
msgid ""
">>> for rank in root.iter('rank'):\n"
"...   new_rank = int(rank.text) + 1\n"
"...   rank.text = str(new_rank)\n"
"...   rank.set('updated', 'yes')\n"
"...\n"
">>> tree.write('output.xml')"
msgstr ""

#: ../../../library/xml.etree.elementtree.rst:162
#: ../../../library/xml.etree.elementtree.rst:200
msgid "Our XML now looks like this:"
msgstr ""

#: ../../../library/xml.etree.elementtree.rst:164
msgid ""
"<?xml version=\"1.0\"?>\n"
"<data>\n"
"    <country name=\"Liechtenstein\">\n"
"        <rank updated=\"yes\">2</rank>\n"
"        <year>2008</year>\n"
"        <gdppc>141100</gdppc>\n"
"        <neighbor name=\"Austria\" direction=\"E\"/>\n"
"        <neighbor name=\"Switzerland\" direction=\"W\"/>\n"
"    </country>\n"
"    <country name=\"Singapore\">\n"
"        <rank updated=\"yes\">5</rank>\n"
"        <year>2011</year>\n"
"        <gdppc>59900</gdppc>\n"
"        <neighbor name=\"Malaysia\" direction=\"N\"/>\n"
"    </country>\n"
"    <country name=\"Panama\">\n"
"        <rank updated=\"yes\">69</rank>\n"
"        <year>2011</year>\n"
"        <gdppc>13600</gdppc>\n"
"        <neighbor name=\"Costa Rica\" direction=\"W\"/>\n"
"        <neighbor name=\"Colombia\" direction=\"E\"/>\n"
"    </country>\n"
"</data>"
msgstr ""

#: ../../../library/xml.etree.elementtree.rst:190
msgid ""
"We can remove elements using :meth:`Element.remove`.  Let's say we want to "
"remove all countries with a rank higher than 50::"
msgstr ""

#: ../../../library/xml.etree.elementtree.rst:193
msgid ""
">>> for country in root.findall('country'):\n"
"...   rank = int(country.find('rank').text)\n"
"...   if rank > 50:\n"
"...     root.remove(country)\n"
"...\n"
">>> tree.write('output.xml')"
msgstr ""

#: ../../../library/xml.etree.elementtree.rst:202
msgid ""
"<?xml version=\"1.0\"?>\n"
"<data>\n"
"    <country name=\"Liechtenstein\">\n"
"        <rank updated=\"yes\">2</rank>\n"
"        <year>2008</year>\n"
"        <gdppc>141100</gdppc>\n"
"        <neighbor name=\"Austria\" direction=\"E\"/>\n"
"        <neighbor name=\"Switzerland\" direction=\"W\"/>\n"
"    </country>\n"
"    <country name=\"Singapore\">\n"
"        <rank updated=\"yes\">5</rank>\n"
"        <year>2011</year>\n"
"        <gdppc>59900</gdppc>\n"
"        <neighbor name=\"Malaysia\" direction=\"N\"/>\n"
"    </country>\n"
"</data>"
msgstr ""

#: ../../../library/xml.etree.elementtree.rst:222
msgid "Building XML documents"
msgstr ""

#: ../../../library/xml.etree.elementtree.rst:224
msgid ""
"The :func:`SubElement` function also provides a convenient way to create new "
"sub-elements for a given element::"
msgstr ""

#: ../../../library/xml.etree.elementtree.rst:227
msgid ""
">>> a = ET.Element('a')\n"
">>> b = ET.SubElement(a, 'b')\n"
">>> c = ET.SubElement(a, 'c')\n"
">>> d = ET.SubElement(c, 'd')\n"
">>> ET.dump(a)\n"
"<a><b /><c><d /></c></a>"
msgstr ""

#: ../../../library/xml.etree.elementtree.rst:235
msgid "Additional resources"
msgstr ""

#: ../../../library/xml.etree.elementtree.rst:237
msgid ""
"See http://effbot.org/zone/element-index.htm for tutorials and links to "
"other docs."
msgstr ""

#: ../../../library/xml.etree.elementtree.rst:244
msgid "XPath support"
msgstr ""

#: ../../../library/xml.etree.elementtree.rst:246
msgid ""
"This module provides limited support for `XPath expressions <http://www.w3."
"org/TR/xpath>`_ for locating elements in a tree.  The goal is to support a "
"small subset of the abbreviated syntax; a full XPath engine is outside the "
"scope of the module."
msgstr ""

#: ../../../library/xml.etree.elementtree.rst:252
msgid "Example"
msgstr ""

#: ../../../library/xml.etree.elementtree.rst:254
msgid ""
"Here's an example that demonstrates some of the XPath capabilities of the "
"module.  We'll be using the ``countrydata`` XML document from the :ref:"
"`Parsing XML <elementtree-parsing-xml>` section::"
msgstr ""

#: ../../../library/xml.etree.elementtree.rst:258
msgid ""
"import xml.etree.ElementTree as ET\n"
"\n"
"root = ET.fromstring(countrydata)\n"
"\n"
"# Top-level elements\n"
"root.findall(\".\")\n"
"\n"
"# All 'neighbor' grand-children of 'country' children of the top-level\n"
"# elements\n"
"root.findall(\"./country/neighbor\")\n"
"\n"
"# Nodes with name='Singapore' that have a 'year' child\n"
"root.findall(\".//year/..[@name='Singapore']\")\n"
"\n"
"# 'year' nodes that are children of nodes with name='Singapore'\n"
"root.findall(\".//*[@name='Singapore']/year\")\n"
"\n"
"# All 'neighbor' nodes that are the second child of their parent\n"
"root.findall(\".//neighbor[2]\")"
msgstr ""

#: ../../../library/xml.etree.elementtree.rst:279
msgid "Supported XPath syntax"
msgstr ""

#: ../../../library/xml.etree.elementtree.rst:284
msgid "Syntax"
msgstr ""

#: ../../../library/xml.etree.elementtree.rst:284
msgid "Meaning"
msgstr ""

#: ../../../library/xml.etree.elementtree.rst:286
msgid "``tag``"
msgstr ""

#: ../../../library/xml.etree.elementtree.rst:286
msgid ""
"Selects all child elements with the given tag. For example, ``spam`` selects "
"all child elements named ``spam``, ``spam/egg`` selects all grandchildren "
"named ``egg`` in all children named ``spam``."
msgstr ""

#: ../../../library/xml.etree.elementtree.rst:292
msgid "``*``"
msgstr ""

#: ../../../library/xml.etree.elementtree.rst:292
msgid ""
"Selects all child elements.  For example, ``*/egg`` selects all "
"grandchildren named ``egg``."
msgstr ""

#: ../../../library/xml.etree.elementtree.rst:295
msgid "``.``"
msgstr ""

#: ../../../library/xml.etree.elementtree.rst:295
msgid ""
"Selects the current node.  This is mostly useful at the beginning of the "
"path, to indicate that it's a relative path."
msgstr ""

#: ../../../library/xml.etree.elementtree.rst:299
msgid "``//``"
msgstr ""

#: ../../../library/xml.etree.elementtree.rst:299
msgid ""
"Selects all subelements, on all levels beneath the current  element.  For "
"example, ``.//egg`` selects all ``egg`` elements in the entire tree."
msgstr ""

#: ../../../library/xml.etree.elementtree.rst:303
msgid "``..``"
msgstr ""

#: ../../../library/xml.etree.elementtree.rst:303
msgid ""
"Selects the parent element.  Returns ``None`` if the path attempts to reach "
"the ancestors of the start element (the element ``find`` was called on)."
msgstr ""

#: ../../../library/xml.etree.elementtree.rst:307
msgid "``[@attrib]``"
msgstr ""

#: ../../../library/xml.etree.elementtree.rst:307
msgid "Selects all elements that have the given attribute."
msgstr ""

#: ../../../library/xml.etree.elementtree.rst:309
msgid "``[@attrib='value']``"
msgstr ""

#: ../../../library/xml.etree.elementtree.rst:309
msgid ""
"Selects all elements for which the given attribute has the given value.  The "
"value cannot contain quotes."
msgstr ""

#: ../../../library/xml.etree.elementtree.rst:313
msgid "``[tag]``"
msgstr ""

#: ../../../library/xml.etree.elementtree.rst:313
msgid ""
"Selects all elements that have a child named ``tag``.  Only immediate "
"children are supported."
msgstr ""

#: ../../../library/xml.etree.elementtree.rst:316
msgid "``[position]``"
msgstr ""

#: ../../../library/xml.etree.elementtree.rst:316
msgid ""
"Selects all elements that are located at the given position.  The position "
"can be either an integer (1 is the first position), the expression "
"``last()`` (for the last position), or a position relative to the last "
"position (e.g. ``last()-1``)."
msgstr ""

#: ../../../library/xml.etree.elementtree.rst:323
msgid ""
"Predicates (expressions within square brackets) must be preceded by a tag "
"name, an asterisk, or another predicate.  ``position`` predicates must be "
"preceded by a tag name."
msgstr ""

#: ../../../library/xml.etree.elementtree.rst:328
msgid "Reference"
msgstr ""

#: ../../../library/xml.etree.elementtree.rst:333
msgid "Functions"
msgstr ""

#: ../../../library/xml.etree.elementtree.rst:338
msgid ""
"Comment element factory.  This factory function creates a special element "
"that will be serialized as an XML comment by the standard serializer.  The "
"comment string can be either a bytestring or a Unicode string.  *text* is a "
"string containing the comment string.  Returns an element instance "
"representing a comment."
msgstr ""

#: ../../../library/xml.etree.elementtree.rst:347
msgid ""
"Writes an element tree or element structure to sys.stdout.  This function "
"should be used for debugging only."
msgstr ""

#: ../../../library/xml.etree.elementtree.rst:350
msgid ""
"The exact output format is implementation dependent.  In this version, it's "
"written as an ordinary XML file."
msgstr ""

#: ../../../library/xml.etree.elementtree.rst:353
msgid "*elem* is an element tree or an individual element."
msgstr ""

#: ../../../library/xml.etree.elementtree.rst:358
msgid ""
"Parses an XML section from a string constant.  Same as :func:`XML`.  *text* "
"is a string containing XML data.  Returns an :class:`Element` instance."
msgstr ""

#: ../../../library/xml.etree.elementtree.rst:364
msgid ""
"Parses an XML document from a sequence of string fragments.  *sequence* is a "
"list or other sequence containing XML data fragments.  *parser* is an "
"optional parser instance.  If not given, the standard :class:`XMLParser` "
"parser is used.  Returns an :class:`Element` instance."
msgstr ""

#: ../../../library/xml.etree.elementtree.rst:374
msgid ""
"Checks if an object appears to be a valid element object.  *element* is an "
"element instance.  Returns a true value if this is an element object."
msgstr ""

#: ../../../library/xml.etree.elementtree.rst:380
msgid ""
"Parses an XML section into an element tree incrementally, and reports what's "
"going on to the user.  *source* is a filename or :term:`file object` "
"containing XML data.  *events* is a tuple of events to report back.  The "
"supported events are the strings ``\"start\"``, ``\"end\"``, ``\"start-"
"ns\"`` and ``\"end-ns\"`` (the \"ns\" events are used to get detailed "
"namespace information).  If *events* is omitted, only ``\"end\"`` events are "
"reported. *parser* is an optional parser instance.  If not given, the "
"standard :class:`XMLParser` parser is used.  *parser* can only use the "
"default :class:`TreeBuilder` as a target.  Returns an :term:`iterator` "
"providing ``(event, elem)`` pairs."
msgstr ""

#: ../../../library/xml.etree.elementtree.rst:393
msgid ""
":func:`iterparse` only guarantees that it has seen the \">\" character of a "
"starting tag when it emits a \"start\" event, so the attributes are defined, "
"but the contents of the text and tail attributes are undefined at that "
"point.  The same applies to the element children; they may or may not be "
"present."
msgstr ""

#: ../../../library/xml.etree.elementtree.rst:399
msgid "If you need a fully populated element, look for \"end\" events instead."
msgstr ""

#: ../../../library/xml.etree.elementtree.rst:404
msgid ""
"Parses an XML section into an element tree.  *source* is a filename or file "
"object containing XML data.  *parser* is an optional parser instance.  If "
"not given, the standard :class:`XMLParser` parser is used.  Returns an :"
"class:`ElementTree` instance."
msgstr ""

#: ../../../library/xml.etree.elementtree.rst:412
msgid ""
"PI element factory.  This factory function creates a special element that "
"will be serialized as an XML processing instruction.  *target* is a string "
"containing the PI target.  *text* is a string containing the PI contents, if "
"given.  Returns an element instance, representing a processing instruction."
msgstr ""

#: ../../../library/xml.etree.elementtree.rst:420
msgid ""
"Registers a namespace prefix.  The registry is global, and any existing "
"mapping for either the given prefix or the namespace URI will be removed. "
"*prefix* is a namespace prefix.  *uri* is a namespace uri.  Tags and "
"attributes in this namespace will be serialized with the given prefix, if at "
"all possible."
msgstr ""

#: ../../../library/xml.etree.elementtree.rst:431
msgid ""
"Subelement factory.  This function creates an element instance, and appends "
"it to an existing element."
msgstr ""

#: ../../../library/xml.etree.elementtree.rst:434
msgid ""
"The element name, attribute names, and attribute values can be either "
"bytestrings or Unicode strings.  *parent* is the parent element.  *tag* is "
"the subelement name.  *attrib* is an optional dictionary, containing element "
"attributes.  *extra* contains additional attributes, given as keyword "
"arguments.  Returns an element instance."
msgstr ""

#: ../../../library/xml.etree.elementtree.rst:443
msgid ""
"Generates a string representation of an XML element, including all "
"subelements.  *element* is an :class:`Element` instance.  *encoding* [1]_ is "
"the output encoding (default is US-ASCII).  Use ``encoding=\"unicode\"`` to "
"generate a Unicode string (otherwise, a bytestring is generated).  *method* "
"is either ``\"xml\"``, ``\"html\"`` or ``\"text\"`` (default is "
"``\"xml\"``). Returns an (optionally) encoded string containing the XML data."
msgstr ""

#: ../../../library/xml.etree.elementtree.rst:453
msgid ""
"Generates a string representation of an XML element, including all "
"subelements.  *element* is an :class:`Element` instance.  *encoding* [1]_ is "
"the output encoding (default is US-ASCII).  Use ``encoding=\"unicode\"`` to "
"generate a Unicode string (otherwise, a bytestring is generated).  *method* "
"is either ``\"xml\"``, ``\"html\"`` or ``\"text\"`` (default is "
"``\"xml\"``). Returns a list of (optionally) encoded strings containing the "
"XML data. It does not guarantee any specific sequence, except that ``b\"\"."
"join(tostringlist(element)) == tostring(element)``."
msgstr ""

#: ../../../library/xml.etree.elementtree.rst:467
msgid ""
"Parses an XML section from a string constant.  This function can be used to "
"embed \"XML literals\" in Python code.  *text* is a string containing XML "
"data.  *parser* is an optional parser instance.  If not given, the standard :"
"class:`XMLParser` parser is used.  Returns an :class:`Element` instance."
msgstr ""

#: ../../../library/xml.etree.elementtree.rst:475
msgid ""
"Parses an XML section from a string constant, and also returns a dictionary "
"which maps from element id:s to elements.  *text* is a string containing XML "
"data.  *parser* is an optional parser instance.  If not given, the standard :"
"class:`XMLParser` parser is used.  Returns a tuple containing an :class:"
"`Element` instance and a dictionary."
msgstr ""

#: ../../../library/xml.etree.elementtree.rst:485
msgid "Element Objects"
msgstr ""

#: ../../../library/xml.etree.elementtree.rst:489
msgid ""
"Element class.  This class defines the Element interface, and provides a "
"reference implementation of this interface."
msgstr ""

#: ../../../library/xml.etree.elementtree.rst:492
msgid ""
"The element name, attribute names, and attribute values can be either "
"bytestrings or Unicode strings.  *tag* is the element name.  *attrib* is an "
"optional dictionary, containing element attributes.  *extra* contains "
"additional attributes, given as keyword arguments."
msgstr ""

#: ../../../library/xml.etree.elementtree.rst:500
msgid ""
"A string identifying what kind of data this element represents (the element "
"type, in other words)."
msgstr ""

#: ../../../library/xml.etree.elementtree.rst:506
msgid ""
"The *text* attribute can be used to hold additional data associated with the "
"element.  As the name implies this attribute is usually a string but may be "
"any application-specific object.  If the element is created from an XML file "
"the attribute will contain any text found between the element tags."
msgstr ""

#: ../../../library/xml.etree.elementtree.rst:515
msgid ""
"The *tail* attribute can be used to hold additional data associated with the "
"element.  This attribute is usually a string but may be any application-"
"specific object.  If the element is created from an XML file the attribute "
"will contain any text found after the element's end tag and before the next "
"tag."
msgstr ""

#: ../../../library/xml.etree.elementtree.rst:524
msgid ""
"A dictionary containing the element's attributes.  Note that while the "
"*attrib* value is always a real mutable Python dictionary, an ElementTree "
"implementation may choose to use another internal representation, and create "
"the dictionary only if someone asks for it.  To take advantage of such "
"implementations, use the dictionary methods below whenever possible."
msgstr ""

#: ../../../library/xml.etree.elementtree.rst:530
msgid "The following dictionary-like methods work on the element attributes."
msgstr ""

#: ../../../library/xml.etree.elementtree.rst:535
msgid ""
"Resets an element.  This function removes all subelements, clears all "
"attributes, and sets the text and tail attributes to ``None``."
msgstr ""

#: ../../../library/xml.etree.elementtree.rst:541
msgid "Gets the element attribute named *key*."
msgstr ""

#: ../../../library/xml.etree.elementtree.rst:543
msgid ""
"Returns the attribute value, or *default* if the attribute was not found."
msgstr ""

#: ../../../library/xml.etree.elementtree.rst:548
msgid ""
"Returns the element attributes as a sequence of (name, value) pairs.  The "
"attributes are returned in an arbitrary order."
msgstr ""

#: ../../../library/xml.etree.elementtree.rst:554
msgid ""
"Returns the elements attribute names as a list.  The names are returned in "
"an arbitrary order."
msgstr ""

#: ../../../library/xml.etree.elementtree.rst:560
msgid "Set the attribute *key* on the element to *value*."
msgstr ""

#: ../../../library/xml.etree.elementtree.rst:562
msgid "The following methods work on the element's children (subelements)."
msgstr ""

#: ../../../library/xml.etree.elementtree.rst:567
msgid ""
"Adds the element *subelement* to the end of this element's internal list of "
"subelements.  Raises :exc:`TypeError` if *subelement* is not an :class:"
"`Element`."
msgstr ""

#: ../../../library/xml.etree.elementtree.rst:574
msgid ""
"Appends *subelements* from a sequence object with zero or more elements. "
"Raises :exc:`TypeError` if a subelement is not an :class:`Element`."
msgstr ""

#: ../../../library/xml.etree.elementtree.rst:582
msgid ""
"Finds the first subelement matching *match*.  *match* may be a tag name or "
"a :ref:`path <elementtree-xpath>`.  Returns an element instance or "
"``None``.  *namespaces* is an optional mapping from namespace prefix to full "
"name."
msgstr ""

#: ../../../library/xml.etree.elementtree.rst:590
msgid ""
"Finds all matching subelements, by tag name or :ref:`path <elementtree-"
"xpath>`.  Returns a list containing all matching elements in document "
"order.  *namespaces* is an optional mapping from namespace prefix to full "
"name."
msgstr ""

#: ../../../library/xml.etree.elementtree.rst:598
msgid ""
"Finds text for the first subelement matching *match*.  *match* may be a tag "
"name or a :ref:`path <elementtree-xpath>`.  Returns the text content of the "
"first matching element, or *default* if no element was found. Note that if "
"the matching element has no text content an empty string is returned. "
"*namespaces* is an optional mapping from namespace prefix to full name."
msgstr ""

#: ../../../library/xml.etree.elementtree.rst:608
msgid "Use ``list(elem)`` or iteration."
msgstr ""

#: ../../../library/xml.etree.elementtree.rst:614
msgid "Use method :meth:`Element.iter` instead."
msgstr ""

#: ../../../library/xml.etree.elementtree.rst:620
msgid ""
"Inserts *subelement* at the given position in this element.  Raises :exc:"
"`TypeError` if *subelement* is not an :class:`Element`."
msgstr ""

#: ../../../library/xml.etree.elementtree.rst:626
msgid ""
"Creates a tree :term:`iterator` with the current element as the root. The "
"iterator iterates over this element and all elements below it, in document "
"(depth first) order.  If *tag* is not ``None`` or ``'*'``, only elements "
"whose tag equals *tag* are returned from the iterator.  If the tree "
"structure is modified during iteration, the result is undefined."
msgstr ""

#: ../../../library/xml.etree.elementtree.rst:637
msgid ""
"Finds all matching subelements, by tag name or :ref:`path <elementtree-"
"xpath>`.  Returns an iterable yielding all matching elements in document "
"order. *namespaces* is an optional mapping from namespace prefix to full "
"name."
msgstr ""

#: ../../../library/xml.etree.elementtree.rst:648
msgid ""
"Creates a text iterator.  The iterator loops over this element and all "
"subelements, in document order, and returns all inner text."
msgstr ""

#: ../../../library/xml.etree.elementtree.rst:656
msgid ""
"Creates a new element object of the same type as this element.  Do not call "
"this method, use the :func:`SubElement` factory function instead."
msgstr ""

#: ../../../library/xml.etree.elementtree.rst:662
msgid ""
"Removes *subelement* from the element.  Unlike the find\\* methods this "
"method compares elements based on the instance identity, not on tag value or "
"contents."
msgstr ""

#: ../../../library/xml.etree.elementtree.rst:666
msgid ""
":class:`Element` objects also support the following sequence type methods "
"for working with subelements: :meth:`~object.__delitem__`, :meth:`~object."
"__getitem__`, :meth:`~object.__setitem__`, :meth:`~object.__len__`."
msgstr ""

#: ../../../library/xml.etree.elementtree.rst:671
msgid ""
"Caution: Elements with no subelements will test as ``False``.  This behavior "
"will change in future versions.  Use specific ``len(elem)`` or ``elem is "
"None`` test instead. ::"
msgstr ""

#: ../../../library/xml.etree.elementtree.rst:675
msgid ""
"element = root.find('foo')\n"
"\n"
"if not element:  # careful!\n"
"    print(\"element not found, or element has no subelements\")\n"
"\n"
"if element is None:\n"
"    print(\"element not found\")"
msgstr ""

#: ../../../library/xml.etree.elementtree.rst:687
msgid "ElementTree Objects"
msgstr ""

#: ../../../library/xml.etree.elementtree.rst:692
msgid ""
"ElementTree wrapper class.  This class represents an entire element "
"hierarchy, and adds some extra support for serialization to and from "
"standard XML."
msgstr ""

#: ../../../library/xml.etree.elementtree.rst:696
msgid ""
"*element* is the root element.  The tree is initialized with the contents of "
"the XML *file* if given."
msgstr ""

#: ../../../library/xml.etree.elementtree.rst:702
msgid ""
"Replaces the root element for this tree.  This discards the current contents "
"of the tree, and replaces it with the given element.  Use with care.  "
"*element* is an element instance."
msgstr ""

#: ../../../library/xml.etree.elementtree.rst:709
msgid "Same as :meth:`Element.find`, starting at the root of the tree."
msgstr ""

#: ../../../library/xml.etree.elementtree.rst:714
msgid "Same as :meth:`Element.findall`, starting at the root of the tree."
msgstr ""

#: ../../../library/xml.etree.elementtree.rst:719
msgid "Same as :meth:`Element.findtext`, starting at the root of the tree."
msgstr ""

#: ../../../library/xml.etree.elementtree.rst:724
msgid "Use method :meth:`ElementTree.iter` instead."
msgstr ""

#: ../../../library/xml.etree.elementtree.rst:730
msgid "Returns the root element for this tree."
msgstr ""

#: ../../../library/xml.etree.elementtree.rst:735
msgid ""
"Creates and returns a tree iterator for the root element.  The iterator "
"loops over all elements in this tree, in section order.  *tag* is the tag to "
"look for (default is to return all elements)"
msgstr ""

#: ../../../library/xml.etree.elementtree.rst:742
msgid "Same as :meth:`Element.iterfind`, starting at the root of the tree."
msgstr ""

#: ../../../library/xml.etree.elementtree.rst:749
msgid ""
"Loads an external XML section into this element tree.  *source* is a file "
"name or :term:`file object`.  *parser* is an optional parser instance. If "
"not given, the standard :class:`XMLParser` parser is used.  Returns the "
"section root element."
msgstr ""

#: ../../../library/xml.etree.elementtree.rst:758
msgid ""
"Writes the element tree to a file, as XML.  *file* is a file name, or a :"
"term:`file object` opened for writing.  *encoding* [1]_ is the output "
"encoding (default is US-ASCII). *xml_declaration* controls if an XML "
"declaration should be added to the file.  Use ``False`` for never, ``True`` "
"for always, ``None`` for only if not US-ASCII or UTF-8 or Unicode (default "
"is ``None``). *default_namespace* sets the default XML namespace (for "
"\"xmlns\"). *method* is either ``\"xml\"``, ``\"html\"`` or ``\"text\"`` "
"(default is ``\"xml\"``)."
msgstr ""

#: ../../../library/xml.etree.elementtree.rst:768
msgid ""
"The output is either a string (:class:`str`) or binary (:class:`bytes`). "
"This is controlled by the *encoding* argument.  If *encoding* is "
"``\"unicode\"``, the output is a string; otherwise, it's binary.  Note that "
"this may conflict with the type of *file* if it's an open :term:`file "
"object`; make sure you do not try to write a string to a binary stream and "
"vice versa."
msgstr ""

#: ../../../library/xml.etree.elementtree.rst:776
msgid "This is the XML file that is going to be manipulated::"
msgstr ""

#: ../../../library/xml.etree.elementtree.rst:778
msgid ""
"<html>\n"
"    <head>\n"
"        <title>Example page</title>\n"
"    </head>\n"
"    <body>\n"
"        <p>Moved to <a href=\"http://example.org/\">example.org</a>\n"
"        or <a href=\"http://example.com/\">example.com</a>.</p>\n"
"    </body>\n"
"</html>"
msgstr ""

#: ../../../library/xml.etree.elementtree.rst:788
msgid ""
"Example of changing the attribute \"target\" of every link in first "
"paragraph::"
msgstr ""

#: ../../../library/xml.etree.elementtree.rst:790
msgid ""
">>> from xml.etree.ElementTree import ElementTree\n"
">>> tree = ElementTree()\n"
">>> tree.parse(\"index.xhtml\")\n"
"<Element 'html' at 0xb77e6fac>\n"
">>> p = tree.find(\"body/p\")     # Finds first occurrence of tag p in body\n"
">>> p\n"
"<Element 'p' at 0xb77ec26c>\n"
">>> links = list(p.iter(\"a\"))   # Returns list of all links\n"
">>> links\n"
"[<Element 'a' at 0xb77ec2ac>, <Element 'a' at 0xb77ec1cc>]\n"
">>> for i in links:             # Iterates through all found links\n"
"...     i.attrib[\"target\"] = \"blank\"\n"
">>> tree.write(\"output.xhtml\")"
msgstr ""

#: ../../../library/xml.etree.elementtree.rst:807
msgid "QName Objects"
msgstr ""

#: ../../../library/xml.etree.elementtree.rst:812
msgid ""
"QName wrapper.  This can be used to wrap a QName attribute value, in order "
"to get proper namespace handling on output.  *text_or_uri* is a string "
"containing the QName value, in the form {uri}local, or, if the tag argument "
"is given, the URI part of a QName.  If *tag* is given, the first argument is "
"interpreted as an URI, and this argument is interpreted as a local name. :"
"class:`QName` instances are opaque."
msgstr ""

#: ../../../library/xml.etree.elementtree.rst:823
msgid "TreeBuilder Objects"
msgstr ""

#: ../../../library/xml.etree.elementtree.rst:828
msgid ""
"Generic element structure builder.  This builder converts a sequence of "
"start, data, and end method calls to a well-formed element structure.  You "
"can use this class to build an element structure using a custom XML parser, "
"or a parser for some other XML-like format.  *element_factory*, when given, "
"must be a callable accepting two positional arguments: a tag and a dict of "
"attributes.  It is expected to return a new element instance."
msgstr ""

#: ../../../library/xml.etree.elementtree.rst:837
msgid ""
"Flushes the builder buffers, and returns the toplevel document element.  "
"Returns an :class:`Element` instance."
msgstr ""

#: ../../../library/xml.etree.elementtree.rst:843
msgid ""
"Adds text to the current element.  *data* is a string.  This should be "
"either a bytestring, or a Unicode string."
msgstr ""

#: ../../../library/xml.etree.elementtree.rst:849
msgid ""
"Closes the current element.  *tag* is the element name.  Returns the closed "
"element."
msgstr ""

#: ../../../library/xml.etree.elementtree.rst:855
msgid ""
"Opens a new element.  *tag* is the element name.  *attrs* is a dictionary "
"containing element attributes.  Returns the opened element."
msgstr ""

#: ../../../library/xml.etree.elementtree.rst:859
msgid ""
"In addition, a custom :class:`TreeBuilder` object can provide the following "
"method:"
msgstr ""

#: ../../../library/xml.etree.elementtree.rst:864
msgid ""
"Handles a doctype declaration.  *name* is the doctype name.  *pubid* is the "
"public identifier.  *system* is the system identifier.  This method does not "
"exist on the default :class:`TreeBuilder` class."
msgstr ""

#: ../../../library/xml.etree.elementtree.rst:874
msgid "XMLParser Objects"
msgstr ""

#: ../../../library/xml.etree.elementtree.rst:879
msgid ""
":class:`Element` structure builder for XML source data, based on the expat "
"parser.  *html* are predefined HTML entities.  This flag is not supported by "
"the current implementation.  *target* is the target object.  If omitted, the "
"builder uses an instance of the standard :class:`TreeBuilder` class. "
"*encoding* [1]_ is optional.  If given, the value overrides the encoding "
"specified in the XML file."
msgstr ""

#: ../../../library/xml.etree.elementtree.rst:889
msgid ""
"Finishes feeding data to the parser.  Returns the result of calling the "
"``close()`` method of the *target* passed during construction; by default, "
"this is the toplevel document element."
msgstr ""

#: ../../../library/xml.etree.elementtree.rst:896
msgid ""
"Define the :meth:`TreeBuilder.doctype` method on a custom TreeBuilder target."
msgstr ""

#: ../../../library/xml.etree.elementtree.rst:903
msgid "Feeds data to the parser.  *data* is encoded data."
msgstr ""

#: ../../../library/xml.etree.elementtree.rst:905
msgid ""
":meth:`XMLParser.feed` calls *target*\\'s ``start()`` method for each "
"opening tag, its ``end()`` method for each closing tag, and data is "
"processed by method ``data()``.  :meth:`XMLParser.close` calls *target*\\'s "
"method ``close()``. :class:`XMLParser` can be used not only for building a "
"tree structure. This is an example of counting the maximum depth of an XML "
"file::"
msgstr ""

#: ../../../library/xml.etree.elementtree.rst:912
msgid ""
">>> from xml.etree.ElementTree import XMLParser\n"
">>> class MaxDepth:                     # The target object of the parser\n"
"...     maxDepth = 0\n"
"...     depth = 0\n"
"...     def start(self, tag, attrib):   # Called for each opening tag.\n"
"...         self.depth += 1\n"
"...         if self.depth > self.maxDepth:\n"
"...             self.maxDepth = self.depth\n"
"...     def end(self, tag):             # Called for each closing tag.\n"
"...         self.depth -= 1\n"
"...     def data(self, data):\n"
"...         pass            # We do not need to do anything with data.\n"
"...     def close(self):    # Called when all data has been parsed.\n"
"...         return self.maxDepth\n"
"...\n"
">>> target = MaxDepth()\n"
">>> parser = XMLParser(target=target)\n"
">>> exampleXml = \"\"\"\n"
"... <a>\n"
"...   <b>\n"
"...   </b>\n"
"...   <b>\n"
"...     <c>\n"
"...       <d>\n"
"...       </d>\n"
"...     </c>\n"
"...   </b>\n"
"... </a>\"\"\"\n"
">>> parser.feed(exampleXml)\n"
">>> parser.close()\n"
"4"
msgstr ""

#: ../../../library/xml.etree.elementtree.rst:945
msgid "Exceptions"
msgstr ""

#: ../../../library/xml.etree.elementtree.rst:949
msgid ""
"XML parse error, raised by the various parsing methods in this module when "
"parsing fails.  The string representation of an instance of this exception "
"will contain a user-friendly error message.  In addition, it will have the "
"following attributes available:"
msgstr ""

#: ../../../library/xml.etree.elementtree.rst:956
msgid ""
"A numeric error code from the expat parser. See the documentation of :mod:"
"`xml.parsers.expat` for the list of error codes and their meanings."
msgstr ""

#: ../../../library/xml.etree.elementtree.rst:961
msgid ""
"A tuple of *line*, *column* numbers, specifying where the error occurred."
msgstr ""

#: ../../../library/xml.etree.elementtree.rst:964
msgid "Footnotes"
msgstr ""

#: ../../../library/xml.etree.elementtree.rst:965
msgid ""
"The encoding string included in XML output should conform to the appropriate "
"standards.  For example, \"UTF-8\" is valid, but \"UTF8\" is not.  See "
"http://www.w3.org/TR/2006/REC-xml11-20060816/#NT-EncodingDecl and http://www."
"iana.org/assignments/character-sets."
msgstr ""

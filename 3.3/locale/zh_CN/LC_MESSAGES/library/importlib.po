# SOME DESCRIPTIVE TITLE.
# Copyright (C) 1990-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.3\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-10 15:08+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../library/importlib.rst:2
msgid ":mod:`importlib` -- The implementation of :keyword:`import`"
msgstr ""

#: ../../../library/importlib.rst:14
msgid "Introduction"
msgstr ""

#: ../../../library/importlib.rst:16
msgid ""
"The purpose of the :mod:`importlib` package is two-fold. One is to provide "
"the implementation of the :keyword:`import` statement (and thus, by "
"extension, the :func:`__import__` function) in Python source code. This "
"provides an implementation of :keyword:`import` which is portable to any "
"Python interpreter. This also provides an implementation which is easier to "
"comprehend than one implemented in a programming language other than Python."
msgstr ""

#: ../../../library/importlib.rst:23
msgid ""
"Two, the components to implement :keyword:`import` are exposed in this "
"package, making it easier for users to create their own custom objects "
"(known generically as an :term:`importer`) to participate in the import "
"process."
msgstr ""

#: ../../../library/importlib.rst:30
msgid ":ref:`import`"
msgstr ""

#: ../../../library/importlib.rst:30
msgid "The language reference for the :keyword:`import` statement."
msgstr ""

#: ../../../library/importlib.rst:35
msgid ""
"`Packages specification <http://www.python.org/doc/essays/packages.html>`__"
msgstr ""

#: ../../../library/importlib.rst:33
msgid ""
"Original specification of packages. Some semantics have changed since the "
"writing of this document (e.g. redirecting based on ``None`` in :data:`sys."
"modules`)."
msgstr ""

#: ../../../library/importlib.rst:38
msgid "The :func:`.__import__` function"
msgstr ""

#: ../../../library/importlib.rst:38
msgid "The :keyword:`import` statement is syntactic sugar for this function."
msgstr ""

#: ../../../library/importlib.rst:41
msgid ":pep:`235`"
msgstr ""

#: ../../../library/importlib.rst:41
msgid "Import on Case-Insensitive Platforms"
msgstr ""

#: ../../../library/importlib.rst:44
msgid ":pep:`263`"
msgstr ""

#: ../../../library/importlib.rst:44
msgid "Defining Python Source Code Encodings"
msgstr ""

#: ../../../library/importlib.rst:47
msgid ":pep:`302`"
msgstr ""

#: ../../../library/importlib.rst:47
msgid "New Import Hooks"
msgstr ""

#: ../../../library/importlib.rst:50
msgid ":pep:`328`"
msgstr ""

#: ../../../library/importlib.rst:50
msgid "Imports: Multi-Line and Absolute/Relative"
msgstr ""

#: ../../../library/importlib.rst:53
msgid ":pep:`366`"
msgstr ""

#: ../../../library/importlib.rst:53
msgid "Main module explicit relative imports"
msgstr ""

#: ../../../library/importlib.rst:56
msgid ":pep:`451`"
msgstr ""

#: ../../../library/importlib.rst:56
msgid "A ModuleSpec Type for the Import System"
msgstr ""

#: ../../../library/importlib.rst:59
msgid ":pep:`3120`"
msgstr ""

#: ../../../library/importlib.rst:59
msgid "Using UTF-8 as the Default Source Encoding"
msgstr ""

#: ../../../library/importlib.rst:61
msgid ":pep:`3147`"
msgstr ""

#: ../../../library/importlib.rst:62
msgid "PYC Repository Directories"
msgstr ""

#: ../../../library/importlib.rst:66
msgid "Functions"
msgstr ""

#: ../../../library/importlib.rst:70
msgid "An implementation of the built-in :func:`__import__` function."
msgstr ""

#: ../../../library/importlib.rst:74
msgid ""
"Import a module. The *name* argument specifies what module to import in "
"absolute or relative terms (e.g. either ``pkg.mod`` or ``..mod``). If the "
"name is specified in relative terms, then the *package* argument must be set "
"to the name of the package which is to act as the anchor for resolving the "
"package name (e.g. ``import_module('..mod', 'pkg.subpkg')`` will import "
"``pkg.mod``)."
msgstr ""

#: ../../../library/importlib.rst:82
msgid ""
"The :func:`import_module` function acts as a simplifying wrapper around :"
"func:`importlib.__import__`. This means all semantics of the function are "
"derived from :func:`importlib.__import__`, including requiring the package "
"from which an import is occurring to have been previously imported (i.e., "
"*package* must already be imported). The most important difference is that :"
"func:`import_module` returns the specified package or module (e.g. ``pkg."
"mod``), while :func:`__import__` returns the top-level package or module (e."
"g. ``pkg``)."
msgstr ""

#: ../../../library/importlib.rst:91
msgid "Parent packages are automatically imported."
msgstr ""

#: ../../../library/importlib.rst:96
msgid ""
"Find the loader for a module, optionally within the specified *path*. If the "
"module is in :attr:`sys.modules`, then ``sys.modules[name].__loader__`` is "
"returned (unless the loader would be ``None``, in which case :exc:"
"`ValueError` is raised). Otherwise a search using :attr:`sys.meta_path` is "
"done. ``None`` is returned if no loader is found."
msgstr ""

#: ../../../library/importlib.rst:102
msgid ""
"A dotted name does not have its parent's implicitly imported as that "
"requires loading them and that may not be desired. To properly import a "
"submodule you will need to import all parent packages of the submodule and "
"use the correct argument to *path*."
msgstr ""

#: ../../../library/importlib.rst:109
msgid ""
"Invalidate the internal caches of finders stored at :data:`sys.meta_path`. "
"If a finder implements ``invalidate_caches()`` then it will be called to "
"perform the invalidation.  This function should be called if any modules are "
"created/installed while your program is running to guarantee all finders "
"will notice the new module's existence."
msgstr ""

#: ../../../library/importlib.rst:119
msgid ":mod:`importlib.abc` -- Abstract base classes related to import"
msgstr ""

#: ../../../library/importlib.rst:124
msgid ""
"The :mod:`importlib.abc` module contains all of the core abstract base "
"classes used by :keyword:`import`. Some subclasses of the core abstract base "
"classes are also provided to help in implementing the core ABCs."
msgstr ""

#: ../../../library/importlib.rst:128
msgid "ABC hierarchy::"
msgstr ""

#: ../../../library/importlib.rst:130
msgid ""
"object\n"
" +-- Finder (deprecated)\n"
" |    +-- MetaPathFinder\n"
" |    +-- PathEntryFinder\n"
" +-- Loader\n"
"      +-- ResourceLoader --------+\n"
"      +-- InspectLoader          |\n"
"           +-- ExecutionLoader --+\n"
"                                 +-- FileLoader\n"
"                                 +-- SourceLoader\n"
"                                      +-- PyLoader (deprecated)\n"
"                                      +-- PyPycLoader (deprecated)"
msgstr ""

#: ../../../library/importlib.rst:146
msgid "An abstract base class representing a :term:`finder`."
msgstr ""

#: ../../../library/importlib.rst:148
msgid "Use :class:`MetaPathFinder` or :class:`PathEntryFinder` instead."
msgstr ""

#: ../../../library/importlib.rst:153
msgid ""
"An abstact method for finding a :term:`loader` for the specified module.  "
"Originally specified in :pep:`302`, this method was meant for use in :data:"
"`sys.meta_path` and in the path-based import subsystem."
msgstr ""

#: ../../../library/importlib.rst:160
msgid ""
"An abstract base class representing a :term:`meta path finder`. For "
"compatibility, this is a subclass of :class:`Finder`."
msgstr ""

#: ../../../library/importlib.rst:167
msgid ""
"An abstract method for finding a :term:`loader` for the specified module.  "
"If this is a top-level import, *path* will be ``None``. Otherwise, this is a "
"search for a subpackage or module and *path* will be the value of :attr:"
"`__path__` from the parent package. If a loader cannot be found, ``None`` is "
"returned."
msgstr ""

#: ../../../library/importlib.rst:175
msgid ""
"An optional method which, when called, should invalidate any internal cache "
"used by the finder. Used by :func:`importlib.invalidate_caches` when "
"invalidating the caches of all finders on :data:`sys.meta_path`."
msgstr ""

#: ../../../library/importlib.rst:182
msgid ""
"An abstract base class representing a :term:`path entry finder`.  Though it "
"bears some similarities to :class:`MetaPathFinder`, ``PathEntryFinder`` is "
"meant for use only within the path-based import subsystem provided by :class:"
"`PathFinder`. This ABC is a subclass of :class:`Finder` for compatibility."
msgstr ""

#: ../../../library/importlib.rst:192
msgid ""
"An abstract method for finding a :term:`loader` for the specified module.  "
"Returns a 2-tuple of ``(loader, portion)`` where ``portion`` is a sequence "
"of file system locations contributing to part of a namespace package. The "
"loader may be ``None`` while specifying ``portion`` to signify the "
"contribution of the file system locations to a namespace package. An empty "
"list can be used for ``portion`` to signify the loader is not part of a "
"package. If ``loader`` is ``None`` and ``portion`` is the empty list then no "
"loader or location for a namespace package were found (i.e. failure to find "
"anything for the module)."
msgstr ""

#: ../../../library/importlib.rst:204
msgid ""
"A concrete implementation of :meth:`Finder.find_module` which is equivalent "
"to ``self.find_loader(fullname)[0]``."
msgstr ""

#: ../../../library/importlib.rst:209
msgid ""
"An optional method which, when called, should invalidate any internal cache "
"used by the finder. Used by :meth:`PathFinder.invalidate_caches` when "
"invalidating the caches of all cached finders."
msgstr ""

#: ../../../library/importlib.rst:216
msgid ""
"An abstract base class for a :term:`loader`. See :pep:`302` for the exact "
"definition for a loader."
msgstr ""

#: ../../../library/importlib.rst:221
msgid ""
"An abstract method for loading a module. If the module cannot be loaded, :"
"exc:`ImportError` is raised, otherwise the loaded module is returned."
msgstr ""

#: ../../../library/importlib.rst:225
msgid ""
"If the requested module already exists in :data:`sys.modules`, that module "
"should be used and reloaded. Otherwise the loader should create a new module "
"and insert it into :data:`sys.modules` before any loading begins, to prevent "
"recursion from the import. If the loader inserted a module and the load "
"fails, it must be removed by the loader from :data:`sys.modules`; modules "
"already in :data:`sys.modules` before the loader began execution should be "
"left alone. The :func:`importlib.util.module_for_loader` decorator handles "
"all of these details."
msgstr ""

#: ../../../library/importlib.rst:235
msgid ""
"The loader should set several attributes on the module. (Note that some of "
"these attributes can change when a module is reloaded.)"
msgstr ""

#: ../../../library/importlib.rst:240
msgid ":attr:`__name__`"
msgstr ""

#: ../../../library/importlib.rst:240
msgid "The name of the module."
msgstr ""

#: ../../../library/importlib.rst:244
msgid ":attr:`__file__`"
msgstr ""

#: ../../../library/importlib.rst:243
msgid ""
"The path to where the module data is stored (not set for built-in modules)."
msgstr ""

#: ../../../library/importlib.rst:248
msgid ":attr:`__cached__`"
msgstr ""

#: ../../../library/importlib.rst:247
msgid ""
"The path to where a compiled version of the module is/should be stored (not "
"set when the attribute would be inappropriate)."
msgstr ""

#: ../../../library/importlib.rst:252
msgid ":attr:`__path__`"
msgstr ""

#: ../../../library/importlib.rst:251
msgid ""
"A list of strings specifying the search path within a package. This "
"attribute is not set on modules."
msgstr ""

#: ../../../library/importlib.rst:258
msgid ":attr:`__package__`"
msgstr ""

#: ../../../library/importlib.rst:255
msgid ""
"The parent package for the module/package. If the module is top-level then "
"it has a value of the empty string. The :func:`importlib.util.set_package` "
"decorator can handle the details for :attr:`__package__`."
msgstr ""

#: ../../../library/importlib.rst:262
msgid ":attr:`__loader__`"
msgstr ""

#: ../../../library/importlib.rst:261
msgid ""
"The loader used to load the module. (This is not set by the built-in import "
"machinery, but it should be set whenever a :term:`loader` is used.)"
msgstr ""

#: ../../../library/importlib.rst:267
msgid ""
"An abstract method which when implemented calculates and returns the given "
"module's repr, as a string."
msgstr ""

#: ../../../library/importlib.rst:275
msgid ""
"An abstract base class for a :term:`loader` which implements the optional :"
"pep:`302` protocol for loading arbitrary resources from the storage back-end."
msgstr ""

#: ../../../library/importlib.rst:281
msgid ""
"An abstract method to return the bytes for the data located at *path*. "
"Loaders that have a file-like storage back-end that allows storing arbitrary "
"data can implement this abstract method to give direct access to the data "
"stored. :exc:`IOError` is to be raised if the *path* cannot be found. The "
"*path* is expected to be constructed using a module's :attr:`__file__` "
"attribute or an item from a package's :attr:`__path__`."
msgstr ""

#: ../../../library/importlib.rst:292
msgid ""
"An abstract base class for a :term:`loader` which implements the optional :"
"pep:`302` protocol for loaders that inspect modules."
msgstr ""

#: ../../../library/importlib.rst:297
msgid ""
"An abstract method to return the :class:`code` object for a module. ``None`` "
"is returned if the module does not have a code object (e.g. built-in "
"module).  :exc:`ImportError` is raised if loader cannot find the requested "
"module."
msgstr ""

#: ../../../library/importlib.rst:307
msgid ""
"An abstract method to return the source of a module. It is returned as a "
"text string using :term:`universal newlines`, translating all recognized "
"line separators into ``'\\n'`` characters.  Returns ``None`` if no source is "
"available (e.g. a built-in module). Raises :exc:`ImportError` if the loader "
"cannot find the module specified."
msgstr ""

#: ../../../library/importlib.rst:315
msgid ""
"An abstract method to return a true value if the module is a package, a "
"false value otherwise. :exc:`ImportError` is raised if the :term:`loader` "
"cannot find the module."
msgstr ""

#: ../../../library/importlib.rst:322
msgid ""
"An abstract base class which inherits from :class:`InspectLoader` that, when "
"implemented, helps a module to be executed as a script. The ABC represents "
"an optional :pep:`302` protocol."
msgstr ""

#: ../../../library/importlib.rst:328
msgid ""
"An abstract method that is to return the value of :attr:`__file__` for the "
"specified module. If no path is available, :exc:`ImportError` is raised."
msgstr ""

#: ../../../library/importlib.rst:332
msgid ""
"If source code is available, then the method should return the path to the "
"source file, regardless of whether a bytecode was used to load the module."
msgstr ""

#: ../../../library/importlib.rst:339
msgid ""
"An abstract base class which inherits from :class:`ResourceLoader` and :"
"class:`ExecutionLoader`, providing concrete implementations of :meth:"
"`ResourceLoader.get_data` and :meth:`ExecutionLoader.get_filename`."
msgstr ""

#: ../../../library/importlib.rst:343
msgid ""
"The *fullname* argument is a fully resolved name of the module the loader is "
"to handle. The *path* argument is the path to the file for the module."
msgstr ""

#: ../../../library/importlib.rst:350
msgid "The name of the module the loader can handle."
msgstr ""

#: ../../../library/importlib.rst:354
msgid "Path to the file of the module."
msgstr ""

#: ../../../library/importlib.rst:358
msgid "Calls super's ``load_module()``."
msgstr ""

#: ../../../library/importlib.rst:362
msgid "Returns :attr:`path`."
msgstr ""

#: ../../../library/importlib.rst:366
msgid "Returns the open, binary file for *path*."
msgstr ""

#: ../../../library/importlib.rst:371
msgid ""
"An abstract base class for implementing source (and optionally bytecode) "
"file loading. The class inherits from both :class:`ResourceLoader` and :"
"class:`ExecutionLoader`, requiring the implementation of:"
msgstr ""

#: ../../../library/importlib.rst:375
msgid ":meth:`ResourceLoader.get_data`"
msgstr ""

#: ../../../library/importlib.rst:378
msgid ":meth:`ExecutionLoader.get_filename`"
msgstr ""

#: ../../../library/importlib.rst:377
msgid ""
"Should only return the path to the source file; sourceless loading is not "
"supported."
msgstr ""

#: ../../../library/importlib.rst:380
msgid ""
"The abstract methods defined by this class are to add optional bytecode file "
"support. Not implementing these optional methods causes the loader to only "
"work with source code. Implementing the methods allows the loader to work "
"with source *and* bytecode files; it does not allow for *sourceless* loading "
"where only bytecode is provided.  Bytecode files are an optimization to "
"speed up loading by removing the parsing step of Python's compiler, and so "
"no bytecode-specific API is exposed."
msgstr ""

#: ../../../library/importlib.rst:390
msgid ""
"Optional abstract method which returns a :class:`dict` containing metadata "
"about the specifed path.  Supported dictionary keys are:"
msgstr ""

#: ../../../library/importlib.rst:393
msgid ""
"``'mtime'`` (mandatory): an integer or floating-point number representing "
"the modification time of the source code;"
msgstr ""

#: ../../../library/importlib.rst:395
msgid "``'size'`` (optional): the size in bytes of the source code."
msgstr ""

#: ../../../library/importlib.rst:397
msgid ""
"Any other keys in the dictionary are ignored, to allow for future extensions."
msgstr ""

#: ../../../library/importlib.rst:404
msgid ""
"Optional abstract method which returns the modification time for the "
"specified path."
msgstr ""

#: ../../../library/importlib.rst:407
msgid ""
"This method is deprecated in favour of :meth:`path_stats`.  You don't have "
"to implement it, but it is still available for compatibility purposes."
msgstr ""

#: ../../../library/importlib.rst:414
msgid ""
"Optional abstract method which writes the specified bytes to a file path. "
"Any intermediate directories which do not exist are to be created "
"automatically."
msgstr ""

#: ../../../library/importlib.rst:418
msgid ""
"When writing to the path fails because the path is read-only (:attr:`errno."
"EACCES`/:exc:`PermissionError`), do not propagate the exception."
msgstr ""

#: ../../../library/importlib.rst:424
msgid "Concrete implementation of :meth:`InspectLoader.get_code`."
msgstr ""

#: ../../../library/importlib.rst:428
msgid "Concrete implementation of :meth:`Loader.load_module`."
msgstr ""

#: ../../../library/importlib.rst:432
msgid "Concrete implementation of :meth:`InspectLoader.get_source`."
msgstr ""

#: ../../../library/importlib.rst:436
msgid ""
"Concrete implementation of :meth:`InspectLoader.is_package`. A module is "
"determined to be a package if its file path (as provided by :meth:"
"`ExecutionLoader.get_filename`) is a file named ``__init__`` when the file "
"extension is removed **and** the module name itself does not end in "
"``__init__``."
msgstr ""

#: ../../../library/importlib.rst:445
msgid ""
"An abstract base class inheriting from :class:`ExecutionLoader` and :class:"
"`ResourceLoader` designed to ease the loading of Python source modules "
"(bytecode is not handled; see :class:`SourceLoader` for a source/bytecode "
"ABC). A subclass implementing this ABC will only need to worry about "
"exposing how the source code is stored; all other details for loading Python "
"source code will be handled by the concrete implementations of key methods."
msgstr ""

#: ../../../library/importlib.rst:454
msgid ""
"This class has been deprecated in favor of :class:`SourceLoader` and is "
"slated for removal in Python 3.4. See below for how to create a subclass "
"that is compatible with Python 3.1 onwards."
msgstr ""

#: ../../../library/importlib.rst:459
msgid ""
"If compatibility with Python 3.1 is required, then use the following idiom "
"to implement a subclass that will work with Python 3.1 onwards (make sure to "
"implement :meth:`ExecutionLoader.get_filename`)::"
msgstr ""

#: ../../../library/importlib.rst:463
msgid ""
"try:\n"
"    from importlib.abc import SourceLoader\n"
"except ImportError:\n"
"    from importlib.abc import PyLoader as SourceLoader\n"
"\n"
"\n"
"class CustomLoader(SourceLoader):\n"
"    def get_filename(self, fullname):\n"
"        \"\"\"Return the path to the source file.\"\"\"\n"
"        # Implement ...\n"
"\n"
"    def source_path(self, fullname):\n"
"        \"\"\"Implement source_path in terms of get_filename.\"\"\"\n"
"        try:\n"
"            return self.get_filename(fullname)\n"
"        except ImportError:\n"
"            return None\n"
"\n"
"    def is_package(self, fullname):\n"
"        \"\"\"Implement is_package by looking for an __init__ file\n"
"        name as returned by get_filename.\"\"\"\n"
"        filename = os.path.basename(self.get_filename(fullname))\n"
"        return os.path.splitext(filename)[0] == '__init__'"
msgstr ""

#: ../../../library/importlib.rst:490
msgid ""
"An abstract method that returns the path to the source code for a module. "
"Should return ``None`` if there is no source code. Raises :exc:`ImportError` "
"if the loader knows it cannot handle the module."
msgstr ""

#: ../../../library/importlib.rst:497
msgid ""
"A concrete implementation of :meth:`importlib.abc.ExecutionLoader."
"get_filename` that relies on :meth:`source_path`. If :meth:`source_path` "
"returns ``None``, then :exc:`ImportError` is raised."
msgstr ""

#: ../../../library/importlib.rst:504
msgid ""
"A concrete implementation of :meth:`importlib.abc.Loader.load_module` that "
"loads Python source code. All needed information comes from the abstract "
"methods required by this ABC. The only pertinent assumption made by this "
"method is that when loading a package :attr:`__path__` is set to ``[os.path."
"dirname(__file__)]``."
msgstr ""

#: ../../../library/importlib.rst:512
msgid ""
"A concrete implementation of :meth:`importlib.abc.InspectLoader.get_code` "
"that creates code objects from Python source code, by requesting the source "
"code (using :meth:`source_path` and :meth:`get_data`) and compiling it with "
"the built-in :func:`compile` function."
msgstr ""

#: ../../../library/importlib.rst:520
msgid ""
"A concrete implementation of :meth:`importlib.abc.InspectLoader.get_source`. "
"Uses :meth:`importlib.abc.ResourceLoader.get_data` and :meth:`source_path` "
"to get the source code.  It tries to guess the source encoding using :func:"
"`tokenize.detect_encoding`."
msgstr ""

#: ../../../library/importlib.rst:529
msgid ""
"An abstract base class inheriting from :class:`PyLoader`. This ABC is meant "
"to help in creating loaders that support both Python source and bytecode."
msgstr ""

#: ../../../library/importlib.rst:533
msgid ""
"This class has been deprecated in favor of :class:`SourceLoader` and to "
"properly support :pep:`3147`. If compatibility is required with Python 3.1, "
"implement both :class:`SourceLoader` and :class:`PyLoader`; instructions on "
"how to do so are included in the documentation for :class:`PyLoader`. Do "
"note that this solution will not support sourceless/bytecode-only loading; "
"only source *and* bytecode loading."
msgstr ""

#: ../../../library/importlib.rst:541
msgid ""
"Updated to parse (but not use) the new source size field in bytecode files "
"when reading and to write out the field properly when writing."
msgstr ""

#: ../../../library/importlib.rst:547
msgid ""
"An abstract method which returns the modification time for the source code "
"of the specified module. The modification time should be an integer. If "
"there is no source code, return ``None``. If the module cannot be found "
"then :exc:`ImportError` is raised."
msgstr ""

#: ../../../library/importlib.rst:554
msgid ""
"An abstract method which returns the path to the bytecode for the specified "
"module, if it exists. It returns ``None`` if no bytecode exists (yet). "
"Raises :exc:`ImportError` if the loader knows it cannot handle the module."
msgstr ""

#: ../../../library/importlib.rst:562
msgid ""
"A concrete implementation of :meth:`ExecutionLoader.get_filename` that "
"relies on :meth:`PyLoader.source_path` and :meth:`bytecode_path`. If :meth:"
"`source_path` returns a path, then that value is returned. Else if :meth:"
"`bytecode_path` returns a path, that path will be returned. If a path is not "
"available from both methods, :exc:`ImportError` is raised."
msgstr ""

#: ../../../library/importlib.rst:572
msgid ""
"An abstract method which has the loader write *bytecode* for future use. If "
"the bytecode is written, return ``True``. Return ``False`` if the bytecode "
"could not be written. This method should not be called if :data:`sys."
"dont_write_bytecode` is true. The *bytecode* argument should be a bytes "
"string or bytes array."
msgstr ""

#: ../../../library/importlib.rst:580
msgid ":mod:`importlib.machinery` -- Importers and path hooks"
msgstr ""

#: ../../../library/importlib.rst:585
msgid ""
"This module contains the various objects that help :keyword:`import` find "
"and load modules."
msgstr ""

#: ../../../library/importlib.rst:590
msgid ""
"A list of strings representing the recognized file suffixes for source "
"modules."
msgstr ""

#: ../../../library/importlib.rst:597
msgid ""
"A list of strings representing the file suffixes for non-optimized bytecode "
"modules."
msgstr ""

#: ../../../library/importlib.rst:604
msgid ""
"A list of strings representing the file suffixes for optimized bytecode "
"modules."
msgstr ""

#: ../../../library/importlib.rst:611
msgid ""
"A list of strings representing the recognized file suffixes for bytecode "
"modules. Set to either :attr:`DEBUG_BYTECODE_SUFFIXES` or :attr:"
"`OPTIMIZED_BYTECODE_SUFFIXES` based on whether ``__debug__`` is true."
msgstr ""

#: ../../../library/importlib.rst:619
msgid ""
"A list of strings representing the recognized file suffixes for extension "
"modules."
msgstr ""

#: ../../../library/importlib.rst:626
msgid ""
"Returns a combined list of strings representing all file suffixes for "
"modules recognized by the standard import machinery. This is a helper for "
"code which simply needs to know if a filesystem path potentially refers to a "
"module without needing any details on the kind of module (for example, :func:"
"`inspect.getmodulename`)"
msgstr ""

#: ../../../library/importlib.rst:637
msgid ""
"An :term:`importer` for built-in modules. All known built-in modules are "
"listed in :data:`sys.builtin_module_names`. This class implements the :class:"
"`importlib.abc.MetaPathFinder` and :class:`importlib.abc.InspectLoader` ABCs."
msgstr ""

#: ../../../library/importlib.rst:642 ../../../library/importlib.rst:652
#: ../../../library/importlib.rst:661 ../../../library/importlib.rst:672
msgid ""
"Only class methods are defined by this class to alleviate the need for "
"instantiation."
msgstr ""

#: ../../../library/importlib.rst:648
msgid ""
"An :term:`importer` for frozen modules. This class implements the :class:"
"`importlib.abc.MetaPathFinder` and :class:`importlib.abc.InspectLoader` ABCs."
msgstr ""

#: ../../../library/importlib.rst:658
msgid ""
":term:`Finder` for modules declared in the Windows registry.  This class "
"implements the :class:`importlib.abc.Finder` ABC."
msgstr ""

#: ../../../library/importlib.rst:669
msgid ""
"A :term:`Finder` for :data:`sys.path` and package ``__path__`` attributes. "
"This class implements the :class:`importlib.abc.MetaPathFinder` ABC."
msgstr ""

#: ../../../library/importlib.rst:677
msgid ""
"Class method that attempts to find a :term:`loader` for the module specified "
"by *fullname* on :data:`sys.path` or, if defined, on *path*. For each path "
"entry that is searched, :data:`sys.path_importer_cache` is checked. If a non-"
"false object is found then it is used as the :term:`path entry finder` to "
"look for the module being searched for. If no entry is found in :data:`sys."
"path_importer_cache`, then :data:`sys.path_hooks` is searched for a finder "
"for the path entry and, if found, is stored in :data:`sys."
"path_importer_cache` along with being queried about the module. If no finder "
"is ever found then ``None`` is both stored in the cache and returned."
msgstr ""

#: ../../../library/importlib.rst:691
msgid ""
"Calls :meth:`importlib.abc.PathEntryFinder.invalidate_caches` on all finders "
"stored in :attr:`sys.path_importer_cache`."
msgstr ""

#: ../../../library/importlib.rst:697
msgid ""
"A concrete implementation of :class:`importlib.abc.PathEntryFinder` which "
"caches results from the file system."
msgstr ""

#: ../../../library/importlib.rst:700
msgid ""
"The *path* argument is the directory for which the finder is in charge of "
"searching."
msgstr ""

#: ../../../library/importlib.rst:703
msgid ""
"The *loader_details* argument is a variable number of 2-item tuples each "
"containing a loader and a sequence of file suffixes the loader recognizes. "
"The loaders are expected to be callables which accept two arguments of the "
"module's name and the path to the file found."
msgstr ""

#: ../../../library/importlib.rst:708
msgid ""
"The finder will cache the directory contents as necessary, making stat calls "
"for each module search to verify the cache is not outdated. Because cache "
"staleness relies upon the granularity of the operating system's state "
"information of the file system, there is a potential race condition of "
"searching for a module, creating a new file, and then searching for the "
"module the new file represents. If the operations happen fast enough to fit "
"within the granularity of stat calls, then the module search will fail. To "
"prevent this from happening, when you create a module dynamically, make sure "
"to call :func:`importlib.invalidate_caches`."
msgstr ""

#: ../../../library/importlib.rst:722
msgid "The path the finder will search in."
msgstr ""

#: ../../../library/importlib.rst:726
msgid "Attempt to find the loader to handle *fullname* within :attr:`path`."
msgstr ""

#: ../../../library/importlib.rst:730
msgid "Clear out the internal cache."
msgstr ""

#: ../../../library/importlib.rst:734
msgid ""
"A class method which returns a closure for use on :attr:`sys.path_hooks`. An "
"instance of :class:`FileFinder` is returned by the closure using the path "
"argument given to the closure directly and *loader_details* indirectly."
msgstr ""

#: ../../../library/importlib.rst:739
msgid ""
"If the argument to the closure is not an existing directory, :exc:"
"`ImportError` is raised."
msgstr ""

#: ../../../library/importlib.rst:745
msgid ""
"A concrete implementation of :class:`importlib.abc.SourceLoader` by "
"subclassing :class:`importlib.abc.FileLoader` and providing some concrete "
"implementations of other methods."
msgstr ""

#: ../../../library/importlib.rst:753
msgid "The name of the module that this loader will handle."
msgstr ""

#: ../../../library/importlib.rst:757
msgid "The path to the source file."
msgstr ""

#: ../../../library/importlib.rst:761
msgid "Return true if :attr:`path` appears to be for a package."
msgstr ""

#: ../../../library/importlib.rst:765
msgid ""
"Concrete implementation of :meth:`importlib.abc.SourceLoader.path_stats`."
msgstr ""

#: ../../../library/importlib.rst:769
msgid "Concrete implementation of :meth:`importlib.abc.SourceLoader.set_data`."
msgstr ""

#: ../../../library/importlib.rst:774
msgid ""
"A concrete implementation of :class:`importlib.abc.FileLoader` which can "
"import bytecode files (i.e. no source code files exist)."
msgstr ""

#: ../../../library/importlib.rst:777
msgid ""
"Please note that direct use of bytecode files (and thus not source code "
"files) inhibits your modules from being usable by all Python implementations "
"or new versions of Python which change the bytecode format."
msgstr ""

#: ../../../library/importlib.rst:786
msgid "The name of the module the loader will handle."
msgstr ""

#: ../../../library/importlib.rst:790
msgid "The path to the bytecode file."
msgstr ""

#: ../../../library/importlib.rst:794
msgid "Determines if the module is a package based on :attr:`path`."
msgstr ""

#: ../../../library/importlib.rst:798
msgid "Returns the code object for :attr:`name` created from :attr:`path`."
msgstr ""

#: ../../../library/importlib.rst:802
msgid ""
"Returns ``None`` as bytecode files have no source when this loader is used."
msgstr ""

#: ../../../library/importlib.rst:808
msgid ""
"A concrete implementation of :class:`importlib.abc.InspectLoader` for "
"extension modules."
msgstr ""

#: ../../../library/importlib.rst:811
msgid ""
"The *fullname* argument specifies the name of the module the loader is to "
"support. The *path* argument is the path to the extension module's file."
msgstr ""

#: ../../../library/importlib.rst:818
msgid "Name of the module the loader supports."
msgstr ""

#: ../../../library/importlib.rst:822
msgid "Path to the extension module."
msgstr ""

#: ../../../library/importlib.rst:826
msgid ""
"Loads the extension module if and only if *fullname* is the same as :attr:"
"`name` or is ``None``."
msgstr ""

#: ../../../library/importlib.rst:831
msgid ""
"Returns ``True`` if the file path points to a package's ``__init__`` module "
"based on :attr:`EXTENSION_SUFFIXES`."
msgstr ""

#: ../../../library/importlib.rst:836
msgid "Returns ``None`` as extension modules lack a code object."
msgstr ""

#: ../../../library/importlib.rst:840
msgid "Returns ``None`` as extension modules do not have source code."
msgstr ""

#: ../../../library/importlib.rst:844
msgid ":mod:`importlib.util` -- Utility code for importers"
msgstr ""

#: ../../../library/importlib.rst:849
msgid ""
"This module contains the various objects that help in the construction of "
"an :term:`importer`."
msgstr ""

#: ../../../library/importlib.rst:854
msgid "Resolve a relative module name to an absolute one."
msgstr ""

#: ../../../library/importlib.rst:856
msgid ""
"If  **name** has no leading dots, then **name** is simply returned. This "
"allows for usage such as ``importlib.util.resolve_name('sys', __package__)`` "
"without doing a check to see if the **package** argument is needed."
msgstr ""

#: ../../../library/importlib.rst:861
msgid ""
":exc:`ValueError` is raised if **name** is a relative module name but "
"package is a false value (e.g. ``None`` or the empty string). :exc:"
"`ValueError` is also raised a relative name would escape its containing "
"package (e.g. requesting ``..bacon`` from within the ``spam`` package)."
msgstr ""

#: ../../../library/importlib.rst:870
msgid ""
"A :term:`decorator` for a :term:`loader` method, to handle selecting the "
"proper module object to load with. The decorated method is expected to have "
"a call signature taking two positional arguments (e.g. ``load_module(self, "
"module)``) for which the second argument will be the module **object** to be "
"used by the loader. Note that the decorator will not work on static methods "
"because of the assumption of two arguments."
msgstr ""

#: ../../../library/importlib.rst:879
msgid ""
"The decorated method will take in the **name** of the module to be loaded as "
"expected for a :term:`loader`. If the module is not found in :data:`sys."
"modules` then a new one is constructed with its :attr:`__name__` attribute "
"set to **name**, :attr:`__loader__` set to **self**, and :attr:`__package__` "
"set if :meth:`importlib.abc.InspectLoader.is_package` is defined for "
"**self** and does not raise :exc:`ImportError` for **name**. If a new module "
"is not needed then the module found in :data:`sys.modules` will be passed "
"into the method."
msgstr ""

#: ../../../library/importlib.rst:889
msgid ""
"If an exception is raised by the decorated method and a module was added to :"
"data:`sys.modules` it will be removed to prevent a partially initialized "
"module from being in left in :data:`sys.modules`. If the module was already "
"in :data:`sys.modules` then it is left alone."
msgstr ""

#: ../../../library/importlib.rst:894
msgid ""
"Use of this decorator handles all the details of which module object a "
"loader should initialize as specified by :pep:`302` as best as possible."
msgstr ""

#: ../../../library/importlib.rst:897
msgid ""
":attr:`__loader__` and :attr:`__package__` are automatically set (when "
"possible)."
msgstr ""

#: ../../../library/importlib.rst:903
msgid ""
"A :term:`decorator` for a :term:`loader` method, to set the :attr:"
"`__loader__` attribute on loaded modules. If the attribute is already set "
"the decorator does nothing. It is assumed that the first positional argument "
"to the wrapped method (i.e. ``self``) is what :attr:`__loader__` should be "
"set to."
msgstr ""

#: ../../../library/importlib.rst:911 ../../../library/importlib.rst:931
msgid ""
"It is recommended that :func:`module_for_loader` be used over this decorator "
"as it subsumes this functionality."
msgstr ""

#: ../../../library/importlib.rst:917
msgid ""
"A :term:`decorator` for a :term:`loader` to set the :attr:`__package__` "
"attribute on the module returned by the loader. If :attr:`__package__` is "
"set and has a value other than ``None`` it will not be changed. Note that "
"the module returned by the loader is what has the attribute set on and not "
"the module found in :data:`sys.modules`."
msgstr ""

#: ../../../library/importlib.rst:923
msgid ""
"Reliance on this decorator is discouraged when it is possible to set :attr:"
"`__package__` before importing. By setting it beforehand the code for the "
"module is executed with the attribute set and thus can be used by global "
"level code during initialization."
msgstr ""

#: ../../../library/importlib.rst:302
msgid "universal newlines"
msgstr ""

#: ../../../library/importlib.rst:302
msgid "importlib.abc.InspectLoader.get_source method"
msgstr ""

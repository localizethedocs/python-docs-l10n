# SOME DESCRIPTIVE TITLE.
# Copyright (C) 1990-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.3\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-11 04:42+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../library/types.rst:2
msgid ":mod:`types` --- Dynamic type creation and names for built-in types"
msgstr ""

#: ../../../library/types.rst:7
msgid "**Source code:** :source:`Lib/types.py`"
msgstr ""

#: ../../../library/types.rst:11
msgid ""
"This module defines utility function to assist in dynamic creation of new "
"types."
msgstr ""

#: ../../../library/types.rst:14
msgid ""
"It also defines names for some object types that are used by the standard "
"Python interpreter, but not exposed as builtins like :class:`int` or :class:"
"`str` are."
msgstr ""

#: ../../../library/types.rst:20
msgid "Dynamic Type Creation"
msgstr ""

#: ../../../library/types.rst:24
msgid "Creates a class object dynamically using the appropriate metaclass."
msgstr ""

#: ../../../library/types.rst:26
msgid ""
"The first three arguments are the components that make up a class definition "
"header: the class name, the base classes (in order), the keyword arguments "
"(such as ``metaclass``)."
msgstr ""

#: ../../../library/types.rst:30
msgid ""
"The *exec_body* argument is a callback that is used to populate the freshly "
"created class namespace. It should accept the class namespace as its sole "
"argument and update the namespace directly with the class contents. If no "
"callback is provided, it has the same effect as passing in ``lambda ns: ns``."
msgstr ""

#: ../../../library/types.rst:40
msgid "Calculates the appropriate metaclass and creates the class namespace."
msgstr ""

#: ../../../library/types.rst:42
msgid ""
"The arguments are the components that make up a class definition header: the "
"class name, the base classes (in order) and the keyword arguments (such as "
"``metaclass``)."
msgstr ""

#: ../../../library/types.rst:46
msgid "The return value is a 3-tuple: ``metaclass, namespace, kwds``"
msgstr ""

#: ../../../library/types.rst:48
msgid ""
"*metaclass* is the appropriate metaclass, *namespace* is the prepared class "
"namespace and *kwds* is an updated copy of the passed in *kwds* argument "
"with any ``'metaclass'`` entry removed. If no *kwds* argument is passed in, "
"this will be an empty dict."
msgstr ""

#: ../../../library/types.rst:58
msgid ":ref:`metaclasses`"
msgstr ""

#: ../../../library/types.rst:58
msgid "Full details of the class creation process supported by these functions"
msgstr ""

#: ../../../library/types.rst:60
msgid ":pep:`3115` - Metaclasses in Python 3000"
msgstr ""

#: ../../../library/types.rst:61
msgid "Introduced the ``__prepare__`` namespace hook"
msgstr ""

#: ../../../library/types.rst:65
msgid "Standard Interpreter Types"
msgstr ""

#: ../../../library/types.rst:67
msgid ""
"This module provides names for many of the types that are required to "
"implement a Python interpreter. It deliberately avoids including some of the "
"types that arise only incidentally during processing such as the "
"``listiterator`` type."
msgstr ""

#: ../../../library/types.rst:72
msgid ""
"Typical use of these names is for :func:`isinstance` or :func:`issubclass` "
"checks."
msgstr ""

#: ../../../library/types.rst:75
msgid "Standard names are defined for the following types:"
msgstr ""

#: ../../../library/types.rst:80
msgid ""
"The type of user-defined functions and functions created by :keyword:"
"`lambda`  expressions."
msgstr ""

#: ../../../library/types.rst:86
msgid ""
"The type of :term:`generator`-iterator objects, produced by calling a "
"generator function."
msgstr ""

#: ../../../library/types.rst:94
msgid "The type for code objects such as returned by :func:`compile`."
msgstr ""

#: ../../../library/types.rst:99
msgid "The type of methods of user-defined class instances."
msgstr ""

#: ../../../library/types.rst:105
msgid ""
"The type of built-in functions like :func:`len` or :func:`sys.exit`, and "
"methods of built-in classes.  (Here, the term \"built-in\" means \"written "
"in C\".)"
msgstr ""

#: ../../../library/types.rst:112
msgid "The type of modules."
msgstr ""

#: ../../../library/types.rst:117
msgid "The type of traceback objects such as found in ``sys.exc_info()[2]``."
msgstr ""

#: ../../../library/types.rst:122
msgid ""
"The type of frame objects such as found in ``tb.tb_frame`` if ``tb`` is a "
"traceback object."
msgstr ""

#: ../../../library/types.rst:128
msgid ""
"The type of objects defined in extension modules with ``PyGetSetDef``, such "
"as ``FrameType.f_locals`` or ``array.array.typecode``.  This type is used as "
"descriptor for object attributes; it has the same purpose as the :class:"
"`property` type, but for classes defined in extension modules."
msgstr ""

#: ../../../library/types.rst:136
msgid ""
"The type of objects defined in extension modules with ``PyMemberDef``, such "
"as ``datetime.timedelta.days``.  This type is used as descriptor for simple "
"C data members which use standard conversion functions; it has the same "
"purpose as the :class:`property` type, but for classes defined in extension "
"modules."
msgstr ""

#: ../../../library/types.rst:143
msgid ""
"In other implementations of Python, this type may be identical to "
"``GetSetDescriptorType``."
msgstr ""

#: ../../../library/types.rst:148
msgid ""
"Read-only proxy of a mapping. It provides a dynamic view on the mapping's "
"entries, which means that when the mapping changes, the view reflects these "
"changes."
msgstr ""

#: ../../../library/types.rst:156
msgid ""
"Return ``True`` if the underlying mapping has a key *key*, else ``False``."
msgstr ""

#: ../../../library/types.rst:161
msgid ""
"Return the item of the underlying mapping with key *key*.  Raises a :exc:"
"`KeyError` if *key* is not in the underlying mapping."
msgstr ""

#: ../../../library/types.rst:166
msgid ""
"Return an iterator over the keys of the underlying mapping.  This is a "
"shortcut for ``iter(proxy.keys())``."
msgstr ""

#: ../../../library/types.rst:171
msgid "Return the number of items in the underlying mapping."
msgstr ""

#: ../../../library/types.rst:175
msgid "Return a shallow copy of the underlying mapping."
msgstr ""

#: ../../../library/types.rst:179
msgid ""
"Return the value for *key* if *key* is in the underlying mapping, else "
"*default*.  If *default* is not given, it defaults to ``None``, so that this "
"method never raises a :exc:`KeyError`."
msgstr ""

#: ../../../library/types.rst:185
msgid ""
"Return a new view of the underlying mapping's items (``(key, value)`` pairs)."
msgstr ""

#: ../../../library/types.rst:190
msgid "Return a new view of the underlying mapping's keys."
msgstr ""

#: ../../../library/types.rst:194
msgid "Return a new view of the underlying mapping's values."
msgstr ""

#: ../../../library/types.rst:199
msgid ""
"A simple :class:`object` subclass that provides attribute access to its "
"namespace, as well as a meaningful repr."
msgstr ""

#: ../../../library/types.rst:202
msgid ""
"Unlike :class:`object`, with ``SimpleNamespace`` you can add and remove "
"attributes.  If a ``SimpleNamespace`` object is initialized with keyword "
"arguments, those are directly added to the underlying namespace."
msgstr ""

#: ../../../library/types.rst:206
msgid "The type is roughly equivalent to the following code::"
msgstr ""

#: ../../../library/types.rst:216
msgid ""
"``SimpleNamespace`` may be useful as a replacement for ``class NS: pass``. "
"However, for a structured record type use :func:`~collections.namedtuple` "
"instead."
msgstr ""

#: ../../../library/types.rst:92
msgid "compile"
msgstr ""

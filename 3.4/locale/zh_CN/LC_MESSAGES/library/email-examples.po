# SOME DESCRIPTIVE TITLE.
# Copyright (C) 1990-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.4\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-10 15:09+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../library/email-examples.rst:4
msgid ":mod:`email`: Examples"
msgstr ""

#: ../../../library/email-examples.rst:6
msgid ""
"Here are a few examples of how to use the :mod:`email` package to read, "
"write, and send simple email messages, as well as more complex MIME messages."
msgstr ""

#: ../../../library/email-examples.rst:9
msgid "First, let's see how to create and send a simple text message:"
msgstr ""

#: ../../../library/email-examples.rst:11
msgid ""
"# Import smtplib for the actual sending function\n"
"import smtplib\n"
"\n"
"# Import the email modules we'll need\n"
"from email.mime.text import MIMEText\n"
"\n"
"# Open a plain text file for reading.  For this example, assume that\n"
"# the text file contains only ASCII characters.\n"
"with open(textfile) as fp:\n"
"    # Create a text/plain message\n"
"    msg = MIMEText(fp.read())\n"
"\n"
"# me == the sender's email address\n"
"# you == the recipient's email address\n"
"msg['Subject'] = 'The contents of %s' % textfile\n"
"msg['From'] = me\n"
"msg['To'] = you\n"
"\n"
"# Send the message via our own SMTP server.\n"
"s = smtplib.SMTP('localhost')\n"
"s.send_message(msg)\n"
"s.quit()\n"
msgstr ""

#: ../../../library/email-examples.rst:14
msgid ""
"And parsing RFC822 headers can easily be done by the parse(filename) or "
"parsestr(message_as_string) methods of the Parser() class:"
msgstr ""

#: ../../../library/email-examples.rst:17
msgid ""
"# Import the email modules we'll need\n"
"from email.parser import Parser\n"
"\n"
"# If the e-mail headers are in a file, uncomment these two lines:\n"
"# with open(messagefile) as fp:\n"
"#     headers = Parser().parse(fp)\n"
"\n"
"#  Or for parsing headers in a string, use:\n"
"headers = Parser().parsestr('From: <user@example.com>\\n'\n"
"        'To: <someone_else@example.com>\\n'\n"
"        'Subject: Test message\\n'\n"
"        '\\n'\n"
"        'Body would go here\\n')\n"
"\n"
"#  Now the header items can be accessed as a dictionary:\n"
"print('To: %s' % headers['to'])\n"
"print('From: %s' % headers['from'])\n"
"print('Subject: %s' % headers['subject'])\n"
msgstr ""

#: ../../../library/email-examples.rst:20
msgid ""
"Here's an example of how to send a MIME message containing a bunch of family "
"pictures that may be residing in a directory:"
msgstr ""

#: ../../../library/email-examples.rst:23
msgid ""
"# Import smtplib for the actual sending function\n"
"import smtplib\n"
"\n"
"# Here are the email package modules we'll need\n"
"from email.mime.image import MIMEImage\n"
"from email.mime.multipart import MIMEMultipart\n"
"\n"
"COMMASPACE = ', '\n"
"\n"
"# Create the container (outer) email message.\n"
"msg = MIMEMultipart()\n"
"msg['Subject'] = 'Our family reunion'\n"
"# me == the sender's email address\n"
"# family = the list of all recipients' email addresses\n"
"msg['From'] = me\n"
"msg['To'] = COMMASPACE.join(family)\n"
"msg.preamble = 'Our family reunion'\n"
"\n"
"# Assume we know that the image files are all in PNG format\n"
"for file in pngfiles:\n"
"    # Open the files in binary mode.  Let the MIMEImage class automatically\n"
"    # guess the specific image type.\n"
"    with open(file, 'rb') as fp:\n"
"        img = MIMEImage(fp.read())\n"
"    msg.attach(img)\n"
"\n"
"# Send the email via our own SMTP server.\n"
"s = smtplib.SMTP('localhost')\n"
"s.send_message(msg)\n"
"s.quit()\n"
msgstr ""

#: ../../../library/email-examples.rst:26
msgid ""
"Here's an example of how to send the entire contents of a directory as an "
"email message: [1]_"
msgstr ""

#: ../../../library/email-examples.rst:29
msgid ""
"#!/usr/bin/env python3\n"
"\n"
"\"\"\"Send the contents of a directory as a MIME message.\"\"\"\n"
"\n"
"import os\n"
"import sys\n"
"import smtplib\n"
"# For guessing MIME type based on file name extension\n"
"import mimetypes\n"
"\n"
"from argparse import ArgumentParser\n"
"\n"
"from email import encoders\n"
"from email.message import Message\n"
"from email.mime.audio import MIMEAudio\n"
"from email.mime.base import MIMEBase\n"
"from email.mime.image import MIMEImage\n"
"from email.mime.multipart import MIMEMultipart\n"
"from email.mime.text import MIMEText\n"
"\n"
"COMMASPACE = ', '\n"
"\n"
"\n"
"def main():\n"
"    parser = ArgumentParser(description=\"\"\"\\\n"
"Send the contents of a directory as a MIME message.\n"
"Unless the -o option is given, the email is sent by forwarding to your "
"local\n"
"SMTP server, which then does the normal delivery process.  Your local "
"machine\n"
"must be running an SMTP server.\n"
"\"\"\")\n"
"    parser.add_argument('-d', '--directory',\n"
"                        help=\"\"\"Mail the contents of the specified "
"directory,\n"
"                        otherwise use the current directory.  Only the "
"regular\n"
"                        files in the directory are sent, and we don't "
"recurse to\n"
"                        subdirectories.\"\"\")\n"
"    parser.add_argument('-o', '--output',\n"
"                        metavar='FILE',\n"
"                        help=\"\"\"Print the composed message to FILE "
"instead of\n"
"                        sending the message to the SMTP server.\"\"\")\n"
"    parser.add_argument('-s', '--sender', required=True,\n"
"                        help='The value of the From: header (required)')\n"
"    parser.add_argument('-r', '--recipient', required=True,\n"
"                        action='append', metavar='RECIPIENT',\n"
"                        default=[], dest='recipients',\n"
"                        help='A To: header value (at least one required)')\n"
"    args = parser.parse_args()\n"
"    directory = args.directory\n"
"    if not directory:\n"
"        directory = '.'\n"
"    # Create the enclosing (outer) message\n"
"    outer = MIMEMultipart()\n"
"    outer['Subject'] = 'Contents of directory %s' % os.path."
"abspath(directory)\n"
"    outer['To'] = COMMASPACE.join(args.recipients)\n"
"    outer['From'] = args.sender\n"
"    outer.preamble = 'You will not see this in a MIME-aware mail reader."
"\\n'\n"
"\n"
"    for filename in os.listdir(directory):\n"
"        path = os.path.join(directory, filename)\n"
"        if not os.path.isfile(path):\n"
"            continue\n"
"        # Guess the content type based on the file's extension.  Encoding\n"
"        # will be ignored, although we should check for simple things like\n"
"        # gzip'd or compressed files.\n"
"        ctype, encoding = mimetypes.guess_type(path)\n"
"        if ctype is None or encoding is not None:\n"
"            # No guess could be made, or the file is encoded (compressed), "
"so\n"
"            # use a generic bag-of-bits type.\n"
"            ctype = 'application/octet-stream'\n"
"        maintype, subtype = ctype.split('/', 1)\n"
"        if maintype == 'text':\n"
"            with open(path) as fp:\n"
"                # Note: we should handle calculating the charset\n"
"                msg = MIMEText(fp.read(), _subtype=subtype)\n"
"        elif maintype == 'image':\n"
"            with open(path, 'rb') as fp:\n"
"                msg = MIMEImage(fp.read(), _subtype=subtype)\n"
"        elif maintype == 'audio':\n"
"            with open(path, 'rb') as fp:\n"
"                msg = MIMEAudio(fp.read(), _subtype=subtype)\n"
"        else:\n"
"            with open(path, 'rb') as fp:\n"
"                msg = MIMEBase(maintype, subtype)\n"
"                msg.set_payload(fp.read())\n"
"            # Encode the payload using Base64\n"
"            encoders.encode_base64(msg)\n"
"        # Set the filename parameter\n"
"        msg.add_header('Content-Disposition', 'attachment', "
"filename=filename)\n"
"        outer.attach(msg)\n"
"    # Now send or store the message\n"
"    composed = outer.as_string()\n"
"    if args.output:\n"
"        with open(args.output, 'w') as fp:\n"
"            fp.write(composed)\n"
"    else:\n"
"        with smtplib.SMTP('localhost') as s:\n"
"            s.sendmail(args.sender, args.recipients, composed)\n"
"\n"
"\n"
"if __name__ == '__main__':\n"
"    main()\n"
msgstr ""

#: ../../../library/email-examples.rst:32
msgid ""
"Here's an example of how to unpack a MIME message like the one above, into a "
"directory of files:"
msgstr ""

#: ../../../library/email-examples.rst:35
msgid ""
"#!/usr/bin/env python3\n"
"\n"
"\"\"\"Unpack a MIME message into a directory of files.\"\"\"\n"
"\n"
"import os\n"
"import sys\n"
"import email\n"
"import errno\n"
"import mimetypes\n"
"\n"
"from argparse import ArgumentParser\n"
"\n"
"\n"
"def main():\n"
"    parser = ArgumentParser(description=\"\"\"\\\n"
"Unpack a MIME message into a directory of files.\n"
"\"\"\")\n"
"    parser.add_argument('-d', '--directory', required=True,\n"
"                        help=\"\"\"Unpack the MIME message into the named\n"
"                        directory, which will be created if it doesn't "
"already\n"
"                        exist.\"\"\")\n"
"    parser.add_argument('msgfile')\n"
"    args = parser.parse_args()\n"
"\n"
"    with open(args.msgfile) as fp:\n"
"        msg = email.message_from_file(fp)\n"
"\n"
"    try:\n"
"        os.mkdir(args.directory)\n"
"    except FileExistsError:\n"
"        pass\n"
"\n"
"    counter = 1\n"
"    for part in msg.walk():\n"
"        # multipart/* are just containers\n"
"        if part.get_content_maintype() == 'multipart':\n"
"            continue\n"
"        # Applications should really sanitize the given filename so that an\n"
"        # email message can't be used to overwrite important files\n"
"        filename = part.get_filename()\n"
"        if not filename:\n"
"            ext = mimetypes.guess_extension(part.get_content_type())\n"
"            if not ext:\n"
"                # Use a generic bag-of-bits extension\n"
"                ext = '.bin'\n"
"            filename = 'part-%03d%s' % (counter, ext)\n"
"        counter += 1\n"
"        with open(os.path.join(args.directory, filename), 'wb') as fp:\n"
"            fp.write(part.get_payload(decode=True))\n"
"\n"
"\n"
"if __name__ == '__main__':\n"
"    main()\n"
msgstr ""

#: ../../../library/email-examples.rst:37
msgid ""
"Here's an example of how to create an HTML message with an alternative plain "
"text version: [2]_"
msgstr ""

#: ../../../library/email-examples.rst:40
msgid ""
"#!/usr/bin/env python3\n"
"\n"
"import smtplib\n"
"\n"
"from email.mime.multipart import MIMEMultipart\n"
"from email.mime.text import MIMEText\n"
"\n"
"# me == my email address\n"
"# you == recipient's email address\n"
"me = \"my@email.com\"\n"
"you = \"your@email.com\"\n"
"\n"
"# Create message container - the correct MIME type is multipart/"
"alternative.\n"
"msg = MIMEMultipart('alternative')\n"
"msg['Subject'] = \"Link\"\n"
"msg['From'] = me\n"
"msg['To'] = you\n"
"\n"
"# Create the body of the message (a plain-text and an HTML version).\n"
"text = \"Hi!\\nHow are you?\\nHere is the link you wanted:\\nhttps://www."
"python.org\"\n"
"html = \"\"\"\\\n"
"<html>\n"
"  <head></head>\n"
"  <body>\n"
"    <p>Hi!<br>\n"
"       How are you?<br>\n"
"       Here is the <a href=\"https://www.python.org\">link</a> you wanted.\n"
"    </p>\n"
"  </body>\n"
"</html>\n"
"\"\"\"\n"
"\n"
"# Record the MIME types of both parts - text/plain and text/html.\n"
"part1 = MIMEText(text, 'plain')\n"
"part2 = MIMEText(html, 'html')\n"
"\n"
"# Attach parts into message container.\n"
"# According to RFC 2046, the last part of a multipart message, in this case\n"
"# the HTML message, is best and preferred.\n"
"msg.attach(part1)\n"
"msg.attach(part2)\n"
"\n"
"# Send the message via local SMTP server.\n"
"s = smtplib.SMTP('localhost')\n"
"# sendmail function takes 3 arguments: sender's address, recipient's "
"address\n"
"# and message to send - here it is sent as one string.\n"
"s.sendmail(me, you, msg.as_string())\n"
"s.quit()\n"
msgstr ""

#: ../../../library/email-examples.rst:46
msgid "Examples using the Provisional API"
msgstr ""

#: ../../../library/email-examples.rst:47
msgid ""
"Here is a reworking of the last example using the provisional API.  To make "
"things a bit more interesting, we include a related image in the html part, "
"and we save a copy of what we are going to send to disk, as well as sending "
"it."
msgstr ""

#: ../../../library/email-examples.rst:51
msgid ""
"This example also shows how easy it is to include non-ASCII, and simplifies "
"the sending of the message using the :meth:`.send_message` method of the :"
"mod:`smtplib` module."
msgstr ""

#: ../../../library/email-examples.rst:55
msgid ""
"#!/usr/bin/env python3\n"
"\n"
"import smtplib\n"
"\n"
"from email.message import EmailMessage\n"
"from email.headerregistry import Address\n"
"from email.utils import make_msgid\n"
"\n"
"# Create the base text message.\n"
"msg = EmailMessage()\n"
"msg['Subject'] = \"Ayons asperges pour le déjeuner\"\n"
"msg['From'] = Address(\"Pepé Le Pew\", \"pepe@example.com\")\n"
"msg['To'] = (Address(\"Penelope Pussycat\", \"penelope@example.com\"),\n"
"             Address(\"Fabrette Pussycat\", \"fabrette@example.com\"))\n"
"msg.set_content(\"\"\"\\\n"
"Salut!\n"
"\n"
"Cela ressemble à un excellent recipie[1] déjeuner.\n"
"\n"
"[1] http://www.yummly.com/recipe/Roasted-Asparagus-Epicurious-203718\n"
"\n"
"--Pepé\n"
"\"\"\")\n"
"\n"
"# Add the html version.  This converts the message into a multipart/"
"alternative\n"
"# container, with the original text message as the first part and the new "
"html\n"
"# message as the second part.\n"
"asparagus_cid = make_msgid()\n"
"msg.add_alternative(\"\"\"\\\n"
"<html>\n"
"  <head></head>\n"
"  <body>\n"
"    <p>Salut!<\\p>\n"
"    <p>Cela ressemble à un excellent\n"
"        <a href=\"http://www.yummly.com/recipe/Roasted-Asparagus-"
"Epicurious-203718>\n"
"            recipie\n"
"        </a> déjeuner.\n"
"    </p>\n"
"    <img src=\"cid:{asparagus_cid}\" \\>\n"
"  </body>\n"
"</html>\n"
"\"\"\".format(asparagus_cid=asparagus_cid[1:-1]), subtype='html')\n"
"# note that we needed to peel the <> off the msgid for use in the html.\n"
"\n"
"# Now add the related image to the html part.\n"
"with open(\"roasted-asparagus.jpg\", 'rb') as img:\n"
"    msg.get_payload()[1].add_related(img.read(), 'image', 'jpeg',\n"
"                                     cid=asparagus_cid)\n"
"\n"
"# Make a local copy of what we are going to send.\n"
"with open('outgoing.msg', 'wb') as f:\n"
"    f.write(bytes(msg))\n"
"\n"
"# Send the message via local SMTP server.\n"
"with smtplib.SMTP('localhost') as s:\n"
"    s.send_message(msg)\n"
msgstr ""

#: ../../../library/email-examples.rst:57
msgid ""
"If we were instead sent the message from the last example, here is one way "
"we could process it:"
msgstr ""

#: ../../../library/email-examples.rst:60
msgid ""
"import os\n"
"import sys\n"
"import tempfile\n"
"import mimetypes\n"
"import webbrowser\n"
"\n"
"# Import the email modules we'll need\n"
"from email import policy\n"
"from email.parser import BytesParser\n"
"\n"
"# An imaginary module that would make this work and be safe.\n"
"from imaginary import magic_html_parser\n"
"\n"
"# In a real program you'd get the filename from the arguments.\n"
"with open('outgoing.msg', 'rb') as fp:\n"
"    msg = BytesParser(policy=policy.default).parse(fp)\n"
"\n"
"# Now the header items can be accessed as a dictionary, and any non-ASCII "
"will\n"
"# be converted to unicode:\n"
"print('To:', msg['to'])\n"
"print('From:', msg['from'])\n"
"print('Subject:', msg['subject'])\n"
"\n"
"# If we want to print a priview of the message content, we can extract "
"whatever\n"
"# the least formatted payload is and print the first three lines.  Of "
"course,\n"
"# if the message has no plain text part printing the first three lines of "
"html\n"
"# is probably useless, but this is just a conceptual example.\n"
"simplest = msg.get_body(preferencelist=('plain', 'html'))\n"
"print()\n"
"print(''.join(simplest.get_content().splitlines(keepends=True)[:3]))\n"
"\n"
"ans = input(\"View full message?\")\n"
"if ans.lower()[0] == 'n':\n"
"    sys.exit()\n"
"\n"
"# We can extract the richest alternative in order to display it:\n"
"richest = msg.get_body()\n"
"partfiles = {}\n"
"if richest['content-type'].maintype == 'text':\n"
"    if richest['content-type'].subtype == 'plain':\n"
"        for line in richest.get_content().splitlines():\n"
"            print(line)\n"
"        sys.exit()\n"
"    elif richest['content-type'].subtype == 'html':\n"
"        body = richest\n"
"    else:\n"
"        print(\"Don't know how to display {}\".format(richest."
"get_content_type()))\n"
"        sys.exit()\n"
"elif richest['content-type'].content_type == 'multipart/related':\n"
"    body = richest.get_body(preferencelist=('html'))\n"
"    for part in richest.iter_attachments():\n"
"        fn = part.get_filename()\n"
"        if fn:\n"
"            extension = os.path.splitext(part.get_filename())[1]\n"
"        else:\n"
"            extension = mimetypes.guess_extension(part.get_content_type())\n"
"        with tempfile.NamedTemporaryFile(suffix=extension, delete=False) as "
"f:\n"
"            f.write(part.get_content())\n"
"            # again strip the <> to go from email form of cid to html form.\n"
"            partfiles[part['content-id'][1:-1]] = f.name\n"
"else:\n"
"    print(\"Don't know how to display {}\".format(richest."
"get_content_type()))\n"
"    sys.exit()\n"
"with tempfile.NamedTemporaryFile(mode='w', delete=False) as f:\n"
"    # The magic_html_parser has to rewrite the href=\"cid:....\" attributes "
"to\n"
"    # point to the filenames in partfiles.  It also has to do a safety-"
"sanitize\n"
"    # of the html.  It could be written using html.parser.\n"
"    f.write(magic_html_parser(body.get_content(), partfiles))\n"
"webbrowser.open(f.name)\n"
"os.remove(f.name)\n"
"for fn in partfiles.values():\n"
"    os.remove(fn)\n"
"\n"
"# Of course, there are lots of email messages that could break this simple\n"
"# minded program, but it will handle the most common ones.\n"
msgstr ""

#: ../../../library/email-examples.rst:62
msgid "Up to the prompt, the output from the above is::"
msgstr ""

#: ../../../library/email-examples.rst:64
msgid ""
"To: Penelope Pussycat <\"penelope@example.com\">, Fabrette Pussycat "
"<\"fabrette@example.com\">\n"
"From: Pepé Le Pew <pepe@example.com>\n"
"Subject: Ayons asperges pour le déjeuner\n"
"\n"
"Salut!\n"
"\n"
"Cela ressemble à un excellent recipie[1] déjeuner."
msgstr ""

#: ../../../library/email-examples.rst:74
msgid "Footnotes"
msgstr ""

#: ../../../library/email-examples.rst:75
msgid ""
"Thanks to Matthew Dixon Cowles for the original inspiration and examples."
msgstr ""

#: ../../../library/email-examples.rst:76
msgid "Contributed by Martin Matejek."
msgstr ""

# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.15\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-18 08:39+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../library/profile.rst:5
msgid "The Python Profilers"
msgstr ""

#: ../../../library/profile.rst:7
msgid ""
"**Source code:** :source:`Lib/profile.py`, :source:`Lib/pstats.py`, and :"
"source:`Lib/profile/sample.py`"
msgstr ""

#: ../../../library/profile.rst:14
msgid "Introduction to the profilers"
msgstr ""

#: ../../../library/profile.rst:22
msgid ""
"Python provides both :dfn:`statistical profiling` and :dfn:`deterministic "
"profiling` of Python programs. A :dfn:`profile` is a set of statistics that "
"describes how often and for how long various parts of the program executed. "
"These statistics can be formatted into reports via the :mod:`pstats` module."
msgstr ""

#: ../../../library/profile.rst:27
msgid ""
"The Python standard library provides three different profiling "
"implementations:"
msgstr ""

#: ../../../library/profile.rst:29
msgid "**Statistical Profiler:**"
msgstr ""

#: ../../../library/profile.rst:31
msgid ""
":mod:`profile.sample` provides statistical profiling of running Python "
"processes using periodic stack sampling. It can attach to any running Python "
"process without requiring code modification or restart, making it ideal for "
"production debugging."
msgstr ""

#: ../../../library/profile.rst:35
msgid "**Deterministic Profilers:**"
msgstr ""

#: ../../../library/profile.rst:37
msgid ""
":mod:`cProfile` is recommended for development and testing; it's a C "
"extension with reasonable overhead that makes it suitable for profiling long-"
"running programs.  Based on :mod:`lsprof`, contributed by Brett Rosen and "
"Ted Czotter."
msgstr ""

#: ../../../library/profile.rst:42
msgid ""
":mod:`profile`, a pure Python module whose interface is imitated by :mod:"
"`cProfile`, but which adds significant overhead to profiled programs. If "
"you're trying to extend the profiler in some way, the task might be easier "
"with this module.  Originally designed and written by Jim Roskind."
msgstr ""

#: ../../../library/profile.rst:49
msgid ""
"The profiler modules are designed to provide an execution profile for a "
"given program, not for benchmarking purposes (for that, there is :mod:"
"`timeit` for reasonably accurate results).  This particularly applies to "
"benchmarking Python code against C code: the profilers introduce overhead "
"for Python code, but not for C-level functions, and so the C code would seem "
"faster than any Python one."
msgstr ""

#: ../../../library/profile.rst:56
msgid "**Profiler Comparison:**"
msgstr ""

#: ../../../library/profile.rst:59
msgid "Feature"
msgstr ""

#: ../../../library/profile.rst:59
msgid "Statistical (``profile.sample``)"
msgstr ""

#: ../../../library/profile.rst:59
msgid "Deterministic (``cProfile``)"
msgstr ""

#: ../../../library/profile.rst:59
msgid "Deterministic (``profile``)"
msgstr ""

#: ../../../library/profile.rst:62
msgid "**Target**"
msgstr ""

#: ../../../library/profile.rst:62
msgid "Running process"
msgstr ""

#: ../../../library/profile.rst:62
msgid "Code you run"
msgstr ""

#: ../../../library/profile.rst:64
msgid "**Overhead**"
msgstr ""

#: ../../../library/profile.rst:64
msgid "Virtually none"
msgstr ""

#: ../../../library/profile.rst:64
msgid "Moderate"
msgstr ""

#: ../../../library/profile.rst:64
msgid "High"
msgstr ""

#: ../../../library/profile.rst:66
msgid "**Accuracy**"
msgstr ""

#: ../../../library/profile.rst:66
msgid "Statistical approx."
msgstr ""

#: ../../../library/profile.rst:66
msgid "Exact call counts"
msgstr ""

#: ../../../library/profile.rst:68
msgid "**Setup**"
msgstr ""

#: ../../../library/profile.rst:68
msgid "Attach to any PID"
msgstr ""

#: ../../../library/profile.rst:68
msgid "Instrument code"
msgstr ""

#: ../../../library/profile.rst:70
msgid "**Use Case**"
msgstr ""

#: ../../../library/profile.rst:70
msgid "Production debugging"
msgstr ""

#: ../../../library/profile.rst:70
msgid "Development/testing"
msgstr ""

#: ../../../library/profile.rst:70
msgid "Profiler extension"
msgstr ""

#: ../../../library/profile.rst:72
msgid "**Implementation**"
msgstr ""

#: ../../../library/profile.rst:72
msgid "C extension"
msgstr ""

#: ../../../library/profile.rst:72
msgid "Pure Python"
msgstr ""

#: ../../../library/profile.rst:77
msgid ""
"The statistical profiler (:mod:`profile.sample`) is recommended for most "
"production use cases due to its extremely low overhead and ability to "
"profile running processes without modification. It can attach to any Python "
"process and collect performance data with minimal impact on execution speed, "
"making it ideal for debugging performance issues in live applications."
msgstr ""

#: ../../../library/profile.rst:87
msgid "What Is Statistical Profiling?"
msgstr ""

#: ../../../library/profile.rst:89
msgid ""
":dfn:`Statistical profiling` works by periodically interrupting a running "
"program to capture its current call stack. Rather than monitoring every "
"function entry and exit like deterministic profilers, it takes snapshots at "
"regular intervals to build a statistical picture of where the program spends "
"its time."
msgstr ""

#: ../../../library/profile.rst:95
msgid ""
"The sampling profiler uses process memory reading (via system calls like "
"``process_vm_readv`` on Linux, ``vm_read`` on macOS, and "
"``ReadProcessMemory`` on Windows) to attach to a running Python process and "
"extract stack trace information without requiring any code modification or "
"restart of the target process. This approach provides several key advantages "
"over traditional profiling methods."
msgstr ""

#: ../../../library/profile.rst:102
msgid ""
"The fundamental principle is that if a function appears frequently in the "
"collected stack samples, it is likely consuming significant CPU time. By "
"analyzing thousands of samples, the profiler can accurately estimate the "
"relative time spent in different parts of the program. The statistical "
"nature means that while individual measurements may vary, the aggregate "
"results converge to represent the true performance characteristics of the "
"application."
msgstr ""

#: ../../../library/profile.rst:109
msgid ""
"Since statistical profiling operates externally to the target process, it "
"introduces virtually no overhead to the running program. The profiler "
"process runs separately and reads the target process memory without "
"interrupting its execution. This makes it suitable for profiling production "
"systems where performance impact must be minimized."
msgstr ""

#: ../../../library/profile.rst:115
msgid ""
"The accuracy of statistical profiling improves with the number of samples "
"collected. Short-lived functions may be missed or underrepresented, while "
"long-running functions will be captured proportionally to their execution "
"time. This characteristic makes statistical profiling particularly effective "
"for identifying the most significant performance bottlenecks rather than "
"providing exhaustive coverage of all function calls."
msgstr ""

#: ../../../library/profile.rst:122
msgid ""
"Statistical profiling excels at answering questions like \"which functions "
"consume the most CPU time?\" and \"where should I focus optimization efforts?"
"\" rather than \"exactly how many times was this function called?\" The "
"trade-off between precision and practicality makes it an invaluable tool for "
"performance analysis in real-world applications."
msgstr ""

#: ../../../library/profile.rst:131
msgid "Instant User's Manual"
msgstr ""

#: ../../../library/profile.rst:133
msgid ""
"This section is provided for users that \"don't want to read the manual.\" "
"It provides a very brief overview, and allows a user to rapidly perform "
"profiling on an existing application."
msgstr ""

#: ../../../library/profile.rst:137
msgid "**Statistical Profiling (Recommended for Production):**"
msgstr ""

#: ../../../library/profile.rst:139
msgid "To profile an existing running process::"
msgstr ""

#: ../../../library/profile.rst:143
msgid "To profile with custom settings::"
msgstr ""

#: ../../../library/profile.rst:147
msgid "**Deterministic Profiling (Development/Testing):**"
msgstr ""

#: ../../../library/profile.rst:149
msgid "To profile a function that takes a single argument, you can do::"
msgstr ""

#: ../../../library/profile.rst:155
msgid ""
"(Use :mod:`profile` instead of :mod:`cProfile` if the latter is not "
"available on your system.)"
msgstr ""

#: ../../../library/profile.rst:158
msgid ""
"The above action would run :func:`re.compile` and print profile results like "
"the following::"
msgstr ""

#: ../../../library/profile.rst:175
msgid ""
"The first line indicates that 214 calls were monitored.  Of those calls, 207 "
"were :dfn:`primitive`, meaning that the call was not induced via recursion. "
"The next line: ``Ordered by: cumulative time`` indicates the output is "
"sorted by the ``cumtime`` values. The column headings include:"
msgstr ""

#: ../../../library/profile.rst:180
msgid "ncalls"
msgstr ""

#: ../../../library/profile.rst:181
msgid "for the number of calls."
msgstr ""

#: ../../../library/profile.rst:183
msgid "tottime"
msgstr ""

#: ../../../library/profile.rst:184
msgid ""
"for the total time spent in the given function (and excluding time made in "
"calls to sub-functions)"
msgstr ""

#: ../../../library/profile.rst:187 ../../../library/profile.rst:194
msgid "percall"
msgstr ""

#: ../../../library/profile.rst:188
msgid "is the quotient of ``tottime`` divided by ``ncalls``"
msgstr ""

#: ../../../library/profile.rst:190
msgid "cumtime"
msgstr ""

#: ../../../library/profile.rst:191
msgid ""
"is the cumulative time spent in this and all subfunctions (from invocation "
"till exit). This figure is accurate *even* for recursive functions."
msgstr ""

#: ../../../library/profile.rst:195
msgid "is the quotient of ``cumtime`` divided by primitive calls"
msgstr ""

#: ../../../library/profile.rst:197
msgid "filename:lineno(function)"
msgstr ""

#: ../../../library/profile.rst:198
msgid "provides the respective data of each function"
msgstr ""

#: ../../../library/profile.rst:200
msgid ""
"When there are two numbers in the first column (for example ``3/1``), it "
"means that the function recursed.  The second value is the number of "
"primitive calls and the former is the total number of calls.  Note that when "
"the function does not recurse, these two values are the same, and only the "
"single figure is printed."
msgstr ""

#: ../../../library/profile.rst:206
msgid ""
"Instead of printing the output at the end of the profile run, you can save "
"the results to a file by specifying a filename to the :func:`run` function::"
msgstr ""

#: ../../../library/profile.rst:213
msgid ""
"The :class:`pstats.Stats` class reads profile results from a file and "
"formats them in various ways."
msgstr ""

#: ../../../library/profile.rst:219
msgid "Statistical Profiler Command Line Interface"
msgstr ""

#: ../../../library/profile.rst:223
msgid ""
"The :mod:`profile.sample` module can be invoked as a script to profile "
"running processes::"
msgstr ""

#: ../../../library/profile.rst:227
msgid "**Basic Usage Examples:**"
msgstr ""

#: ../../../library/profile.rst:229
msgid "Profile process 1234 for 10 seconds with default settings::"
msgstr ""

#: ../../../library/profile.rst:233
msgid "Profile with custom interval and duration, save to file::"
msgstr ""

#: ../../../library/profile.rst:237
msgid ""
"Generate collapsed stacks to use with tools like `flamegraph.pl <https://"
"github.com/brendangregg/FlameGraph>`_::"
msgstr ""

#: ../../../library/profile.rst:242
msgid "Profile all threads, sort by total time::"
msgstr ""

#: ../../../library/profile.rst:246
msgid "Profile with real-time sampling statistics::"
msgstr ""

#: ../../../library/profile.rst:250
msgid "**Command Line Options:**"
msgstr ""

#: ../../../library/profile.rst:254
msgid "Process ID of the Python process to profile (required)"
msgstr ""

#: ../../../library/profile.rst:258 ../../../library/profile.rst:362
msgid "Sampling interval in microseconds (default: 100)"
msgstr ""

#: ../../../library/profile.rst:262
msgid "Sampling duration in seconds (default: 10)"
msgstr ""

#: ../../../library/profile.rst:266
msgid "Sample all threads in the process instead of just the main thread"
msgstr ""

#: ../../../library/profile.rst:270
msgid "Print real-time sampling statistics during profiling"
msgstr ""

#: ../../../library/profile.rst:274
msgid "Generate pstats output (default)"
msgstr ""

#: ../../../library/profile.rst:278
msgid "Generate collapsed stack traces for flamegraphs"
msgstr ""

#: ../../../library/profile.rst:282
msgid "Save output to a file"
msgstr ""

#: ../../../library/profile.rst:284
msgid "**Sorting Options (pstats format only):**"
msgstr ""

#: ../../../library/profile.rst:288
msgid "Sort by number of direct samples"
msgstr ""

#: ../../../library/profile.rst:292
msgid "Sort by total time"
msgstr ""

#: ../../../library/profile.rst:296
msgid "Sort by cumulative time (default)"
msgstr ""

#: ../../../library/profile.rst:300
msgid "Sort by sample percentage"
msgstr ""

#: ../../../library/profile.rst:304
msgid "Sort by cumulative sample percentage"
msgstr ""

#: ../../../library/profile.rst:308
msgid "Sort by cumulative samples"
msgstr ""

#: ../../../library/profile.rst:312
msgid "Sort by function name"
msgstr ""

#: ../../../library/profile.rst:316
msgid "Limit the number of rows in the output (default: 15)"
msgstr ""

#: ../../../library/profile.rst:320
msgid "Disable the summary section in the output"
msgstr ""

#: ../../../library/profile.rst:322
msgid "**Understanding Statistical Profile Output:**"
msgstr ""

#: ../../../library/profile.rst:324
msgid ""
"The statistical profiler produces output similar to deterministic profilers "
"but with different column meanings::"
msgstr ""

#: ../../../library/profile.rst:331
msgid "**Column Meanings:**"
msgstr ""

#: ../../../library/profile.rst:333
msgid ""
"**nsamples**: ``direct/cumulative`` - Times function was directly "
"executing / on call stack"
msgstr ""

#: ../../../library/profile.rst:334
msgid ""
"**sample%**: Percentage of total samples where function was directly "
"executing"
msgstr ""

#: ../../../library/profile.rst:335
msgid "**tottime**: Estimated time spent directly in this function"
msgstr ""

#: ../../../library/profile.rst:336
msgid ""
"**cumul%**: Percentage of samples where function was anywhere on call stack"
msgstr ""

#: ../../../library/profile.rst:337
msgid "**cumtime**: Estimated cumulative time including called functions"
msgstr ""

#: ../../../library/profile.rst:338
msgid "**filename:lineno(function)**: Location and name of the function"
msgstr ""

#: ../../../library/profile.rst:343
msgid ":mod:`profile.sample` Module Reference"
msgstr ""

#: ../../../library/profile.rst:348
msgid ""
"This section documents the programmatic interface for the :mod:`profile."
"sample` module. For command-line usage, see :ref:`sampling-profiler-cli`. "
"For conceptual information about statistical profiling, see :ref:"
"`statistical-profiling`"
msgstr ""

#: ../../../library/profile.rst:354
msgid "Sample a Python process and generate profiling data."
msgstr ""

#: ../../../library/profile.rst:356
msgid ""
"This is the main entry point for statistical profiling. It creates a :class:"
"`SampleProfiler`, collects stack traces from the target process, and outputs "
"the results in the specified format."
msgstr ""

#: ../../../library/profile.rst:0
msgid "Parameters"
msgstr ""

#: ../../../library/profile.rst:360 ../../../library/profile.rst:393
msgid "Process ID of the target Python process"
msgstr ""

#: ../../../library/profile.rst:361
msgid "Sort order for pstats output (default: 2 for cumulative time)"
msgstr ""

#: ../../../library/profile.rst:363 ../../../library/profile.rst:405
msgid "Duration to sample in seconds (default: 10)"
msgstr ""

#: ../../../library/profile.rst:364
msgid "Output filename (None for stdout/default naming)"
msgstr ""

#: ../../../library/profile.rst:365
msgid "Whether to sample all threads (default: False)"
msgstr ""

#: ../../../library/profile.rst:366
msgid "Maximum number of functions to display (default: None)"
msgstr ""

#: ../../../library/profile.rst:367
msgid "Whether to show summary statistics (default: True)"
msgstr ""

#: ../../../library/profile.rst:368
msgid "Output format - 'pstats' or 'collapsed' (default: 'pstats')"
msgstr ""

#: ../../../library/profile.rst:369
msgid "Whether to display real-time statistics (default: False)"
msgstr ""

#: ../../../library/profile.rst:0
msgid "Raises"
msgstr ""

#: ../../../library/profile.rst:371
msgid "If output_format is not 'pstats' or 'collapsed'"
msgstr ""

#: ../../../library/profile.rst:373
msgid "Examples::"
msgstr ""

#: ../../../library/profile.rst:387
msgid "Low-level API for the statistical profiler."
msgstr ""

#: ../../../library/profile.rst:389
msgid ""
"This profiler uses periodic stack sampling to collect performance data from "
"running Python processes with minimal overhead. It can attach to any Python "
"process by PID and collect stack traces at regular intervals."
msgstr ""

#: ../../../library/profile.rst:394
msgid "Sampling interval in microseconds"
msgstr ""

#: ../../../library/profile.rst:395
msgid "Whether to sample all threads or just the main thread"
msgstr ""

#: ../../../library/profile.rst:399
msgid "Sample the target process for the specified duration."
msgstr ""

#: ../../../library/profile.rst:401
msgid ""
"Collects stack traces from the target process at regular intervals and "
"passes them to the provided collector for processing."
msgstr ""

#: ../../../library/profile.rst:404
msgid "Object that implements ``collect()`` method to process stack traces"
msgstr ""

#: ../../../library/profile.rst:407
msgid ""
"The method tracks sampling statistics and can display real-time information "
"if realtime_stats is enabled."
msgstr ""

#: ../../../library/profile.rst:412
msgid ":ref:`sampling-profiler-cli`"
msgstr ""

#: ../../../library/profile.rst:413
msgid "Command-line interface documentation for the statistical profiler."
msgstr ""

#: ../../../library/profile.rst:416
msgid "Deterministic Profiler Command Line Interface"
msgstr ""

#: ../../../library/profile.rst:420
msgid ""
"The files :mod:`cProfile` and :mod:`profile` can also be invoked as a script "
"to profile another script.  For example::"
msgstr ""

#: ../../../library/profile.rst:427
msgid "Writes the profile results to a file instead of to stdout."
msgstr ""

#: ../../../library/profile.rst:431
msgid ""
"Specifies one of the :func:`~pstats.Stats.sort_stats` sort values to sort "
"the output by. This only applies when :option:`-o <cProfile -o>` is not "
"supplied."
msgstr ""

#: ../../../library/profile.rst:437
msgid "Specifies that a module is being profiled instead of a script."
msgstr ""

#: ../../../library/profile.rst:439
msgid "Added the ``-m`` option to :mod:`cProfile`."
msgstr ""

#: ../../../library/profile.rst:442
msgid "Added the ``-m`` option to :mod:`profile`."
msgstr ""

#: ../../../library/profile.rst:445
msgid ""
"The :mod:`pstats` module's :class:`~pstats.Stats` class has a variety of "
"methods for manipulating and printing the data saved into a profile results "
"file::"
msgstr ""

#: ../../../library/profile.rst:453
msgid ""
"The :meth:`~pstats.Stats.strip_dirs` method removed the extraneous path from "
"all the module names. The :meth:`~pstats.Stats.sort_stats` method sorted all "
"the entries according to the standard module/line/name string that is "
"printed. The :meth:`~pstats.Stats.print_stats` method printed out all the "
"statistics.  You might try the following sort calls::"
msgstr ""

#: ../../../library/profile.rst:462
msgid ""
"The first call will actually sort the list by function name, and the second "
"call will print out the statistics.  The following are some interesting "
"calls to experiment with::"
msgstr ""

#: ../../../library/profile.rst:468
msgid ""
"This sorts the profile by cumulative time in a function, and then only "
"prints the ten most significant lines.  If you want to understand what "
"algorithms are taking time, the above line is what you would use."
msgstr ""

#: ../../../library/profile.rst:472
msgid ""
"If you were looking to see what functions were looping a lot, and taking a "
"lot of time, you would do::"
msgstr ""

#: ../../../library/profile.rst:477
msgid ""
"to sort according to time spent within each function, and then print the "
"statistics for the top ten functions."
msgstr ""

#: ../../../library/profile.rst:480
msgid "You might also try::"
msgstr ""

#: ../../../library/profile.rst:484
msgid ""
"This will sort all the statistics by file name, and then print out "
"statistics for only the class init methods (since they are spelled with "
"``__init__`` in them).  As one final example, you could try::"
msgstr ""

#: ../../../library/profile.rst:490
msgid ""
"This line sorts statistics with a primary key of time, and a secondary key "
"of cumulative time, and then prints out some of the statistics. To be "
"specific, the list is first culled down to 50% (re: ``.5``) of its original "
"size, then only lines containing ``init`` are maintained, and that sub-sub-"
"list is printed."
msgstr ""

#: ../../../library/profile.rst:495
msgid ""
"If you wondered what functions called the above functions, you could now "
"(``p`` is still sorted according to the last criteria) do::"
msgstr ""

#: ../../../library/profile.rst:500
msgid "and you would get a list of callers for each of the listed functions."
msgstr ""

#: ../../../library/profile.rst:502
msgid ""
"If you want more functionality, you're going to have to read the manual, or "
"guess what the following functions do::"
msgstr ""

#: ../../../library/profile.rst:508
msgid ""
"Invoked as a script, the :mod:`pstats` module is a statistics browser for "
"reading and examining profile dumps.  It has a simple line-oriented "
"interface (implemented using :mod:`cmd`) and interactive help."
msgstr ""

#: ../../../library/profile.rst:513
msgid ":mod:`profile` and :mod:`cProfile` Module Reference"
msgstr ""

#: ../../../library/profile.rst:519
msgid ""
"Both the :mod:`profile` and :mod:`cProfile` modules provide the following "
"functions:"
msgstr ""

#: ../../../library/profile.rst:524
msgid ""
"This function takes a single argument that can be passed to the :func:`exec` "
"function, and an optional file name.  In all cases this routine executes::"
msgstr ""

#: ../../../library/profile.rst:529
msgid ""
"and gathers profiling statistics from the execution. If no file name is "
"present, then this function automatically creates a :class:`~pstats.Stats` "
"instance and prints a simple profiling report. If the sort value is "
"specified, it is passed to this :class:`~pstats.Stats` instance to control "
"how the results are sorted."
msgstr ""

#: ../../../library/profile.rst:537
msgid ""
"This function is similar to :func:`run`, with added arguments to supply the "
"globals and locals mappings for the *command* string. This routine executes::"
msgstr ""

#: ../../../library/profile.rst:543
msgid "and gathers profiling statistics as in the :func:`run` function above."
msgstr ""

#: ../../../library/profile.rst:547
msgid ""
"This class is normally only used if more precise control over profiling is "
"needed than what the :func:`cProfile.run` function provides."
msgstr ""

#: ../../../library/profile.rst:550
msgid ""
"A custom timer can be supplied for measuring how long code takes to run via "
"the *timer* argument. This must be a function that returns a single number "
"representing the current time. If the number is an integer, the *timeunit* "
"specifies a multiplier that specifies the duration of each unit of time. For "
"example, if the timer returns times measured in thousands of seconds, the "
"time unit would be ``.001``."
msgstr ""

#: ../../../library/profile.rst:557
msgid ""
"Directly using the :class:`Profile` class allows formatting profile results "
"without writing the profile data to a file::"
msgstr ""

#: ../../../library/profile.rst:572
msgid ""
"The :class:`Profile` class can also be used as a context manager (supported "
"only in :mod:`cProfile` module. see :ref:`typecontextmanager`)::"
msgstr ""

#: ../../../library/profile.rst:582
msgid "Added context manager support."
msgstr ""

#: ../../../library/profile.rst:587
msgid "Start collecting profiling data. Only in :mod:`cProfile`."
msgstr ""

#: ../../../library/profile.rst:591
msgid "Stop collecting profiling data. Only in :mod:`cProfile`."
msgstr ""

#: ../../../library/profile.rst:595
msgid ""
"Stop collecting profiling data and record the results internally as the "
"current profile."
msgstr ""

#: ../../../library/profile.rst:600
msgid ""
"Create a :class:`~pstats.Stats` object based on the current profile and "
"print the results to stdout."
msgstr ""

#: ../../../library/profile.rst:603
msgid ""
"The *sort* parameter specifies the sorting order of the displayed "
"statistics. It accepts a single key or a tuple of keys to enable multi-level "
"sorting, as in :func:`Stats.sort_stats <pstats.Stats.sort_stats>`."
msgstr ""

#: ../../../library/profile.rst:607
msgid ":meth:`~Profile.print_stats` now accepts a tuple of keys."
msgstr ""

#: ../../../library/profile.rst:612
msgid "Write the results of the current profile to *filename*."
msgstr ""

#: ../../../library/profile.rst:616
msgid "Profile the cmd via :func:`exec`."
msgstr ""

#: ../../../library/profile.rst:620
msgid ""
"Profile the cmd via :func:`exec` with the specified global and local "
"environment."
msgstr ""

#: ../../../library/profile.rst:625
msgid "Profile ``func(*args, **kwargs)``"
msgstr ""

#: ../../../library/profile.rst:627
msgid ""
"Note that profiling will only work if the called command/function actually "
"returns.  If the interpreter is terminated (e.g. via a :func:`sys.exit` call "
"during the called command/function execution) no profiling results will be "
"printed."
msgstr ""

#: ../../../library/profile.rst:635
msgid "The :class:`Stats` Class"
msgstr ""

#: ../../../library/profile.rst:637
msgid ""
"Analysis of the profiler data is done using the :class:`~pstats.Stats` class."
msgstr ""

#: ../../../library/profile.rst:644
msgid ""
"This class constructor creates an instance of a \"statistics object\" from a "
"*filename* (or list of filenames) or from a :class:`Profile` instance. "
"Output will be printed to the stream specified by *stream*."
msgstr ""

#: ../../../library/profile.rst:648
msgid ""
"The file selected by the above constructor must have been created by the "
"corresponding version of :mod:`profile` or :mod:`cProfile`.  To be specific, "
"there is *no* file compatibility guaranteed with future versions of this "
"profiler, and there is no compatibility with files produced by other "
"profilers, or the same profiler run on a different operating system.  If "
"several files are provided, all the statistics for identical functions will "
"be coalesced, so that an overall view of several processes can be considered "
"in a single report.  If additional files need to be combined with data in an "
"existing :class:`~pstats.Stats` object, the :meth:`~pstats.Stats.add` method "
"can be used."
msgstr ""

#: ../../../library/profile.rst:659
msgid ""
"Instead of reading the profile data from a file, a :class:`cProfile.Profile` "
"or :class:`profile.Profile` object can be used as the profile data source."
msgstr ""

#: ../../../library/profile.rst:662
msgid ":class:`Stats` objects have the following methods:"
msgstr ""

#: ../../../library/profile.rst:666
msgid ""
"This method for the :class:`Stats` class removes all leading path "
"information from file names.  It is very useful in reducing the size of the "
"printout to fit within (close to) 80 columns.  This method modifies the "
"object, and the stripped information is lost.  After performing a strip "
"operation, the object is considered to have its entries in a \"random\" "
"order, as it was just after object initialization and loading. If :meth:"
"`~pstats.Stats.strip_dirs` causes two function names to be indistinguishable "
"(they are on the same line of the same filename, and have the same function "
"name), then the statistics for these two entries are accumulated into a "
"single entry."
msgstr ""

#: ../../../library/profile.rst:680
msgid ""
"This method of the :class:`Stats` class accumulates additional profiling "
"information into the current profiling object.  Its arguments should refer "
"to filenames created by the corresponding version of :func:`profile.run` or :"
"func:`cProfile.run`. Statistics for identically named (re: file, line, name) "
"functions are automatically accumulated into single function statistics."
msgstr ""

#: ../../../library/profile.rst:690
msgid ""
"Save the data loaded into the :class:`Stats` object to a file named "
"*filename*.  The file is created if it does not exist, and is overwritten if "
"it already exists.  This is equivalent to the method of the same name on "
"the :class:`profile.Profile` and :class:`cProfile.Profile` classes."
msgstr ""

#: ../../../library/profile.rst:698
msgid ""
"This method modifies the :class:`Stats` object by sorting it according to "
"the supplied criteria.  The argument can be either a string or a SortKey "
"enum identifying the basis of a sort (example: ``'time'``, ``'name'``, "
"``SortKey.TIME`` or ``SortKey.NAME``). The SortKey enums argument have "
"advantage over the string argument in that it is more robust and less error "
"prone."
msgstr ""

#: ../../../library/profile.rst:705
msgid ""
"When more than one key is provided, then additional keys are used as "
"secondary criteria when there is equality in all keys selected before them.  "
"For example, ``sort_stats(SortKey.NAME, SortKey.FILE)`` will sort all the "
"entries according to their function name, and resolve all ties (identical "
"function names) by sorting by file name."
msgstr ""

#: ../../../library/profile.rst:711
msgid ""
"For the string argument, abbreviations can be used for any key names, as "
"long as the abbreviation is unambiguous."
msgstr ""

#: ../../../library/profile.rst:714
msgid "The following are the valid string and SortKey:"
msgstr ""

#: ../../../library/profile.rst:717
msgid "Valid String Arg"
msgstr ""

#: ../../../library/profile.rst:717
msgid "Valid enum Arg"
msgstr ""

#: ../../../library/profile.rst:717
msgid "Meaning"
msgstr ""

#: ../../../library/profile.rst:719
msgid "``'calls'``"
msgstr ""

#: ../../../library/profile.rst:719
msgid "SortKey.CALLS"
msgstr ""

#: ../../../library/profile.rst:719 ../../../library/profile.rst:731
msgid "call count"
msgstr ""

#: ../../../library/profile.rst:721
msgid "``'cumulative'``"
msgstr ""

#: ../../../library/profile.rst:721
msgid "SortKey.CUMULATIVE"
msgstr ""

#: ../../../library/profile.rst:721 ../../../library/profile.rst:723
msgid "cumulative time"
msgstr ""

#: ../../../library/profile.rst:723
msgid "``'cumtime'``"
msgstr ""

#: ../../../library/profile.rst:723 ../../../library/profile.rst:725
#: ../../../library/profile.rst:729 ../../../library/profile.rst:731
#: ../../../library/profile.rst:745
msgid "N/A"
msgstr ""

#: ../../../library/profile.rst:725
msgid "``'file'``"
msgstr ""

#: ../../../library/profile.rst:725 ../../../library/profile.rst:727
#: ../../../library/profile.rst:729
msgid "file name"
msgstr ""

#: ../../../library/profile.rst:727
msgid "``'filename'``"
msgstr ""

#: ../../../library/profile.rst:727
msgid "SortKey.FILENAME"
msgstr ""

#: ../../../library/profile.rst:729
msgid "``'module'``"
msgstr ""

#: ../../../library/profile.rst:731
msgid "``'ncalls'``"
msgstr ""

#: ../../../library/profile.rst:733
msgid "``'pcalls'``"
msgstr ""

#: ../../../library/profile.rst:733
msgid "SortKey.PCALLS"
msgstr ""

#: ../../../library/profile.rst:733
msgid "primitive call count"
msgstr ""

#: ../../../library/profile.rst:735
msgid "``'line'``"
msgstr ""

#: ../../../library/profile.rst:735
msgid "SortKey.LINE"
msgstr ""

#: ../../../library/profile.rst:735
msgid "line number"
msgstr ""

#: ../../../library/profile.rst:737
msgid "``'name'``"
msgstr ""

#: ../../../library/profile.rst:737
msgid "SortKey.NAME"
msgstr ""

#: ../../../library/profile.rst:737
msgid "function name"
msgstr ""

#: ../../../library/profile.rst:739
msgid "``'nfl'``"
msgstr ""

#: ../../../library/profile.rst:739
msgid "SortKey.NFL"
msgstr ""

#: ../../../library/profile.rst:739
msgid "name/file/line"
msgstr ""

#: ../../../library/profile.rst:741
msgid "``'stdname'``"
msgstr ""

#: ../../../library/profile.rst:741
msgid "SortKey.STDNAME"
msgstr ""

#: ../../../library/profile.rst:741
msgid "standard name"
msgstr ""

#: ../../../library/profile.rst:743
msgid "``'time'``"
msgstr ""

#: ../../../library/profile.rst:743
msgid "SortKey.TIME"
msgstr ""

#: ../../../library/profile.rst:743 ../../../library/profile.rst:745
msgid "internal time"
msgstr ""

#: ../../../library/profile.rst:745
msgid "``'tottime'``"
msgstr ""

#: ../../../library/profile.rst:748
msgid ""
"Note that all sorts on statistics are in descending order (placing most time "
"consuming items first), where as name, file, and line number searches are in "
"ascending order (alphabetical). The subtle distinction between ``SortKey."
"NFL`` and ``SortKey.STDNAME`` is that the standard name is a sort of the "
"name as printed, which means that the embedded line numbers get compared in "
"an odd way.  For example, lines 3, 20, and 40 would (if the file names were "
"the same) appear in the string order 20, 3 and 40. In contrast, ``SortKey."
"NFL`` does a numeric compare of the line numbers. In fact, "
"``sort_stats(SortKey.NFL)`` is the same as ``sort_stats(SortKey.NAME, "
"SortKey.FILENAME, SortKey.LINE)``."
msgstr ""

#: ../../../library/profile.rst:759
msgid ""
"For backward-compatibility reasons, the numeric arguments ``-1``, ``0``, "
"``1``, and ``2`` are permitted.  They are interpreted as ``'stdname'``, "
"``'calls'``, ``'time'``, and ``'cumulative'`` respectively.  If this old "
"style format (numeric) is used, only one sort key (the numeric key) will be "
"used, and additional arguments will be silently ignored."
msgstr ""

#: ../../../library/profile.rst:767
msgid "Added the SortKey enum."
msgstr ""

#: ../../../library/profile.rst:772
msgid ""
"This method for the :class:`Stats` class reverses the ordering of the basic "
"list within the object.  Note that by default ascending vs descending order "
"is properly selected based on the sort key of choice."
msgstr ""

#: ../../../library/profile.rst:782
msgid ""
"This method for the :class:`Stats` class prints out a report as described in "
"the :func:`profile.run` definition."
msgstr ""

#: ../../../library/profile.rst:785
msgid ""
"The order of the printing is based on the last :meth:`~pstats.Stats."
"sort_stats` operation done on the object (subject to caveats in :meth:"
"`~pstats.Stats.add` and :meth:`~pstats.Stats.strip_dirs`)."
msgstr ""

#: ../../../library/profile.rst:790
msgid ""
"The arguments provided (if any) can be used to limit the list down to the "
"significant entries.  Initially, the list is taken to be the complete set of "
"profiled functions.  Each restriction is either an integer (to select a "
"count of lines), or a decimal fraction between 0.0 and 1.0 inclusive (to "
"select a percentage of lines), or a string that will be interpreted as a "
"regular expression (to pattern match the standard name that is printed). If "
"several restrictions are provided, then they are applied sequentially. For "
"example::"
msgstr ""

#: ../../../library/profile.rst:801
msgid ""
"would first limit the printing to first 10% of list, and then only print "
"functions that were part of filename :file:`.\\*foo:`.  In contrast, the "
"command::"
msgstr ""

#: ../../../library/profile.rst:807
msgid ""
"would limit the list to all functions having file names :file:`.\\*foo:`, "
"and then proceed to only print the first 10% of them."
msgstr ""

#: ../../../library/profile.rst:813
msgid ""
"This method for the :class:`Stats` class prints a list of all functions that "
"called each function in the profiled database.  The ordering is identical to "
"that provided by :meth:`~pstats.Stats.print_stats`, and the definition of "
"the restricting argument is also identical.  Each caller is reported on its "
"own line.  The format differs slightly depending on the profiler that "
"produced the stats:"
msgstr ""

#: ../../../library/profile.rst:820
msgid ""
"With :mod:`profile`, a number is shown in parentheses after each caller to "
"show how many times this specific call was made.  For convenience, a second "
"non-parenthesized number repeats the cumulative time spent in the function "
"at the right."
msgstr ""

#: ../../../library/profile.rst:825
msgid ""
"With :mod:`cProfile`, each caller is preceded by three numbers: the number "
"of times this specific call was made, and the total and cumulative times "
"spent in the current function while it was invoked by this specific caller."
msgstr ""

#: ../../../library/profile.rst:833
msgid ""
"This method for the :class:`Stats` class prints a list of all function that "
"were called by the indicated function.  Aside from this reversal of "
"direction of calls (re: called vs was called by), the arguments and ordering "
"are identical to the :meth:`~pstats.Stats.print_callers` method."
msgstr ""

#: ../../../library/profile.rst:841
msgid ""
"This method returns an instance of StatsProfile, which contains a mapping of "
"function names to instances of FunctionProfile. Each FunctionProfile "
"instance holds information related to the function's profile such as how "
"long the function took to run, how many times it was called, etc..."
msgstr ""

#: ../../../library/profile.rst:846
msgid ""
"Added the following dataclasses: StatsProfile, FunctionProfile. Added the "
"following function: get_stats_profile."
msgstr ""

#: ../../../library/profile.rst:853
msgid "What Is Deterministic Profiling?"
msgstr ""

#: ../../../library/profile.rst:855
msgid ""
":dfn:`Deterministic profiling` is meant to reflect the fact that all "
"*function call*, *function return*, and *exception* events are monitored, "
"and precise timings are made for the intervals between these events (during "
"which time the user's code is executing).  In contrast, :dfn:`statistical "
"profiling` (which is provided by the :mod:`profile.sample` module) "
"periodically samples the effective instruction pointer, and deduces where "
"time is being spent.  The latter technique traditionally involves less "
"overhead (as the code does not need to be instrumented), but provides only "
"relative indications of where time is being spent."
msgstr ""

#: ../../../library/profile.rst:864
msgid ""
"In Python, since there is an interpreter active during execution, the "
"presence of instrumented code is not required in order to do deterministic "
"profiling. Python automatically provides a :dfn:`hook` (optional callback) "
"for each event. In addition, the interpreted nature of Python tends to add "
"so much overhead to execution, that deterministic profiling tends to only "
"add small processing overhead in typical applications.  The result is that "
"deterministic profiling is not that expensive, yet provides extensive run "
"time statistics about the execution of a Python program."
msgstr ""

#: ../../../library/profile.rst:873
msgid ""
"Call count statistics can be used to identify bugs in code (surprising "
"counts), and to identify possible inline-expansion points (high call "
"counts).  Internal time statistics can be used to identify \"hot loops\" "
"that should be carefully optimized.  Cumulative time statistics should be "
"used to identify high level errors in the selection of algorithms.  Note "
"that the unusual handling of cumulative times in this profiler allows "
"statistics for recursive implementations of algorithms to be directly "
"compared to iterative implementations."
msgstr ""

#: ../../../library/profile.rst:886
msgid "Limitations"
msgstr ""

#: ../../../library/profile.rst:888
msgid ""
"One limitation has to do with accuracy of timing information. There is a "
"fundamental problem with deterministic profilers involving accuracy.  The "
"most obvious restriction is that the underlying \"clock\" is only ticking at "
"a rate (typically) of about .001 seconds.  Hence no measurements will be "
"more accurate than the underlying clock.  If enough measurements are taken, "
"then the \"error\" will tend to average out. Unfortunately, removing this "
"first error induces a second source of error."
msgstr ""

#: ../../../library/profile.rst:896
msgid ""
"The second problem is that it \"takes a while\" from when an event is "
"dispatched until the profiler's call to get the time actually *gets* the "
"state of the clock.  Similarly, there is a certain lag when exiting the "
"profiler event handler from the time that the clock's value was obtained "
"(and then squirreled away), until the user's code is once again executing.  "
"As a result, functions that are called many times, or call many functions, "
"will typically accumulate this error. The error that accumulates in this "
"fashion is typically less than the accuracy of the clock (less than one "
"clock tick), but it *can* accumulate and become very significant."
msgstr ""

#: ../../../library/profile.rst:906
msgid ""
"The problem is more important with :mod:`profile` than with the lower-"
"overhead :mod:`cProfile`.  For this reason, :mod:`profile` provides a means "
"of calibrating itself for a given platform so that this error can be "
"probabilistically (on the average) removed. After the profiler is "
"calibrated, it will be more accurate (in a least square sense), but it will "
"sometimes produce negative numbers (when call counts are exceptionally low, "
"and the gods of probability work against you :-). )  Do *not* be alarmed by "
"negative numbers in the profile.  They should *only* appear if you have "
"calibrated your profiler, and the results are actually better than without "
"calibration."
msgstr ""

#: ../../../library/profile.rst:920
msgid "Calibration"
msgstr ""

#: ../../../library/profile.rst:922
msgid ""
"The profiler of the :mod:`profile` module subtracts a constant from each "
"event handling time to compensate for the overhead of calling the time "
"function, and socking away the results.  By default, the constant is 0. The "
"following procedure can be used to obtain a better constant for a given "
"platform (see :ref:`profile-limitations`). ::"
msgstr ""

#: ../../../library/profile.rst:933
msgid ""
"The method executes the number of Python calls given by the argument, "
"directly and again under the profiler, measuring the time for both. It then "
"computes the hidden overhead per profiler event, and returns that as a "
"float.  For example, on a 1.8Ghz Intel Core i5 running macOS, and using "
"Python's time.process_time() as the timer, the magical number is about "
"4.04e-6."
msgstr ""

#: ../../../library/profile.rst:939
msgid ""
"The object of this exercise is to get a fairly consistent result. If your "
"computer is *very* fast, or your timer function has poor resolution, you "
"might have to pass 100000, or even 1000000, to get consistent results."
msgstr ""

#: ../../../library/profile.rst:943
msgid ""
"When you have a consistent answer, there are three ways you can use it::"
msgstr ""

#: ../../../library/profile.rst:957
msgid ""
"If you have a choice, you are better off choosing a smaller constant, and "
"then your results will \"less often\" show up as negative in profile "
"statistics."
msgstr ""

#: ../../../library/profile.rst:963
msgid "Using a custom timer"
msgstr ""

#: ../../../library/profile.rst:965
msgid ""
"If you want to change how current time is determined (for example, to force "
"use of wall-clock time or elapsed process time), pass the timing function "
"you want to the :class:`Profile` class constructor::"
msgstr ""

#: ../../../library/profile.rst:971
msgid ""
"The resulting profiler will then call ``your_time_func``. Depending on "
"whether you are using :class:`profile.Profile` or :class:`cProfile.Profile`, "
"``your_time_func``'s return value will be interpreted differently:"
msgstr ""

#: ../../../library/profile.rst:975
msgid ":class:`profile.Profile`"
msgstr ""

#: ../../../library/profile.rst:976
msgid ""
"``your_time_func`` should return a single number, or a list of numbers whose "
"sum is the current time (like what :func:`os.times` returns).  If the "
"function returns a single time number, or the list of returned numbers has "
"length 2, then you will get an especially fast version of the dispatch "
"routine."
msgstr ""

#: ../../../library/profile.rst:982
msgid ""
"Be warned that you should calibrate the profiler class for the timer "
"function that you choose (see :ref:`profile-calibration`).  For most "
"machines, a timer that returns a lone integer value will provide the best "
"results in terms of low overhead during profiling.  (:func:`os.times` is "
"*pretty* bad, as it returns a tuple of floating-point values).  If you want "
"to substitute a better timer in the cleanest fashion, derive a class and "
"hardwire a replacement dispatch method that best handles your timer call, "
"along with the appropriate calibration constant."
msgstr ""

#: ../../../library/profile.rst:991
msgid ":class:`cProfile.Profile`"
msgstr ""

#: ../../../library/profile.rst:992
msgid ""
"``your_time_func`` should return a single number.  If it returns integers, "
"you can also invoke the class constructor with a second argument specifying "
"the real duration of one unit of time.  For example, if "
"``your_integer_time_func`` returns times measured in thousands of seconds, "
"you would construct the :class:`Profile` instance as follows::"
msgstr ""

#: ../../../library/profile.rst:1000
msgid ""
"As the :class:`cProfile.Profile` class cannot be calibrated, custom timer "
"functions should be used with care and should be as fast as possible.  For "
"the best results with a custom timer, it might be necessary to hard-code it "
"in the C source of the internal :mod:`!_lsprof` module."
msgstr ""

#: ../../../library/profile.rst:1005
msgid ""
"Python 3.3 adds several new functions in :mod:`time` that can be used to "
"make precise measurements of process or wall-clock time. For example, see :"
"func:`time.perf_counter`."
msgstr ""

#: ../../../library/profile.rst:16
msgid "statistical profiling"
msgstr ""

#: ../../../library/profile.rst:16
msgid "profiling, statistical"
msgstr ""

#: ../../../library/profile.rst:16
msgid "deterministic profiling"
msgstr ""

#: ../../../library/profile.rst:16
msgid "profiling, deterministic"
msgstr ""

# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.15\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-10 15:08+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../howto/perf_profiling.rst:7
msgid "Python support for the ``perf map`` compatible profilers"
msgstr ""

#: ../../../howto/perf_profiling.rst:0
msgid "author"
msgstr ""

#: ../../../howto/perf_profiling.rst:9
msgid "Pablo Galindo"
msgstr ""

#: ../../../howto/perf_profiling.rst:11
msgid ""
"`The Linux perf profiler <https://perf.wiki.kernel.org>`_ and `samply "
"<https://github.com/mstange/samply>`_ are powerful tools that allow you to "
"profile and obtain information about the performance of your application. "
"Both tools have vibrant ecosystems that aid with the analysis of the data "
"they produce."
msgstr ""

#: ../../../howto/perf_profiling.rst:16
msgid ""
"The main problem with using these profilers with Python applications is that "
"they only get information about native symbols, that is, the names of "
"functions and procedures written in C. This means that the names and file "
"names of Python functions in your code will not appear in the profiler "
"output."
msgstr ""

#: ../../../howto/perf_profiling.rst:21
msgid ""
"Since Python 3.12, the interpreter can run in a special mode that allows "
"Python functions to appear in the output of compatible profilers. When this "
"mode is enabled, the interpreter will interpose a small piece of code "
"compiled on the fly before the execution of every Python function and it "
"will teach the profiler the relationship between this piece of code and the "
"associated Python function using :doc:`perf map files <../c-api/perfmaps>`."
msgstr ""

#: ../../../howto/perf_profiling.rst:30
msgid ""
"Support for profiling is available on Linux and macOS on select "
"architectures. Perf is available on Linux, while samply can be used on both "
"Linux and macOS. samply support on macOS is available starting from Python "
"3.15. Check the output of the ``configure`` build step or check the output "
"of ``python -m sysconfig | grep HAVE_PERF_TRAMPOLINE`` to see if your system "
"is supported."
msgstr ""

#: ../../../howto/perf_profiling.rst:37
msgid "For example, consider the following script:"
msgstr ""

#: ../../../howto/perf_profiling.rst:39
msgid ""
"def foo(n):\n"
"    result = 0\n"
"    for _ in range(n):\n"
"        result += 1\n"
"    return result\n"
"\n"
"def bar(n):\n"
"    foo(n)\n"
"\n"
"def baz(n):\n"
"    bar(n)\n"
"\n"
"if __name__ == \"__main__\":\n"
"    baz(1000000)"
msgstr ""

#: ../../../howto/perf_profiling.rst:56
msgid "We can run ``perf`` to sample CPU stack traces at 9999 hertz::"
msgstr ""

#: ../../../howto/perf_profiling.rst:58
msgid "$ perf record -F 9999 -g -o perf.data python my_script.py"
msgstr ""

#: ../../../howto/perf_profiling.rst:60
msgid "Then we can use ``perf report`` to analyze the data:"
msgstr ""

#: ../../../howto/perf_profiling.rst:62
msgid ""
"$ perf report --stdio -n -g\n"
"\n"
"# Children      Self       Samples  Command     Shared Object       Symbol\n"
"# ........  ........  ............  ..........  ..................  ..........................................\n"
"#\n"
"    91.08%     0.00%             0  python.exe  python.exe          [.] "
"_start\n"
"            |\n"
"            ---_start\n"
"            |\n"
"                --90.71%--__libc_start_main\n"
"                        Py_BytesMain\n"
"                        |\n"
"                        |--56.88%--pymain_run_python.constprop.0\n"
"                        |          |\n"
"                        |          |--56.13%--_PyRun_AnyFileObject\n"
"                        |          |          _PyRun_SimpleFileObject\n"
"                        |          |          |\n"
"                        |          |          |--55.02%--run_mod\n"
"                        |          |          |          |\n"
"                        |          |          |           --54.65%--"
"PyEval_EvalCode\n"
"                        |          |          |                     "
"_PyEval_EvalFrameDefault\n"
"                        |          |          |                     "
"PyObject_Vectorcall\n"
"                        |          |          |                     "
"_PyEval_Vector\n"
"                        |          |          |                     "
"_PyEval_EvalFrameDefault\n"
"                        |          |          |                     "
"PyObject_Vectorcall\n"
"                        |          |          |                     "
"_PyEval_Vector\n"
"                        |          |          |                     "
"_PyEval_EvalFrameDefault\n"
"                        |          |          |                     "
"PyObject_Vectorcall\n"
"                        |          |          |                     "
"_PyEval_Vector\n"
"                        |          |          |                     |\n"
"                        |          |          |                     "
"|--51.67%--_PyEval_EvalFrameDefault\n"
"                        |          |          |                     "
"|          |\n"
"                        |          |          |                     "
"|          |--11.52%--_PyCompactLong_Add\n"
"                        |          |          |                     "
"|          |          |\n"
"                        |          |          |                     "
"|          |          |--2.97%--_PyObject_Malloc\n"
"..."
msgstr ""

#: ../../../howto/perf_profiling.rst:101
msgid ""
"As you can see, the Python functions are not shown in the output, only "
"``_PyEval_EvalFrameDefault`` (the function that evaluates the Python "
"bytecode) shows up. Unfortunately that's not very useful because all Python "
"functions use the same C function to evaluate bytecode so we cannot know "
"which Python function corresponds to which bytecode-evaluating function."
msgstr ""

#: ../../../howto/perf_profiling.rst:106
msgid ""
"Instead, if we run the same experiment with ``perf`` support enabled we get:"
msgstr ""

#: ../../../howto/perf_profiling.rst:108
msgid ""
"$ perf report --stdio -n -g\n"
"\n"
"# Children      Self       Samples  Command     Shared Object       Symbol\n"
"# ........  ........  ............  ..........  ..................  .....................................................................\n"
"#\n"
"    90.58%     0.36%             1  python.exe  python.exe          [.] "
"_start\n"
"            |\n"
"            ---_start\n"
"            |\n"
"                --89.86%--__libc_start_main\n"
"                        Py_BytesMain\n"
"                        |\n"
"                        |--55.43%--pymain_run_python.constprop.0\n"
"                        |          |\n"
"                        |          |--54.71%--_PyRun_AnyFileObject\n"
"                        |          |          _PyRun_SimpleFileObject\n"
"                        |          |          |\n"
"                        |          |          |--53.62%--run_mod\n"
"                        |          |          |          |\n"
"                        |          |          |           --53.26%--"
"PyEval_EvalCode\n"
"                        |          |          |                     py::"
"<module>:/src/script.py\n"
"                        |          |          |                     "
"_PyEval_EvalFrameDefault\n"
"                        |          |          |                     "
"PyObject_Vectorcall\n"
"                        |          |          |                     "
"_PyEval_Vector\n"
"                        |          |          |                     py::baz:/"
"src/script.py\n"
"                        |          |          |                     "
"_PyEval_EvalFrameDefault\n"
"                        |          |          |                     "
"PyObject_Vectorcall\n"
"                        |          |          |                     "
"_PyEval_Vector\n"
"                        |          |          |                     py::bar:/"
"src/script.py\n"
"                        |          |          |                     "
"_PyEval_EvalFrameDefault\n"
"                        |          |          |                     "
"PyObject_Vectorcall\n"
"                        |          |          |                     "
"_PyEval_Vector\n"
"                        |          |          |                     py::foo:/"
"src/script.py\n"
"                        |          |          |                     |\n"
"                        |          |          |                     "
"|--51.81%--_PyEval_EvalFrameDefault\n"
"                        |          |          |                     "
"|          |\n"
"                        |          |          |                     "
"|          |--13.77%--_PyCompactLong_Add\n"
"                        |          |          |                     "
"|          |          |\n"
"                        |          |          |                     "
"|          |          |--3.26%--_PyObject_Malloc"
msgstr ""

#: ../../../howto/perf_profiling.rst:153
msgid "Using the samply profiler"
msgstr ""

#: ../../../howto/perf_profiling.rst:155
msgid ""
"samply is a modern profiler that can be used as an alternative to perf. It "
"uses the same perf map files that Python generates, making it compatible "
"with Python's profiling support. samply is particularly useful on macOS "
"where perf is not available."
msgstr ""

#: ../../../howto/perf_profiling.rst:160
msgid ""
"To use samply with Python, first install it following the instructions at "
"https://github.com/mstange/samply, then run::"
msgstr ""

#: ../../../howto/perf_profiling.rst:163
msgid "$ samply record PYTHONPERFSUPPORT=1 python my_script.py"
msgstr ""

#: ../../../howto/perf_profiling.rst:165
msgid ""
"This will open a web interface where you can analyze the profiling data "
"interactively. The advantage of samply is that it provides a modern web-"
"based interface for analyzing profiling data and works on both Linux and "
"macOS."
msgstr ""

#: ../../../howto/perf_profiling.rst:170
msgid ""
"On macOS, samply support requires Python 3.15 or later. Also on macOS, "
"samply can't profile signed Python executables due to restrictions by macOS. "
"You can profile with Python binaries that you've compiled yourself, or which "
"are unsigned or locally-signed (such as anything installed by Homebrew). In "
"order to attach to running processes on macOS, run ``samply setup`` once "
"(and every time samply is updated) to self-sign the samply binary."
msgstr ""

#: ../../../howto/perf_profiling.rst:178
msgid "How to enable ``perf`` profiling support"
msgstr ""

#: ../../../howto/perf_profiling.rst:180
msgid ""
"``perf`` profiling support can be enabled either from the start using the "
"environment variable :envvar:`PYTHONPERFSUPPORT` or the :option:`-X perf <-"
"X>` option, or dynamically using :func:`sys.activate_stack_trampoline` and :"
"func:`sys.deactivate_stack_trampoline`."
msgstr ""

#: ../../../howto/perf_profiling.rst:186
msgid ""
"The :mod:`!sys` functions take precedence over the :option:`!-X` option, "
"the :option:`!-X` option takes precedence over the environment variable."
msgstr ""

#: ../../../howto/perf_profiling.rst:189
msgid "Example, using the environment variable::"
msgstr ""

#: ../../../howto/perf_profiling.rst:191
msgid ""
"$ PYTHONPERFSUPPORT=1 perf record -F 9999 -g -o perf.data python my_script."
"py\n"
"$ perf report -g -i perf.data"
msgstr ""

#: ../../../howto/perf_profiling.rst:194
msgid "Example, using the :option:`!-X` option::"
msgstr ""

#: ../../../howto/perf_profiling.rst:196
msgid ""
"$ perf record -F 9999 -g -o perf.data python -X perf my_script.py\n"
"$ perf report -g -i perf.data"
msgstr ""

#: ../../../howto/perf_profiling.rst:199
msgid "Example, using the :mod:`sys` APIs in file :file:`example.py`:"
msgstr ""

#: ../../../howto/perf_profiling.rst:201
msgid ""
"import sys\n"
"\n"
"sys.activate_stack_trampoline(\"perf\")\n"
"do_profiled_stuff()\n"
"sys.deactivate_stack_trampoline()\n"
"\n"
"non_profiled_stuff()"
msgstr ""

#: ../../../howto/perf_profiling.rst:211
msgid "...then::"
msgstr ""

#: ../../../howto/perf_profiling.rst:213
msgid ""
"$ perf record -F 9999 -g -o perf.data python ./example.py\n"
"$ perf report -g -i perf.data"
msgstr ""

#: ../../../howto/perf_profiling.rst:218
msgid "How to obtain the best results"
msgstr ""

#: ../../../howto/perf_profiling.rst:220
msgid ""
"For best results, Python should be compiled with ``CFLAGS=\"-fno-omit-frame-"
"pointer -mno-omit-leaf-frame-pointer\"`` as this allows profilers to unwind "
"using only the frame pointer and not on DWARF debug information. This is "
"because as the code that is interposed to allow ``perf`` support is "
"dynamically generated it doesn't have any DWARF debugging information "
"available."
msgstr ""

#: ../../../howto/perf_profiling.rst:227
msgid ""
"You can check if your system has been compiled with this flag by running::"
msgstr ""

#: ../../../howto/perf_profiling.rst:229
msgid "$ python -m sysconfig | grep 'no-omit-frame-pointer'"
msgstr ""

#: ../../../howto/perf_profiling.rst:231
msgid ""
"If you don't see any output it means that your interpreter has not been "
"compiled with frame pointers and therefore it may not be able to show Python "
"functions in the output of ``perf``."
msgstr ""

#: ../../../howto/perf_profiling.rst:237
msgid "How to work without frame pointers"
msgstr ""

#: ../../../howto/perf_profiling.rst:239
msgid ""
"If you are working with a Python interpreter that has been compiled without "
"frame pointers, you can still use the ``perf`` profiler, but the overhead "
"will be a bit higher because Python needs to generate unwinding information "
"for every Python function call on the fly. Additionally, ``perf`` will take "
"more time to process the data because it will need to use the DWARF "
"debugging information to unwind the stack and this is a slow process."
msgstr ""

#: ../../../howto/perf_profiling.rst:246
msgid ""
"To enable this mode, you can use the environment variable :envvar:"
"`PYTHON_PERF_JIT_SUPPORT` or the :option:`-X perf_jit <-X>` option, which "
"will enable the JIT mode for the ``perf`` profiler."
msgstr ""

#: ../../../howto/perf_profiling.rst:252
msgid ""
"Due to a bug in the ``perf`` tool, only ``perf`` versions higher than v6.8 "
"will work with the JIT mode.  The fix was also backported to the v6.7.2 "
"version of the tool."
msgstr ""

#: ../../../howto/perf_profiling.rst:256
msgid ""
"Note that when checking the version of the ``perf`` tool (which can be done "
"by running ``perf version``) you must take into account that some distros "
"add some custom version numbers including a ``-`` character.  This means "
"that ``perf 6.7-3`` is not necessarily ``perf 6.7.3``."
msgstr ""

#: ../../../howto/perf_profiling.rst:261
msgid ""
"When using the perf JIT mode, you need an extra step before you can run "
"``perf report``. You need to call the ``perf inject`` command to inject the "
"JIT information into the ``perf.data`` file.::"
msgstr ""

#: ../../../howto/perf_profiling.rst:265
msgid ""
"$ perf record -F 9999 -g -k 1 --call-graph dwarf -o perf.data python -"
"Xperf_jit my_script.py\n"
"$ perf inject -i perf.data --jit --output perf.jit.data\n"
"$ perf report -g -i perf.jit.data"
msgstr ""

#: ../../../howto/perf_profiling.rst:269
msgid "or using the environment variable::"
msgstr ""

#: ../../../howto/perf_profiling.rst:271
msgid ""
"$ PYTHON_PERF_JIT_SUPPORT=1 perf record -F 9999 -g --call-graph dwarf -o "
"perf.data python my_script.py\n"
"$ perf inject -i perf.data --jit --output perf.jit.data\n"
"$ perf report -g -i perf.jit.data"
msgstr ""

#: ../../../howto/perf_profiling.rst:275
msgid ""
"``perf inject --jit`` command will read ``perf.data``, automatically pick up "
"the perf dump file that Python creates (in ``/tmp/perf-$PID.dump``), and "
"then create ``perf.jit.data`` which merges all the JIT information together. "
"It should also create a lot of ``jitted-XXXX-N.so`` files in the current "
"directory which are ELF images for all the JIT trampolines that were created "
"by Python."
msgstr ""

#: ../../../howto/perf_profiling.rst:283
msgid ""
"When using ``--call-graph dwarf``, the ``perf`` tool will take snapshots of "
"the stack of the process being profiled and save the information in the "
"``perf.data`` file. By default, the size of the stack dump is 8192 bytes, "
"but you can change the size by passing it after a comma like ``--call-graph "
"dwarf,16384``."
msgstr ""

#: ../../../howto/perf_profiling.rst:289
msgid ""
"The size of the stack dump is important because if the size is too small "
"``perf`` will not be able to unwind the stack and the output will be "
"incomplete. On the other hand, if the size is too big, then ``perf`` won't "
"be able to sample the process as frequently as it would like as the overhead "
"will be higher."
msgstr ""

#: ../../../howto/perf_profiling.rst:295
msgid ""
"The stack size is particularly important when profiling Python code compiled "
"with low optimization levels (like ``-O0``), as these builds tend to have "
"larger stack frames. If you are compiling Python with ``-O0`` and not seeing "
"Python functions in your profiling output, try increasing the stack dump "
"size to 65528 bytes (the maximum)::"
msgstr ""

#: ../../../howto/perf_profiling.rst:301
msgid ""
"$ perf record -F 9999 -g -k 1 --call-graph dwarf,65528 -o perf.data python -"
"Xperf_jit my_script.py"
msgstr ""

#: ../../../howto/perf_profiling.rst:303
msgid "Different compilation flags can significantly impact stack sizes:"
msgstr ""

#: ../../../howto/perf_profiling.rst:305
msgid ""
"Builds with ``-O0`` typically have much larger stack frames than those with "
"``-O1`` or higher"
msgstr ""

#: ../../../howto/perf_profiling.rst:306
msgid ""
"Adding optimizations (``-O1``, ``-O2``, etc.) typically reduces stack size"
msgstr ""

#: ../../../howto/perf_profiling.rst:307
msgid ""
"Frame pointers (``-fno-omit-frame-pointer``) generally provide more reliable "
"stack unwinding"
msgstr ""

# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.15\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-12-01 09:06+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../c-api/module.rst:6
msgid "Module Objects"
msgstr ""

#: ../../../c-api/module.rst:14
msgid ""
"This instance of :c:type:`PyTypeObject` represents the Python module type.  "
"This is exposed to Python programs as :py:class:`types.ModuleType`."
msgstr ""

#: ../../../c-api/module.rst:20
msgid ""
"Return true if *p* is a module object, or a subtype of a module object. This "
"function always succeeds."
msgstr ""

#: ../../../c-api/module.rst:26
msgid ""
"Return true if *p* is a module object, but not a subtype of :c:data:"
"`PyModule_Type`.  This function always succeeds."
msgstr ""

#: ../../../c-api/module.rst:39
msgid ""
"Return a new module object with :attr:`module.__name__` set to *name*. The "
"module's :attr:`!__name__`, :attr:`~module.__doc__`, :attr:`~module."
"__package__` and :attr:`~module.__loader__` attributes are filled in (all "
"but :attr:`!__name__` are set to ``None``). The caller is responsible for "
"setting a :attr:`~module.__file__` attribute."
msgstr ""

#: ../../../c-api/module.rst:45 ../../../c-api/module.rst:776
#: ../../../c-api/module.rst:803
msgid "Return ``NULL`` with an exception set on error."
msgstr ""

#: ../../../c-api/module.rst:49
msgid ""
":attr:`~module.__package__` and :attr:`~module.__loader__` are now set to "
"``None``."
msgstr ""

#: ../../../c-api/module.rst:56
msgid ""
"Similar to :c:func:`PyModule_NewObject`, but the name is a UTF-8 encoded "
"string instead of a Unicode object."
msgstr ""

#: ../../../c-api/module.rst:64
msgid ""
"Return the dictionary object that implements *module*'s namespace; this "
"object is the same as the :attr:`~object.__dict__` attribute of the module "
"object. If *module* is not a module object (or a subtype of a module "
"object), :exc:`SystemError` is raised and ``NULL`` is returned."
msgstr ""

#: ../../../c-api/module.rst:69
msgid ""
"It is recommended extensions use other ``PyModule_*`` and ``PyObject_*`` "
"functions rather than directly manipulate a module's :attr:`~object."
"__dict__`."
msgstr ""

#: ../../../c-api/module.rst:73
msgid ""
"The returned reference is borrowed from the module; it is valid until the "
"module is destroyed."
msgstr ""

#: ../../../c-api/module.rst:83
msgid ""
"Return *module*'s :attr:`~module.__name__` value.  If the module does not "
"provide one, or if it is not a string, :exc:`SystemError` is raised and "
"``NULL`` is returned."
msgstr ""

#: ../../../c-api/module.rst:92
msgid ""
"Similar to :c:func:`PyModule_GetNameObject` but return the name encoded to "
"``'utf-8'``."
msgstr ""

#: ../../../c-api/module.rst:95
msgid ""
"The returned buffer is only valid until the module is renamed or destroyed. "
"Note that Python code may rename a module by setting its :py:attr:`~module."
"__name__` attribute."
msgstr ""

#: ../../../c-api/module.rst:101
msgid ""
"Return a pointer to the :c:type:`PyModuleDef` struct from which the module "
"was created, or ``NULL`` if the module wasn't created from a definition."
msgstr ""

#: ../../../c-api/module.rst:104
msgid ""
"On error, return ``NULL`` with an exception set. Use :c:func:"
"`PyErr_Occurred` to tell this case apart from a missing :c:type:`!"
"PyModuleDef`."
msgstr ""

#: ../../../c-api/module.rst:115
msgid ""
"Return the name of the file from which *module* was loaded using *module*'s :"
"attr:`~module.__file__` attribute.  If this is not defined, or if it is not "
"a string, raise :exc:`SystemError` and return ``NULL``; otherwise return a "
"reference to a Unicode object."
msgstr ""

#: ../../../c-api/module.rst:125
msgid ""
"Similar to :c:func:`PyModule_GetFilenameObject` but return the filename "
"encoded to 'utf-8'."
msgstr ""

#: ../../../c-api/module.rst:128
msgid ""
"The returned buffer is only valid until the module's :py:attr:`~module."
"__file__` attribute is reassigned or the module is destroyed."
msgstr ""

#: ../../../c-api/module.rst:131
msgid ""
":c:func:`PyModule_GetFilename` raises :exc:`UnicodeEncodeError` on "
"unencodable filenames, use :c:func:`PyModule_GetFilenameObject` instead."
msgstr ""

#: ../../../c-api/module.rst:139
msgid "Module definition"
msgstr ""

#: ../../../c-api/module.rst:141
msgid ""
"Modules created using the C API are typically defined using an array of :dfn:"
"`slots`. The slots provide a \"description\" of how a module should be "
"created."
msgstr ""

#: ../../../c-api/module.rst:147
msgid ""
"Previously, a :c:type:`PyModuleDef` struct was necessary to define modules. "
"The older way of defining modules is still available: consult either the :"
"ref:`pymoduledef` section or earlier versions of this documentation if you "
"plan to support earlier Python versions."
msgstr ""

#: ../../../c-api/module.rst:152
msgid ""
"The slots array is usually used to define an extension module's “main” "
"module object (see :ref:`extension-modules` for details). It can also be "
"used to :ref:`create extension modules dynamically <module-from-slots>`."
msgstr ""

#: ../../../c-api/module.rst:157
msgid ""
"Unless specified otherwise, the same slot ID may not be repeated in an array "
"of slots."
msgstr ""

#: ../../../c-api/module.rst:165
msgid ""
"A slot ID, chosen from the available ``Py_mod_*`` values explained below."
msgstr ""

#: ../../../c-api/module.rst:167
msgid "An ID of 0 marks the end of a :c:type:`!PyModuleDef_Slot` array."
msgstr ""

#: ../../../c-api/module.rst:171
msgid "Value of the slot, whose meaning depends on the slot ID."
msgstr ""

#: ../../../c-api/module.rst:173
msgid ""
"The value may not be NULL. To leave a slot out, omit the :c:type:"
"`PyModuleDef_Slot` entry entirely."
msgstr ""

#: ../../../c-api/module.rst:180
msgid "Metadata slots"
msgstr ""

#: ../../../c-api/module.rst:184
msgid ""
":c:type:`Slot ID <PyModuleDef_Slot.slot>` for the name of the new module, as "
"a NUL-terminated UTF8-encoded ``const char *``."
msgstr ""

#: ../../../c-api/module.rst:187
msgid ""
"Note that modules are typically created using a :py:class:`~importlib."
"machinery.ModuleSpec`, and when they are, the name from the spec will be "
"used instead of :c:data:`!Py_mod_name`. However, it is still recommended to "
"include this slot for introspection and debugging purposes."
msgstr ""

#: ../../../c-api/module.rst:195
msgid ""
"Use :c:member:`PyModuleDef.m_name` instead to support previous versions."
msgstr ""

#: ../../../c-api/module.rst:199
msgid ""
":c:type:`Slot ID <PyModuleDef_Slot.slot>` for the docstring of the new "
"module, as a NUL-terminated UTF8-encoded ``const char *``."
msgstr ""

#: ../../../c-api/module.rst:202
msgid "Usually it is set to a variable created with :c:macro:`PyDoc_STRVAR`."
msgstr ""

#: ../../../c-api/module.rst:206
msgid "Use :c:member:`PyModuleDef.m_doc` instead to support previous versions."
msgstr ""

#: ../../../c-api/module.rst:210
msgid "Feature slots"
msgstr ""

#: ../../../c-api/module.rst:214
msgid ""
":c:type:`Slot ID <PyModuleDef_Slot.slot>` whose value points to a :c:struct:"
"`PyABIInfo` structure describing the ABI that the extension is using."
msgstr ""

#: ../../../c-api/module.rst:218
msgid ""
"A suitable :c:struct:`!PyABIInfo` variable can be defined using the :c:macro:"
"`PyABIInfo_VAR` macro, as in:"
msgstr ""

#: ../../../c-api/module.rst:230
msgid ""
"When creating a module, Python checks the value of this slot using :c:func:"
"`PyABIInfo_Check`."
msgstr ""

#: ../../../c-api/module.rst:237 ../../../c-api/module.rst:267
msgid ":c:type:`Slot ID <PyModuleDef_Slot.slot>` whose value is one of:"
msgstr ""

#: ../../../c-api/module.rst:243
msgid "The module does not support being imported in subinterpreters."
msgstr ""

#: ../../../c-api/module.rst:247
msgid ""
"The module supports being imported in subinterpreters, but only when they "
"share the main interpreter's GIL. (See :ref:`isolating-extensions-howto`.)"
msgstr ""

#: ../../../c-api/module.rst:253
msgid ""
"The module supports being imported in subinterpreters, even when they have "
"their own GIL. (See :ref:`isolating-extensions-howto`.)"
msgstr ""

#: ../../../c-api/module.rst:257
msgid ""
"This slot determines whether or not importing this module in a "
"subinterpreter will fail."
msgstr ""

#: ../../../c-api/module.rst:260
msgid ""
"If ``Py_mod_multiple_interpreters`` is not specified, the import machinery "
"defaults to ``Py_MOD_MULTIPLE_INTERPRETERS_SUPPORTED``."
msgstr ""

#: ../../../c-api/module.rst:273
msgid ""
"The module depends on the presence of the global interpreter lock (GIL), and "
"may access global state without synchronization."
msgstr ""

#: ../../../c-api/module.rst:278
msgid "The module is safe to run without an active GIL."
msgstr ""

#: ../../../c-api/module.rst:280
msgid ""
"This slot is ignored by Python builds not configured with :option:`--disable-"
"gil`.  Otherwise, it determines whether or not importing this module will "
"cause the GIL to be automatically enabled. See :ref:`whatsnew313-free-"
"threaded-cpython` for more detail."
msgstr ""

#: ../../../c-api/module.rst:285
msgid ""
"If ``Py_mod_gil`` is not specified, the import machinery defaults to "
"``Py_MOD_GIL_USED``."
msgstr ""

#: ../../../c-api/module.rst:292
msgid "Creation and initialization slots"
msgstr ""

#: ../../../c-api/module.rst:296
msgid ""
":c:type:`Slot ID <PyModuleDef_Slot.slot>` for a function that creates the "
"module object itself. The function must have the signature:"
msgstr ""

#: ../../../c-api/module.rst:304
msgid "The function will be called with:"
msgstr ""

#: ../../../c-api/module.rst:306
msgid ""
"*spec*: a ``ModuleSpec``-like object, meaning that any attributes defined "
"for :py:class:`importlib.machinery.ModuleSpec` have matching semantics. "
"However, any of the attributes may be missing."
msgstr ""

#: ../../../c-api/module.rst:309
msgid ""
"*def*: ``NULL``, or the module definition if the module is created from one."
msgstr ""

#: ../../../c-api/module.rst:311
msgid ""
"The function should return a new module object, or set an error and return "
"``NULL``."
msgstr ""

#: ../../../c-api/module.rst:314
msgid ""
"This function should be kept minimal. In particular, it should not call "
"arbitrary Python code, as trying to import the same module again may result "
"in an infinite loop."
msgstr ""

#: ../../../c-api/module.rst:318
msgid ""
"If ``Py_mod_create`` is not specified, the import machinery will create a "
"normal module object using :c:func:`PyModule_New`. The name is taken from "
"*spec*, not the definition, to allow extension modules to dynamically adjust "
"to their place in the module hierarchy and be imported under different names "
"through symlinks, all while sharing a single module definition."
msgstr ""

#: ../../../c-api/module.rst:324
msgid ""
"There is no requirement for the returned object to be an instance of :c:type:"
"`PyModule_Type`. However, some slots may only be used with :c:type:`!"
"PyModule_Type` instances; in particular:"
msgstr ""

#: ../../../c-api/module.rst:329
msgid ":c:macro:`Py_mod_exec`,"
msgstr ""

#: ../../../c-api/module.rst:330
msgid ""
":ref:`module state slots <ext-module-state-slots>` (``Py_mod_state_*``),"
msgstr ""

#: ../../../c-api/module.rst:331
msgid ":c:macro:`Py_mod_token`."
msgstr ""

#: ../../../c-api/module.rst:337
msgid ""
"The *slots* argument may be a ``ModuleSpec``-like object, rather than a "
"true :py:class:`~importlib.machinery.ModuleSpec` instance. Note that "
"previous versions of CPython did not enforce this."
msgstr ""

#: ../../../c-api/module.rst:341
msgid ""
"The *def* argument may now be ``NULL``, since modules are not necessarily "
"made from definitions."
msgstr ""

#: ../../../c-api/module.rst:346
msgid ""
":c:type:`Slot ID <PyModuleDef_Slot.slot>` for a function that will :dfn:"
"`execute`, or initialize, the module. This function does the equivalent to "
"executing the code of a Python module: typically, it adds classes and "
"constants to the module. The signature of the function is:"
msgstr ""

#: ../../../c-api/module.rst:356
msgid ""
"See the :ref:`capi-module-support-functions` section for some useful "
"functions to call."
msgstr ""

#: ../../../c-api/module.rst:359
msgid ""
"For backwards compatibility, the :c:type:`PyModuleDef.m_slots` array may "
"contain multiple :c:macro:`!Py_mod_exec` slots; these are processed in the "
"order they appear in the array. Elsewhere (that is, in arguments to :c:func:"
"`PyModule_FromSlotsAndSpec` and in return values of :samp:"
"`PyModExport_{<name>}`), repeating the slot is not allowed."
msgstr ""

#: ../../../c-api/module.rst:370
msgid ""
"Repeated ``Py_mod_exec`` slots are disallowed, except in :c:type:"
"`PyModuleDef.m_slots`."
msgstr ""

#: ../../../c-api/module.rst:375
msgid ""
":c:type:`Slot ID <PyModuleDef_Slot.slot>` for a table of module-level "
"functions, as an array of :c:type:`PyMethodDef` values suitable as the "
"*functions* argument to :c:func:`PyModule_AddFunctions`."
msgstr ""

#: ../../../c-api/module.rst:379
msgid ""
"Like other slot IDs, a slots array may only contain one :c:macro:`!"
"Py_mod_methods` entry. To add functions from multiple :c:type:`PyMethodDef` "
"arrays, call :c:func:`PyModule_AddFunctions` in the :c:macro:`Py_mod_exec` "
"function."
msgstr ""

#: ../../../c-api/module.rst:384
msgid ""
"The table must be statically allocated (or otherwise guaranteed to outlive "
"the module object)."
msgstr ""

#: ../../../c-api/module.rst:389
msgid ""
"Use :c:member:`PyModuleDef.m_methods` instead to support previous versions."
msgstr ""

#: ../../../c-api/module.rst:394
msgid "Module state"
msgstr ""

#: ../../../c-api/module.rst:396
msgid ""
"Extension modules can have *module state* -- a piece of memory that is "
"allocated on module creation, and freed when the module object is "
"deallocated. The module state is specified using :ref:`dedicated slots <ext-"
"module-state-slots>`."
msgstr ""

#: ../../../c-api/module.rst:401
msgid ""
"A typical use of module state is storing an exception type -- or indeed "
"*any* type object defined by the module --"
msgstr ""

#: ../../../c-api/module.rst:404
msgid ""
"Unlike the module's Python attributes, Python code cannot replace or delete "
"data stored in module state."
msgstr ""

#: ../../../c-api/module.rst:407
msgid ""
"Keeping per-module information in attributes and module state, rather than "
"in static globals, makes module objects *isolated* and safer for use in "
"multiple sub-interpreters. It also helps Python do an orderly clean-up when "
"it shuts down."
msgstr ""

#: ../../../c-api/module.rst:412
msgid ""
"Extensions that keep references to Python objects as part of module state "
"must implement :c:macro:`Py_mod_state_traverse` and :c:macro:"
"`Py_mod_state_clear` functions to avoid reference leaks."
msgstr ""

#: ../../../c-api/module.rst:416
msgid "To retrieve the state from a given module, use the following functions:"
msgstr ""

#: ../../../c-api/module.rst:420
msgid ""
"Return the \"state\" of the module, that is, a pointer to the block of "
"memory allocated at module creation time, or ``NULL``.  See :c:macro:"
"`Py_mod_state_size`."
msgstr ""

#: ../../../c-api/module.rst:424
msgid ""
"On error, return ``NULL`` with an exception set. Use :c:func:"
"`PyErr_Occurred` to tell this case apart from missing module state."
msgstr ""

#: ../../../c-api/module.rst:431
msgid ""
"Set *\\*result* to the size of the module's state, as specified using :c:"
"macro:`Py_mod_state_size` (or :c:member:`PyModuleDef.m_size`), and return 0."
msgstr ""

#: ../../../c-api/module.rst:435
msgid "On error, set *\\*result* to -1, and return -1 with an exception set."
msgstr ""

#: ../../../c-api/module.rst:444
msgid "Slots for defining module state"
msgstr ""

#: ../../../c-api/module.rst:446
msgid ""
"The following :c:member:`PyModuleDef_Slot.slot` IDs are available for "
"defining the module state."
msgstr ""

#: ../../../c-api/module.rst:451
msgid ""
":c:type:`Slot ID <PyModuleDef_Slot.slot>` for the size of the module state, "
"in bytes."
msgstr ""

#: ../../../c-api/module.rst:454
msgid ""
"Setting the value to a non-negative value means that the module can be re-"
"initialized and specifies the additional amount of memory it requires for "
"its state."
msgstr ""

#: ../../../c-api/module.rst:458
msgid "See :PEP:`3121` for more details."
msgstr ""

#: ../../../c-api/module.rst:460
msgid ""
"Use :c:func:`PyModule_GetStateSize` to retrieve the size of a given module."
msgstr ""

#: ../../../c-api/module.rst:464 ../../../c-api/module.rst:487
msgid ""
"Use :c:member:`PyModuleDef.m_size` instead to support previous versions."
msgstr ""

#: ../../../c-api/module.rst:468
msgid ""
":c:type:`Slot ID <PyModuleDef_Slot.slot>` for a traversal function to call "
"during GC traversal of the module object."
msgstr ""

#: ../../../c-api/module.rst:471
msgid ""
"The signature of the function, and meanings of the arguments, is similar as "
"for :c:member:`PyTypeObject.tp_traverse`:"
msgstr ""

#: ../../../c-api/module.rst:478 ../../../c-api/module.rst:500
#: ../../../c-api/module.rst:528
msgid ""
"This function is not called if the module state was requested but is not "
"allocated yet. This is the case immediately after the module is created and "
"before the module is executed (:c:data:`Py_mod_exec` function). More "
"precisely, this function is not called if the state size (:c:data:"
"`Py_mod_state_size`) is greater than 0 and the module state (as returned by :"
"c:func:`PyModule_GetState`) is ``NULL``."
msgstr ""

#: ../../../c-api/module.rst:491
msgid ""
":c:type:`Slot ID <PyModuleDef_Slot.slot>` for a clear function to call "
"during GC clearing of the module object."
msgstr ""

#: ../../../c-api/module.rst:494 ../../../c-api/module.rst:522
msgid "The signature of the function is:"
msgstr ""

#: ../../../c-api/module.rst:507
msgid ""
"Like :c:member:`PyTypeObject.tp_clear`, this function is not *always* called "
"before a module is deallocated. For example, when reference counting is "
"enough to determine that an object is no longer used, the cyclic garbage "
"collector is not involved and the :c:macro:`Py_mod_state_free` function is "
"called directly."
msgstr ""

#: ../../../c-api/module.rst:515
msgid ""
"Use :c:member:`PyModuleDef.m_clear` instead to support previous versions."
msgstr ""

#: ../../../c-api/module.rst:519
msgid ""
":c:type:`Slot ID <PyModuleDef_Slot.slot>` for a function to call during "
"deallocation of the module object."
msgstr ""

#: ../../../c-api/module.rst:537
msgid ""
"Use :c:member:`PyModuleDef.m_free` instead to support previous versions."
msgstr ""

#: ../../../c-api/module.rst:543
msgid "Module token"
msgstr ""

#: ../../../c-api/module.rst:545
msgid ""
"Each module may have an associated *token*: a pointer-sized value intended "
"to identify of the module state's memory layout. This means that if you have "
"a module object, but you are not sure if it “belongs” to your extension, you "
"can check using code like this:"
msgstr ""

#: ../../../c-api/module.rst:566
msgid ""
"A module's token -- and the *your_token* value to use in the above code -- "
"is:"
msgstr ""

#: ../../../c-api/module.rst:568
msgid ""
"For modules created with :c:type:`PyModuleDef`: the address of that :c:type:"
"`PyModuleDef`;"
msgstr ""

#: ../../../c-api/module.rst:570
msgid ""
"For modules defined with the :c:macro:`Py_mod_token` slot: the value of that "
"slot;"
msgstr ""

#: ../../../c-api/module.rst:572
msgid ""
"For modules created from an ``PyModExport_*`` :ref:`export hook <extension-"
"export-hook>`: the slots array that the export hook returned (unless "
"overriden with :c:macro:`Py_mod_token`)."
msgstr ""

#: ../../../c-api/module.rst:578
msgid ":c:type:`Slot ID <PyModuleDef_Slot.slot>` for the module token."
msgstr ""

#: ../../../c-api/module.rst:580
msgid ""
"If you use this slot to set the module token (rather than rely on the "
"default), you must ensure that:"
msgstr ""

#: ../../../c-api/module.rst:583
msgid ""
"The pointer outlives the class, so it's not reused for something else while "
"the class exists."
msgstr ""

#: ../../../c-api/module.rst:585
msgid ""
"It \"belongs\" to the extension module where the class lives, so it will not "
"clash with other extensions."
msgstr ""

#: ../../../c-api/module.rst:587
msgid ""
"If the token points to a :c:type:`PyModuleDef` struct, the module should "
"behave as if it was created from that :c:type:`PyModuleDef`. In particular, "
"the module state must have matching layout and semantics."
msgstr ""

#: ../../../c-api/module.rst:591
msgid ""
"Modules created from :c:type:`PyModuleDef` allways use the address of the :c:"
"type:`PyModuleDef` as the token. This means that :c:macro:`!Py_mod_token` "
"cannot be used in :c:member:`PyModuleDef.m_slots`."
msgstr ""

#: ../../../c-api/module.rst:600
msgid "Set *\\*result* to the module's token and return 0."
msgstr ""

#: ../../../c-api/module.rst:602
msgid "On error, set *\\*result* to NULL, and return -1 with an exception set."
msgstr ""

#: ../../../c-api/module.rst:606
msgid "See also :c:func:`PyType_GetModuleByToken`."
msgstr ""

#: ../../../c-api/module.rst:612
msgid "Creating extension modules dynamically"
msgstr ""

#: ../../../c-api/module.rst:614
msgid ""
"The following functions may be used to create an extension module "
"dynamically, rather than from an extension's :ref:`export hook <extension-"
"export-hook>`."
msgstr ""

#: ../../../c-api/module.rst:619
msgid ""
"Create a new module object, given an array of :ref:`slots "
"<pymoduledef_slot>` and the :py:class:`~importlib.machinery.ModuleSpec` "
"*spec*."
msgstr ""

#: ../../../c-api/module.rst:622
msgid ""
"The *slots* argument must point to an array of :c:type:`PyModuleDef_Slot` "
"structures, terminated by an entry slot with slot ID of 0 (typically written "
"as ``{0}`` or ``{0, NULL}`` in C). The *slots* argument may not be ``NULL``."
msgstr ""

#: ../../../c-api/module.rst:627
msgid ""
"The *spec* argument may be any ``ModuleSpec``-like object, as described in :"
"c:macro:`Py_mod_create` documentation. Currently, the *spec* must have a "
"``name`` attribute."
msgstr ""

#: ../../../c-api/module.rst:631
msgid ""
"On success, return the new module. On error, return ``NULL`` with an "
"exception set."
msgstr ""

#: ../../../c-api/module.rst:634
msgid ""
"Note that this does not process the module's execution slot (:c:data:"
"`Py_mod_exec`). Both :c:func:`!PyModule_FromSlotsAndSpec` and :c:func:"
"`PyModule_Exec` must be called to fully initialize a module. (See also :ref:"
"`multi-phase-initialization`.)"
msgstr ""

#: ../../../c-api/module.rst:640
msgid ""
"The *slots* array only needs to be valid for the duration of the :c:func:`!"
"PyModule_FromSlotsAndSpec` call. In particular, it may be heap-allocated."
msgstr ""

#: ../../../c-api/module.rst:648
msgid "Execute the :c:data:`Py_mod_exec` slot(s) of the given *module*."
msgstr ""

#: ../../../c-api/module.rst:650
msgid "On success, return 0. On error, return -1 with an exception set."
msgstr ""

#: ../../../c-api/module.rst:653
msgid ""
"For clarity: If *module* has no slots, for example if it uses :ref:`legacy "
"single-phase initialization <single-phase-initialization>`, this function "
"does nothing and returns 0."
msgstr ""

#: ../../../c-api/module.rst:664
msgid "Module definition struct"
msgstr ""

#: ../../../c-api/module.rst:666
msgid ""
"Traditionally, extension modules were defined using a *module definition* as "
"the “description\" of how a module should be created. Rather than using an "
"array of :ref:`slots <pymoduledef_slot>` directly, the definition has "
"dedicated members for most common functionality, and allows additional slots "
"as an extension mechanism."
msgstr ""

#: ../../../c-api/module.rst:672
msgid ""
"This way of defining modules is still available and there are no plans to "
"remove it."
msgstr ""

#: ../../../c-api/module.rst:677
msgid ""
"The module definition struct, which holds information needed to create a "
"module object."
msgstr ""

#: ../../../c-api/module.rst:680
msgid ""
"This structure must be statically allocated (or be otherwise guaranteed to "
"be valid while any modules created from it exist). Usually, there is only "
"one variable of this type for each extension module defined this way."
msgstr ""

#: ../../../c-api/module.rst:687
msgid "Always initialize this member to :c:macro:`PyModuleDef_HEAD_INIT`:"
msgstr ""

#: ../../../c-api/module.rst:693
msgid "The type of :c:member:`!PyModuleDef.m_base`."
msgstr ""

#: ../../../c-api/module.rst:697
msgid "The required initial value for :c:member:`!PyModuleDef.m_base`."
msgstr ""

#: ../../../c-api/module.rst:701
msgid "Corresponds to the :c:macro:`Py_mod_name` slot."
msgstr ""

#: ../../../c-api/module.rst:705
msgid ""
"These members correspond to the :c:macro:`Py_mod_doc` slot. Setting this to "
"NULL is equivalent to omitting the slot."
msgstr ""

#: ../../../c-api/module.rst:710
msgid ""
"Corresponds to the :c:macro:`Py_mod_state_size` slot. Setting this to zero "
"is equivalent to omitting the slot."
msgstr ""

#: ../../../c-api/module.rst:713
msgid ""
"When using :ref:`legacy single-phase initialization <single-phase-"
"initialization>` or when creating modules dynamically using :c:func:"
"`PyModule_Create` or :c:func:`PyModule_Create2`, :c:member:`!m_size` may be "
"set to -1. This indicates that the module does not support sub-interpreters, "
"because it has global state."
msgstr ""

#: ../../../c-api/module.rst:721
msgid ""
"Corresponds to the :c:macro:`Py_mod_methods` slot. Setting this to NULL is "
"equivalent to omitting the slot."
msgstr ""

#: ../../../c-api/module.rst:726
msgid "An array of additional slots, terminated by a ``{0, NULL}`` entry."
msgstr ""

#: ../../../c-api/module.rst:728
msgid ""
"This array may not contain slots corresponding to :c:type:`PyModuleDef` "
"members. For example, you cannot use :c:macro:`Py_mod_name` in :c:member:`!"
"m_slots`; the module name must be given as :c:member:`PyModuleDef.m_name`."
msgstr ""

#: ../../../c-api/module.rst:735
msgid ""
"Prior to version 3.5, this member was always set to ``NULL``, and was "
"defined as:"
msgstr ""

#: ../../../c-api/module.rst:744
msgid ""
"These members correspond to the :c:macro:`Py_mod_state_traverse`, :c:macro:"
"`Py_mod_state_clear`, and :c:macro:`Py_mod_state_free` slots, respectively."
msgstr ""

#: ../../../c-api/module.rst:748
msgid ""
"Setting these members to NULL is equivalent to omitting the corresponding "
"slots."
msgstr ""

#: ../../../c-api/module.rst:753
msgid ""
":c:member:`m_traverse`, :c:member:`m_clear` and :c:member:`m_free` functions "
"are longer called before the module state is allocated."
msgstr ""

#: ../../../c-api/module.rst:759
msgid ""
"The following API can be used to create modules from a :c:type:`!"
"PyModuleDef` struct:"
msgstr ""

#: ../../../c-api/module.rst:764
msgid ""
"Create a new module object, given the definition in *def*. This is a macro "
"that calls :c:func:`PyModule_Create2` with *module_api_version* set to :c:"
"macro:`PYTHON_API_VERSION`, or to :c:macro:`PYTHON_ABI_VERSION` if using "
"the :ref:`limited API <limited-c-api>`."
msgstr ""

#: ../../../c-api/module.rst:772
msgid ""
"Create a new module object, given the definition in *def*, assuming the API "
"version *module_api_version*.  If that version does not match the version of "
"the running interpreter, a :exc:`RuntimeWarning` is emitted."
msgstr ""

#: ../../../c-api/module.rst:778
msgid ""
"This function does not support slots. The :c:member:`~PyModuleDef.m_slots` "
"member of *def* must be ``NULL``."
msgstr ""

#: ../../../c-api/module.rst:784
msgid ""
"Most uses of this function should be using :c:func:`PyModule_Create` "
"instead; only use this if you are sure you need it."
msgstr ""

#: ../../../c-api/module.rst:789
msgid ""
"This macro calls :c:func:`PyModule_FromDefAndSpec2` with "
"*module_api_version* set to :c:macro:`PYTHON_API_VERSION`, or to :c:macro:"
"`PYTHON_ABI_VERSION` if using the :ref:`limited API <limited-c-api>`."
msgstr ""

#: ../../../c-api/module.rst:798
msgid ""
"Create a new module object, given the definition in *def* and the ModuleSpec "
"*spec*, assuming the API version *module_api_version*. If that version does "
"not match the version of the running interpreter, a :exc:`RuntimeWarning` is "
"emitted."
msgstr ""

#: ../../../c-api/module.rst:805
msgid ""
"Note that this does not process execution slots (:c:data:`Py_mod_exec`). "
"Both ``PyModule_FromDefAndSpec`` and ``PyModule_ExecDef`` must be called to "
"fully initialize a module."
msgstr ""

#: ../../../c-api/module.rst:811
msgid ""
"Most uses of this function should be using :c:func:`PyModule_FromDefAndSpec` "
"instead; only use this if you are sure you need it."
msgstr ""

#: ../../../c-api/module.rst:818
msgid "Process any execution slots (:c:data:`Py_mod_exec`) given in *def*."
msgstr ""

#: ../../../c-api/module.rst:824
msgid "The C API version. Defined for backwards compatibility."
msgstr ""

#: ../../../c-api/module.rst:826 ../../../c-api/module.rst:833
msgid ""
"Currently, this constant is not updated in new Python versions, and is not "
"useful for versioning. This may change in the future."
msgstr ""

#: ../../../c-api/module.rst:831
msgid "Defined as ``3`` for backwards compatibility."
msgstr ""

#: ../../../c-api/module.rst:840
msgid "Support functions"
msgstr ""

#: ../../../c-api/module.rst:842
msgid ""
"The following functions are provided to help initialize a module object. "
"They are intended for a module's execution slot (:c:data:`Py_mod_exec`), the "
"initialization function for legacy :ref:`single-phase initialization <single-"
"phase-initialization>`, or code that creates modules dynamically."
msgstr ""

#: ../../../c-api/module.rst:849
msgid ""
"Add an object to *module* as *name*.  This is a convenience function which "
"can be used from the module's initialization function."
msgstr ""

#: ../../../c-api/module.rst:852
msgid ""
"On success, return ``0``. On error, raise an exception and return ``-1``."
msgstr ""

#: ../../../c-api/module.rst:854 ../../../c-api/module.rst:905
#: ../../../c-api/module.rst:932
msgid "Example usage::"
msgstr ""

#: ../../../c-api/module.rst:868
msgid ""
"To be convenient, the function accepts ``NULL`` *value* with an exception "
"set. In this case, return ``-1`` and just leave the raised exception "
"unchanged."
msgstr ""

#: ../../../c-api/module.rst:872
msgid ""
"The example can also be written without checking explicitly if *obj* is "
"``NULL``::"
msgstr ""

#: ../../../c-api/module.rst:884
msgid ""
"Note that ``Py_XDECREF()`` should be used instead of ``Py_DECREF()`` in this "
"case, since *obj* can be ``NULL``."
msgstr ""

#: ../../../c-api/module.rst:887
msgid ""
"The number of different *name* strings passed to this function should be "
"kept small, usually by only using statically allocated strings as *name*. "
"For names that aren't known at compile time, prefer calling :c:func:"
"`PyUnicode_FromString` and :c:func:`PyObject_SetAttr` directly. For more "
"details, see :c:func:`PyUnicode_InternFromString`, which may be used "
"internally to create a key object."
msgstr ""

#: ../../../c-api/module.rst:900
msgid ""
"Similar to :c:func:`PyModule_AddObjectRef`, but \"steals\" a reference to "
"*value*. It can be called with a result of function that returns a new "
"reference without bothering to check its result or even saving it to a "
"variable."
msgstr ""

#: ../../../c-api/module.rst:916
msgid ""
"Similar to :c:func:`PyModule_AddObjectRef`, but steals a reference to "
"*value* on success (if it returns ``0``)."
msgstr ""

#: ../../../c-api/module.rst:919
msgid ""
"The new :c:func:`PyModule_Add` or :c:func:`PyModule_AddObjectRef` functions "
"are recommended, since it is easy to introduce reference leaks by misusing "
"the :c:func:`PyModule_AddObject` function."
msgstr ""

#: ../../../c-api/module.rst:926
msgid ""
"Unlike other functions that steal references, ``PyModule_AddObject()`` only "
"releases the reference to *value* **on success**."
msgstr ""

#: ../../../c-api/module.rst:929
msgid ""
"This means that its return value must be checked, and calling code must :c:"
"func:`Py_XDECREF` *value* manually on error."
msgstr ""

#: ../../../c-api/module.rst:947
msgid ":c:func:`PyModule_AddObject` is :term:`soft deprecated`."
msgstr ""

#: ../../../c-api/module.rst:952
msgid ""
"Add an integer constant to *module* as *name*.  This convenience function "
"can be used from the module's initialization function. Return ``-1`` with an "
"exception set on error, ``0`` on success."
msgstr ""

#: ../../../c-api/module.rst:956
msgid ""
"This is a convenience function that calls :c:func:`PyLong_FromLong` and :c:"
"func:`PyModule_AddObjectRef`; see their documentation for details."
msgstr ""

#: ../../../c-api/module.rst:962
msgid ""
"Add a string constant to *module* as *name*.  This convenience function can "
"be used from the module's initialization function.  The string *value* must "
"be ``NULL``-terminated. Return ``-1`` with an exception set on error, ``0`` "
"on success."
msgstr ""

#: ../../../c-api/module.rst:967
msgid ""
"This is a convenience function that calls :c:func:"
"`PyUnicode_InternFromString` and :c:func:`PyModule_AddObjectRef`; see their "
"documentation for details."
msgstr ""

#: ../../../c-api/module.rst:974
msgid ""
"Add an int constant to *module*. The name and the value are taken from "
"*macro*. For example ``PyModule_AddIntMacro(module, AF_INET)`` adds the int "
"constant *AF_INET* with the value of *AF_INET* to *module*. Return ``-1`` "
"with an exception set on error, ``0`` on success."
msgstr ""

#: ../../../c-api/module.rst:982
msgid "Add a string constant to *module*."
msgstr ""

#: ../../../c-api/module.rst:986
msgid ""
"Add a type object to *module*. The type object is finalized by calling "
"internally :c:func:`PyType_Ready`. The name of the type object is taken from "
"the last component of :c:member:`~PyTypeObject.tp_name` after dot. Return "
"``-1`` with an exception set on error, ``0`` on success."
msgstr ""

#: ../../../c-api/module.rst:996
msgid ""
"Add the functions from the ``NULL`` terminated *functions* array to "
"*module*. Refer to the :c:type:`PyMethodDef` documentation for details on "
"individual entries (due to the lack of a shared module namespace, module "
"level \"functions\" implemented in C typically receive the module as their "
"first parameter, making them similar to instance methods on Python classes)."
msgstr ""

#: ../../../c-api/module.rst:1002
msgid ""
"This function is called automatically when creating a module from "
"``PyModuleDef`` (such as when using :ref:`multi-phase-initialization`, "
"``PyModule_Create``, or ``PyModule_FromDefAndSpec``). Some module authors "
"may prefer defining functions in multiple :c:type:`PyMethodDef` arrays; in "
"that case they should call this function directly."
msgstr ""

#: ../../../c-api/module.rst:1009
msgid ""
"The *functions* array must be statically allocated (or otherwise guaranteed "
"to outlive the module object)."
msgstr ""

#: ../../../c-api/module.rst:1016
msgid ""
"Set the docstring for *module* to *docstring*. This function is called "
"automatically when creating a module from ``PyModuleDef`` (such as when "
"using :ref:`multi-phase-initialization`, ``PyModule_Create``, or "
"``PyModule_FromDefAndSpec``)."
msgstr ""

#: ../../../c-api/module.rst:1025
msgid ""
"Indicate that *module* does or does not support running without the global "
"interpreter lock (GIL), using one of the values from :c:macro:`Py_mod_gil`. "
"It must be called during *module*'s initialization function when using :ref:"
"`single-phase-initialization`. If this function is not called during module "
"initialization, the import machinery assumes the module does not support "
"running without the GIL. This function is only available in Python builds "
"configured with :option:`--disable-gil`. Return ``-1`` with an exception set "
"on error, ``0`` on success."
msgstr ""

#: ../../../c-api/module.rst:1039
msgid "Module lookup (single-phase initialization)"
msgstr ""

#: ../../../c-api/module.rst:1041
msgid ""
"The legacy :ref:`single-phase initialization <single-phase-initialization>` "
"initialization scheme creates singleton modules that can be looked up in the "
"context of the current interpreter. This allows the module object to be "
"retrieved later with only a reference to the module definition."
msgstr ""

#: ../../../c-api/module.rst:1046
msgid ""
"These functions will not work on modules created using multi-phase "
"initialization, since multiple such modules can be created from a single "
"definition."
msgstr ""

#: ../../../c-api/module.rst:1051
msgid ""
"Returns the module object that was created from *def* for the current "
"interpreter. This method requires that the module object has been attached "
"to the interpreter state with :c:func:`PyState_AddModule` beforehand. In "
"case the corresponding module object is not found or has not been attached "
"to the interpreter state yet, it returns ``NULL``."
msgstr ""

#: ../../../c-api/module.rst:1058
msgid ""
"Attaches the module object passed to the function to the interpreter state. "
"This allows the module object to be accessible via :c:func:"
"`PyState_FindModule`."
msgstr ""

#: ../../../c-api/module.rst:1061
msgid "Only effective on modules created using single-phase initialization."
msgstr ""

#: ../../../c-api/module.rst:1063
msgid ""
"Python calls ``PyState_AddModule`` automatically after importing a module "
"that uses :ref:`single-phase initialization <single-phase-initialization>`, "
"so it is unnecessary (but harmless) to call it from module initialization "
"code. An explicit call is needed only if the module's own init code "
"subsequently calls ``PyState_FindModule``. The function is mainly intended "
"for implementing alternative import mechanisms (either by calling it "
"directly, or by referring to its implementation for details of the required "
"state updates)."
msgstr ""

#: ../../../c-api/module.rst:1072
msgid ""
"If a module was attached previously using the same *def*, it is replaced by "
"the new *module*."
msgstr ""

#: ../../../c-api/module.rst:1075 ../../../c-api/module.rst:1086
msgid "The caller must have an :term:`attached thread state`."
msgstr ""

#: ../../../c-api/module.rst:1077
msgid "Return ``-1`` with an exception set on error, ``0`` on success."
msgstr ""

#: ../../../c-api/module.rst:1083
msgid ""
"Removes the module object created from *def* from the interpreter state. "
"Return ``-1`` with an exception set on error, ``0`` on success."
msgstr ""

#: ../../../c-api/module.rst:8
msgid "object"
msgstr ""

#: ../../../c-api/module.rst:8
msgid "module"
msgstr ""

#: ../../../c-api/module.rst:12
msgid "ModuleType (in module types)"
msgstr ""

#: ../../../c-api/module.rst:32 ../../../c-api/module.rst:79
msgid "__name__ (module attribute)"
msgstr ""

#: ../../../c-api/module.rst:32
msgid "__doc__ (module attribute)"
msgstr ""

#: ../../../c-api/module.rst:32 ../../../c-api/module.rst:111
msgid "__file__ (module attribute)"
msgstr ""

#: ../../../c-api/module.rst:32
msgid "__package__ (module attribute)"
msgstr ""

#: ../../../c-api/module.rst:32
msgid "__loader__ (module attribute)"
msgstr ""

#: ../../../c-api/module.rst:62
msgid "__dict__ (module attribute)"
msgstr ""

#: ../../../c-api/module.rst:79 ../../../c-api/module.rst:111
msgid "SystemError (built-in exception)"
msgstr ""

# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.15\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2026-02-23 09:28+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../c-api/profiling.rst:6
msgid "Profiling and tracing"
msgstr ""

#: ../../../c-api/profiling.rst:8
msgid ""
"The Python interpreter provides some low-level support for attaching "
"profiling and execution tracing facilities.  These are used for profiling, "
"debugging, and coverage analysis tools."
msgstr ""

#: ../../../c-api/profiling.rst:12
msgid ""
"This C interface allows the profiling or tracing code to avoid the overhead "
"of calling through Python-level callable objects, making a direct C function "
"call instead.  The essential attributes of the facility have not changed; "
"the interface allows trace functions to be installed per-thread, and the "
"basic events reported to the trace function are the same as had been "
"reported to the Python-level trace functions in previous versions."
msgstr ""

#: ../../../c-api/profiling.rst:22
msgid ""
"The type of the trace function registered using :c:func:`PyEval_SetProfile` "
"and :c:func:`PyEval_SetTrace`. The first parameter is the object passed to "
"the registration function as *obj*, *frame* is the frame object to which the "
"event pertains, *what* is one of the constants :c:data:`PyTrace_CALL`, :c:"
"data:`PyTrace_EXCEPTION`, :c:data:`PyTrace_LINE`, :c:data:`PyTrace_RETURN`, :"
"c:data:`PyTrace_C_CALL`, :c:data:`PyTrace_C_EXCEPTION`, :c:data:"
"`PyTrace_C_RETURN`, or :c:data:`PyTrace_OPCODE`, and *arg* depends on the "
"value of *what*:"
msgstr ""

#: ../../../c-api/profiling.rst:31
msgid "Value of *what*"
msgstr ""

#: ../../../c-api/profiling.rst:31
msgid "Meaning of *arg*"
msgstr ""

#: ../../../c-api/profiling.rst:33
msgid ":c:data:`PyTrace_CALL`"
msgstr ""

#: ../../../c-api/profiling.rst:33 ../../../c-api/profiling.rst:38
#: ../../../c-api/profiling.rst:49
msgid "Always :c:data:`Py_None`."
msgstr ""

#: ../../../c-api/profiling.rst:35
msgid ":c:data:`PyTrace_EXCEPTION`"
msgstr ""

#: ../../../c-api/profiling.rst:35
msgid "Exception information as returned by :func:`sys.exc_info`."
msgstr ""

#: ../../../c-api/profiling.rst:38
msgid ":c:data:`PyTrace_LINE`"
msgstr ""

#: ../../../c-api/profiling.rst:40
msgid ":c:data:`PyTrace_RETURN`"
msgstr ""

#: ../../../c-api/profiling.rst:40
msgid ""
"Value being returned to the caller, or ``NULL`` if caused by an exception."
msgstr ""

#: ../../../c-api/profiling.rst:43
msgid ":c:data:`PyTrace_C_CALL`"
msgstr ""

#: ../../../c-api/profiling.rst:43 ../../../c-api/profiling.rst:45
#: ../../../c-api/profiling.rst:47
msgid "Function object being called."
msgstr ""

#: ../../../c-api/profiling.rst:45
msgid ":c:data:`PyTrace_C_EXCEPTION`"
msgstr ""

#: ../../../c-api/profiling.rst:47
msgid ":c:data:`PyTrace_C_RETURN`"
msgstr ""

#: ../../../c-api/profiling.rst:49
msgid ":c:data:`PyTrace_OPCODE`"
msgstr ""

#: ../../../c-api/profiling.rst:54
msgid ""
"The value of the *what* parameter to a :c:type:`Py_tracefunc` function when "
"a new call to a function or method is being reported, or a new entry into a "
"generator. Note that the creation of the iterator for a generator function "
"is not reported as there is no control transfer to the Python bytecode in "
"the corresponding frame."
msgstr ""

#: ../../../c-api/profiling.rst:63
msgid ""
"The value of the *what* parameter to a :c:type:`Py_tracefunc` function when "
"an exception has been raised.  The callback function is called with this "
"value for *what* when after any bytecode is processed after which the "
"exception becomes set within the frame being executed.  The effect of this "
"is that as exception propagation causes the Python stack to unwind, the "
"callback is called upon return to each frame as the exception propagates.  "
"Only trace functions receive these events; they are not needed by the "
"profiler."
msgstr ""

#: ../../../c-api/profiling.rst:74
msgid ""
"The value passed as the *what* parameter to a :c:type:`Py_tracefunc` "
"function (but not a profiling function) when a line-number event is being "
"reported. It may be disabled for a frame by setting :attr:`~frame."
"f_trace_lines` to *0* on that frame."
msgstr ""

#: ../../../c-api/profiling.rst:82
msgid ""
"The value for the *what* parameter to :c:type:`Py_tracefunc` functions when "
"a call is about to return."
msgstr ""

#: ../../../c-api/profiling.rst:88
msgid ""
"The value for the *what* parameter to :c:type:`Py_tracefunc` functions when "
"a C function is about to be called."
msgstr ""

#: ../../../c-api/profiling.rst:94
msgid ""
"The value for the *what* parameter to :c:type:`Py_tracefunc` functions when "
"a C function has raised an exception."
msgstr ""

#: ../../../c-api/profiling.rst:100
msgid ""
"The value for the *what* parameter to :c:type:`Py_tracefunc` functions when "
"a C function has returned."
msgstr ""

#: ../../../c-api/profiling.rst:106
msgid ""
"The value for the *what* parameter to :c:type:`Py_tracefunc` functions (but "
"not profiling functions) when a new opcode is about to be executed.  This "
"event is not emitted by default: it must be explicitly requested by setting :"
"attr:`~frame.f_trace_opcodes` to *1* on the frame."
msgstr ""

#: ../../../c-api/profiling.rst:114
msgid ""
"Set the profiler function to *func*.  The *obj* parameter is passed to the "
"function as its first parameter, and may be any Python object, or ``NULL``.  "
"If the profile function needs to maintain state, using a different value for "
"*obj* for each thread provides a convenient and thread-safe place to store "
"it.  The profile function is called for all monitored events except :c:data:"
"`PyTrace_LINE` :c:data:`PyTrace_OPCODE` and :c:data:`PyTrace_EXCEPTION`."
msgstr ""

#: ../../../c-api/profiling.rst:121
msgid "See also the :func:`sys.setprofile` function."
msgstr ""

#: ../../../c-api/profiling.rst:123 ../../../c-api/profiling.rst:131
#: ../../../c-api/profiling.rst:150 ../../../c-api/profiling.rst:158
msgid "The caller must have an :term:`attached thread state`."
msgstr ""

#: ../../../c-api/profiling.rst:128
msgid ""
"Like :c:func:`PyEval_SetProfile` but sets the profile function in all "
"running threads belonging to the current interpreter instead of the setting "
"it only on the current thread."
msgstr ""

#: ../../../c-api/profiling.rst:133
msgid ""
"As :c:func:`PyEval_SetProfile`, this function ignores any exceptions raised "
"while setting the profile functions in all threads."
msgstr ""

#: ../../../c-api/profiling.rst:141
msgid ""
"Set the tracing function to *func*.  This is similar to :c:func:"
"`PyEval_SetProfile`, except the tracing function does receive line-number "
"events and per-opcode events, but does not receive any event related to C "
"function objects being called.  Any trace function registered using :c:func:"
"`PyEval_SetTrace` will not receive :c:data:`PyTrace_C_CALL`, :c:data:"
"`PyTrace_C_EXCEPTION` or :c:data:`PyTrace_C_RETURN` as a value for the "
"*what* parameter."
msgstr ""

#: ../../../c-api/profiling.rst:148
msgid "See also the :func:`sys.settrace` function."
msgstr ""

#: ../../../c-api/profiling.rst:155
msgid ""
"Like :c:func:`PyEval_SetTrace` but sets the tracing function in all running "
"threads belonging to the current interpreter instead of the setting it only "
"on the current thread."
msgstr ""

#: ../../../c-api/profiling.rst:160
msgid ""
"As :c:func:`PyEval_SetTrace`, this function ignores any exceptions raised "
"while setting the trace functions in all threads."
msgstr ""

#: ../../../c-api/profiling.rst:167
msgid "Reference tracing"
msgstr ""

#: ../../../c-api/profiling.rst:174
msgid ""
"The type of the trace function registered using :c:func:"
"`PyRefTracer_SetTracer`. The first parameter is a Python object that has "
"been just created (when **event** is set to :c:data:`PyRefTracer_CREATE`) or "
"about to be destroyed (when **event** is set to :c:data:"
"`PyRefTracer_DESTROY`). The **data** argument is the opaque pointer that was "
"provided when :c:func:`PyRefTracer_SetTracer` was called."
msgstr ""

#: ../../../c-api/profiling.rst:180
msgid ""
"If a new tracing function is registered replacing the current one, a call to "
"the trace function will be made with the object set to **NULL** and "
"**event** set to :c:data:`PyRefTracer_TRACKER_REMOVED`. This will happen "
"just before the new function is registered."
msgstr ""

#: ../../../c-api/profiling.rst:190
msgid ""
"The value for the *event* parameter to :c:type:`PyRefTracer` functions when "
"a Python object has been created."
msgstr ""

#: ../../../c-api/profiling.rst:196
msgid ""
"The value for the *event* parameter to :c:type:`PyRefTracer` functions when "
"a Python object has been destroyed."
msgstr ""

#: ../../../c-api/profiling.rst:202
msgid ""
"The value for the *event* parameter to :c:type:`PyRefTracer` functions when "
"the current tracer is about to be replaced by a new one."
msgstr ""

#: ../../../c-api/profiling.rst:210
msgid ""
"Register a reference tracer function. The function will be called when a new "
"Python object has been created or when an object is going to be destroyed. "
"If **data** is provided it must be an opaque pointer that will be provided "
"when the tracer function is called. Return ``0`` on success. Set an "
"exception and return ``-1`` on error."
msgstr ""

#: ../../../c-api/profiling.rst:216
msgid ""
"Note that tracer functions **must not** create Python objects inside or "
"otherwise the call will be re-entrant. The tracer also **must not** clear "
"any existing exception or set an exception.  A :term:`thread state` will be "
"active every time the tracer function is called."
msgstr ""

#: ../../../c-api/profiling.rst:221 ../../../c-api/profiling.rst:237
msgid ""
"There must be an :term:`attached thread state` when calling this function."
msgstr ""

#: ../../../c-api/profiling.rst:223
msgid ""
"If another tracer function was already registered, the old function will be "
"called with **event** set to :c:data:`PyRefTracer_TRACKER_REMOVED` just "
"before the new function is registered."
msgstr ""

#: ../../../c-api/profiling.rst:232
msgid ""
"Get the registered reference tracer function and the value of the opaque "
"data pointer that was registered when :c:func:`PyRefTracer_SetTracer` was "
"called. If no tracer was registered this function will return NULL and will "
"set the **data** pointer to NULL."
msgstr ""

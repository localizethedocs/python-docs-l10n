# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.15\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2026-02-23 09:28+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../c-api/subinterpreters.rst:6
msgid "Multiple interpreters in a Python process"
msgstr ""

#: ../../../c-api/subinterpreters.rst:8
msgid ""
"While in most uses, you will only embed a single Python interpreter, there "
"are cases where you need to create several independent interpreters in the "
"same process and perhaps even in the same thread. Sub-interpreters allow you "
"to do that."
msgstr ""

#: ../../../c-api/subinterpreters.rst:13
msgid ""
"The \"main\" interpreter is the first one created when the runtime "
"initializes. It is usually the only Python interpreter in a process.  Unlike "
"sub-interpreters, the main interpreter has unique process-global "
"responsibilities like signal handling.  It is also responsible for execution "
"during runtime initialization and is usually the active interpreter during "
"runtime finalization.  The :c:func:`PyInterpreterState_Main` function "
"returns a pointer to its state."
msgstr ""

#: ../../../c-api/subinterpreters.rst:20
msgid ""
"You can switch between sub-interpreters using the :c:func:"
"`PyThreadState_Swap` function. You can create and destroy them using the "
"following functions:"
msgstr ""

#: ../../../c-api/subinterpreters.rst:26
msgid ""
"Structure containing most parameters to configure a sub-interpreter. Its "
"values are used only in :c:func:`Py_NewInterpreterFromConfig` and never "
"modified by the runtime."
msgstr ""

#: ../../../c-api/subinterpreters.rst:32
msgid "Structure fields:"
msgstr ""

#: ../../../c-api/subinterpreters.rst:36
msgid ""
"If this is ``0`` then the sub-interpreter will use its own \"object\" "
"allocator state. Otherwise it will use (share) the main interpreter's."
msgstr ""

#: ../../../c-api/subinterpreters.rst:40
msgid ""
"If this is ``0`` then :c:member:`~PyInterpreterConfig."
"check_multi_interp_extensions` must be ``1`` (non-zero). If this is ``1`` "
"then :c:member:`~PyInterpreterConfig.gil` must not be :c:macro:"
"`PyInterpreterConfig_OWN_GIL`."
msgstr ""

#: ../../../c-api/subinterpreters.rst:48
msgid ""
"If this is ``0`` then the runtime will not support forking the process in "
"any thread where the sub-interpreter is currently active. Otherwise fork is "
"unrestricted."
msgstr ""

#: ../../../c-api/subinterpreters.rst:52
msgid ""
"Note that the :mod:`subprocess` module still works when fork is disallowed."
msgstr ""

#: ../../../c-api/subinterpreters.rst:57
msgid ""
"If this is ``0`` then the runtime will not support replacing the current "
"process via exec (e.g. :func:`os.execv`) in any thread where the sub-"
"interpreter is currently active. Otherwise exec is unrestricted."
msgstr ""

#: ../../../c-api/subinterpreters.rst:62
msgid ""
"Note that the :mod:`subprocess` module still works when exec is disallowed."
msgstr ""

#: ../../../c-api/subinterpreters.rst:67
msgid ""
"If this is ``0`` then the sub-interpreter's :mod:`threading` module won't "
"create threads. Otherwise threads are allowed."
msgstr ""

#: ../../../c-api/subinterpreters.rst:73
msgid ""
"If this is ``0`` then the sub-interpreter's :mod:`threading` module won't "
"create daemon threads. Otherwise daemon threads are allowed (as long as :c:"
"member:`~PyInterpreterConfig.allow_threads` is non-zero)."
msgstr ""

#: ../../../c-api/subinterpreters.rst:80
msgid ""
"If this is ``0`` then all extension modules may be imported, including "
"legacy (single-phase init) modules, in any thread where the sub-interpreter "
"is currently active. Otherwise only multi-phase init extension modules (see :"
"pep:`489`) may be imported. (Also see :c:macro:"
"`Py_mod_multiple_interpreters`.)"
msgstr ""

#: ../../../c-api/subinterpreters.rst:87
msgid ""
"This must be ``1`` (non-zero) if :c:member:`~PyInterpreterConfig."
"use_main_obmalloc` is ``0``."
msgstr ""

#: ../../../c-api/subinterpreters.rst:92
msgid ""
"This determines the operation of the GIL for the sub-interpreter. It may be "
"one of the following:"
msgstr ""

#: ../../../c-api/subinterpreters.rst:99
msgid "Use the default selection (:c:macro:`PyInterpreterConfig_SHARED_GIL`)."
msgstr ""

#: ../../../c-api/subinterpreters.rst:103
msgid "Use (share) the main interpreter's GIL."
msgstr ""

#: ../../../c-api/subinterpreters.rst:107
msgid "Use the sub-interpreter's own GIL."
msgstr ""

#: ../../../c-api/subinterpreters.rst:109
msgid ""
"If this is :c:macro:`PyInterpreterConfig_OWN_GIL` then :c:member:"
"`PyInterpreterConfig.use_main_obmalloc` must be ``0``."
msgstr ""

#: ../../../c-api/subinterpreters.rst:123
msgid ""
"Create a new sub-interpreter.  This is an (almost) totally separate "
"environment for the execution of Python code.  In particular, the new "
"interpreter has separate, independent versions of all imported modules, "
"including the fundamental modules :mod:`builtins`, :mod:`__main__` and :mod:"
"`sys`.  The table of loaded modules (``sys.modules``) and the module search "
"path (``sys.path``) are also separate.  The new environment has no ``sys."
"argv`` variable.  It has new standard I/O stream file objects ``sys.stdin``, "
"``sys.stdout`` and ``sys.stderr`` (however these refer to the same "
"underlying file descriptors)."
msgstr ""

#: ../../../c-api/subinterpreters.rst:133
msgid ""
"The given *config* controls the options with which the interpreter is "
"initialized."
msgstr ""

#: ../../../c-api/subinterpreters.rst:136
msgid ""
"Upon success, *tstate_p* will be set to the first :term:`thread state` "
"created in the new sub-interpreter.  This thread state is :term:`attached "
"<attached thread state>`. Note that no actual thread is created; see the "
"discussion of thread states below.  If creation of the new interpreter is "
"unsuccessful, *tstate_p* is set to ``NULL``; no exception is set since the "
"exception state is stored in the :term:`attached thread state`, which might "
"not exist."
msgstr ""

#: ../../../c-api/subinterpreters.rst:145
msgid ""
"Like all other Python/C API functions, an :term:`attached thread state` must "
"be present before calling this function, but it might be detached upon "
"returning. On success, the returned thread state will be :term:`attached "
"<attached thread state>`. If the sub-interpreter is created with its own :"
"term:`GIL` then the :term:`attached thread state` of the calling interpreter "
"will be detached. When the function returns, the new interpreter's :term:"
"`thread state` will be :term:`attached <attached thread state>` to the "
"current thread and the previous interpreter's :term:`attached thread state` "
"will remain detached."
msgstr ""

#: ../../../c-api/subinterpreters.rst:156
msgid ""
"Sub-interpreters are most effective when isolated from each other, with "
"certain functionality restricted::"
msgstr ""

#: ../../../c-api/subinterpreters.rst:174
msgid ""
"Note that the config is used only briefly and does not get modified. During "
"initialization the config's values are converted into various :c:type:"
"`PyInterpreterState` values.  A read-only copy of the config may be stored "
"internally on the :c:type:`PyInterpreterState`."
msgstr ""

#: ../../../c-api/subinterpreters.rst:183
msgid "Extension modules are shared between (sub-)interpreters as follows:"
msgstr ""

#: ../../../c-api/subinterpreters.rst:185
msgid ""
"For modules using multi-phase initialization, e.g. :c:func:"
"`PyModule_FromDefAndSpec`, a separate module object is created and "
"initialized for each interpreter. Only C-level static and global variables "
"are shared between these module objects."
msgstr ""

#: ../../../c-api/subinterpreters.rst:191
msgid ""
"For modules using legacy :ref:`single-phase initialization <single-phase-"
"initialization>`, e.g. :c:func:`PyModule_Create`, the first time a "
"particular extension is imported, it is initialized normally, and a "
"(shallow) copy of its module's dictionary is squirreled away. When the same "
"extension is imported by another (sub-)interpreter, a new module is "
"initialized and filled with the contents of this copy; the extension's "
"``init`` function is not called. Objects in the module's dictionary thus end "
"up shared across (sub-)interpreters, which might cause unwanted behavior "
"(see `Bugs and caveats`_ below)."
msgstr ""

#: ../../../c-api/subinterpreters.rst:203
msgid ""
"Note that this is different from what happens when an extension is imported "
"after the interpreter has been completely re-initialized by calling :c:func:"
"`Py_FinalizeEx` and :c:func:`Py_Initialize`; in that case, the extension's "
"``initmodule`` function *is* called again. As with multi-phase "
"initialization, this means that only C-level static and global variables are "
"shared between these modules."
msgstr ""

#: ../../../c-api/subinterpreters.rst:223
msgid ""
"Create a new sub-interpreter.  This is essentially just a wrapper around :c:"
"func:`Py_NewInterpreterFromConfig` with a config that preserves the existing "
"behavior.  The result is an unisolated sub-interpreter that shares the main "
"interpreter's GIL, allows fork/exec, allows daemon threads, and allows "
"single-phase init modules."
msgstr ""

#: ../../../c-api/subinterpreters.rst:235
msgid ""
"Destroy the (sub-)interpreter represented by the given :term:`thread state`. "
"The given thread state must be :term:`attached <attached thread state>`. "
"When the call returns, there will be no :term:`attached thread state`. All "
"thread states associated with this interpreter are destroyed."
msgstr ""

#: ../../../c-api/subinterpreters.rst:240
msgid ""
":c:func:`Py_FinalizeEx` will destroy all sub-interpreters that haven't been "
"explicitly destroyed at that point."
msgstr ""

#: ../../../c-api/subinterpreters.rst:247
msgid "A per-interpreter GIL"
msgstr ""

#: ../../../c-api/subinterpreters.rst:251
msgid ""
"Using :c:func:`Py_NewInterpreterFromConfig` you can create a sub-interpreter "
"that is completely isolated from other interpreters, including having its "
"own GIL.  The most important benefit of this isolation is that such an "
"interpreter can execute Python code without being blocked by other "
"interpreters or blocking any others.  Thus a single Python process can truly "
"take advantage of multiple CPU cores when running Python code.  The "
"isolation also encourages a different approach to concurrency than that of "
"just using threads. (See :pep:`554` and :pep:`684`.)"
msgstr ""

#: ../../../c-api/subinterpreters.rst:261
msgid ""
"Using an isolated interpreter requires vigilance in preserving that "
"isolation.  That especially means not sharing any objects or mutable state "
"without guarantees about thread-safety.  Even objects that are otherwise "
"immutable (e.g. ``None``, ``(1, 5)``) can't normally be shared because of "
"the refcount.  One simple but less-efficient approach around this is to use "
"a global lock around all use of some state (or object). Alternately, "
"effectively immutable objects (like integers or strings) can be made safe in "
"spite of their refcounts by making them :term:`immortal`. In fact, this has "
"been done for the builtin singletons, small integers, and a number of other "
"builtin objects."
msgstr ""

#: ../../../c-api/subinterpreters.rst:272
msgid ""
"If you preserve isolation then you will have access to proper multi-core "
"computing without the complications that come with free-threading. Failure "
"to preserve isolation will expose you to the full consequences of free-"
"threading, including races and hard-to-debug crashes."
msgstr ""

#: ../../../c-api/subinterpreters.rst:277
msgid ""
"Aside from that, one of the main challenges of using multiple isolated "
"interpreters is how to communicate between them safely (not break isolation) "
"and efficiently.  The runtime and stdlib do not provide any standard "
"approach to this yet.  A future stdlib module would help mitigate the effort "
"of preserving isolation and expose effective tools for communicating (and "
"sharing) data between interpreters."
msgstr ""

#: ../../../c-api/subinterpreters.rst:286
msgid "Bugs and caveats"
msgstr ""

#: ../../../c-api/subinterpreters.rst:288
msgid ""
"Because sub-interpreters (and the main interpreter) are part of the same "
"process, the insulation between them isn't perfect --- for example, using "
"low-level file operations like :func:`os.close` they can (accidentally or "
"maliciously) affect each other's open files.  Because of the way extensions "
"are shared between (sub-)interpreters, some extensions may not work "
"properly; this is especially likely when using single-phase initialization "
"or (static) global variables. It is possible to insert objects created in "
"one sub-interpreter into a namespace of another (sub-)interpreter; this "
"should be avoided if possible."
msgstr ""

#: ../../../c-api/subinterpreters.rst:298
msgid ""
"Special care should be taken to avoid sharing user-defined functions, "
"methods, instances or classes between sub-interpreters, since import "
"operations executed by such objects may affect the wrong (sub-)interpreter's "
"dictionary of loaded modules. It is equally important to avoid sharing "
"objects from which the above are reachable."
msgstr ""

#: ../../../c-api/subinterpreters.rst:304
msgid ""
"Also note that combining this functionality with ``PyGILState_*`` APIs is "
"delicate, because these APIs assume a bijection between Python thread states "
"and OS-level threads, an assumption broken by the presence of sub-"
"interpreters. It is highly recommended that you don't switch sub-"
"interpreters between a pair of matching :c:func:`PyGILState_Ensure` and :c:"
"func:`PyGILState_Release` calls. Furthermore, extensions (such as :mod:"
"`ctypes`) using these APIs to allow calling of Python code from non-Python "
"created threads will probably be broken when using sub-interpreters."
msgstr ""

#: ../../../c-api/subinterpreters.rst:315
msgid "High-level APIs"
msgstr ""

#: ../../../c-api/subinterpreters.rst:319
msgid ""
"This data structure represents the state shared by a number of cooperating "
"threads.  Threads belonging to the same interpreter share their module "
"administration and a few other internal items. There are no public members "
"in this structure."
msgstr ""

#: ../../../c-api/subinterpreters.rst:324
msgid ""
"Threads belonging to different interpreters initially share nothing, except "
"process state like available memory, open file descriptors and such.  The "
"global interpreter lock is also shared by all threads, regardless of to "
"which interpreter they belong."
msgstr ""

#: ../../../c-api/subinterpreters.rst:331
msgid ""
":pep:`684` introduced the possibility of a :ref:`per-interpreter GIL <per-"
"interpreter-gil>`. See :c:func:`Py_NewInterpreterFromConfig`."
msgstr ""

#: ../../../c-api/subinterpreters.rst:338
msgid "Get the current interpreter."
msgstr ""

#: ../../../c-api/subinterpreters.rst:340
msgid ""
"Issue a fatal error if there is no :term:`attached thread state`. It cannot "
"return NULL."
msgstr ""

#: ../../../c-api/subinterpreters.rst:348
msgid ""
"Return the interpreter's unique ID.  If there was any error in doing so then "
"``-1`` is returned and an error is set."
msgstr ""

#: ../../../c-api/subinterpreters.rst:351
msgid "The caller must have an :term:`attached thread state`."
msgstr ""

#: ../../../c-api/subinterpreters.rst:358
msgid ""
"Return a dictionary in which interpreter-specific data may be stored. If "
"this function returns ``NULL`` then no exception has been raised and the "
"caller should assume no interpreter-specific dict is available."
msgstr ""

#: ../../../c-api/subinterpreters.rst:362
msgid ""
"This is not a replacement for :c:func:`PyModule_GetState()`, which "
"extensions should use to store interpreter-specific state information."
msgstr ""

#: ../../../c-api/subinterpreters.rst:365
msgid ""
"The returned dictionary is borrowed from the interpreter and is valid until "
"interpreter shutdown."
msgstr ""

#: ../../../c-api/subinterpreters.rst:373
msgid "Type of a frame evaluation function."
msgstr ""

#: ../../../c-api/subinterpreters.rst:375
msgid ""
"The *throwflag* parameter is used by the ``throw()`` method of generators: "
"if non-zero, handle the current exception."
msgstr ""

#: ../../../c-api/subinterpreters.rst:378
msgid "The function now takes a *tstate* parameter."
msgstr ""

#: ../../../c-api/subinterpreters.rst:381
msgid ""
"The *frame* parameter changed from ``PyFrameObject*`` to "
"``_PyInterpreterFrame*``."
msgstr ""

#: ../../../c-api/subinterpreters.rst:387
msgid "Get the frame evaluation function."
msgstr ""

#: ../../../c-api/subinterpreters.rst:389
#: ../../../c-api/subinterpreters.rst:398
msgid "See the :pep:`523` \"Adding a frame evaluation API to CPython\"."
msgstr ""

#: ../../../c-api/subinterpreters.rst:396
msgid "Set the frame evaluation function."
msgstr ""

#: ../../../c-api/subinterpreters.rst:404
msgid "Low-level APIs"
msgstr ""

#: ../../../c-api/subinterpreters.rst:406
msgid ""
"All of the following functions must be called after :c:func:`Py_Initialize`."
msgstr ""

#: ../../../c-api/subinterpreters.rst:408
msgid ""
":c:func:`Py_Initialize()` now initializes the :term:`GIL` and sets an :term:"
"`attached thread state`."
msgstr ""

#: ../../../c-api/subinterpreters.rst:415
msgid ""
"Create a new interpreter state object.  An :term:`attached thread state` is "
"not needed, but may optionally exist if it is necessary to serialize calls "
"to this function."
msgstr ""

#: ../../../c-api/subinterpreters.rst:419
msgid ""
"Raises an :ref:`auditing event <auditing>` ``cpython."
"PyInterpreterState_New`` with no arguments."
msgstr ""

#: ../../../c-api/subinterpreters.rst:424
msgid ""
"Reset all information in an interpreter state object.  There must be an :"
"term:`attached thread state` for the interpreter."
msgstr ""

#: ../../../c-api/subinterpreters.rst:427
msgid ""
"Raises an :ref:`auditing event <auditing>` ``cpython."
"PyInterpreterState_Clear`` with no arguments."
msgstr ""

#: ../../../c-api/subinterpreters.rst:432
msgid ""
"Destroy an interpreter state object.  There **should not** be an :term:"
"`attached thread state` for the target interpreter. The interpreter state "
"must have been reset with a previous call to :c:func:"
"`PyInterpreterState_Clear`."
msgstr ""

#: ../../../c-api/subinterpreters.rst:440
msgid "Advanced debugger support"
msgstr ""

#: ../../../c-api/subinterpreters.rst:442
msgid ""
"These functions are only intended to be used by advanced debugging tools."
msgstr ""

#: ../../../c-api/subinterpreters.rst:447
msgid ""
"Return the interpreter state object at the head of the list of all such "
"objects."
msgstr ""

#: ../../../c-api/subinterpreters.rst:452
msgid "Return the main interpreter state object."
msgstr ""

#: ../../../c-api/subinterpreters.rst:457
msgid ""
"Return the next interpreter state object after *interp* from the list of all "
"such objects."
msgstr ""

#: ../../../c-api/subinterpreters.rst:463
msgid ""
"Return the pointer to the first :c:type:`PyThreadState` object in the list "
"of threads associated with the interpreter *interp*."
msgstr ""

#: ../../../c-api/subinterpreters.rst:469
msgid ""
"Return the next thread state object after *tstate* from the list of all such "
"objects belonging to the same :c:type:`PyInterpreterState` object."
msgstr ""

#: ../../../c-api/subinterpreters.rst:115
#: ../../../c-api/subinterpreters.rst:215
msgid "module"
msgstr ""

#: ../../../c-api/subinterpreters.rst:115
#: ../../../c-api/subinterpreters.rst:215
msgid "builtins"
msgstr ""

#: ../../../c-api/subinterpreters.rst:115
#: ../../../c-api/subinterpreters.rst:215
msgid "__main__"
msgstr ""

#: ../../../c-api/subinterpreters.rst:115
#: ../../../c-api/subinterpreters.rst:215
msgid "sys"
msgstr ""

#: ../../../c-api/subinterpreters.rst:115
#: ../../../c-api/subinterpreters.rst:215
msgid "stdout (in module sys)"
msgstr ""

#: ../../../c-api/subinterpreters.rst:115
#: ../../../c-api/subinterpreters.rst:215
msgid "stderr (in module sys)"
msgstr ""

#: ../../../c-api/subinterpreters.rst:115
#: ../../../c-api/subinterpreters.rst:215
msgid "stdin (in module sys)"
msgstr ""

#: ../../../c-api/subinterpreters.rst:179
#: ../../../c-api/subinterpreters.rst:233
msgid "Py_FinalizeEx (C function)"
msgstr ""

#: ../../../c-api/subinterpreters.rst:179
msgid "Py_Initialize (C function)"
msgstr ""

#: ../../../c-api/subinterpreters.rst:210
msgid "close (in module os)"
msgstr ""

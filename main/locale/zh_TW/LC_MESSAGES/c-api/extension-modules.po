# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.15\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-12-01 09:06+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../c-api/extension-modules.rst:6
msgid "Defining extension modules"
msgstr ""

#: ../../../c-api/extension-modules.rst:8
msgid ""
"A C extension for CPython is a shared library (for example, a ``.so`` file "
"on Linux, ``.pyd`` DLL on Windows), which is loadable into the Python "
"process (for example, it is compiled with compatible compiler settings), and "
"which exports an :dfn:`export hook` function (or an old-style :ref:"
"`initialization function <extension-pyinit>`)."
msgstr ""

#: ../../../c-api/extension-modules.rst:14
msgid ""
"To be importable by default (that is, by :py:class:`importlib.machinery."
"ExtensionFileLoader`), the shared library must be available on :py:attr:`sys."
"path`, and must be named after the module name plus an extension listed in :"
"py:attr:`importlib.machinery.EXTENSION_SUFFIXES`."
msgstr ""

#: ../../../c-api/extension-modules.rst:22
msgid ""
"Building, packaging and distributing extension modules is best done with "
"third-party tools, and is out of scope of this document. One suitable tool "
"is Setuptools, whose documentation can be found at https://setuptools.pypa."
"io/en/latest/setuptools.html."
msgstr ""

#: ../../../c-api/extension-modules.rst:30
msgid "Extension export hook"
msgstr ""

#: ../../../c-api/extension-modules.rst:34
msgid ""
"Support for the :samp:`PyModExport_{<name>}` export hook was added in Python "
"3.15. The older way of defining modules is still available: consult either "
"the :ref:`extension-pyinit` section or earlier versions of this "
"documentation if you plan to support earlier Python versions."
msgstr ""

#: ../../../c-api/extension-modules.rst:39
msgid ""
"The export hook must be an exported function with the following signature:"
msgstr ""

#: ../../../c-api/extension-modules.rst:43
msgid ""
"For modules with ASCII-only names, the :ref:`export hook <extension-export-"
"hook>` must be named :samp:`PyModExport_{<name>}`, with ``<name>`` replaced "
"by the module's name."
msgstr ""

#: ../../../c-api/extension-modules.rst:47
msgid ""
"For non-ASCII module names, the export hook must instead be named :samp:"
"`PyModExportU_{<name>}` (note the ``U``), with ``<name>`` encoded using "
"Python's *punycode* encoding with hyphens replaced by underscores. In Python:"
msgstr ""

#: ../../../c-api/extension-modules.rst:60
msgid ""
"The export hook returns an array of :c:type:`PyModuleDef_Slot` entries, "
"terminated by an entry with a slot ID of ``0``. These slots describe how the "
"module should be created and initialized."
msgstr ""

#: ../../../c-api/extension-modules.rst:64
msgid ""
"This array must remain valid and constant until interpreter shutdown. "
"Typically, it should use ``static`` storage. Prefer using the :c:macro:"
"`Py_mod_create` and :c:macro:`Py_mod_exec` slots for any dynamic behavior."
msgstr ""

#: ../../../c-api/extension-modules.rst:69
msgid ""
"The export hook may return ``NULL`` with an exception set to signal failure."
msgstr ""

#: ../../../c-api/extension-modules.rst:71
msgid ""
"It is recommended to define the export hook function using a helper macro:"
msgstr ""

#: ../../../c-api/extension-modules.rst:75
msgid "Declare an extension module export hook. This macro:"
msgstr ""

#: ../../../c-api/extension-modules.rst:78
msgid "specifies the :c:expr:`PyModuleDef_Slot*` return type,"
msgstr ""

#: ../../../c-api/extension-modules.rst:79
#: ../../../c-api/extension-modules.rst:224
msgid "adds any special linkage declarations required by the platform, and"
msgstr ""

#: ../../../c-api/extension-modules.rst:80
#: ../../../c-api/extension-modules.rst:225
msgid "for C++, declares the function as ``extern \"C\"``."
msgstr ""

#: ../../../c-api/extension-modules.rst:82
#: ../../../c-api/extension-modules.rst:255
msgid "For example, a module called ``spam`` would be defined like this::"
msgstr ""

#: ../../../c-api/extension-modules.rst:100
msgid ""
"The export hook is typically the only non-\\ ``static`` item defined in the "
"module's C source."
msgstr ""

#: ../../../c-api/extension-modules.rst:103
msgid ""
"The hook should be kept short -- ideally, one line as above. If you do need "
"to use Python C API in this function, it is recommended to call "
"``PyABIInfo_Check(&abi_info, \"modulename\")`` first to raise an exception, "
"rather than crash, in common cases of ABI mismatch."
msgstr ""

#: ../../../c-api/extension-modules.rst:111
msgid ""
"It is possible to export multiple modules from a single shared library by "
"defining multiple export hooks. However, importing  them requires a custom "
"importer or suitably named copies/links of the extension file, because "
"Python's import machinery only finds the function corresponding to the "
"filename. See the `Multiple modules in one library <https://peps.python.org/"
"pep-0489/#multiple-modules-in-one-library>`__ section in :pep:`489` for "
"details."
msgstr ""

#: ../../../c-api/extension-modules.rst:123
msgid "Multi-phase initialization"
msgstr "多階段初始化"

#: ../../../c-api/extension-modules.rst:125
msgid "The process of creating an extension module follows several phases:"
msgstr ""

#: ../../../c-api/extension-modules.rst:127
msgid ""
"Python finds and calls the export hook to get information on how to create "
"the module."
msgstr ""

#: ../../../c-api/extension-modules.rst:129
msgid ""
"Before any substantial code is executed, Python can determine which "
"capabilities the module supports, and it can adjust the environment or "
"refuse loading an incompatible extension. Slots like :c:data:`Py_mod_abi`, :"
"c:data:`Py_mod_gil` and :c:data:`Py_mod_multiple_interpreters` influence "
"this step."
msgstr ""

#: ../../../c-api/extension-modules.rst:134
msgid ""
"By default, Python itself then creates the module object -- that is, it does "
"the equivalent of calling :py:meth:`~object.__new__` when creating an "
"object. This step can be overridden using the :c:data:`Py_mod_create` slot."
msgstr ""

#: ../../../c-api/extension-modules.rst:137
msgid ""
"Python sets initial module attributes like :attr:`~module.__package__` and :"
"attr:`~module.__loader__`, and inserts the module object into :py:attr:`sys."
"modules`."
msgstr ""

#: ../../../c-api/extension-modules.rst:140
msgid ""
"Afterwards, the module object is initialized in an extension-specific way -- "
"the equivalent of :py:meth:`~object.__init__` when creating an object, or of "
"executing top-level code in a Python-language module. The behavior is "
"specified using the :c:data:`Py_mod_exec` slot."
msgstr ""

#: ../../../c-api/extension-modules.rst:145
msgid ""
"This is called *multi-phase initialization* to distinguish it from the "
"legacy (but still supported) :ref:`single-phase initialization <single-phase-"
"initialization>`, where an initialization function returns a fully "
"constructed module."
msgstr ""

#: ../../../c-api/extension-modules.rst:151
msgid "Added support for multi-phase initialization (:pep:`489`)."
msgstr ""

#: ../../../c-api/extension-modules.rst:155
msgid "Multiple module instances"
msgstr ""

#: ../../../c-api/extension-modules.rst:157
msgid ""
"By default, extension modules are not singletons. For example, if the :py:"
"attr:`sys.modules` entry is removed and the module is re-imported, a new "
"module object is created and, typically, populated with fresh method and "
"type objects. The old module is subject to normal garbage collection. This "
"mirrors the behavior of pure-Python modules."
msgstr ""

#: ../../../c-api/extension-modules.rst:164
msgid ""
"Additional module instances may be created in :ref:`sub-interpreters <sub-"
"interpreter-support>` or after Python runtime reinitialization (:c:func:"
"`Py_Finalize` and :c:func:`Py_Initialize`). In these cases, sharing Python "
"objects between module instances would likely cause crashes or undefined "
"behavior."
msgstr ""

#: ../../../c-api/extension-modules.rst:171
msgid ""
"To avoid such issues, each instance of an extension module should be "
"*isolated*: changes to one instance should not implicitly affect the others, "
"and all state owned by the module, including references to Python objects, "
"should be specific to a particular module instance. See :ref:`isolating-"
"extensions-howto` for more details and a practical guide."
msgstr ""

#: ../../../c-api/extension-modules.rst:177
msgid ""
"A simpler way to avoid these issues is :ref:`raising an error on repeated "
"initialization <isolating-extensions-optout>`."
msgstr ""

#: ../../../c-api/extension-modules.rst:180
msgid ""
"All modules are expected to support :ref:`sub-interpreters <sub-interpreter-"
"support>`, or otherwise explicitly signal a lack of support. This is usually "
"achieved by isolation or blocking repeated initialization, as above. A "
"module may also be limited to the main interpreter using the :c:data:"
"`Py_mod_multiple_interpreters` slot."
msgstr ""

#: ../../../c-api/extension-modules.rst:192
msgid "``PyInit`` function"
msgstr ""

#: ../../../c-api/extension-modules.rst:196
msgid ""
"This functionality is :term:`soft deprecated`. It will not get new features, "
"but there are no plans to remove it."
msgstr ""

#: ../../../c-api/extension-modules.rst:199
msgid ""
"Instead of :c:func:`PyModExport_modulename`, an extension module can define "
"an older-style :dfn:`initialization function` with the signature:"
msgstr ""

#: ../../../c-api/extension-modules.rst:204
msgid ""
"Its name should be :samp:`PyInit_{<name>}`, with ``<name>`` replaced by the "
"name of the module. For non-ASCII module names, use :samp:`PyInitU_{<name>}` "
"instead, with ``<name>`` encoded in the same way as for the :ref:`export "
"hook <extension-export-hook>` (that is, using Punycode with underscores)."
msgstr ""

#: ../../../c-api/extension-modules.rst:211
msgid ""
"If a module exports both :samp:`PyInit_{<name>}` and :samp:"
"`PyModExport_{<name>}`, the :samp:`PyInit_{<name>}` function is ignored."
msgstr ""

#: ../../../c-api/extension-modules.rst:215
msgid ""
"Like with :c:macro:`PyMODEXPORT_FUNC`, it is recommended to define the "
"initialization function using a helper macro:"
msgstr ""

#: ../../../c-api/extension-modules.rst:220
msgid "Declare an extension module initialization function. This macro:"
msgstr ""

#: ../../../c-api/extension-modules.rst:223
msgid "specifies the :c:expr:`PyObject*` return type,"
msgstr ""

#: ../../../c-api/extension-modules.rst:228
msgid ""
"Normally, the initialization function (``PyInit_modulename``) returns a :c:"
"type:`PyModuleDef` instance with non-``NULL`` :c:member:`~PyModuleDef."
"m_slots`. This allows Python to use :ref:`multi-phase initialization <multi-"
"phase-initialization>`."
msgstr ""

#: ../../../c-api/extension-modules.rst:233
msgid ""
"Before it is returned, the ``PyModuleDef`` instance must be initialized "
"using the following function:"
msgstr ""

#: ../../../c-api/extension-modules.rst:238
msgid ""
"Ensure a module definition is a properly initialized Python object that "
"correctly reports its type and a reference count."
msgstr ""

#: ../../../c-api/extension-modules.rst:241
msgid "Return *def* cast to ``PyObject*``, or ``NULL`` if an error occurred."
msgstr ""

#: ../../../c-api/extension-modules.rst:243
msgid ""
"Calling this function is required before returning a :c:type:`PyModuleDef` "
"from a module initialization function. It should not be used in other "
"contexts."
msgstr ""

#: ../../../c-api/extension-modules.rst:247
msgid ""
"Note that Python assumes that ``PyModuleDef`` structures are statically "
"allocated. This function may return either a new reference or a borrowed "
"one; this reference must not be released."
msgstr ""

#: ../../../c-api/extension-modules.rst:273
msgid "Legacy single-phase initialization"
msgstr ""

#: ../../../c-api/extension-modules.rst:277
msgid ""
"Single-phase initialization is :term:`soft deprecated`. It is a legacy "
"mechanism to initialize extension modules, with known drawbacks and design "
"flaws. Extension module authors are encouraged to use multi-phase "
"initialization instead."
msgstr ""

#: ../../../c-api/extension-modules.rst:282
msgid "However, there are no plans to remove support for it."
msgstr ""

#: ../../../c-api/extension-modules.rst:284
msgid ""
"In single-phase initialization, the old-style :ref:`initializaton function "
"<extension-pyinit>` (``PyInit_modulename``) should create, populate and "
"return a module object. This is typically done using :c:func:"
"`PyModule_Create` and functions like :c:func:`PyModule_AddObjectRef`."
msgstr ""

#: ../../../c-api/extension-modules.rst:290
msgid ""
"Single-phase initialization differs from the :ref:`default <multi-phase-"
"initialization>` in the following ways:"
msgstr ""

#: ../../../c-api/extension-modules.rst:293
msgid "Single-phase modules are, or rather *contain*, “singletons”."
msgstr ""

#: ../../../c-api/extension-modules.rst:295
msgid ""
"When the module is first initialized, Python saves the contents of the "
"module's ``__dict__`` (that is, typically, the module's functions and types)."
msgstr ""

#: ../../../c-api/extension-modules.rst:299
msgid ""
"For subsequent imports, Python does not call the initialization function "
"again. Instead, it creates a new module object with a new ``__dict__``, and "
"copies the saved contents to it. For example, given a single-phase module "
"``_testsinglephase`` [#testsinglephase]_ that defines a function ``sum`` and "
"an exception class ``error``:"
msgstr ""

#: ../../../c-api/extension-modules.rst:322
msgid ""
"The exact behavior should be considered a CPython implementation detail."
msgstr ""

#: ../../../c-api/extension-modules.rst:324
msgid ""
"To work around the fact that ``PyInit_modulename`` does not take a *spec* "
"argument, some state of the import machinery is saved and applied to the "
"first suitable module created during the ``PyInit_modulename`` call. "
"Specifically, when a sub-module is imported, this mechanism prepends the "
"parent package name to the name of the module."
msgstr ""

#: ../../../c-api/extension-modules.rst:330
msgid ""
"A single-phase ``PyInit_modulename`` function should create “its” module "
"object as soon as possible, before any other module objects can be created."
msgstr ""

#: ../../../c-api/extension-modules.rst:333
msgid "Non-ASCII module names (``PyInitU_modulename``) are not supported."
msgstr ""

#: ../../../c-api/extension-modules.rst:335
msgid ""
"Single-phase modules support module lookup functions like :c:func:"
"`PyState_FindModule`."
msgstr ""

#: ../../../c-api/extension-modules.rst:338
msgid "The module's :c:member:`PyModuleDef.m_slots` must be NULL."
msgstr ""

#: ../../../c-api/extension-modules.rst:340
msgid ""
"``_testsinglephase`` is an internal module used in CPython's self-test "
"suite; your installation may or may not include it."
msgstr ""

# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.15\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2026-02-16 09:11+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../reference/lexical_analysis.rst:6
msgid "Lexical analysis"
msgstr ""

#: ../../../reference/lexical_analysis.rst:10
msgid ""
"A Python program is read by a *parser*.  Input to the parser is a stream of :"
"term:`tokens <token>`, generated by the *lexical analyzer* (also known as "
"the *tokenizer*). This chapter describes how the lexical analyzer produces "
"these tokens."
msgstr ""

#: ../../../reference/lexical_analysis.rst:15
msgid ""
"The lexical analyzer determines the program text's :ref:`encoding "
"<encodings>` (UTF-8 by default), and decodes the text into :ref:`source "
"characters <lexical-source-character>`. If the text cannot be decoded, a :"
"exc:`SyntaxError` is raised."
msgstr ""

#: ../../../reference/lexical_analysis.rst:20
msgid ""
"Next, the lexical analyzer uses the source characters to generate a stream "
"of tokens. The type of a generated token generally depends on the next "
"source character to be processed. Similarly, other special behavior of the "
"analyzer depends on the first source character that hasn't yet been "
"processed. The following table gives a quick summary of these source "
"characters, with links to sections that contain more information."
msgstr ""

#: ../../../reference/lexical_analysis.rst:30
msgid "Character"
msgstr ""

#: ../../../reference/lexical_analysis.rst:31
msgid "Next token (or other relevant documentation)"
msgstr ""

#: ../../../reference/lexical_analysis.rst:33
#: ../../../reference/lexical_analysis.rst:266
msgid "space"
msgstr ""

#: ../../../reference/lexical_analysis.rst:34
#: ../../../reference/lexical_analysis.rst:266
msgid "tab"
msgstr ""

#: ../../../reference/lexical_analysis.rst:35
msgid "formfeed"
msgstr ""

#: ../../../reference/lexical_analysis.rst:36
msgid ":ref:`Whitespace <whitespace>`"
msgstr ""

#: ../../../reference/lexical_analysis.rst:38
msgid "CR, LF"
msgstr ""

#: ../../../reference/lexical_analysis.rst:39
msgid ":ref:`New line <line-structure>`"
msgstr ""

#: ../../../reference/lexical_analysis.rst:40
msgid ":ref:`Indentation <indentation>`"
msgstr ""

#: ../../../reference/lexical_analysis.rst:42
msgid "backslash (``\\``)"
msgstr ""

#: ../../../reference/lexical_analysis.rst:43
msgid ":ref:`Explicit line joining <explicit-joining>`"
msgstr ""

#: ../../../reference/lexical_analysis.rst:44
msgid "(Also significant in :ref:`string escape sequences <escape-sequences>`)"
msgstr ""

#: ../../../reference/lexical_analysis.rst:46
msgid "hash (``#``)"
msgstr ""

#: ../../../reference/lexical_analysis.rst:47
msgid ":ref:`Comment <comments>`"
msgstr ""

#: ../../../reference/lexical_analysis.rst:49
msgid "quote (``'``, ``\"``)"
msgstr ""

#: ../../../reference/lexical_analysis.rst:50
msgid ":ref:`String literal <strings>`"
msgstr ""

#: ../../../reference/lexical_analysis.rst:52
msgid "ASCII letter (``a``-``z``, ``A``-``Z``)"
msgstr ""

#: ../../../reference/lexical_analysis.rst:53
msgid "non-ASCII character"
msgstr ""

#: ../../../reference/lexical_analysis.rst:54
#: ../../../reference/lexical_analysis.rst:58
msgid ":ref:`Name <identifiers>`"
msgstr ""

#: ../../../reference/lexical_analysis.rst:55
msgid "Prefixed :ref:`string or bytes literal <strings>`"
msgstr ""

#: ../../../reference/lexical_analysis.rst:57
msgid "underscore (``_``)"
msgstr ""

#: ../../../reference/lexical_analysis.rst:59
msgid "(Can also be part of :ref:`numeric literals <numbers>`)"
msgstr ""

#: ../../../reference/lexical_analysis.rst:61
msgid "number (``0``-``9``)"
msgstr ""

#: ../../../reference/lexical_analysis.rst:62
#: ../../../reference/lexical_analysis.rst:65
msgid ":ref:`Numeric literal <numbers>`"
msgstr ""

#: ../../../reference/lexical_analysis.rst:64
msgid "dot (``.``)"
msgstr ""

#: ../../../reference/lexical_analysis.rst:66
msgid ":ref:`Operator <operators>`"
msgstr ""

#: ../../../reference/lexical_analysis.rst:68
msgid "question mark (``?``)"
msgstr ""

#: ../../../reference/lexical_analysis.rst:69
msgid "dollar (``$``)"
msgstr ""

#: ../../../reference/lexical_analysis.rst:74
msgid "backquote (``‚Äã`‚Äã``)"
msgstr ""

#: ../../../reference/lexical_analysis.rst:75
msgid "control character"
msgstr ""

#: ../../../reference/lexical_analysis.rst:76
msgid "Error (outside string literals and comments)"
msgstr ""

#: ../../../reference/lexical_analysis.rst:78
msgid "other printing character"
msgstr ""

#: ../../../reference/lexical_analysis.rst:79
msgid ":ref:`Operator or delimiter <operators>`"
msgstr ""

#: ../../../reference/lexical_analysis.rst:81
msgid "end of file"
msgstr ""

#: ../../../reference/lexical_analysis.rst:82
msgid ":ref:`End marker <endmarker-token>`"
msgstr ""

#: ../../../reference/lexical_analysis.rst:88
msgid "Line structure"
msgstr ""

#: ../../../reference/lexical_analysis.rst:92
msgid "A Python program is divided into a number of *logical lines*."
msgstr ""

#: ../../../reference/lexical_analysis.rst:98
msgid "Logical lines"
msgstr ""

#: ../../../reference/lexical_analysis.rst:102
msgid ""
"The end of a logical line is represented by the token :data:`~token."
"NEWLINE`. Statements cannot cross logical line boundaries except where :data:"
"`!NEWLINE` is allowed by the syntax (e.g., between statements in compound "
"statements). A logical line is constructed from one or more *physical lines* "
"by following the :ref:`explicit <explicit-joining>` or :ref:`implicit "
"<implicit-joining>` *line joining* rules."
msgstr ""

#: ../../../reference/lexical_analysis.rst:113
msgid "Physical lines"
msgstr ""

#: ../../../reference/lexical_analysis.rst:115
msgid ""
"A physical line is a sequence of characters terminated by one the following "
"end-of-line sequences:"
msgstr ""

#: ../../../reference/lexical_analysis.rst:118
msgid "the Unix form using ASCII LF (linefeed),"
msgstr ""

#: ../../../reference/lexical_analysis.rst:119
msgid ""
"the Windows form using the ASCII sequence CR LF (return followed by "
"linefeed),"
msgstr ""

#: ../../../reference/lexical_analysis.rst:120
msgid "the '`Classic Mac OS`__' form using the ASCII CR (return) character."
msgstr ""

#: ../../../reference/lexical_analysis.rst:124
msgid ""
"Regardless of platform, each of these sequences is replaced by a single "
"ASCII LF (linefeed) character. (This is done even inside :ref:`string "
"literals <strings>`.) Each line can use any of the sequences; they do not "
"need to be consistent within a file."
msgstr ""

#: ../../../reference/lexical_analysis.rst:130
msgid ""
"The end of input also serves as an implicit terminator for the final "
"physical line."
msgstr ""

#: ../../../reference/lexical_analysis.rst:133
msgid "Formally:"
msgstr ""

#: ../../../reference/lexical_analysis.rst:144
msgid "Comments"
msgstr ""

#: ../../../reference/lexical_analysis.rst:149
msgid ""
"A comment starts with a hash character (``#``) that is not part of a string "
"literal, and ends at the end of the physical line.  A comment signifies the "
"end of the logical line unless the implicit line joining rules are invoked. "
"Comments are ignored by the syntax."
msgstr ""

#: ../../../reference/lexical_analysis.rst:158
msgid "Encoding declarations"
msgstr ""

#: ../../../reference/lexical_analysis.rst:163
msgid ""
"If a comment in the first or second line of the Python script matches the "
"regular expression ``coding[=:]\\s*([-\\w.]+)``, this comment is processed "
"as an encoding declaration; the first group of this expression names the "
"encoding of the source code file. The encoding declaration must appear on a "
"line of its own. If it is the second line, the first line must also be a "
"comment-only line. The recommended forms of an encoding expression are ::"
msgstr ""

#: ../../../reference/lexical_analysis.rst:172
msgid "which is recognized also by GNU Emacs, and ::"
msgstr ""

#: ../../../reference/lexical_analysis.rst:176
msgid "which is recognized by Bram Moolenaar's VIM."
msgstr ""

#: ../../../reference/lexical_analysis.rst:178
msgid ""
"If no encoding declaration is found, the default encoding is UTF-8.  If the "
"implicit or explicit encoding of a file is UTF-8, an initial UTF-8 byte-"
"order mark (``b'\\xef\\xbb\\xbf'``) is ignored rather than being a syntax "
"error."
msgstr ""

#: ../../../reference/lexical_analysis.rst:182
msgid ""
"If an encoding is declared, the encoding name must be recognized by Python "
"(see :ref:`standard-encodings`). The encoding is used for all lexical "
"analysis, including string literals, comments and identifiers."
msgstr ""

#: ../../../reference/lexical_analysis.rst:189
msgid ""
"All lexical analysis, including string literals, comments and identifiers, "
"works on Unicode text decoded using the source encoding. Any Unicode code "
"point, except the NUL control character, can appear in Python source."
msgstr ""

#: ../../../reference/lexical_analysis.rst:203
msgid "Explicit line joining"
msgstr ""

#: ../../../reference/lexical_analysis.rst:207
msgid ""
"Two or more physical lines may be joined into logical lines using backslash "
"characters (``\\``), as follows: when a physical line ends in a backslash "
"that is not part of a string literal or comment, it is joined with the "
"following forming a single logical line, deleting the backslash and the "
"following end-of-line character.  For example::"
msgstr ""

#: ../../../reference/lexical_analysis.rst:218
msgid ""
"A line ending in a backslash cannot carry a comment.  A backslash does not "
"continue a comment.  A backslash does not continue a token except for string "
"literals (i.e., tokens other than string literals cannot be split across "
"physical lines using a backslash).  A backslash is illegal elsewhere on a "
"line outside a string literal."
msgstr ""

#: ../../../reference/lexical_analysis.rst:228
msgid "Implicit line joining"
msgstr ""

#: ../../../reference/lexical_analysis.rst:230
msgid ""
"Expressions in parentheses, square brackets or curly braces can be split "
"over more than one physical line without using backslashes. For example::"
msgstr ""

#: ../../../reference/lexical_analysis.rst:238
msgid ""
"Implicitly continued lines can carry comments.  The indentation of the "
"continuation lines is not important.  Blank continuation lines are allowed. "
"There is no NEWLINE token between implicit continuation lines.  Implicitly "
"continued lines can also occur within triple-quoted strings (see below); in "
"that case they cannot carry comments."
msgstr ""

#: ../../../reference/lexical_analysis.rst:248
msgid "Blank lines"
msgstr ""

#: ../../../reference/lexical_analysis.rst:252
msgid ""
"A logical line that contains only spaces, tabs, formfeeds and possibly a "
"comment, is ignored (i.e., no :data:`~token.NEWLINE` token is generated). "
"During interactive input of statements, handling of a blank line may differ "
"depending on the implementation of the read-eval-print loop. In the standard "
"interactive interpreter, an entirely blank logical line (that is, one "
"containing not even whitespace or a comment) terminates a multi-line "
"statement."
msgstr ""

#: ../../../reference/lexical_analysis.rst:264
msgid "Indentation"
msgstr ""

#: ../../../reference/lexical_analysis.rst:268
msgid ""
"Leading whitespace (spaces and tabs) at the beginning of a logical line is "
"used to compute the indentation level of the line, which in turn is used to "
"determine the grouping of statements."
msgstr ""

#: ../../../reference/lexical_analysis.rst:272
msgid ""
"Tabs are replaced (from left to right) by one to eight spaces such that the "
"total number of characters up to and including the replacement is a multiple "
"of eight (this is intended to be the same rule as used by Unix).  The total "
"number of spaces preceding the first non-blank character then determines the "
"line's indentation.  Indentation cannot be split over multiple physical "
"lines using backslashes; the whitespace up to the first backslash determines "
"the indentation."
msgstr ""

#: ../../../reference/lexical_analysis.rst:280
msgid ""
"Indentation is rejected as inconsistent if a source file mixes tabs and "
"spaces in a way that makes the meaning dependent on the worth of a tab in "
"spaces; a :exc:`TabError` is raised in that case."
msgstr ""

#: ../../../reference/lexical_analysis.rst:284
msgid ""
"**Cross-platform compatibility note:** because of the nature of text editors "
"on non-UNIX platforms, it is unwise to use a mixture of spaces and tabs for "
"the indentation in a single source file.  It should also be noted that "
"different platforms may explicitly limit the maximum indentation level."
msgstr ""

#: ../../../reference/lexical_analysis.rst:289
msgid ""
"A formfeed character may be present at the start of the line; it will be "
"ignored for the indentation calculations above.  Formfeed characters "
"occurring elsewhere in the leading whitespace have an undefined effect (for "
"instance, they may reset the space count to zero)."
msgstr ""

#: ../../../reference/lexical_analysis.rst:296
msgid ""
"The indentation levels of consecutive lines are used to generate :data:"
"`~token.INDENT` and :data:`~token.DEDENT` tokens, using a stack, as follows."
msgstr ""

#: ../../../reference/lexical_analysis.rst:300
msgid ""
"Before the first line of the file is read, a single zero is pushed on the "
"stack; this will never be popped off again.  The numbers pushed on the stack "
"will always be strictly increasing from bottom to top.  At the beginning of "
"each logical line, the line's indentation level is compared to the top of "
"the stack. If it is equal, nothing happens. If it is larger, it is pushed on "
"the stack, and one :data:`!INDENT` token is generated.  If it is smaller, it "
"*must* be one of the numbers occurring on the stack; all numbers on the "
"stack that are larger are popped off, and for each number popped off a :data:"
"`!DEDENT` token is generated. At the end of the file, a :data:`!DEDENT` "
"token is generated for each number remaining on the stack that is larger "
"than zero."
msgstr ""

#: ../../../reference/lexical_analysis.rst:311
msgid ""
"Here is an example of a correctly (though confusingly) indented piece of "
"Python code::"
msgstr ""

#: ../../../reference/lexical_analysis.rst:326
msgid "The following example shows various indentation errors::"
msgstr ""

#: ../../../reference/lexical_analysis.rst:336
msgid ""
"(Actually, the first three errors are detected by the parser; only the last "
"error is found by the lexical analyzer --- the indentation of ``return r`` "
"does not match a level popped off the stack.)"
msgstr ""

#: ../../../reference/lexical_analysis.rst:344
msgid "Whitespace between tokens"
msgstr ""

#: ../../../reference/lexical_analysis.rst:346
msgid ""
"Except at the beginning of a logical line or in string literals, the "
"whitespace characters space, tab and formfeed can be used interchangeably to "
"separate tokens:"
msgstr ""

#: ../../../reference/lexical_analysis.rst:356
msgid ""
"Whitespace is needed between two tokens only if their concatenation could "
"otherwise be interpreted as a different token. For example, ``ab`` is one "
"token, but ``a b`` is two tokens. However, ``+a`` and ``+ a`` both produce "
"two tokens, ``+`` and ``a``, as ``+a`` is not a valid token."
msgstr ""

#: ../../../reference/lexical_analysis.rst:365
msgid "End marker"
msgstr ""

#: ../../../reference/lexical_analysis.rst:367
msgid ""
"At the end of non-interactive input, the lexical analyzer generates an :data:"
"`~token.ENDMARKER` token."
msgstr ""

#: ../../../reference/lexical_analysis.rst:374
msgid "Other tokens"
msgstr ""

#: ../../../reference/lexical_analysis.rst:376
msgid ""
"Besides :data:`~token.NEWLINE`, :data:`~token.INDENT` and :data:`~token."
"DEDENT`, the following categories of tokens exist: *identifiers* and "
"*keywords* (:data:`~token.NAME`), *literals* (such as :data:`~token.NUMBER` "
"and :data:`~token.STRING`), and other symbols (*operators* and "
"*delimiters*, :data:`~token.OP`). Whitespace characters (other than logical "
"line terminators, discussed earlier) are not tokens, but serve to delimit "
"tokens. Where ambiguity exists, a token comprises the longest possible "
"string that forms a legal token, when read from left to right."
msgstr ""

#: ../../../reference/lexical_analysis.rst:390
msgid "Names (identifiers and keywords)"
msgstr ""

#: ../../../reference/lexical_analysis.rst:394
msgid ""
":data:`~token.NAME` tokens represent *identifiers*, *keywords*, and *soft "
"keywords*."
msgstr ""

#: ../../../reference/lexical_analysis.rst:397
msgid "Names are composed of the following characters:"
msgstr ""

#: ../../../reference/lexical_analysis.rst:399
msgid "uppercase and lowercase letters (``A-Z`` and ``a-z``),"
msgstr ""

#: ../../../reference/lexical_analysis.rst:400
msgid "the underscore (``_``),"
msgstr ""

#: ../../../reference/lexical_analysis.rst:401
msgid ""
"digits (``0`` through ``9``), which cannot appear as the first character, and"
msgstr ""

#: ../../../reference/lexical_analysis.rst:402
msgid ""
"non-ASCII characters. Valid names may only contain \"letter-like\" and "
"\"digit-like\" characters; see :ref:`lexical-names-nonascii` for details."
msgstr ""

#: ../../../reference/lexical_analysis.rst:405
msgid ""
"Names must contain at least one character, but have no upper length limit. "
"Case is significant."
msgstr ""

#: ../../../reference/lexical_analysis.rst:408
msgid "Formally, names are described by the following lexical definitions:"
msgstr ""

#: ../../../reference/lexical_analysis.rst:418
msgid ""
"Note that not all names matched by this grammar are valid; see :ref:`lexical-"
"names-nonascii` for details."
msgstr ""

#: ../../../reference/lexical_analysis.rst:425
msgid "Keywords"
msgstr ""

#: ../../../reference/lexical_analysis.rst:431
msgid ""
"The following names are used as reserved words, or *keywords* of the "
"language, and cannot be used as ordinary identifiers.  They must be spelled "
"exactly as written here:"
msgstr ""

#: ../../../reference/lexical_analysis.rst:449
msgid "Soft Keywords"
msgstr ""

#: ../../../reference/lexical_analysis.rst:455
msgid ""
"Some names are only reserved under specific contexts. These are known as "
"*soft keywords*:"
msgstr ""

#: ../../../reference/lexical_analysis.rst:458
msgid ""
"``match``, ``case``, and ``_``, when used in the :keyword:`match` statement."
msgstr ""

#: ../../../reference/lexical_analysis.rst:459
msgid "``type``, when used in the :keyword:`type` statement."
msgstr ""

#: ../../../reference/lexical_analysis.rst:460
msgid "``lazy``, when used before an :keyword:`import` statement."
msgstr ""

#: ../../../reference/lexical_analysis.rst:462
msgid ""
"These syntactically act as keywords in their specific contexts, but this "
"distinction is done at the parser level, not when tokenizing."
msgstr ""

#: ../../../reference/lexical_analysis.rst:465
msgid ""
"As soft keywords, their use in the grammar is possible while still "
"preserving compatibility with existing code that uses these names as "
"identifier names."
msgstr ""

#: ../../../reference/lexical_analysis.rst:469
msgid "``type`` is now a soft keyword."
msgstr ""

#: ../../../reference/lexical_analysis.rst:472
msgid "``lazy`` is now a soft keyword."
msgstr ""

#: ../../../reference/lexical_analysis.rst:481
msgid "Reserved classes of identifiers"
msgstr ""

#: ../../../reference/lexical_analysis.rst:483
msgid ""
"Certain classes of identifiers (besides keywords) have special meanings.  "
"These classes are identified by the patterns of leading and trailing "
"underscore characters:"
msgstr ""

#: ../../../reference/lexical_analysis.rst:487
msgid "``_*``"
msgstr ""

#: ../../../reference/lexical_analysis.rst:488
msgid "Not imported by ``from module import *``."
msgstr ""

#: ../../../reference/lexical_analysis.rst:490
msgid "``_``"
msgstr ""

#: ../../../reference/lexical_analysis.rst:491
msgid ""
"In a ``case`` pattern within a :keyword:`match` statement, ``_`` is a :ref:"
"`soft keyword <soft-keywords>` that denotes a :ref:`wildcard <wildcard-"
"patterns>`."
msgstr ""

#: ../../../reference/lexical_analysis.rst:495
msgid ""
"Separately, the interactive interpreter makes the result of the last "
"evaluation available in the variable ``_``. (It is stored in the :mod:"
"`builtins` module, alongside built-in functions like ``print``.)"
msgstr ""

#: ../../../reference/lexical_analysis.rst:500
msgid ""
"Elsewhere, ``_`` is a regular identifier. It is often used to name "
"\"special\" items, but it is not special to Python itself."
msgstr ""

#: ../../../reference/lexical_analysis.rst:505
msgid ""
"The name ``_`` is often used in conjunction with internationalization; refer "
"to the documentation for the :mod:`gettext` module for more information on "
"this convention."
msgstr ""

#: ../../../reference/lexical_analysis.rst:509
msgid "It is also commonly used for unused variables."
msgstr ""

#: ../../../reference/lexical_analysis.rst:511
msgid "``__*__``"
msgstr ""

#: ../../../reference/lexical_analysis.rst:512
msgid ""
"System-defined names, informally known as \"dunder\" names. These names are "
"defined by the interpreter and its implementation (including the standard "
"library). Current system names are discussed in the :ref:`specialnames` "
"section and elsewhere. More will likely be defined in future versions of "
"Python.  *Any* use of ``__*__`` names, in any context, that does not follow "
"explicitly documented use, is subject to breakage without warning."
msgstr ""

#: ../../../reference/lexical_analysis.rst:519
msgid "``__*``"
msgstr ""

#: ../../../reference/lexical_analysis.rst:520
msgid ""
"Class-private names.  Names in this category, when used within the context "
"of a class definition, are re-written to use a mangled form to help avoid "
"name clashes between \"private\" attributes of base and derived classes. See "
"section :ref:`atom-identifiers`."
msgstr ""

#: ../../../reference/lexical_analysis.rst:529
msgid "Non-ASCII characters in names"
msgstr ""

#: ../../../reference/lexical_analysis.rst:531
msgid ""
"Names that contain non-ASCII characters need additional normalization and "
"validation beyond the rules and grammar explained :ref:`above "
"<identifiers>`. For example, ``≈ô_1``, ``Ëõá``, or ``‡§∏‡§æ‡§Å‡§™``  are valid names, "
"but ``r„Ä∞2``, ``‚Ç¨``, or ``üêç`` are not."
msgstr ""

#: ../../../reference/lexical_analysis.rst:537
msgid "This section explains the exact rules."
msgstr ""

#: ../../../reference/lexical_analysis.rst:539
msgid ""
"All names are converted into the `normalization form`_ NFKC while parsing. "
"This means that, for example, some typographic variants of characters are "
"converted to their \"basic\" form. For example, ``Ô¨Å‚Åø‚ÇêÀ°·µ¢·∂ª‚Çê·µó·µ¢·µí‚Çô`` normalizes "
"to ``finalization``, so Python treats them as the same name::"
msgstr ""

#: ../../../reference/lexical_analysis.rst:550
msgid ""
"Normalization is done at the lexical level only. Run-time functions that "
"take names as *strings* generally do not normalize their arguments. For "
"example, the variable defined above is accessible at run time in the :func:"
"`globals` dictionary as ``globals()[\"finalization\"]`` but not ``globals()"
"[\"Ô¨Å‚Åø‚ÇêÀ°·µ¢·∂ª‚Çê·µó·µ¢·µí‚Çô\"]``."
msgstr ""

#: ../../../reference/lexical_analysis.rst:557
msgid ""
"Similarly to how ASCII-only names must contain only letters, digits and the "
"underscore, and cannot start with a digit, a valid name must start with a "
"character in the \"letter-like\" set ``xid_start``, and the remaining "
"characters must be in the \"letter- and digit-like\" set ``xid_continue``."
msgstr ""

#: ../../../reference/lexical_analysis.rst:563
msgid ""
"These sets based on the *XID_Start* and *XID_Continue* sets as defined by "
"the Unicode standard annex `UAX-31`_. Python's ``xid_start`` additionally "
"includes the underscore (``_``). Note that Python does not necessarily "
"conform to `UAX-31`_."
msgstr ""

#: ../../../reference/lexical_analysis.rst:568
msgid ""
"A non-normative listing of characters in the *XID_Start* and *XID_Continue* "
"sets as defined by Unicode is available in the `DerivedCoreProperties.txt`_ "
"file in the Unicode Character Database. For reference, the construction "
"rules for the ``xid_*`` sets are given below."
msgstr ""

#: ../../../reference/lexical_analysis.rst:573
msgid "The set ``id_start`` is defined as the union of:"
msgstr ""

#: ../../../reference/lexical_analysis.rst:575
msgid "Unicode category ``<Lu>`` - uppercase letters (includes ``A`` to ``Z``)"
msgstr ""

#: ../../../reference/lexical_analysis.rst:576
msgid "Unicode category ``<Ll>`` - lowercase letters (includes ``a`` to ``z``)"
msgstr ""

#: ../../../reference/lexical_analysis.rst:577
msgid "Unicode category ``<Lt>`` - titlecase letters"
msgstr ""

#: ../../../reference/lexical_analysis.rst:578
msgid "Unicode category ``<Lm>`` - modifier letters"
msgstr ""

#: ../../../reference/lexical_analysis.rst:579
msgid "Unicode category ``<Lo>`` - other letters"
msgstr ""

#: ../../../reference/lexical_analysis.rst:580
msgid "Unicode category ``<Nl>`` - letter numbers"
msgstr ""

#: ../../../reference/lexical_analysis.rst:581
msgid "{``\"_\"``} - the underscore"
msgstr ""

#: ../../../reference/lexical_analysis.rst:582
msgid ""
"``<Other_ID_Start>`` - an explicit set of characters in `PropList.txt`_ to "
"support backwards compatibility"
msgstr ""

#: ../../../reference/lexical_analysis.rst:585
msgid ""
"The set ``xid_start`` then closes this set under NFKC normalization, by "
"removing all characters whose normalization is not of the form ``id_start "
"id_continue*``."
msgstr ""

#: ../../../reference/lexical_analysis.rst:589
msgid "The set ``id_continue`` is defined as the union of:"
msgstr ""

#: ../../../reference/lexical_analysis.rst:591
msgid "``id_start`` (see above)"
msgstr ""

#: ../../../reference/lexical_analysis.rst:592
msgid "Unicode category ``<Nd>`` - decimal numbers (includes ``0`` to ``9``)"
msgstr ""

#: ../../../reference/lexical_analysis.rst:593
msgid "Unicode category ``<Pc>`` - connector punctuations"
msgstr ""

#: ../../../reference/lexical_analysis.rst:594
msgid "Unicode category ``<Mn>`` - nonspacing marks"
msgstr ""

#: ../../../reference/lexical_analysis.rst:595
msgid "Unicode category ``<Mc>`` - spacing combining marks"
msgstr ""

#: ../../../reference/lexical_analysis.rst:596
msgid ""
"``<Other_ID_Continue>`` - another explicit set of characters in `PropList."
"txt`_ to support backwards compatibility"
msgstr ""

#: ../../../reference/lexical_analysis.rst:599
msgid "Again, ``xid_continue`` closes this set under NFKC normalization."
msgstr ""

#: ../../../reference/lexical_analysis.rst:601
msgid ""
"Unicode categories use the version of the Unicode Character Database as "
"included in the :mod:`unicodedata` module."
msgstr ""

#: ../../../reference/lexical_analysis.rst:611
msgid ":pep:`3131` -- Supporting Non-ASCII Identifiers"
msgstr ""

#: ../../../reference/lexical_analysis.rst:612
msgid ":pep:`672` -- Unicode-related Security Considerations for Python"
msgstr ""

#: ../../../reference/lexical_analysis.rst:618
msgid "Literals"
msgstr ""

#: ../../../reference/lexical_analysis.rst:622
msgid "Literals are notations for constant values of some built-in types."
msgstr ""

#: ../../../reference/lexical_analysis.rst:624
msgid ""
"In terms of lexical analysis, Python has :ref:`string, bytes <strings>` and :"
"ref:`numeric <numbers>` literals."
msgstr ""

#: ../../../reference/lexical_analysis.rst:627
msgid ""
"Other \"literals\" are lexically denoted using :ref:`keywords <keywords>` "
"(``None``, ``True``, ``False``) and the special :ref:`ellipsis token "
"<lexical-ellipsis>` (``...``)."
msgstr ""

#: ../../../reference/lexical_analysis.rst:638
msgid "String and Bytes literals"
msgstr ""

#: ../../../reference/lexical_analysis.rst:640
msgid ""
"String literals are text enclosed in single quotes (``'``) or double quotes "
"(``\"``). For example:"
msgstr ""

#: ../../../reference/lexical_analysis.rst:648
msgid ""
"The quote used to start the literal also terminates it, so a string literal "
"can only contain the other quote (except with escape sequences, see below). "
"For example:"
msgstr ""

#: ../../../reference/lexical_analysis.rst:657
msgid ""
"Except for this limitation, the choice of quote character (``'`` or ``\"``) "
"does not affect how the literal is parsed."
msgstr ""

#: ../../../reference/lexical_analysis.rst:660
msgid ""
"Inside a string literal, the backslash (``\\``) character introduces an :dfn:"
"`escape sequence`, which has special meaning depending on the character "
"after the backslash. For example, ``\\\"`` denotes the double quote "
"character, and does *not* end the string:"
msgstr ""

#: ../../../reference/lexical_analysis.rst:671
msgid ""
"See :ref:`escape sequences <escape-sequences>` below for a full list of such "
"sequences, and more details."
msgstr ""

#: ../../../reference/lexical_analysis.rst:680
msgid "Triple-quoted strings"
msgstr ""

#: ../../../reference/lexical_analysis.rst:682
msgid ""
"Strings can also be enclosed in matching groups of three single or double "
"quotes. These are generally referred to as :dfn:`triple-quoted strings`::"
msgstr ""

#: ../../../reference/lexical_analysis.rst:688
msgid ""
"In triple-quoted literals, unescaped quotes are allowed (and are retained), "
"except that three unescaped quotes in a row terminate the literal, if they "
"are of the same kind (``'`` or ``\"``) used at the start::"
msgstr ""

#: ../../../reference/lexical_analysis.rst:694
msgid "Unescaped newlines are also allowed and retained::"
msgstr ""

#: ../../../reference/lexical_analysis.rst:705
msgid "String prefixes"
msgstr ""

#: ../../../reference/lexical_analysis.rst:707
msgid ""
"String literals can have an optional :dfn:`prefix` that influences how the "
"content of the literal is parsed, for example:"
msgstr ""

#: ../../../reference/lexical_analysis.rst:715
msgid "The allowed prefixes are:"
msgstr ""

#: ../../../reference/lexical_analysis.rst:717
msgid "``b``: :ref:`Bytes literal <bytes-literal>`"
msgstr ""

#: ../../../reference/lexical_analysis.rst:718
msgid "``r``: :ref:`Raw string <raw-strings>`"
msgstr ""

#: ../../../reference/lexical_analysis.rst:719
msgid "``f``: :ref:`Formatted string literal <f-strings>` (\"f-string\")"
msgstr ""

#: ../../../reference/lexical_analysis.rst:720
msgid "``t``: :ref:`Template string literal <t-strings>` (\"t-string\")"
msgstr ""

#: ../../../reference/lexical_analysis.rst:721
msgid "``u``: No effect (allowed for backwards compatibility)"
msgstr ""

#: ../../../reference/lexical_analysis.rst:723
msgid "See the linked sections for details on each type."
msgstr ""

#: ../../../reference/lexical_analysis.rst:725
msgid ""
"Prefixes are case-insensitive (for example, '``B``' works the same as "
"'``b``'). The '``r``' prefix can be combined with '``f``', '``t``' or "
"'``b``', so '``fr``', '``rf``', '``tr``', '``rt``', '``br``', and '``rb``' "
"are also valid prefixes."
msgstr ""

#: ../../../reference/lexical_analysis.rst:729
msgid ""
"The ``'rb'`` prefix of raw bytes literals has been added as a synonym of "
"``'br'``."
msgstr ""

#: ../../../reference/lexical_analysis.rst:733
msgid ""
"Support for the unicode legacy literal (``u'value'``) was reintroduced to "
"simplify the maintenance of dual Python 2.x and 3.x codebases. See :pep:"
"`414` for more information."
msgstr ""

#: ../../../reference/lexical_analysis.rst:739
msgid "Formal grammar"
msgstr ""

#: ../../../reference/lexical_analysis.rst:741
msgid ""
"String literals, except :ref:`\"f-strings\" <f-strings>` and :ref:`\"t-"
"strings\" <t-strings>`, are described by the following lexical definitions."
msgstr ""

#: ../../../reference/lexical_analysis.rst:745
msgid ""
"These definitions use :ref:`negative lookaheads <lexical-lookaheads>` (``!"
"``) to indicate that an ending quote ends the literal."
msgstr ""

#: ../../../reference/lexical_analysis.rst:763
msgid ""
"Note that as in all lexical definitions, whitespace is significant. In "
"particular, the prefix (if any) must be immediately followed by the starting "
"quote."
msgstr ""

#: ../../../reference/lexical_analysis.rst:785
msgid "Escape sequences"
msgstr ""

#: ../../../reference/lexical_analysis.rst:787
msgid ""
"Unless an '``r``' or '``R``' prefix is present, escape sequences in string "
"and bytes literals are interpreted according to rules similar to those used "
"by Standard C.  The recognized escape sequences are:"
msgstr ""

#: ../../../reference/lexical_analysis.rst:795
msgid "Escape Sequence"
msgstr ""

#: ../../../reference/lexical_analysis.rst:796
msgid "Meaning"
msgstr ""

#: ../../../reference/lexical_analysis.rst:797
msgid "``\\``\\ <newline>"
msgstr ""

#: ../../../reference/lexical_analysis.rst:798
msgid ":ref:`string-escape-ignore`"
msgstr ""

#: ../../../reference/lexical_analysis.rst:799
msgid "``\\\\``"
msgstr ""

#: ../../../reference/lexical_analysis.rst:800
msgid ":ref:`Backslash <string-escape-escaped-char>`"
msgstr ""

#: ../../../reference/lexical_analysis.rst:801
msgid "``\\'``"
msgstr ""

#: ../../../reference/lexical_analysis.rst:802
msgid ":ref:`Single quote <string-escape-escaped-char>`"
msgstr ""

#: ../../../reference/lexical_analysis.rst:803
msgid "``\\\"``"
msgstr ""

#: ../../../reference/lexical_analysis.rst:804
msgid ":ref:`Double quote <string-escape-escaped-char>`"
msgstr ""

#: ../../../reference/lexical_analysis.rst:805
msgid "``\\a``"
msgstr ""

#: ../../../reference/lexical_analysis.rst:806
msgid "ASCII Bell (BEL)"
msgstr ""

#: ../../../reference/lexical_analysis.rst:807
msgid "``\\b``"
msgstr ""

#: ../../../reference/lexical_analysis.rst:808
msgid "ASCII Backspace (BS)"
msgstr ""

#: ../../../reference/lexical_analysis.rst:809
msgid "``\\f``"
msgstr ""

#: ../../../reference/lexical_analysis.rst:810
msgid "ASCII Formfeed (FF)"
msgstr ""

#: ../../../reference/lexical_analysis.rst:811
msgid "``\\n``"
msgstr ""

#: ../../../reference/lexical_analysis.rst:812
msgid "ASCII Linefeed (LF)"
msgstr ""

#: ../../../reference/lexical_analysis.rst:813
msgid "``\\r``"
msgstr ""

#: ../../../reference/lexical_analysis.rst:814
msgid "ASCII Carriage Return (CR)"
msgstr ""

#: ../../../reference/lexical_analysis.rst:815
msgid "``\\t``"
msgstr ""

#: ../../../reference/lexical_analysis.rst:816
msgid "ASCII Horizontal Tab (TAB)"
msgstr ""

#: ../../../reference/lexical_analysis.rst:817
msgid "``\\v``"
msgstr ""

#: ../../../reference/lexical_analysis.rst:818
msgid "ASCII Vertical Tab (VT)"
msgstr ""

#: ../../../reference/lexical_analysis.rst:819
msgid ":samp:`\\\\\\\\{ooo}`"
msgstr ""

#: ../../../reference/lexical_analysis.rst:820
msgid ":ref:`string-escape-oct`"
msgstr ""

#: ../../../reference/lexical_analysis.rst:821
msgid ":samp:`\\\\x{hh}`"
msgstr ""

#: ../../../reference/lexical_analysis.rst:822
msgid ":ref:`string-escape-hex`"
msgstr ""

#: ../../../reference/lexical_analysis.rst:823
msgid ":samp:`\\\\N\\\\{{name}\\\\}`"
msgstr ""

#: ../../../reference/lexical_analysis.rst:824
msgid ":ref:`string-escape-named`"
msgstr ""

#: ../../../reference/lexical_analysis.rst:825
msgid ":samp:`\\\\u{xxxx}`"
msgstr ""

#: ../../../reference/lexical_analysis.rst:826
#: ../../../reference/lexical_analysis.rst:828
msgid ":ref:`Hexadecimal Unicode character <string-escape-long-hex>`"
msgstr ""

#: ../../../reference/lexical_analysis.rst:827
msgid ":samp:`\\\\U{xxxxxxxx}`"
msgstr ""

#: ../../../reference/lexical_analysis.rst:833
msgid "Ignored end of line"
msgstr ""

#: ../../../reference/lexical_analysis.rst:835
msgid "A backslash can be added at the end of a line to ignore the newline::"
msgstr ""

#: ../../../reference/lexical_analysis.rst:841
msgid ""
"The same result can be achieved using :ref:`triple-quoted strings "
"<strings>`, or parentheses and :ref:`string literal concatenation <string-"
"concatenation>`."
msgstr ""

#: ../../../reference/lexical_analysis.rst:847
msgid "Escaped characters"
msgstr ""

#: ../../../reference/lexical_analysis.rst:849
msgid ""
"To include a backslash in a non-:ref:`raw <raw-strings>` Python string "
"literal, it must be doubled. The ``\\\\`` escape sequence denotes a single "
"backslash character::"
msgstr ""

#: ../../../reference/lexical_analysis.rst:856
msgid ""
"Similarly, the ``\\'`` and ``\\\"`` sequences denote the single and double "
"quote character, respectively::"
msgstr ""

#: ../../../reference/lexical_analysis.rst:865
msgid "Octal character"
msgstr ""

#: ../../../reference/lexical_analysis.rst:867
msgid ""
"The sequence :samp:`\\\\\\\\{ooo}` denotes a *character* with the octal "
"(base 8) value *ooo*::"
msgstr ""

#: ../../../reference/lexical_analysis.rst:873
msgid "Up to three octal digits (0 through 7) are accepted."
msgstr ""

#: ../../../reference/lexical_analysis.rst:875
#: ../../../reference/lexical_analysis.rst:900
msgid ""
"In a bytes literal, *character* means a *byte* with the given value. In a "
"string literal, it means a Unicode character with the given value."
msgstr ""

#: ../../../reference/lexical_analysis.rst:878
msgid ""
"Octal escapes with value larger than ``0o377`` (255) produce a :exc:"
"`DeprecationWarning`."
msgstr ""

#: ../../../reference/lexical_analysis.rst:882
msgid ""
"Octal escapes with value larger than ``0o377`` (255) produce a :exc:"
"`SyntaxWarning`. In a future Python version they will raise a :exc:"
"`SyntaxError`."
msgstr ""

#: ../../../reference/lexical_analysis.rst:890
msgid "Hexadecimal character"
msgstr ""

#: ../../../reference/lexical_analysis.rst:892
msgid ""
"The sequence :samp:`\\\\x{hh}` denotes a *character* with the hex (base 16) "
"value *hh*::"
msgstr ""

#: ../../../reference/lexical_analysis.rst:898
msgid "Unlike in Standard C, exactly two hex digits are required."
msgstr ""

#: ../../../reference/lexical_analysis.rst:906
msgid "Named Unicode character"
msgstr ""

#: ../../../reference/lexical_analysis.rst:908
msgid ""
"The sequence :samp:`\\\\N\\\\{{name}\\\\}` denotes a Unicode character with "
"the given *name*::"
msgstr ""

#: ../../../reference/lexical_analysis.rst:916
msgid "This sequence cannot appear in :ref:`bytes literals <bytes-literal>`."
msgstr ""

#: ../../../reference/lexical_analysis.rst:918
msgid ""
"Support for `name aliases <https://www.unicode.org/Public/17.0.0/ucd/"
"NameAliases.txt>`__ has been added."
msgstr ""

#: ../../../reference/lexical_analysis.rst:925
msgid "Hexadecimal Unicode characters"
msgstr ""

#: ../../../reference/lexical_analysis.rst:927
msgid ""
"These sequences :samp:`\\\\u{xxxx}` and :samp:`\\\\U{xxxxxxxx}` denote the "
"Unicode character with the given hex (base 16) value. Exactly four digits "
"are required for ``\\u``; exactly eight digits are required for ``\\U``. The "
"latter can encode any Unicode character."
msgstr ""

#: ../../../reference/lexical_analysis.rst:940
msgid "These sequences cannot appear in :ref:`bytes literals <bytes-literal>`."
msgstr ""

#: ../../../reference/lexical_analysis.rst:946
msgid "Unrecognized escape sequences"
msgstr ""

#: ../../../reference/lexical_analysis.rst:948
msgid ""
"Unlike in Standard C, all unrecognized escape sequences are left in the "
"string unchanged, that is, *the backslash is left in the result*::"
msgstr ""

#: ../../../reference/lexical_analysis.rst:956
msgid ""
"Note that for bytes literals, the escape sequences only recognized in string "
"literals (``\\N...``, ``\\u...``, ``\\U...``) fall into the category of "
"unrecognized escapes."
msgstr ""

#: ../../../reference/lexical_analysis.rst:960
msgid "Unrecognized escape sequences produce a :exc:`DeprecationWarning`."
msgstr ""

#: ../../../reference/lexical_analysis.rst:963
msgid ""
"Unrecognized escape sequences produce a :exc:`SyntaxWarning`. In a future "
"Python version they will raise a :exc:`SyntaxError`."
msgstr ""

#: ../../../reference/lexical_analysis.rst:976
msgid "Bytes literals"
msgstr ""

#: ../../../reference/lexical_analysis.rst:978
msgid ""
":dfn:`Bytes literals` are always prefixed with '``b``' or '``B``'; they "
"produce an instance of the :class:`bytes` type instead of the :class:`str` "
"type. They may only contain ASCII characters; bytes with a numeric value of "
"128 or greater must be expressed with escape sequences (typically :ref:"
"`string-escape-hex` or :ref:`string-escape-oct`):"
msgstr ""

#: ../../../reference/lexical_analysis.rst:991
msgid ""
"Similarly, a zero byte must be expressed using an escape sequence (typically "
"``\\0`` or ``\\x00``)."
msgstr ""

#: ../../../reference/lexical_analysis.rst:1002
msgid "Raw string literals"
msgstr ""

#: ../../../reference/lexical_analysis.rst:1004
msgid ""
"Both string and bytes literals may optionally be prefixed with a letter "
"'``r``' or '``R``'; such constructs are called :dfn:`raw string literals` "
"and :dfn:`raw bytes literals` respectively and treat backslashes as literal "
"characters. As a result, in raw string literals, :ref:`escape sequences "
"<escape-sequences>` are not treated specially:"
msgstr ""

#: ../../../reference/lexical_analysis.rst:1016
msgid ""
"Even in a raw literal, quotes can be escaped with a backslash, but the "
"backslash remains in the result; for example, ``r\"\\\"\"`` is a valid "
"string literal consisting of two characters: a backslash and a double quote; "
"``r\"\\\"`` is not a valid string literal (even a raw string cannot end in "
"an odd number of backslashes).  Specifically, *a raw literal cannot end in a "
"single backslash* (since the backslash would escape the following quote "
"character).  Note also that a single backslash followed by a newline is "
"interpreted as those two characters as part of the literal, *not* as a line "
"continuation."
msgstr ""

#: ../../../reference/lexical_analysis.rst:1044
msgid "f-strings"
msgstr ""

#: ../../../reference/lexical_analysis.rst:1047
msgid ""
"The :keyword:`await` and :keyword:`async for` can be used in expressions "
"within f-strings."
msgstr ""

#: ../../../reference/lexical_analysis.rst:1050
msgid "Added the debug specifier (``=``)"
msgstr ""

#: ../../../reference/lexical_analysis.rst:1052
msgid ""
"Many restrictions on expressions within f-strings have been removed. "
"Notably, nested strings, comments, and backslashes are now permitted."
msgstr ""

#: ../../../reference/lexical_analysis.rst:1056
msgid ""
"A :dfn:`formatted string literal` or :dfn:`f-string` is a string literal "
"that is prefixed with '``f``' or '``F``'. Unlike other string literals, f-"
"strings do not have a constant value. They may contain *replacement fields* "
"delimited by curly braces ``{}``. Replacement fields contain expressions "
"which are evaluated at run time. For example::"
msgstr ""

#: ../../../reference/lexical_analysis.rst:1068
msgid ""
"Any doubled curly braces (``{{`` or ``}}``) outside replacement fields are "
"replaced with the corresponding single curly brace::"
msgstr ""

#: ../../../reference/lexical_analysis.rst:1074
msgid ""
"Other characters outside replacement fields are treated like in ordinary "
"string literals. This means that escape sequences are decoded (except when a "
"literal is also marked as a raw string), and newlines are possible in triple-"
"quoted f-strings::"
msgstr ""

#: ../../../reference/lexical_analysis.rst:1091
msgid ""
"Expressions in formatted string literals are treated like regular Python "
"expressions. Each expression is evaluated in the context where the formatted "
"string literal appears, in order from left to right. An empty expression is "
"not allowed, and both :keyword:`lambda` and assignment expressions ``:=`` "
"must be surrounded by explicit parentheses::"
msgstr ""

#: ../../../reference/lexical_analysis.rst:1101
msgid ""
"Reusing the outer f-string quoting type inside a replacement field is "
"permitted::"
msgstr ""

#: ../../../reference/lexical_analysis.rst:1108
msgid ""
"Backslashes are also allowed in replacement fields and are evaluated the "
"same way as in any other context::"
msgstr ""

#: ../../../reference/lexical_analysis.rst:1118
msgid "It is possible to nest f-strings::"
msgstr ""

#: ../../../reference/lexical_analysis.rst:1124
msgid "Portable Python programs should not use more than 5 levels of nesting."
msgstr ""

#: ../../../reference/lexical_analysis.rst:1128
msgid "CPython does not limit nesting of f-strings."
msgstr ""

#: ../../../reference/lexical_analysis.rst:1130
msgid ""
"Replacement expressions can contain newlines in both single-quoted and "
"triple-quoted f-strings and they can contain comments. Everything that comes "
"after a ``#`` inside a replacement field is a comment (even closing braces "
"and quotes). This means that replacement fields with comments must be closed "
"in a different line:"
msgstr ""

#: ../../../reference/lexical_analysis.rst:1144
msgid "After the expression, replacement fields may optionally contain:"
msgstr ""

#: ../../../reference/lexical_analysis.rst:1146
msgid ""
"a *debug specifier* -- an equal sign (``=``), optionally surrounded by "
"whitespace on one or both sides;"
msgstr ""

#: ../../../reference/lexical_analysis.rst:1148
msgid "a *conversion specifier* -- ``!s``, ``!r`` or ``!a``; and/or"
msgstr ""

#: ../../../reference/lexical_analysis.rst:1149
msgid "a *format specifier* prefixed with a colon (``:``)."
msgstr ""

#: ../../../reference/lexical_analysis.rst:1151
msgid ""
"See the :ref:`Standard Library section on f-strings <stdtypes-fstrings>` for "
"details on how these fields are evaluated."
msgstr ""

#: ../../../reference/lexical_analysis.rst:1154
msgid ""
"As that section explains, *format specifiers* are passed as the second "
"argument to the :func:`format` function to format a replacement field value. "
"For example, they can be used to specify a field width and padding "
"characters using the :ref:`Format Specification Mini-Language <formatspec>`::"
msgstr ""

#: ../../../reference/lexical_analysis.rst:1163
msgid "Top-level format specifiers may include nested replacement fields::"
msgstr ""

#: ../../../reference/lexical_analysis.rst:1170
msgid ""
"These nested fields may include their own conversion fields and :ref:`format "
"specifiers <formatspec>`::"
msgstr ""

#: ../../../reference/lexical_analysis.rst:1179
msgid ""
"However, these nested fields may not include more deeply nested replacement "
"fields."
msgstr ""

#: ../../../reference/lexical_analysis.rst:1182
msgid ""
"Formatted string literals cannot be used as :term:`docstrings <docstring>`, "
"even if they do not include expressions::"
msgstr ""

#: ../../../reference/lexical_analysis.rst:1193
msgid ":pep:`498` -- Literal String Interpolation"
msgstr ""

#: ../../../reference/lexical_analysis.rst:1194
msgid ":pep:`701` -- Syntactic formalization of f-strings"
msgstr ""

#: ../../../reference/lexical_analysis.rst:1195
msgid ":meth:`str.format`, which uses a related format string mechanism."
msgstr ""

#: ../../../reference/lexical_analysis.rst:1202
msgid "t-strings"
msgstr ""

#: ../../../reference/lexical_analysis.rst:1206
msgid ""
"A :dfn:`template string literal` or :dfn:`t-string` is a string literal that "
"is prefixed with '``t``' or '``T``'. These strings follow the same syntax "
"rules as :ref:`formatted string literals <f-strings>`. For differences in "
"evaluation rules, see the :ref:`Standard Library section on t-strings "
"<stdtypes-tstrings>`"
msgstr ""

#: ../../../reference/lexical_analysis.rst:1215
msgid "Formal grammar for f-strings"
msgstr ""

#: ../../../reference/lexical_analysis.rst:1217
msgid ""
"F-strings are handled partly by the :term:`lexical analyzer`, which produces "
"the tokens :py:data:`~token.FSTRING_START`, :py:data:`~token.FSTRING_MIDDLE` "
"and :py:data:`~token.FSTRING_END`, and partly by the parser, which handles "
"expressions in the replacement field. The exact way the work is split is a "
"CPython implementation detail."
msgstr ""

#: ../../../reference/lexical_analysis.rst:1223
msgid ""
"Correspondingly, the f-string grammar is a mix of :ref:`lexical and "
"syntactic definitions <notation-lexical-vs-syntactic>`."
msgstr ""

#: ../../../reference/lexical_analysis.rst:1226
msgid "Whitespace is significant in these situations:"
msgstr ""

#: ../../../reference/lexical_analysis.rst:1228
msgid ""
"There may be no whitespace in :py:data:`~token.FSTRING_START` (between the "
"prefix and quote)."
msgstr ""

#: ../../../reference/lexical_analysis.rst:1230
msgid ""
"Whitespace in :py:data:`~token.FSTRING_MIDDLE` is part of the literal string "
"contents."
msgstr ""

#: ../../../reference/lexical_analysis.rst:1232
msgid ""
"In ``fstring_replacement_field``, if ``f_debug_specifier`` is present, all "
"whitespace after the opening brace until the ``f_debug_specifier``, as well "
"as whitespace immediately following ``f_debug_specifier``, is retained as "
"part of the expression."
msgstr ""

#: ../../../reference/lexical_analysis.rst:1239
msgid ""
"The expression is not handled in the tokenization phase; it is retrieved "
"from the source code using locations of the ``{`` token and the token after "
"``=``."
msgstr ""

#: ../../../reference/lexical_analysis.rst:1244
msgid ""
"The ``FSTRING_MIDDLE`` definition uses :ref:`negative lookaheads <lexical-"
"lookaheads>` (``!``) to indicate special characters (backslash, newline, "
"``{``, ``}``) and sequences (``f_quote``)."
msgstr ""

#: ../../../reference/lexical_analysis.rst:1285
msgid ""
"In the above grammar snippet, the ``f_quote`` and ``FSTRING_MIDDLE`` rules "
"are context-sensitive -- they depend on the contents of ``FSTRING_START`` of "
"the nearest enclosing ``fstring``."
msgstr ""

#: ../../../reference/lexical_analysis.rst:1289
msgid ""
"Constructing a more traditional formal grammar from this template is left as "
"an exercise for the reader."
msgstr ""

#: ../../../reference/lexical_analysis.rst:1292
msgid ""
"The grammar for t-strings is identical to the one for f-strings, with *t* "
"instead of *f* at the beginning of rule and token names and in the prefix."
msgstr ""

#: ../../../reference/lexical_analysis.rst:1306
msgid "Numeric literals"
msgstr ""

#: ../../../reference/lexical_analysis.rst:1312
msgid ""
":data:`~token.NUMBER` tokens represent numeric literals, of which there are "
"three types: integers, floating-point numbers, and imaginary numbers."
msgstr ""

#: ../../../reference/lexical_analysis.rst:1320
msgid ""
"The numeric value of a numeric literal is the same as if it were passed as a "
"string to the :class:`int`, :class:`float` or :class:`complex` class "
"constructor, respectively. Note that not all valid inputs for those "
"constructors are also valid literals."
msgstr ""

#: ../../../reference/lexical_analysis.rst:1325
msgid ""
"Numeric literals do not include a sign; a phrase like ``-1`` is actually an "
"expression composed of the unary operator '``-``' and the literal ``1``."
msgstr ""

#: ../../../reference/lexical_analysis.rst:1339
msgid "Integer literals"
msgstr ""

#: ../../../reference/lexical_analysis.rst:1341
msgid "Integer literals denote whole numbers. For example::"
msgstr ""

#: ../../../reference/lexical_analysis.rst:1347
msgid ""
"There is no limit for the length of integer literals apart from what can be "
"stored in available memory::"
msgstr ""

#: ../../../reference/lexical_analysis.rst:1352
msgid ""
"Underscores can be used to group digits for enhanced readability, and are "
"ignored for determining the numeric value of the literal. For example, the "
"following literals are equivalent::"
msgstr ""

#: ../../../reference/lexical_analysis.rst:1360
msgid ""
"Underscores can only occur between digits. For example, ``_123``, ``321_``, "
"and ``123__321`` are *not* valid literals."
msgstr ""

#: ../../../reference/lexical_analysis.rst:1363
msgid ""
"Integers can be specified in binary (base 2), octal (base 8), or hexadecimal "
"(base 16) using the prefixes ``0b``, ``0o`` and ``0x``, respectively. "
"Hexadecimal digits 10 through 15 are represented by letters ``A``-``F``, "
"case-insensitive.  For example::"
msgstr ""

#: ../../../reference/lexical_analysis.rst:1375
msgid ""
"An underscore can follow the base specifier. For example, ``0x_1f`` is a "
"valid literal, but ``0_x1f`` and ``0x__1f`` are not."
msgstr ""

#: ../../../reference/lexical_analysis.rst:1379
msgid ""
"Leading zeros in a non-zero decimal number are not allowed. For example, "
"``0123`` is not a valid literal. This is for disambiguation with C-style "
"octal literals, which Python used before version 3.0."
msgstr ""

#: ../../../reference/lexical_analysis.rst:1384
msgid ""
"Formally, integer literals are described by the following lexical "
"definitions:"
msgstr ""

#: ../../../reference/lexical_analysis.rst:1401
#: ../../../reference/lexical_analysis.rst:1465
msgid "Underscores are now allowed for grouping purposes in literals."
msgstr ""

#: ../../../reference/lexical_analysis.rst:1412
msgid "Floating-point literals"
msgstr ""

#: ../../../reference/lexical_analysis.rst:1414
msgid ""
"Floating-point (float) literals, such as ``3.14`` or ``1.5``, denote :ref:"
"`approximations of real numbers <datamodel-float>`."
msgstr ""

#: ../../../reference/lexical_analysis.rst:1417
msgid ""
"They consist of *integer* and *fraction* parts, each composed of decimal "
"digits. The parts are separated by a decimal point, ``.``::"
msgstr ""

#: ../../../reference/lexical_analysis.rst:1423
msgid ""
"Unlike in integer literals, leading zeros are allowed. For example, "
"``077.010`` is legal, and denotes the same number as ``77.01``."
msgstr ""

#: ../../../reference/lexical_analysis.rst:1426
msgid ""
"As in integer literals, single underscores may occur between digits to help "
"readability::"
msgstr ""

#: ../../../reference/lexical_analysis.rst:1432
msgid "Either of these parts, but not both, can be empty. For example::"
msgstr ""

#: ../../../reference/lexical_analysis.rst:1437
msgid ""
"Optionally, the integer and fraction may be followed by an *exponent*: the "
"letter ``e`` or ``E``, followed by an optional sign, ``+`` or ``-``, and a "
"number in the same format as the integer and fraction parts. The ``e`` or "
"``E`` represents \"times ten raised to the power of\"::"
msgstr ""

#: ../../../reference/lexical_analysis.rst:1446
msgid ""
"In floats with only integer and exponent parts, the decimal point may be "
"omitted::"
msgstr ""

#: ../../../reference/lexical_analysis.rst:1452
msgid ""
"Formally, floating-point literals are described by the following lexical "
"definitions:"
msgstr ""

#: ../../../reference/lexical_analysis.rst:1474
msgid "Imaginary literals"
msgstr ""

#: ../../../reference/lexical_analysis.rst:1476
msgid ""
"Python has :ref:`complex number <typesnumeric>` objects, but no complex "
"literals. Instead, *imaginary literals* denote complex numbers with a zero "
"real part."
msgstr ""

#: ../../../reference/lexical_analysis.rst:1481
msgid ""
"For example, in math, the complex number 3+4.2\\ *i* is written as the real "
"number 3 added to the imaginary number 4.2\\ *i*. Python uses a similar "
"syntax, except the imaginary unit is written as ``j`` rather than *i*::"
msgstr ""

#: ../../../reference/lexical_analysis.rst:1488
msgid ""
"This is an expression composed of the :ref:`integer literal <integers>` "
"``3``, the :ref:`operator <operators>` '``+``', and the :ref:`imaginary "
"literal <imaginary>` ``4.2j``. Since these are three separate tokens, "
"whitespace is allowed between them::"
msgstr ""

#: ../../../reference/lexical_analysis.rst:1496
msgid ""
"No whitespace is allowed *within* each token. In particular, the ``j`` "
"suffix, may not be separated from the number before it."
msgstr ""

#: ../../../reference/lexical_analysis.rst:1500
msgid ""
"The number before the ``j`` has the same syntax as a floating-point literal. "
"Thus, the following are valid imaginary literals::"
msgstr ""

#: ../../../reference/lexical_analysis.rst:1511
msgid ""
"Unlike in a floating-point literal the decimal point can be omitted if the "
"imaginary number only has an integer part. The number is still evaluated as "
"a floating-point number, not an integer::"
msgstr ""

#: ../../../reference/lexical_analysis.rst:1519
msgid ""
"The ``j`` suffix is case-insensitive. That means you can use ``J`` instead::"
msgstr ""

#: ../../../reference/lexical_analysis.rst:1524
msgid ""
"Formally, imaginary literals are described by the following lexical "
"definition:"
msgstr ""

#: ../../../reference/lexical_analysis.rst:1537
msgid "Operators and delimiters"
msgstr ""

#: ../../../reference/lexical_analysis.rst:1543
msgid ""
"The following grammar defines :dfn:`operator` and :dfn:`delimiter` tokens, "
"that is, the generic :data:`~token.OP` token type. A :ref:`list of these "
"tokens and their names <token_operators_delimiters>` is also available in "
"the :mod:`!token` module documentation."
msgstr ""

#: ../../../reference/lexical_analysis.rst:1572
msgid ""
"Generally, *operators* are used to combine :ref:`expressions <expressions>`, "
"while *delimiters* serve other purposes. However, there is no clear, formal "
"distinction between the two categories."
msgstr ""

#: ../../../reference/lexical_analysis.rst:1576
msgid ""
"Some tokens can serve as either operators or delimiters, depending on usage. "
"For example, ``*`` is both the multiplication operator and a delimiter used "
"for sequence unpacking, and ``@`` is both the matrix multiplication and a "
"delimiter that introduces decorators."
msgstr ""

#: ../../../reference/lexical_analysis.rst:1581
msgid ""
"For some tokens, the distinction is unclear. For example, some people "
"consider ``.``, ``(``, and ``)`` to be delimiters, while others see the :py:"
"func:`getattr` operator and the function call operator(s)."
msgstr ""

#: ../../../reference/lexical_analysis.rst:1585
msgid ""
"Some of Python's operators, like ``and``, ``or``, and ``not in``, use :ref:"
"`keyword <keywords>` tokens rather than \"symbols\" (operator tokens)."
msgstr ""

#: ../../../reference/lexical_analysis.rst:1588
msgid ""
"A sequence of three consecutive periods (``...``) has a special meaning as "
"an :py:data:`Ellipsis` literal."
msgstr ""

#: ../../../reference/lexical_analysis.rst:8
msgid "lexical analysis"
msgstr ""

#: ../../../reference/lexical_analysis.rst:8
msgid "parser"
msgstr ""

#: ../../../reference/lexical_analysis.rst:8
msgid "token"
msgstr ""

#: ../../../reference/lexical_analysis.rst:90
msgid "line structure"
msgstr ""

#: ../../../reference/lexical_analysis.rst:100
msgid "logical line"
msgstr ""

#: ../../../reference/lexical_analysis.rst:100
#: ../../../reference/lexical_analysis.rst:205
#: ../../../reference/lexical_analysis.rst:767
msgid "physical line"
msgstr ""

#: ../../../reference/lexical_analysis.rst:100
#: ../../../reference/lexical_analysis.rst:205
msgid "line joining"
msgstr ""

#: ../../../reference/lexical_analysis.rst:100
msgid "NEWLINE token"
msgstr ""

#: ../../../reference/lexical_analysis.rst:146
msgid "comment"
msgstr ""

#: ../../../reference/lexical_analysis.rst:146
msgid "hash character"
msgstr ""

#: ../../../reference/lexical_analysis.rst:146
#: ../../../reference/lexical_analysis.rst:160
msgid "# (hash)"
msgstr ""

#: ../../../reference/lexical_analysis.rst:160
msgid "source character set"
msgstr ""

#: ../../../reference/lexical_analysis.rst:160
msgid "encoding declarations (source file)"
msgstr ""

#: ../../../reference/lexical_analysis.rst:160
msgid "source encoding declaration"
msgstr ""

#: ../../../reference/lexical_analysis.rst:205
msgid "line continuation"
msgstr ""

#: ../../../reference/lexical_analysis.rst:205
msgid "backslash character"
msgstr ""

#: ../../../reference/lexical_analysis.rst:250
msgid "blank line"
msgstr ""

#: ../../../reference/lexical_analysis.rst:266
msgid "indentation"
msgstr ""

#: ../../../reference/lexical_analysis.rst:266
msgid "leading whitespace"
msgstr ""

#: ../../../reference/lexical_analysis.rst:266
msgid "grouping"
msgstr ""

#: ../../../reference/lexical_analysis.rst:266
msgid "statement grouping"
msgstr ""

#: ../../../reference/lexical_analysis.rst:294
msgid "INDENT token"
msgstr ""

#: ../../../reference/lexical_analysis.rst:294
msgid "DEDENT token"
msgstr ""

#: ../../../reference/lexical_analysis.rst:392
msgid "identifier"
msgstr ""

#: ../../../reference/lexical_analysis.rst:392
msgid "name"
msgstr ""

#: ../../../reference/lexical_analysis.rst:427
#: ../../../reference/lexical_analysis.rst:451
msgid "keyword"
msgstr ""

#: ../../../reference/lexical_analysis.rst:427
msgid "reserved word"
msgstr ""

#: ../../../reference/lexical_analysis.rst:451
msgid "soft keyword"
msgstr ""

#: ../../../reference/lexical_analysis.rst:475
msgid "_, identifiers"
msgstr ""

#: ../../../reference/lexical_analysis.rst:475
msgid "__, identifiers"
msgstr ""

#: ../../../reference/lexical_analysis.rst:620
msgid "literal"
msgstr ""

#: ../../../reference/lexical_analysis.rst:620
msgid "constant"
msgstr ""

#: ../../../reference/lexical_analysis.rst:632
#: ../../../reference/lexical_analysis.rst:675
#: ../../../reference/lexical_analysis.rst:700
msgid "string literal"
msgstr ""

#: ../../../reference/lexical_analysis.rst:632
#: ../../../reference/lexical_analysis.rst:968
msgid "bytes literal"
msgstr ""

#: ../../../reference/lexical_analysis.rst:632
msgid "ASCII"
msgstr ""

#: ../../../reference/lexical_analysis.rst:632
msgid "' (single quote)"
msgstr ""

#: ../../../reference/lexical_analysis.rst:632
msgid "\" (double quote)"
msgstr ""

#: ../../../reference/lexical_analysis.rst:675
msgid "triple-quoted string"
msgstr ""

#: ../../../reference/lexical_analysis.rst:675
msgid "\"\"\""
msgstr ""

#: ../../../reference/lexical_analysis.rst:675
msgid "'''"
msgstr ""

#: ../../../reference/lexical_analysis.rst:700
msgid "u'"
msgstr ""

#: ../../../reference/lexical_analysis.rst:700
msgid "u\""
msgstr ""

#: ../../../reference/lexical_analysis.rst:767
msgid "escape sequence"
msgstr ""

#: ../../../reference/lexical_analysis.rst:767
msgid "Standard C"
msgstr ""

#: ../../../reference/lexical_analysis.rst:767
msgid "C"
msgstr ""

#: ../../../reference/lexical_analysis.rst:767
msgid "\\ (backslash)"
msgstr ""

#: ../../../reference/lexical_analysis.rst:767
msgid "\\\\"
msgstr "\\\\"

#: ../../../reference/lexical_analysis.rst:767
msgid "\\a"
msgstr "\\a"

#: ../../../reference/lexical_analysis.rst:767
msgid "\\b"
msgstr "\\b"

#: ../../../reference/lexical_analysis.rst:767
msgid "\\f"
msgstr "\\f"

#: ../../../reference/lexical_analysis.rst:767
msgid "\\n"
msgstr "\\n"

#: ../../../reference/lexical_analysis.rst:767
msgid "\\r"
msgstr ""

#: ../../../reference/lexical_analysis.rst:767
msgid "\\t"
msgstr "\\t"

#: ../../../reference/lexical_analysis.rst:767
msgid "\\v"
msgstr "\\v"

#: ../../../reference/lexical_analysis.rst:767
msgid "\\x"
msgstr "\\x"

#: ../../../reference/lexical_analysis.rst:767
msgid "\\N"
msgstr "\\N"

#: ../../../reference/lexical_analysis.rst:767
msgid "\\u"
msgstr "\\u"

#: ../../../reference/lexical_analysis.rst:767
msgid "\\U"
msgstr "\\U"

#: ../../../reference/lexical_analysis.rst:943
msgid "unrecognized escape sequence"
msgstr ""

#: ../../../reference/lexical_analysis.rst:968
msgid "b'"
msgstr ""

#: ../../../reference/lexical_analysis.rst:968
msgid "b\""
msgstr ""

#: ../../../reference/lexical_analysis.rst:995
msgid "r'"
msgstr ""

#: ../../../reference/lexical_analysis.rst:995
msgid "raw string literal"
msgstr ""

#: ../../../reference/lexical_analysis.rst:995
msgid "r\""
msgstr ""

#: ../../../reference/lexical_analysis.rst:1026
msgid "formatted string literal"
msgstr ""

#: ../../../reference/lexical_analysis.rst:1026
msgid "interpolated string literal"
msgstr ""

#: ../../../reference/lexical_analysis.rst:1026
msgid "string"
msgstr ""

#: ../../../reference/lexical_analysis.rst:1026
msgid "formatted literal"
msgstr ""

#: ../../../reference/lexical_analysis.rst:1026
msgid "interpolated literal"
msgstr ""

#: ../../../reference/lexical_analysis.rst:1026
msgid "f-string"
msgstr ""

#: ../../../reference/lexical_analysis.rst:1026
msgid "fstring"
msgstr ""

#: ../../../reference/lexical_analysis.rst:1026
msgid "f'"
msgstr ""

#: ../../../reference/lexical_analysis.rst:1026
msgid "f\""
msgstr ""

#: ../../../reference/lexical_analysis.rst:1026
msgid "{} (curly brackets)"
msgstr ""

#: ../../../reference/lexical_analysis.rst:1026
msgid "in formatted string literal"
msgstr ""

#: ../../../reference/lexical_analysis.rst:1026
msgid "! (exclamation)"
msgstr ""

#: ../../../reference/lexical_analysis.rst:1026
msgid ": (colon)"
msgstr ""

#: ../../../reference/lexical_analysis.rst:1026
msgid "= (equals)"
msgstr ""

#: ../../../reference/lexical_analysis.rst:1026
msgid "for help in debugging using string literals"
msgstr ""

#: ../../../reference/lexical_analysis.rst:1308
msgid "number"
msgstr ""

#: ../../../reference/lexical_analysis.rst:1308
msgid "numeric literal"
msgstr ""

#: ../../../reference/lexical_analysis.rst:1308
#: ../../../reference/lexical_analysis.rst:1330
msgid "integer literal"
msgstr ""

#: ../../../reference/lexical_analysis.rst:1308
msgid "floating-point literal"
msgstr ""

#: ../../../reference/lexical_analysis.rst:1308
msgid "hexadecimal literal"
msgstr ""

#: ../../../reference/lexical_analysis.rst:1308
msgid "octal literal"
msgstr ""

#: ../../../reference/lexical_analysis.rst:1308
msgid "binary literal"
msgstr ""

#: ../../../reference/lexical_analysis.rst:1308
msgid "decimal literal"
msgstr ""

#: ../../../reference/lexical_analysis.rst:1308
msgid "imaginary literal"
msgstr ""

#: ../../../reference/lexical_analysis.rst:1308
msgid "complex literal"
msgstr ""

#: ../../../reference/lexical_analysis.rst:1330
msgid "0b"
msgstr ""

#: ../../../reference/lexical_analysis.rst:1330
msgid "0o"
msgstr ""

#: ../../../reference/lexical_analysis.rst:1330
msgid "0x"
msgstr ""

#: ../../../reference/lexical_analysis.rst:1330
#: ../../../reference/lexical_analysis.rst:1405
msgid "_ (underscore)"
msgstr ""

#: ../../../reference/lexical_analysis.rst:1330
#: ../../../reference/lexical_analysis.rst:1405
#: ../../../reference/lexical_analysis.rst:1469
msgid "in numeric literal"
msgstr ""

#: ../../../reference/lexical_analysis.rst:1405
msgid ". (dot)"
msgstr ""

#: ../../../reference/lexical_analysis.rst:1405
msgid "e"
msgstr ""

#: ../../../reference/lexical_analysis.rst:1469
msgid "j"
msgstr ""

#: ../../../reference/lexical_analysis.rst:1539
msgid "operators"
msgstr ""

#: ../../../reference/lexical_analysis.rst:1539
msgid "delimiters"
msgstr ""

# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.15\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2026-02-16 09:11+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../library/profiling.sampling.rst:7
msgid ":mod:`!profiling.sampling` --- Statistical profiler"
msgstr ""

#: ../../../library/profiling.sampling.rst:14
msgid "**Source code:** :source:`Lib/profiling/sampling/`"
msgstr ""

#: ../../../library/profiling.sampling.rst:20
msgid "Tachyon logo"
msgstr ""

#: ../../../library/profiling.sampling.rst:25
msgid ""
"The :mod:`!profiling.sampling` module, named **Tachyon**, provides "
"statistical profiling of Python programs through periodic stack sampling. "
"Tachyon can run scripts directly or attach to any running Python process "
"without requiring code changes or restarts. Because sampling occurs "
"externally to the target process, overhead is virtually zero, making Tachyon "
"suitable for both development and production environments."
msgstr ""

#: ../../../library/profiling.sampling.rst:34
msgid "What is statistical profiling?"
msgstr ""

#: ../../../library/profiling.sampling.rst:36
msgid ""
"Statistical profiling builds a picture of program behavior by periodically "
"capturing snapshots of the call stack. Rather than instrumenting every "
"function call and return as deterministic profilers do, Tachyon reads the "
"call stack at regular intervals to record what code is currently running."
msgstr ""

#: ../../../library/profiling.sampling.rst:41
msgid ""
"This approach rests on a simple principle: functions that consume "
"significant CPU time will appear frequently in the collected samples. By "
"gathering thousands of samples over a profiling session, Tachyon constructs "
"an accurate statistical estimate of where time is spent. The more samples "
"collected, the more precise this estimate becomes."
msgstr ""

#: ../../../library/profiling.sampling.rst:49
msgid ""
"The following interactive visualization demonstrates how sampling profiling "
"works. Press **Play** to watch a Python program execute, and observe how the "
"profiler periodically captures snapshots of the call stack. Adjust the "
"**sample interval** to see how sampling frequency affects the results."
msgstr ""

#: ../../../library/profiling.sampling.rst:54
msgid ""
"<div id=\"sampling-profiler-viz\" class=\"sampling-profiler-viz\"></div>\n"
msgstr ""

#: ../../../library/profiling.sampling.rst:61
msgid ""
"An interactive visualization of sampling profiling is available in the HTML "
"version of this documentation."
msgstr ""

#: ../../../library/profiling.sampling.rst:66
msgid "How time is estimated"
msgstr ""

#: ../../../library/profiling.sampling.rst:68
msgid ""
"The time values shown in Tachyon's output are **estimates derived from "
"sample counts**, not direct measurements. Tachyon counts how many times each "
"function appears in the collected samples, then multiplies by the sampling "
"interval to estimate time."
msgstr ""

#: ../../../library/profiling.sampling.rst:73
msgid ""
"For example, with a 10 kHz sampling rate over a 10-second profile, Tachyon "
"collects approximately 100,000 samples. If a function appears in 5,000 "
"samples (5% of total), Tachyon estimates it consumed 5% of the 10-second "
"duration, or about 500 milliseconds. This is a statistical estimate, not a "
"precise measurement."
msgstr ""

#: ../../../library/profiling.sampling.rst:79
msgid ""
"The accuracy of these estimates depends on sample count. With 100,000 "
"samples, a function showing 5% has a margin of error of roughly Â±0.5%. With "
"only 1,000 samples, the same 5% measurement could actually represent "
"anywhere from 3% to 7% of real time."
msgstr ""

#: ../../../library/profiling.sampling.rst:84
msgid ""
"This is why longer profiling durations and shorter sampling intervals "
"produce more reliable results---they collect more samples. For most "
"performance analysis, the default settings provide sufficient accuracy to "
"identify bottlenecks and guide optimization efforts."
msgstr ""

#: ../../../library/profiling.sampling.rst:89
msgid ""
"Because sampling is statistical, results will vary slightly between runs. A "
"function showing 12% in one run might show 11% or 13% in the next. This is "
"normal and expected. Focus on the overall pattern rather than exact "
"percentages, and don't worry about small variations between runs."
msgstr ""

#: ../../../library/profiling.sampling.rst:96
msgid "When to use a different approach"
msgstr ""

#: ../../../library/profiling.sampling.rst:98
msgid "Statistical sampling is not ideal for every situation."
msgstr ""

#: ../../../library/profiling.sampling.rst:100
msgid ""
"For very short scripts that complete in under one second, the profiler may "
"not collect enough samples for reliable results. Use :mod:`profiling."
"tracing` instead, or run the script in a loop to extend profiling time."
msgstr ""

#: ../../../library/profiling.sampling.rst:104
msgid ""
"When you need exact call counts, sampling cannot provide them. Sampling "
"estimates frequency from snapshots, so if you need to know precisely how "
"many times a function was called, use :mod:`profiling.tracing`."
msgstr ""

#: ../../../library/profiling.sampling.rst:108
msgid ""
"When comparing two implementations where the difference might be only 1-2%, "
"sampling noise can obscure real differences. Use :mod:`timeit` for micro-"
"benchmarks or :mod:`profiling.tracing` for precise measurements."
msgstr ""

#: ../../../library/profiling.sampling.rst:113
msgid ""
"The key difference from :mod:`profiling.tracing` is how measurement happens. "
"A tracing profiler instruments your code, recording every function call and "
"return. This provides exact call counts and precise timing but adds overhead "
"to every function call. A sampling profiler, by contrast, observes the "
"program from outside at fixed intervals without modifying its execution. "
"Think of the difference like this: tracing is like having someone follow you "
"and write down every step you take, while sampling is like taking "
"photographs every second and inferring your path from those snapshots."
msgstr ""

#: ../../../library/profiling.sampling.rst:122
msgid ""
"This external observation model is what makes sampling profiling practical "
"for production use. The profiled program runs at full speed because there is "
"no instrumentation code running inside it, and the target process is never "
"stopped or paused during sampling---Tachyon reads the call stack directly "
"from the process's memory while it continues to run. You can attach to a "
"live server, collect data, and detach without the application ever knowing "
"it was observed. The trade-off is that very short-lived functions may be "
"missed if they happen to complete between samples."
msgstr ""

#: ../../../library/profiling.sampling.rst:131
msgid ""
"Statistical profiling excels at answering the question, \"Where is my "
"program spending time?\" It reveals hotspots and bottlenecks in production "
"code where deterministic profiling overhead would be unacceptable. For exact "
"call counts and complete call graphs, use :mod:`profiling.tracing` instead."
msgstr ""

#: ../../../library/profiling.sampling.rst:138
msgid "Quick examples"
msgstr ""

#: ../../../library/profiling.sampling.rst:140
msgid "Profile a script and see the results immediately::"
msgstr ""

#: ../../../library/profiling.sampling.rst:144
msgid "Profile a module with arguments::"
msgstr ""

#: ../../../library/profiling.sampling.rst:148
msgid "Generate an interactive flame graph::"
msgstr ""

#: ../../../library/profiling.sampling.rst:152
msgid "Attach to a running process by PID::"
msgstr ""

#: ../../../library/profiling.sampling.rst:156
msgid "Use live mode for real-time monitoring (press ``q`` to quit)::"
msgstr ""

#: ../../../library/profiling.sampling.rst:160
msgid "Profile for 60 seconds with a faster sampling rate::"
msgstr ""

#: ../../../library/profiling.sampling.rst:164
msgid "Generate a line-by-line heatmap::"
msgstr ""

#: ../../../library/profiling.sampling.rst:168
msgid ""
"Enable opcode-level profiling to see which bytecode instructions are "
"executing::"
msgstr ""

#: ../../../library/profiling.sampling.rst:174
msgid "Commands"
msgstr ""

#: ../../../library/profiling.sampling.rst:176
msgid ""
"Tachyon operates through two subcommands that determine how to obtain the "
"target process."
msgstr ""

#: ../../../library/profiling.sampling.rst:181
msgid "The ``run`` command"
msgstr ""

#: ../../../library/profiling.sampling.rst:183
msgid ""
"The ``run`` command launches a Python script or module and profiles it from "
"startup::"
msgstr ""

#: ../../../library/profiling.sampling.rst:189
msgid ""
"When profiling a script, the profiler starts the target in a subprocess, "
"waits for it to initialize, then begins collecting samples. The ``-m`` flag "
"indicates that the target should be run as a module (equivalent to ``python -"
"m``). Arguments after the target are passed through to the profiled program::"
msgstr ""

#: ../../../library/profiling.sampling.rst:199
msgid "The ``attach`` command"
msgstr ""

#: ../../../library/profiling.sampling.rst:201
msgid ""
"The ``attach`` command connects to an already-running Python process by its "
"process ID::"
msgstr ""

#: ../../../library/profiling.sampling.rst:206
msgid ""
"This command is particularly valuable for investigating performance issues "
"in production systems. The target process requires no modification and need "
"not be restarted. The profiler attaches, collects samples for the specified "
"duration, then detaches and produces output."
msgstr ""

#: ../../../library/profiling.sampling.rst:216
msgid ""
"On most systems, attaching to another process requires appropriate "
"permissions. See :ref:`profiling-permissions` for platform-specific "
"requirements."
msgstr ""

#: ../../../library/profiling.sampling.rst:223
msgid "The ``replay`` command"
msgstr ""

#: ../../../library/profiling.sampling.rst:225
msgid ""
"The ``replay`` command converts binary profile files to other output "
"formats::"
msgstr ""

#: ../../../library/profiling.sampling.rst:230
msgid ""
"This command is useful when you have captured profiling data in binary "
"format and want to analyze it later or convert it to a visualization format. "
"Binary profiles can be replayed multiple times to different formats without "
"re-profiling."
msgstr ""

#: ../../../library/profiling.sampling.rst:251
msgid "Profiling in production"
msgstr ""

#: ../../../library/profiling.sampling.rst:253
msgid ""
"The sampling profiler is designed for production use. It imposes no "
"measurable overhead on the target process because it reads memory externally "
"rather than instrumenting code. The target application continues running at "
"full speed and is unaware it is being profiled."
msgstr ""

#: ../../../library/profiling.sampling.rst:258
msgid "When profiling production systems, keep these guidelines in mind:"
msgstr ""

#: ../../../library/profiling.sampling.rst:260
msgid ""
"Start with shorter durations (10-30 seconds) to get quick results, then "
"extend if you need more statistical accuracy. By default, profiling runs "
"until the target process completes, which is usually sufficient to identify "
"major hotspots."
msgstr ""

#: ../../../library/profiling.sampling.rst:264
msgid ""
"If possible, profile during representative load rather than peak traffic. "
"Profiles collected during normal operation are easier to interpret than "
"those collected during unusual spikes."
msgstr ""

#: ../../../library/profiling.sampling.rst:268
msgid ""
"The profiler itself consumes some CPU on the machine where it runs (not on "
"the target process). On the same machine, this is typically negligible. When "
"profiling remote processes, network latency does not affect the target."
msgstr ""

#: ../../../library/profiling.sampling.rst:272
msgid ""
"Results from production may differ from development due to different data "
"sizes, concurrent load, or caching effects. This is expected and is often "
"exactly what you want to capture."
msgstr ""

#: ../../../library/profiling.sampling.rst:280
msgid "Platform requirements"
msgstr ""

#: ../../../library/profiling.sampling.rst:282
msgid ""
"The profiler reads the target process's memory to capture stack traces. This "
"requires elevated permissions on most operating systems."
msgstr ""

#: ../../../library/profiling.sampling.rst:285
msgid "**Linux**"
msgstr ""

#: ../../../library/profiling.sampling.rst:287
msgid ""
"On Linux, the profiler uses ``ptrace`` or ``process_vm_readv`` to read the "
"target process's memory. This typically requires one of:"
msgstr ""

#: ../../../library/profiling.sampling.rst:290
#: ../../../library/profiling.sampling.rst:304
msgid "Running as root"
msgstr ""

#: ../../../library/profiling.sampling.rst:291
msgid "Having the ``CAP_SYS_PTRACE`` capability"
msgstr ""

#: ../../../library/profiling.sampling.rst:292
msgid "Adjusting the Yama ptrace scope: ``/proc/sys/kernel/yama/ptrace_scope``"
msgstr ""

#: ../../../library/profiling.sampling.rst:294
msgid ""
"The default ptrace_scope of 1 restricts ptrace to parent processes only. To "
"allow attaching to any process owned by the same user, set it to 0::"
msgstr ""

#: ../../../library/profiling.sampling.rst:299
msgid "**macOS**"
msgstr ""

#: ../../../library/profiling.sampling.rst:301
msgid ""
"On macOS, the profiler uses ``task_for_pid()`` to access the target process. "
"This requires one of:"
msgstr ""

#: ../../../library/profiling.sampling.rst:305
msgid ""
"The profiler binary having the ``com.apple.security.cs.debugger`` entitlement"
msgstr ""

#: ../../../library/profiling.sampling.rst:306
msgid "System Integrity Protection (SIP) being disabled (not recommended)"
msgstr ""

#: ../../../library/profiling.sampling.rst:308
msgid "**Windows**"
msgstr ""

#: ../../../library/profiling.sampling.rst:310
msgid ""
"On Windows, the profiler requires administrative privileges or the "
"``SeDebugPrivilege`` privilege to read another process's memory."
msgstr ""

#: ../../../library/profiling.sampling.rst:315
msgid "Version compatibility"
msgstr ""

#: ../../../library/profiling.sampling.rst:317
msgid ""
"The profiler and target process must run the same Python minor version (for "
"example, both Python 3.15). Attaching from Python 3.14 to a Python 3.15 "
"process is not supported."
msgstr ""

#: ../../../library/profiling.sampling.rst:321
msgid ""
"Additional restrictions apply to pre-release Python versions: if either the "
"profiler or target is running a pre-release (alpha, beta, or release "
"candidate), both must run the exact same version."
msgstr ""

#: ../../../library/profiling.sampling.rst:325
msgid ""
"On free-threaded Python builds, the profiler cannot attach from a free-"
"threaded build to a standard build, or vice versa."
msgstr ""

#: ../../../library/profiling.sampling.rst:330
msgid "Sampling configuration"
msgstr ""

#: ../../../library/profiling.sampling.rst:332
msgid ""
"Before exploring the various output formats and visualization options, it is "
"important to understand how to configure the sampling process itself. The "
"profiler offers several options that control how frequently samples are "
"collected, how long profiling runs, which threads are observed, and what "
"additional context is captured in each sample."
msgstr ""

#: ../../../library/profiling.sampling.rst:338
msgid "The default configuration works well for most use cases:"
msgstr ""

#: ../../../library/profiling.sampling.rst:344
msgid "Option"
msgstr ""

#: ../../../library/profiling.sampling.rst:345
msgid "Default"
msgstr ""

#: ../../../library/profiling.sampling.rst:346
msgid "Default for ``--sampling-rate`` / ``-r``"
msgstr ""

#: ../../../library/profiling.sampling.rst:347
msgid "1 kHz"
msgstr ""

#: ../../../library/profiling.sampling.rst:348
msgid "Default for ``--duration`` / ``-d``"
msgstr ""

#: ../../../library/profiling.sampling.rst:349
msgid "Run to completion"
msgstr ""

#: ../../../library/profiling.sampling.rst:350
msgid "Default for ``--all-threads`` / ``-a``"
msgstr ""

#: ../../../library/profiling.sampling.rst:351
msgid "Main thread only"
msgstr ""

#: ../../../library/profiling.sampling.rst:352
msgid "Default for ``--native``"
msgstr ""

#: ../../../library/profiling.sampling.rst:353
msgid "No ``<native>`` frames (C code time attributed to caller)"
msgstr ""

#: ../../../library/profiling.sampling.rst:354
msgid "Default for ``--no-gc``"
msgstr ""

#: ../../../library/profiling.sampling.rst:355
msgid "``<GC>`` frames included when garbage collection is active"
msgstr ""

#: ../../../library/profiling.sampling.rst:356
msgid "Default for ``--mode``"
msgstr ""

#: ../../../library/profiling.sampling.rst:357
msgid "Wall-clock mode (all samples recorded)"
msgstr ""

#: ../../../library/profiling.sampling.rst:358
msgid "Default for ``--realtime-stats``"
msgstr ""

#: ../../../library/profiling.sampling.rst:359
#: ../../../library/profiling.sampling.rst:361
msgid "Disabled"
msgstr ""

#: ../../../library/profiling.sampling.rst:360
msgid "Default for ``--subprocesses``"
msgstr ""

#: ../../../library/profiling.sampling.rst:362
msgid "Default for ``--blocking``"
msgstr ""

#: ../../../library/profiling.sampling.rst:363
msgid "Disabled (non-blocking sampling)"
msgstr ""

#: ../../../library/profiling.sampling.rst:367
msgid "Sampling rate and duration"
msgstr ""

#: ../../../library/profiling.sampling.rst:369
msgid ""
"The two most fundamental parameters are the sampling rate and duration. "
"Together, these determine how many samples will be collected during a "
"profiling session."
msgstr ""

#: ../../../library/profiling.sampling.rst:373
msgid ""
"The :option:`--sampling-rate` option (:option:`-r`) sets how frequently "
"samples are collected. The default is 1 kHz (1,000 samples per second)::"
msgstr ""

#: ../../../library/profiling.sampling.rst:378
msgid ""
"Higher rates capture more samples and provide finer-grained data at the cost "
"of slightly higher profiler CPU usage. Lower rates reduce profiler overhead "
"but may miss short-lived functions. For most applications, the default rate "
"provides a good balance between accuracy and overhead."
msgstr ""

#: ../../../library/profiling.sampling.rst:383
msgid ""
"The :option:`--duration` option (:option:`-d`) sets how long to profile in "
"seconds. By default, profiling continues until the target process exits or "
"is interrupted::"
msgstr ""

#: ../../../library/profiling.sampling.rst:388
msgid ""
"Specifying a duration is useful when attaching to long-running processes or "
"when you want to limit profiling to a specific time window. When profiling a "
"script, the default behavior of running to completion is usually what you "
"want."
msgstr ""

#: ../../../library/profiling.sampling.rst:394
msgid "Thread selection"
msgstr ""

#: ../../../library/profiling.sampling.rst:396
msgid ""
"Python programs often use multiple threads, whether explicitly through the :"
"mod:`threading` module or implicitly through libraries that manage thread "
"pools."
msgstr ""

#: ../../../library/profiling.sampling.rst:400
msgid ""
"By default, the profiler samples only the main thread. The :option:`--all-"
"threads` option (:option:`-a`) enables sampling of all threads in the "
"process::"
msgstr ""

#: ../../../library/profiling.sampling.rst:405
msgid ""
"Multi-thread profiling reveals how work is distributed across threads and "
"can identify threads that are blocked or starved. Each thread's samples are "
"combined in the output, with the ability to filter by thread in some "
"formats. This option is particularly useful when investigating concurrency "
"issues or when work is distributed across a thread pool."
msgstr ""

#: ../../../library/profiling.sampling.rst:415
msgid "Blocking mode"
msgstr ""

#: ../../../library/profiling.sampling.rst:417
msgid ""
"By default, Tachyon reads the target process's memory without stopping it. "
"This non-blocking approach is ideal for most profiling scenarios because it "
"imposes virtually zero overhead on the target application: the profiled "
"program runs at full speed and is unaware it is being observed."
msgstr ""

#: ../../../library/profiling.sampling.rst:422
msgid ""
"However, non-blocking sampling can occasionally produce incomplete or "
"inconsistent stack traces in applications with many generators or coroutines "
"that rapidly switch between yield points, or in programs with very fast-"
"changing call stacks where functions enter and exit between the start and "
"end of a single stack read, resulting in reconstructed stacks that mix "
"frames from different execution states or that never actually existed."
msgstr ""

#: ../../../library/profiling.sampling.rst:429
msgid ""
"For these cases, the :option:`--blocking` option stops the target process "
"during each sample::"
msgstr ""

#: ../../../library/profiling.sampling.rst:435
msgid ""
"When blocking mode is enabled, the profiler suspends the target process, "
"reads its stack, then resumes it. This guarantees that each captured stack "
"represents a real, consistent snapshot of what the process was doing at that "
"instant. The trade-off is that the target process runs slower because it is "
"repeatedly paused."
msgstr ""

#: ../../../library/profiling.sampling.rst:443
msgid ""
"Do not use very high sample rates (low ``--interval`` values) with blocking "
"mode. Suspending and resuming a process takes time, and if the sampling "
"interval is too short, the target will spend more time stopped than running. "
"For blocking mode, intervals of 1000 microseconds (1 millisecond) or higher "
"are recommended. The default 100 microsecond interval may cause noticeable "
"slowdown in the target application."
msgstr ""

#: ../../../library/profiling.sampling.rst:450
msgid ""
"Use blocking mode only when you observe inconsistent stacks in your "
"profiles, particularly with generator-heavy or coroutine-heavy code. For "
"most applications, the default non-blocking mode provides accurate results "
"with zero impact on the target process."
msgstr ""

#: ../../../library/profiling.sampling.rst:457
msgid "Special frames"
msgstr ""

#: ../../../library/profiling.sampling.rst:459
msgid ""
"The profiler can inject artificial frames into the captured stacks to "
"provide additional context about what the interpreter is doing at the moment "
"each sample is taken. These synthetic frames help distinguish different "
"types of execution that would otherwise be invisible."
msgstr ""

#: ../../../library/profiling.sampling.rst:464
msgid ""
"The :option:`--native` option adds ``<native>`` frames to indicate when "
"Python has called into C code (extension modules, built-in functions, or the "
"interpreter itself)::"
msgstr ""

#: ../../../library/profiling.sampling.rst:470
msgid ""
"These frames help distinguish time spent in Python code versus time spent in "
"native libraries. Without this option, native code execution appears as time "
"in the Python function that made the call. This is useful when optimizing "
"code that makes heavy use of C extensions like NumPy or database drivers."
msgstr ""

#: ../../../library/profiling.sampling.rst:475
msgid ""
"By default, the profiler includes ``<GC>`` frames when garbage collection is "
"active. The :option:`--no-gc` option suppresses these frames::"
msgstr ""

#: ../../../library/profiling.sampling.rst:480
msgid ""
"GC frames help identify programs where garbage collection consumes "
"significant time, which may indicate memory allocation patterns worth "
"optimizing. If you see substantial time in ``<GC>`` frames, consider "
"investigating object allocation rates or using object pooling."
msgstr ""

#: ../../../library/profiling.sampling.rst:487
msgid "Opcode-aware profiling"
msgstr ""

#: ../../../library/profiling.sampling.rst:489
msgid ""
"The :option:`--opcodes` option enables instruction-level profiling that "
"captures which Python bytecode instructions are executing at each sample::"
msgstr ""

#: ../../../library/profiling.sampling.rst:494
msgid ""
"This feature provides visibility into Python's bytecode execution, including "
"adaptive specialization optimizations. When a generic instruction like "
"``LOAD_ATTR`` is specialized at runtime into a more efficient variant like "
"``LOAD_ATTR_INSTANCE_VALUE``, the profiler shows both the specialized name "
"and the base instruction."
msgstr ""

#: ../../../library/profiling.sampling.rst:500
msgid "Opcode information appears in several output formats:"
msgstr ""

#: ../../../library/profiling.sampling.rst:502
msgid ""
"**Flame graphs**: Hovering over a frame displays a tooltip with a bytecode "
"instruction breakdown, showing which opcodes consumed time in that function"
msgstr ""

#: ../../../library/profiling.sampling.rst:504
msgid ""
"**Heatmap**: Expandable bytecode panels per source line show instruction "
"breakdown with specialization percentages"
msgstr ""

#: ../../../library/profiling.sampling.rst:506
msgid ""
"**Live mode**: An opcode panel shows instruction-level statistics for the "
"selected function, accessible via keyboard navigation"
msgstr ""

#: ../../../library/profiling.sampling.rst:508
msgid ""
"**Gecko format**: Opcode transitions are emitted as interval markers in the "
"Firefox Profiler timeline"
msgstr ""

#: ../../../library/profiling.sampling.rst:511
msgid "This level of detail is particularly useful for:"
msgstr ""

#: ../../../library/profiling.sampling.rst:513
msgid ""
"Understanding the performance impact of Python's adaptive specialization"
msgstr ""

#: ../../../library/profiling.sampling.rst:514
msgid ""
"Identifying hot bytecode instructions that might benefit from optimization"
msgstr ""

#: ../../../library/profiling.sampling.rst:515
msgid ""
"Analyzing the effectiveness of different code patterns at the instruction "
"level"
msgstr ""

#: ../../../library/profiling.sampling.rst:516
msgid "Debugging performance issues that occur at the bytecode level"
msgstr ""

#: ../../../library/profiling.sampling.rst:518
msgid ""
"The :option:`--opcodes` option is compatible with :option:`--live`, :option:"
"`--flamegraph`, :option:`--heatmap`, and :option:`--gecko` formats. It "
"requires additional memory to store opcode information and may slightly "
"reduce sampling performance, but provides unprecedented visibility into "
"Python's execution model."
msgstr ""

#: ../../../library/profiling.sampling.rst:525
msgid "Real-time statistics"
msgstr ""

#: ../../../library/profiling.sampling.rst:527
msgid ""
"The :option:`--realtime-stats` option displays sampling rate statistics "
"during profiling::"
msgstr ""

#: ../../../library/profiling.sampling.rst:532
msgid ""
"This shows the actual achieved sampling rate, which may be lower than "
"requested if the profiler cannot keep up. The statistics help verify that "
"profiling is working correctly and that sufficient samples are being "
"collected. See :ref:`sampling-efficiency` for details on interpreting these "
"metrics."
msgstr ""

#: ../../../library/profiling.sampling.rst:539
msgid "Subprocess profiling"
msgstr ""

#: ../../../library/profiling.sampling.rst:541
msgid ""
"The :option:`--subprocesses` option enables automatic profiling of "
"subprocesses spawned by the target::"
msgstr ""

#: ../../../library/profiling.sampling.rst:547
msgid ""
"When enabled, the profiler monitors the target process for child process "
"creation. When a new Python child process is detected, a separate profiler "
"instance is automatically spawned to profile it. This is useful for "
"applications that use :mod:`multiprocessing`, :mod:`subprocess`, :mod:"
"`concurrent.futures` with :class:`~concurrent.futures.ProcessPoolExecutor`, "
"or other process spawning mechanisms."
msgstr ""

#: ../../../library/profiling.sampling.rst:554
msgid "worker_pool.py"
msgstr ""

#: ../../../library/profiling.sampling.rst:576
msgid ""
"This produces separate flame graphs for the main process and each worker "
"process: ``flamegraph_<main_pid>.html``, ``flamegraph_<worker1_pid>.html``, "
"and so on."
msgstr ""

#: ../../../library/profiling.sampling.rst:580
msgid ""
"Each subprocess receives its own output file. The filename is derived from "
"the specified output path (or the default) with the subprocess's process ID "
"appended:"
msgstr ""

#: ../../../library/profiling.sampling.rst:584
msgid ""
"If you specify ``-o profile.html``, subprocesses produce ``profile_12345."
"html``, ``profile_12346.html``, and so on"
msgstr ""

#: ../../../library/profiling.sampling.rst:586
msgid ""
"With default output, subprocesses produce files like ``flamegraph_12345."
"html`` or directories like ``heatmap_12345``"
msgstr ""

#: ../../../library/profiling.sampling.rst:588
msgid ""
"For pstats format (which defaults to stdout), subprocesses produce files "
"like ``profile_12345.pstats``"
msgstr ""

#: ../../../library/profiling.sampling.rst:591
msgid ""
"The subprocess profilers inherit most sampling options from the parent "
"(sampling rate, duration, thread selection, native frames, GC frames, async-"
"aware mode, and output format). All Python descendant processes are profiled "
"recursively, including grandchildren and further descendants."
msgstr ""

#: ../../../library/profiling.sampling.rst:596
msgid ""
"Subprocess detection works by periodically scanning for new descendants of "
"the target process and checking whether each new process is a Python process "
"by probing the process memory for Python runtime structures. Non-Python "
"subprocesses (such as shell commands or external tools) are ignored."
msgstr ""

#: ../../../library/profiling.sampling.rst:601
msgid ""
"There is a limit of 100 concurrent subprocess profilers to prevent resource "
"exhaustion in programs that spawn many processes. If this limit is reached, "
"additional subprocesses are not profiled and a warning is printed."
msgstr ""

#: ../../../library/profiling.sampling.rst:605
msgid ""
"The :option:`--subprocesses` option is incompatible with :option:`--live` "
"mode because live mode uses an interactive terminal interface that cannot "
"accommodate multiple concurrent profiler displays."
msgstr ""

#: ../../../library/profiling.sampling.rst:613
msgid "Sampling efficiency"
msgstr ""

#: ../../../library/profiling.sampling.rst:615
msgid ""
"Sampling efficiency metrics help assess the quality of the collected data. "
"These metrics appear in the profiler's terminal output and in the flame "
"graph sidebar."
msgstr ""

#: ../../../library/profiling.sampling.rst:619
msgid ""
"**Sampling efficiency** is the percentage of sample attempts that succeeded. "
"Each sample attempt reads the target process's call stack from memory. An "
"attempt can fail if the process is in an inconsistent state at the moment of "
"reading, such as during a context switch or while the interpreter is "
"updating its internal structures. A low efficiency may indicate that the "
"profiler could not keep up with the requested sampling rate, often due to "
"system load or an overly aggressive interval setting."
msgstr ""

#: ../../../library/profiling.sampling.rst:627
msgid ""
"**Missed samples** is the percentage of expected samples that were not "
"collected. Based on the configured interval and duration, the profiler "
"expects to collect a certain number of samples. Some samples may be missed "
"if the profiler falls behind schedule, for example when the system is under "
"heavy load. A small percentage of missed samples is normal and does not "
"significantly affect the statistical accuracy of the profile."
msgstr ""

#: ../../../library/profiling.sampling.rst:634
msgid ""
"Both metrics are informational. Even with some failed attempts or missed "
"samples, the profile remains statistically valid as long as enough samples "
"were collected. The profiler reports the actual number of samples captured, "
"which you can use to judge whether the data is sufficient for your analysis."
msgstr ""

#: ../../../library/profiling.sampling.rst:641
msgid "Profiling modes"
msgstr ""

#: ../../../library/profiling.sampling.rst:643
msgid ""
"The sampling profiler supports four modes that control which samples are "
"recorded. The mode determines what the profile measures: total elapsed time, "
"CPU execution time, time spent holding the global interpreter lock, or "
"exception handling."
msgstr ""

#: ../../../library/profiling.sampling.rst:650
msgid "Wall-clock mode"
msgstr ""

#: ../../../library/profiling.sampling.rst:652
msgid ""
"Wall-clock mode (:option:`--mode`\\ ``=wall``) captures all samples "
"regardless of what the thread is doing. This is the default mode and "
"provides a complete picture of where time passes during program execution::"
msgstr ""

#: ../../../library/profiling.sampling.rst:658
msgid ""
"In wall-clock mode, samples are recorded whether the thread is actively "
"executing Python code, waiting for I/O, blocked on a lock, or sleeping. This "
"makes wall-clock profiling ideal for understanding the overall time "
"distribution in your program, including time spent waiting."
msgstr ""

#: ../../../library/profiling.sampling.rst:663
msgid ""
"If your program spends significant time in I/O operations, network calls, or "
"sleep, wall-clock mode will show these waits as time attributed to the "
"calling function. This is often exactly what you want when optimizing end-to-"
"end latency."
msgstr ""

#: ../../../library/profiling.sampling.rst:670
msgid "CPU mode"
msgstr ""

#: ../../../library/profiling.sampling.rst:672
msgid ""
"CPU mode (:option:`--mode`\\ ``=cpu``) records samples only when the thread "
"is actually executing on a CPU core::"
msgstr ""

#: ../../../library/profiling.sampling.rst:677
msgid ""
"Samples taken while the thread is sleeping, blocked on I/O, or waiting for a "
"lock are discarded. The resulting profile shows where CPU cycles are "
"consumed, filtering out idle time."
msgstr ""

#: ../../../library/profiling.sampling.rst:681
msgid ""
"CPU mode is useful when you want to focus on computational hotspots without "
"being distracted by I/O waits. If your program alternates between "
"computation and network calls, CPU mode reveals which computational sections "
"are most expensive."
msgstr ""

#: ../../../library/profiling.sampling.rst:688
msgid "Comparing wall-clock and CPU profiles"
msgstr ""

#: ../../../library/profiling.sampling.rst:690
msgid ""
"Running both wall-clock and CPU mode profiles can reveal whether a "
"function's time is spent computing or waiting."
msgstr ""

#: ../../../library/profiling.sampling.rst:693
msgid ""
"If a function appears prominently in both profiles, it is a true "
"computational hotspot---actively using the CPU. Optimization should focus on "
"algorithmic improvements or more efficient code."
msgstr ""

#: ../../../library/profiling.sampling.rst:697
msgid ""
"If a function is high in wall-clock mode but low or absent in CPU mode, it "
"is I/O-bound or waiting. The function spends most of its time waiting for "
"network, disk, locks, or sleep. CPU optimization won't help here; consider "
"async I/O, connection pooling, or reducing wait time instead."
msgstr ""

#: ../../../library/profiling.sampling.rst:723
msgid "GIL mode"
msgstr ""

#: ../../../library/profiling.sampling.rst:725
msgid ""
"GIL mode (:option:`--mode`\\ ``=gil``) records samples only when the thread "
"holds Python's global interpreter lock::"
msgstr ""

#: ../../../library/profiling.sampling.rst:730
msgid ""
"The GIL is held only while executing Python bytecode. When Python calls into "
"C extensions, performs I/O operations, or executes native code, the GIL is "
"typically released. This means GIL mode effectively measures time spent "
"running Python code specifically, filtering out time in native libraries."
msgstr ""

#: ../../../library/profiling.sampling.rst:735
msgid ""
"In multi-threaded programs, GIL mode reveals which code is preventing other "
"threads from running Python bytecode. Since only one thread can hold the GIL "
"at a time, functions that appear frequently in GIL mode profiles are "
"monopolizing the interpreter."
msgstr ""

#: ../../../library/profiling.sampling.rst:740
msgid ""
"GIL mode helps answer questions like \"which functions are monopolizing the "
"GIL?\" and \"why are my other threads starving?\" It can also be useful in "
"single-threaded programs to distinguish Python execution time from time "
"spent in C extensions or I/O."
msgstr ""

#: ../../../library/profiling.sampling.rst:770
msgid "Exception mode"
msgstr ""

#: ../../../library/profiling.sampling.rst:772
msgid ""
"Exception mode (``--mode=exception``) records samples only when a thread has "
"an active exception::"
msgstr ""

#: ../../../library/profiling.sampling.rst:777
msgid ""
"Samples are recorded in two situations: when an exception is being "
"propagated up the call stack (after ``raise`` but before being caught), or "
"when code is executing inside an ``except`` block where exception "
"information is still present in the thread state."
msgstr ""

#: ../../../library/profiling.sampling.rst:782
msgid "The following example illustrates which code regions are captured:"
msgstr ""

#: ../../../library/profiling.sampling.rst:809
msgid ""
"Note that ``finally`` blocks are only captured when an exception is actively "
"propagating through them. Once an ``except`` block finishes executing, "
"Python clears the exception information before running any subsequent "
"``finally`` block. Similarly, ``finally`` blocks that run during normal "
"execution (when no exception was raised) are not captured because no "
"exception state is present."
msgstr ""

#: ../../../library/profiling.sampling.rst:815
msgid ""
"This mode is useful for understanding where your program spends time "
"handling errors. Exception handling can be a significant source of overhead "
"in code that uses exceptions for flow control (such as ``StopIteration`` in "
"iterators) or in applications that process many error conditions (such as "
"network servers handling connection failures)."
msgstr ""

#: ../../../library/profiling.sampling.rst:821
msgid ""
"Exception mode helps answer questions like \"how much time is spent handling "
"exceptions?\" and \"which exception handlers are the most expensive?\" It "
"can reveal hidden performance costs in code that catches and processes many "
"exceptions, even when those exceptions are handled gracefully. For example, "
"if a parsing library uses exceptions internally to signal format errors, "
"this mode will capture time spent in those handlers even if the calling code "
"never sees the exceptions."
msgstr ""

#: ../../../library/profiling.sampling.rst:831
msgid "Output formats"
msgstr ""

#: ../../../library/profiling.sampling.rst:833
msgid ""
"The profiler produces output in several formats, each suited to different "
"analysis workflows. The format is selected with a command-line flag, and "
"output goes to stdout, a file, or a directory depending on the format."
msgstr ""

#: ../../../library/profiling.sampling.rst:839
msgid "pstats format"
msgstr ""

#: ../../../library/profiling.sampling.rst:841
msgid ""
"The pstats format (:option:`--pstats`) produces a text table similar to what "
"deterministic profilers generate. This is the default output format::"
msgstr ""

#: ../../../library/profiling.sampling.rst:847
msgid "Tachyon pstats terminal output"
msgstr ""

#: ../../../library/profiling.sampling.rst:852
msgid ""
"The pstats format displays profiling results in a color-coded table showing "
"function hotspots, sample counts, and timing estimates."
msgstr ""

#: ../../../library/profiling.sampling.rst:855
msgid "Output appears on stdout by default::"
msgstr ""

#: ../../../library/profiling.sampling.rst:863
msgid "The columns show sampling counts and estimated times:"
msgstr ""

#: ../../../library/profiling.sampling.rst:865
msgid ""
"**nsamples**: Displayed as ``direct/cumulative`` (for example, ``10/50``). "
"Direct samples are when the function was at the top of the stack, actively "
"executing. Cumulative samples are when the function appeared anywhere on the "
"stack, including when it was waiting for functions it called. If a function "
"shows ``10/50``, it was directly executing in 10 samples and was on the call "
"stack in 50 samples total."
msgstr ""

#: ../../../library/profiling.sampling.rst:872
msgid ""
"**sample%** and **cumul%**: Percentages of total samples for direct and "
"cumulative counts respectively."
msgstr ""

#: ../../../library/profiling.sampling.rst:875
msgid ""
"**tottime** and **cumtime**: Estimated wall-clock time based on sample "
"counts and the profiling duration. Time units are selected automatically "
"based on the magnitude: seconds for large values, milliseconds for moderate "
"values, or microseconds for small values."
msgstr ""

#: ../../../library/profiling.sampling.rst:880
msgid ""
"The output includes a legend explaining each column and a summary of "
"interesting functions that highlights:"
msgstr ""

#: ../../../library/profiling.sampling.rst:883
msgid ""
"**Hot spots**: Functions with high direct/cumulative sample ratio (ratio "
"close to 1.0). These functions spend most of their time executing their own "
"code rather than waiting for callees. High ratios indicate where CPU time is "
"actually consumed."
msgstr ""

#: ../../../library/profiling.sampling.rst:888
msgid ""
"**Indirect calls**: Functions with large differences between cumulative and "
"direct samples. These are orchestration functions that delegate work to "
"other functions. They appear frequently on the stack but rarely at the top."
msgstr ""

#: ../../../library/profiling.sampling.rst:892
msgid ""
"**Call magnification**: Functions where cumulative samples far exceed direct "
"samples (high cumulative/direct multiplier). These are frequently-nested "
"functions that appear deep in many call chains."
msgstr ""

#: ../../../library/profiling.sampling.rst:896
msgid ""
"Use :option:`--no-summary` to suppress both the legend and summary sections."
msgstr ""

#: ../../../library/profiling.sampling.rst:898
msgid "To save pstats output to a binary file instead of stdout::"
msgstr ""

#: ../../../library/profiling.sampling.rst:902
msgid ""
"The pstats format supports several options for controlling the display. The :"
"option:`--sort` option determines the column used for ordering results::"
msgstr ""

#: ../../../library/profiling.sampling.rst:909
msgid "The :option:`--limit` option restricts output to the top N entries::"
msgstr ""

#: ../../../library/profiling.sampling.rst:913
msgid ""
"The :option:`--no-summary` option suppresses the header summary that "
"precedes the statistics table."
msgstr ""

#: ../../../library/profiling.sampling.rst:918
msgid "Collapsed stacks format"
msgstr ""

#: ../../../library/profiling.sampling.rst:920
msgid ""
"Collapsed stacks format (:option:`--collapsed`) produces one line per unique "
"call stack, with a count of how many times that stack was sampled::"
msgstr ""

#: ../../../library/profiling.sampling.rst:925
msgid "The output looks like:"
msgstr ""

#: ../../../library/profiling.sampling.rst:933
msgid ""
"Each line contains semicolon-separated function names representing the call "
"stack from bottom to top, followed by a space and the sample count. This "
"format is designed for compatibility with external flame graph tools, "
"particularly Brendan Gregg's ``flamegraph.pl`` script."
msgstr ""

#: ../../../library/profiling.sampling.rst:938
msgid "To generate a flame graph from collapsed stacks::"
msgstr ""

#: ../../../library/profiling.sampling.rst:943
msgid ""
"The resulting SVG can be viewed in any web browser and provides an "
"interactive visualization where you can click to zoom into specific call "
"paths."
msgstr ""

#: ../../../library/profiling.sampling.rst:948
msgid "Flame graph format"
msgstr ""

#: ../../../library/profiling.sampling.rst:950
msgid ""
"Flame graph format (:option:`--flamegraph`) produces a self-contained HTML "
"file with an interactive flame graph visualization::"
msgstr ""

#: ../../../library/profiling.sampling.rst:956
msgid "Tachyon interactive flame graph"
msgstr ""

#: ../../../library/profiling.sampling.rst:961
msgid ""
"The flame graph visualization shows call stacks as nested rectangles, with "
"width proportional to time spent. The sidebar displays runtime statistics, "
"GIL metrics, and hotspot functions."
msgstr ""

#: ../../../library/profiling.sampling.rst:967
msgid ""
"`Try the interactive example <../_static/tachyon-example-flamegraph.html>`__!"
msgstr ""

#: ../../../library/profiling.sampling.rst:969
msgid ""
"If no output file is specified, the profiler generates a filename based on "
"the process ID (for example, ``flamegraph.12345.html``)."
msgstr ""

#: ../../../library/profiling.sampling.rst:972
msgid ""
"The generated HTML file requires no external dependencies and can be opened "
"directly in a web browser. The visualization displays call stacks as nested "
"rectangles, with width proportional to time spent. Hovering over a rectangle "
"shows details about that function including source code context, and "
"clicking zooms into that portion of the call tree."
msgstr ""

#: ../../../library/profiling.sampling.rst:978
msgid "The flame graph interface includes:"
msgstr ""

#: ../../../library/profiling.sampling.rst:980
msgid ""
"A sidebar showing profile summary, thread statistics, sampling efficiency "
"metrics (see :ref:`sampling-efficiency`), and top hotspot functions"
msgstr ""

#: ../../../library/profiling.sampling.rst:982
msgid ""
"Search functionality supporting both function name matching and ``file."
"py:42`` line patterns"
msgstr ""

#: ../../../library/profiling.sampling.rst:984
msgid "Per-thread filtering via dropdown"
msgstr ""

#: ../../../library/profiling.sampling.rst:985
msgid "Dark/light theme toggle (preference saved across sessions)"
msgstr ""

#: ../../../library/profiling.sampling.rst:986
msgid "SVG export for saving the current view"
msgstr ""

#: ../../../library/profiling.sampling.rst:988
msgid "The thread statistics section shows runtime behavior metrics:"
msgstr ""

#: ../../../library/profiling.sampling.rst:990
msgid ""
"**GIL Held**: percentage of samples where a thread held the global "
"interpreter lock (actively running Python code)"
msgstr ""

#: ../../../library/profiling.sampling.rst:992
msgid "**GIL Released**: percentage of samples where no thread held the GIL"
msgstr ""

#: ../../../library/profiling.sampling.rst:993
msgid ""
"**Waiting GIL**: percentage of samples where a thread was waiting to acquire "
"the GIL"
msgstr ""

#: ../../../library/profiling.sampling.rst:995
msgid "**GC**: percentage of samples during garbage collection"
msgstr ""

#: ../../../library/profiling.sampling.rst:997
msgid ""
"These statistics help identify GIL contention and understand how time is "
"distributed between Python execution, native code, and waiting."
msgstr ""

#: ../../../library/profiling.sampling.rst:1000
msgid ""
"Flame graphs are particularly effective for identifying deep call stacks and "
"understanding the hierarchical structure of time consumption. Wide "
"rectangles at the top indicate functions that consume significant time "
"either directly or through their callees."
msgstr ""

#: ../../../library/profiling.sampling.rst:1007
msgid "Gecko format"
msgstr ""

#: ../../../library/profiling.sampling.rst:1009
msgid ""
"Gecko format (:option:`--gecko`) produces JSON output compatible with the "
"Firefox Profiler::"
msgstr ""

#: ../../../library/profiling.sampling.rst:1015
msgid ""
"The `Firefox Profiler <https://profiler.firefox.com>`__ is a sophisticated "
"web-based tool originally built for profiling Firefox itself. It provides "
"features beyond basic flame graphs, including a timeline view, call tree "
"exploration, and marker visualization. See the `Firefox Profiler "
"documentation <https://profiler.firefox.com/docs/#/>`__ for detailed usage "
"instructions."
msgstr ""

#: ../../../library/profiling.sampling.rst:1022
msgid ""
"To use the output, open the Firefox Profiler in your browser and load the "
"JSON file. The profiler runs entirely client-side, so your profiling data "
"never leaves your machine."
msgstr ""

#: ../../../library/profiling.sampling.rst:1026
msgid ""
"Gecko format automatically collects additional metadata about GIL state and "
"CPU activity, enabling analysis features specific to Python's threading "
"model. The profiler emits interval markers that appear as colored bands in "
"the Firefox Profiler timeline:"
msgstr ""

#: ../../../library/profiling.sampling.rst:1031
msgid ""
"**GIL markers**: show when threads hold or release the global interpreter "
"lock"
msgstr ""

#: ../../../library/profiling.sampling.rst:1032
msgid "**CPU markers**: show when threads are executing on CPU versus idle"
msgstr ""

#: ../../../library/profiling.sampling.rst:1033
msgid ""
"**Code type markers**: distinguish Python code from native (C extension) code"
msgstr ""

#: ../../../library/profiling.sampling.rst:1034
msgid "**GC markers**: indicate garbage collection activity"
msgstr ""

#: ../../../library/profiling.sampling.rst:1036
msgid ""
"For this reason, the :option:`--mode` option is not available with Gecko "
"format; all relevant data is captured automatically."
msgstr ""

#: ../../../library/profiling.sampling.rst:1039
msgid "Firefox Profiler Call Tree view"
msgstr ""

#: ../../../library/profiling.sampling.rst:1044
msgid ""
"The Call Tree view shows the complete call hierarchy with sample counts and "
"percentages. The sidebar displays detailed statistics for the selected "
"function including running time and sample distribution."
msgstr ""

#: ../../../library/profiling.sampling.rst:1048
msgid "Firefox Profiler Flame Graph view"
msgstr ""

#: ../../../library/profiling.sampling.rst:1053
msgid ""
"The Flame Graph visualization shows call stacks as nested rectangles. "
"Functions names are visible in the call hierarchy."
msgstr ""

#: ../../../library/profiling.sampling.rst:1056
msgid "Firefox Profiler Marker Chart with opcodes"
msgstr ""

#: ../../../library/profiling.sampling.rst:1061
msgid ""
"The Marker Chart displays interval markers including CPU state, GIL status, "
"and opcodes. With ``--opcodes`` enabled, bytecode instructions like "
"``BINARY_OP_ADD_FLOAT``, ``CALL_PY_EXACT_ARGS``, and ``CALL_LIST_APPEND`` "
"appear as markers showing execution over time."
msgstr ""

#: ../../../library/profiling.sampling.rst:1068
msgid "Heatmap format"
msgstr ""

#: ../../../library/profiling.sampling.rst:1070
msgid ""
"Heatmap format (:option:`--heatmap`) generates an interactive HTML "
"visualization showing sample counts at the source line level::"
msgstr ""

#: ../../../library/profiling.sampling.rst:1076
msgid "Tachyon heatmap visualization"
msgstr ""

#: ../../../library/profiling.sampling.rst:1081
msgid ""
"The heatmap overlays sample counts directly on your source code. Lines are "
"color-coded from cool (few samples) to hot (many samples). Navigation "
"buttons (â²â¼) let you jump between callers and callees."
msgstr ""

#: ../../../library/profiling.sampling.rst:1085
msgid ""
"Unlike other formats that produce a single file, heatmap output creates a "
"directory containing HTML files for each profiled source file. If no output "
"path is specified, the directory is named ``heatmap_PID``."
msgstr ""

#: ../../../library/profiling.sampling.rst:1089
msgid ""
"The heatmap visualization displays your source code with a color gradient "
"indicating how many samples were collected at each line. Hot lines (many "
"samples) appear in warm colors, while cold lines (few or no samples) appear "
"in cool colors. This view helps pinpoint exactly which lines of code are "
"responsible for time consumption."
msgstr ""

#: ../../../library/profiling.sampling.rst:1095
msgid "The heatmap interface provides several interactive features:"
msgstr ""

#: ../../../library/profiling.sampling.rst:1097
msgid ""
"**Coloring modes**: toggle between \"Self Time\" (direct execution) and "
"\"Total Time\" (cumulative, including time in called functions)"
msgstr ""

#: ../../../library/profiling.sampling.rst:1099
msgid "**Cold code filtering**: show all lines or only lines with samples"
msgstr ""

#: ../../../library/profiling.sampling.rst:1100
msgid ""
"**Call graph navigation**: each line shows navigation buttons (â² for "
"callers, â¼ for callees) that let you trace execution paths through your "
"code. When multiple functions called or were called from a line, a menu "
"appears showing all options with their sample counts."
msgstr ""

#: ../../../library/profiling.sampling.rst:1104
msgid ""
"**Scroll minimap**: a vertical overview showing the heat distribution across "
"the entire file"
msgstr ""

#: ../../../library/profiling.sampling.rst:1106
msgid ""
"**Hierarchical index**: files organized by type (stdlib, site-packages, "
"project) with aggregate sample counts per folder"
msgstr ""

#: ../../../library/profiling.sampling.rst:1108
msgid "**Dark/light theme**: toggle with preference saved across sessions"
msgstr ""

#: ../../../library/profiling.sampling.rst:1109
msgid "**Line linking**: click line numbers to create shareable URLs"
msgstr ""

#: ../../../library/profiling.sampling.rst:1111
msgid ""
"When opcode-level profiling is enabled with :option:`--opcodes`, each hot "
"line can be expanded to show which bytecode instructions consumed time:"
msgstr ""

#: ../../../library/profiling.sampling.rst:1114
msgid "Heatmap with expanded bytecode panel"
msgstr ""

#: ../../../library/profiling.sampling.rst:1119
msgid ""
"Expanding a hot line reveals the bytecode instructions executed, including "
"specialized variants. The panel shows sample counts per instruction and the "
"overall specialization percentage for the line."
msgstr ""

#: ../../../library/profiling.sampling.rst:1125
msgid ""
"`Try the interactive example <../_static/tachyon-example-heatmap.html>`__!"
msgstr ""

#: ../../../library/profiling.sampling.rst:1127
msgid ""
"Heatmaps are especially useful when you know which file contains a "
"performance issue but need to identify the specific lines. Many developers "
"prefer this format because it maps directly to their source code, making it "
"easy to read and navigate. For smaller scripts and focused analysis, "
"heatmaps provide an intuitive view that shows exactly where time is spent "
"without requiring interpretation of hierarchical visualizations."
msgstr ""

#: ../../../library/profiling.sampling.rst:1136
msgid "Binary format"
msgstr ""

#: ../../../library/profiling.sampling.rst:1138
msgid ""
"Binary format (:option:`--binary`) produces a compact binary file for "
"efficient storage of profiling data::"
msgstr ""

#: ../../../library/profiling.sampling.rst:1144
msgid "The :option:`--compression` option controls data compression:"
msgstr ""

#: ../../../library/profiling.sampling.rst:1146
msgid ""
"``auto`` (default): Use zstd compression if available, otherwise no "
"compression"
msgstr ""

#: ../../../library/profiling.sampling.rst:1148
msgid ""
"``zstd``: Force zstd compression (requires :mod:`compression.zstd` support)"
msgstr ""

#: ../../../library/profiling.sampling.rst:1149
msgid "``none``: Disable compression"
msgstr ""

#: ../../../library/profiling.sampling.rst:1155
msgid ""
"To analyze binary profiles, use the :ref:`replay-command` to convert them to "
"other formats like flame graphs or pstats output."
msgstr ""

#: ../../../library/profiling.sampling.rst:1160
msgid "Record and replay workflow"
msgstr ""

#: ../../../library/profiling.sampling.rst:1162
msgid ""
"The binary format combined with the replay command enables a record-and-"
"replay workflow that separates data capture from analysis. Rather than "
"generating visualizations during profiling, you capture raw data to a "
"compact binary file and convert it to different formats later."
msgstr ""

#: ../../../library/profiling.sampling.rst:1167
msgid "This approach has three main benefits:"
msgstr ""

#: ../../../library/profiling.sampling.rst:1169
msgid ""
"Sampling runs faster because the work of building data structures for "
"visualization is deferred until replay."
msgstr ""

#: ../../../library/profiling.sampling.rst:1171
msgid ""
"A single binary capture can be converted to multiple output formats without "
"re-profiling: pstats for a quick overview, flame graph for visual "
"exploration, heatmap for line-level detail."
msgstr ""

#: ../../../library/profiling.sampling.rst:1174
msgid ""
"Binary files are compact and easy to share with colleagues who can convert "
"them to their preferred format."
msgstr ""

#: ../../../library/profiling.sampling.rst:1177
msgid "A typical workflow::"
msgstr ""

#: ../../../library/profiling.sampling.rst:1189
msgid "Live mode"
msgstr ""

#: ../../../library/profiling.sampling.rst:1191
msgid ""
"Live mode (:option:`--live`) provides a terminal-based real-time view of "
"profiling data, similar to the ``top`` command for system processes::"
msgstr ""

#: ../../../library/profiling.sampling.rst:1197
msgid "Tachyon live mode showing all threads"
msgstr ""

#: ../../../library/profiling.sampling.rst:1202
msgid ""
"Live mode displays real-time profiling statistics, showing combined data "
"from multiple threads in a multi-threaded application."
msgstr ""

#: ../../../library/profiling.sampling.rst:1205
msgid ""
"The display updates continuously as new samples arrive, showing the current "
"hottest functions. This mode requires the :mod:`curses` module, which is "
"available on Unix-like systems but not on Windows. The terminal must be at "
"least 60 columns wide and 12 lines tall; larger terminals display more "
"columns."
msgstr ""

#: ../../../library/profiling.sampling.rst:1210
msgid ""
"The header displays the top 3 hottest functions, sampling efficiency "
"metrics, and thread status statistics (GIL held percentage, CPU usage, GC "
"time). The main table shows function statistics with the currently sorted "
"column indicated by an arrow (â¼)."
msgstr ""

#: ../../../library/profiling.sampling.rst:1215
msgid ""
"When :option:`--opcodes` is enabled, an additional opcode panel appears "
"below the main table, showing instruction-level statistics for the currently "
"selected function. This panel displays which bytecode instructions are "
"executing most frequently, including specialized variants and their base "
"opcodes."
msgstr ""

#: ../../../library/profiling.sampling.rst:1220
msgid "Tachyon live mode with opcode panel"
msgstr ""

#: ../../../library/profiling.sampling.rst:1225
msgid ""
"Live mode with ``--opcodes`` enabled shows an opcode panel with a bytecode "
"instruction breakdown for the selected function."
msgstr ""

#: ../../../library/profiling.sampling.rst:1230
msgid "Keyboard commands"
msgstr ""

#: ../../../library/profiling.sampling.rst:1232
msgid "Within live mode, keyboard commands control the display:"
msgstr ""

#: ../../../library/profiling.sampling.rst:1234
msgid ":kbd:`q`"
msgstr ""

#: ../../../library/profiling.sampling.rst:1235
msgid "Quit the profiler and return to the shell."
msgstr ""

#: ../../../library/profiling.sampling.rst:1237
msgid ":kbd:`s` / :kbd:`S`"
msgstr ""

#: ../../../library/profiling.sampling.rst:1238
msgid ""
"Cycle through sort orders forward/backward (sample count, percentage, total "
"time, cumulative percentage, cumulative time)."
msgstr ""

#: ../../../library/profiling.sampling.rst:1241
msgid ":kbd:`p`"
msgstr ""

#: ../../../library/profiling.sampling.rst:1242
msgid ""
"Pause or resume display updates. Sampling continues in the background while "
"the display is paused, so you can freeze the view to examine results without "
"stopping data collection."
msgstr ""

#: ../../../library/profiling.sampling.rst:1246
msgid ":kbd:`r`"
msgstr ""

#: ../../../library/profiling.sampling.rst:1247
msgid ""
"Reset all statistics and start fresh. This is disabled after profiling "
"finishes to prevent accidental data loss."
msgstr ""

#: ../../../library/profiling.sampling.rst:1250
msgid ":kbd:`/`"
msgstr ""

#: ../../../library/profiling.sampling.rst:1251
msgid ""
"Enter filter mode to search for functions by name. The filter uses case-"
"insensitive substring matching against the filename and function name. Type "
"a pattern and press Enter to apply, or Escape to cancel. Glob patterns and "
"regular expressions are not supported."
msgstr ""

#: ../../../library/profiling.sampling.rst:1256
msgid ":kbd:`c`"
msgstr ""

#: ../../../library/profiling.sampling.rst:1257
msgid "Clear the current filter and show all functions again."
msgstr ""

#: ../../../library/profiling.sampling.rst:1259
msgid ":kbd:`t`"
msgstr ""

#: ../../../library/profiling.sampling.rst:1260
msgid ""
"Toggle between viewing all threads combined or per-thread statistics. In per-"
"thread mode, a thread counter (for example, ``1/4``) appears showing your "
"position among the available threads."
msgstr ""

#: ../../../library/profiling.sampling.rst:1264
msgid ":kbd:`â` :kbd:`â` or :kbd:`â` :kbd:`â`"
msgstr ""

#: ../../../library/profiling.sampling.rst:1265
msgid ""
"In per-thread view, navigate between threads. Navigation wraps around from "
"the last thread to the first and vice versa."
msgstr ""

#: ../../../library/profiling.sampling.rst:1268
msgid ":kbd:`+` / :kbd:`-`"
msgstr ""

#: ../../../library/profiling.sampling.rst:1269
msgid ""
"Increase or decrease the display refresh rate. The range is 0.05 seconds (20 "
"Hz, very responsive) to 1.0 second (1 Hz, lower overhead). Faster refresh "
"rates use more CPU. The default is 0.1 seconds (10 Hz)."
msgstr ""

#: ../../../library/profiling.sampling.rst:1273
msgid ":kbd:`x`"
msgstr ""

#: ../../../library/profiling.sampling.rst:1274
msgid ""
"Toggle trend indicators that show whether functions are becoming hotter or "
"cooler over time. When enabled, increasing metrics appear in green and "
"decreasing metrics appear in red, comparing each update to the previous one."
msgstr ""

#: ../../../library/profiling.sampling.rst:1278
msgid ":kbd:`h` or :kbd:`?`"
msgstr ""

#: ../../../library/profiling.sampling.rst:1279
msgid "Show the help screen with all available commands."
msgstr ""

#: ../../../library/profiling.sampling.rst:1281
msgid ":kbd:`j` / :kbd:`k` (or :kbd:`Up` / :kbd:`Down`)"
msgstr ""

#: ../../../library/profiling.sampling.rst:1282
msgid ""
"Navigate through opcode entries in the opcode panel (when ``--opcodes`` is "
"enabled). These keys scroll through the instruction-level statistics for the "
"currently selected function."
msgstr ""

#: ../../../library/profiling.sampling.rst:1286
msgid ""
"When profiling finishes (duration expires or target process exits), the "
"display shows a \"PROFILING COMPLETE\" banner and freezes the final results. "
"You can still navigate, sort, and filter the results before pressing :kbd:"
"`q` to exit."
msgstr ""

#: ../../../library/profiling.sampling.rst:1290
msgid ""
"Live mode is incompatible with output format options (:option:`--"
"collapsed`, :option:`--flamegraph`, and so on) because it uses an "
"interactive terminal interface rather than producing file output."
msgstr ""

#: ../../../library/profiling.sampling.rst:1296
msgid "Async-aware profiling"
msgstr ""

#: ../../../library/profiling.sampling.rst:1298
msgid ""
"For programs using :mod:`asyncio`, the profiler offers async-aware mode (:"
"option:`--async-aware`) that reconstructs call stacks based on the task "
"structure rather than the raw Python frames::"
msgstr ""

#: ../../../library/profiling.sampling.rst:1304
msgid ""
"Standard profiling of async code can be confusing because the physical call "
"stack often shows event loop internals rather than the logical flow of your "
"coroutines. Async-aware mode addresses this by tracking which task is "
"running and presenting stacks that reflect the ``await`` chain."
msgstr ""

#: ../../../library/profiling.sampling.rst:1330
msgid ""
"Async-aware profiling requires the target process to have the :mod:`asyncio` "
"module loaded. If you profile a script before it imports asyncio, async-"
"aware mode will not be able to capture task information."
msgstr ""

#: ../../../library/profiling.sampling.rst:1336
msgid "Async modes"
msgstr ""

#: ../../../library/profiling.sampling.rst:1338
msgid ""
"The :option:`--async-mode` option controls which tasks appear in the "
"profile::"
msgstr ""

#: ../../../library/profiling.sampling.rst:1343
msgid ""
"With :option:`--async-mode`\\ ``=running`` (the default), only the task "
"currently executing on the CPU is profiled. This shows where your program is "
"actively spending time and is the typical choice for performance analysis."
msgstr ""

#: ../../../library/profiling.sampling.rst:1347
msgid ""
"With :option:`--async-mode`\\ ``=all``, tasks that are suspended (awaiting I/"
"O, locks, or other tasks) are also included. This mode is useful for "
"understanding what your program is waiting on, but produces larger profiles "
"since every suspended task appears in each sample."
msgstr ""

#: ../../../library/profiling.sampling.rst:1354
msgid "Task markers and stack reconstruction"
msgstr ""

#: ../../../library/profiling.sampling.rst:1356
msgid ""
"In async-aware profiles, you will see ``<task>`` frames that mark boundaries "
"between asyncio tasks. These are synthetic frames inserted by the profiler "
"to show the task structure. The task name appears as the function name in "
"these frames."
msgstr ""

#: ../../../library/profiling.sampling.rst:1361
msgid ""
"When a task awaits another task, the profiler reconstructs the logical call "
"chain by following the ``await`` relationships. Only \"leaf\" tasks (tasks "
"that no other task is currently awaiting) generate their own stack entries. "
"Tasks being awaited by other tasks appear as part of their awaiter's stack "
"instead."
msgstr ""

#: ../../../library/profiling.sampling.rst:1366
msgid ""
"If a task has multiple awaiters (a diamond pattern in the task graph), the "
"profiler deterministically selects one parent and annotates the task marker "
"with the number of parents, for example ``MyTask (2 parents)``. This "
"indicates that alternate execution paths exist but are not shown in this "
"particular stack."
msgstr ""

#: ../../../library/profiling.sampling.rst:1373
msgid "Option restrictions"
msgstr ""

#: ../../../library/profiling.sampling.rst:1375
msgid ""
"Async-aware mode uses a different stack reconstruction mechanism and is "
"incompatible with: :option:`--native`, :option:`--no-gc`, :option:`--all-"
"threads`, and :option:`--mode`\\ ``=cpu`` or :option:`--mode`\\ ``=gil``."
msgstr ""

#: ../../../library/profiling.sampling.rst:1381
msgid "Command-line interface"
msgstr ""

#: ../../../library/profiling.sampling.rst:1385
msgid "The complete command-line interface for reference."
msgstr ""

#: ../../../library/profiling.sampling.rst:1389
msgid "Global options"
msgstr ""

#: ../../../library/profiling.sampling.rst:1393
msgid "Run and profile a Python script or module."
msgstr ""

#: ../../../library/profiling.sampling.rst:1397
msgid "Attach to and profile a running process by PID."
msgstr ""

#: ../../../library/profiling.sampling.rst:1401
msgid "Convert a binary profile file to another output format."
msgstr ""

#: ../../../library/profiling.sampling.rst:1405
msgid "Sampling options"
msgstr ""

#: ../../../library/profiling.sampling.rst:1409
msgid ""
"Sampling rate (for example, ``10000``, ``10khz``, ``10k``). Default: "
"``1khz``."
msgstr ""

#: ../../../library/profiling.sampling.rst:1413
msgid "Profiling duration in seconds. Default: run to completion."
msgstr ""

#: ../../../library/profiling.sampling.rst:1417
msgid "Sample all threads, not just the main thread."
msgstr ""

#: ../../../library/profiling.sampling.rst:1421
msgid "Display sampling statistics during profiling."
msgstr ""

#: ../../../library/profiling.sampling.rst:1425
msgid "Include ``<native>`` frames for non-Python code."
msgstr ""

#: ../../../library/profiling.sampling.rst:1429
msgid "Exclude ``<GC>`` frames for garbage collection."
msgstr ""

#: ../../../library/profiling.sampling.rst:1433
msgid "Enable async-aware profiling for asyncio programs."
msgstr ""

#: ../../../library/profiling.sampling.rst:1437
msgid ""
"Gather bytecode opcode information for instruction-level profiling. Shows "
"which bytecode instructions are executing, including specializations. "
"Compatible with ``--live``, ``--flamegraph``, ``--heatmap``, and ``--gecko`` "
"formats only."
msgstr ""

#: ../../../library/profiling.sampling.rst:1444
msgid ""
"Also profile subprocesses. Each subprocess gets its own profiler instance "
"and output file. Incompatible with ``--live``."
msgstr ""

#: ../../../library/profiling.sampling.rst:1449
msgid ""
"Pause the target process during each sample. This ensures consistent stack "
"traces at the cost of slowing down the target. Use with longer intervals "
"(1000 Âµs or higher) to minimize impact. See :ref:`blocking-mode` for details."
msgstr ""

#: ../../../library/profiling.sampling.rst:1456
msgid "Mode options"
msgstr ""

#: ../../../library/profiling.sampling.rst:1460
msgid ""
"Sampling mode: ``wall`` (default), ``cpu``, ``gil``, or ``exception``. The "
"``cpu``, ``gil``, and ``exception`` modes are incompatible with ``--async-"
"aware``."
msgstr ""

#: ../../../library/profiling.sampling.rst:1466
msgid ""
"Async profiling mode: ``running`` (default) or ``all``. Requires ``--async-"
"aware``."
msgstr ""

#: ../../../library/profiling.sampling.rst:1471
msgid "Output options"
msgstr ""

#: ../../../library/profiling.sampling.rst:1475
msgid ""
"Generate pstats statistics. This is the default. When written to stdout, the "
"output is a text table; with :option:`-o`, it is a binary pstats file."
msgstr ""

#: ../../../library/profiling.sampling.rst:1481
msgid "Generate collapsed stack format for external flame graph tools."
msgstr ""

#: ../../../library/profiling.sampling.rst:1485
msgid "Generate self-contained HTML flame graph."
msgstr ""

#: ../../../library/profiling.sampling.rst:1489
msgid "Generate Gecko JSON format for Firefox Profiler."
msgstr ""

#: ../../../library/profiling.sampling.rst:1493
msgid "Generate HTML heatmap with line-level sample counts."
msgstr ""

#: ../../../library/profiling.sampling.rst:1497
msgid ""
"Generate high-performance binary format for later conversion with the "
"``replay`` command."
msgstr ""

#: ../../../library/profiling.sampling.rst:1502
msgid ""
"Compression for binary format: ``auto`` (use zstd if available, default), "
"``zstd``, or ``none``."
msgstr ""

#: ../../../library/profiling.sampling.rst:1507
msgid ""
"Output file or directory path. Default behavior varies by format: :option:`--"
"pstats` prints a text table to stdout, while ``-o`` writes a binary pstats "
"file. Other formats generate a file named ``<format>_<PID>.<ext>`` (for "
"example, ``flamegraph_12345.html``). :option:`--heatmap` creates a directory "
"named ``heatmap_<PID>``."
msgstr ""

#: ../../../library/profiling.sampling.rst:1515
msgid ""
"Automatically open HTML output (:option:`--flamegraph` and :option:`--"
"heatmap`) in your default web browser after generation. When profiling with :"
"option:`--subprocesses`, only the main process opens the browser; subprocess "
"outputs are never auto-opened."
msgstr ""

#: ../../../library/profiling.sampling.rst:1522
msgid "pstats display options"
msgstr ""

#: ../../../library/profiling.sampling.rst:1524
msgid "These options apply only to pstats format output."
msgstr ""

#: ../../../library/profiling.sampling.rst:1528
msgid ""
"Sort order: ``nsamples``, ``tottime``, ``cumtime``, ``sample-pct``, ``cumul-"
"pct``, ``nsamples-cumul``, or ``name``. Default: ``nsamples``."
msgstr ""

#: ../../../library/profiling.sampling.rst:1533
msgid "Maximum number of entries to display. Default: 15."
msgstr ""

#: ../../../library/profiling.sampling.rst:1537
msgid ""
"Omit the Legend and Summary of Interesting Functions sections from output."
msgstr ""

#: ../../../library/profiling.sampling.rst:1541
msgid "Run command options"
msgstr ""

#: ../../../library/profiling.sampling.rst:1545
msgid "Treat the target as a module name rather than a script path."
msgstr ""

#: ../../../library/profiling.sampling.rst:1549
msgid "Start interactive terminal interface instead of batch profiling."
msgstr ""

#: ../../../library/profiling.sampling.rst:1554
msgid ":mod:`profiling`"
msgstr ""

#: ../../../library/profiling.sampling.rst:1555
msgid "Overview of Python profiling tools and guidance on choosing a profiler."
msgstr ""

#: ../../../library/profiling.sampling.rst:1557
msgid ":mod:`profiling.tracing`"
msgstr ""

#: ../../../library/profiling.sampling.rst:1558
msgid "Deterministic tracing profiler for exact call counts and timing."
msgstr ""

#: ../../../library/profiling.sampling.rst:1560
msgid ":mod:`pstats`"
msgstr ""

#: ../../../library/profiling.sampling.rst:1561
msgid "Statistics analysis for profile data."
msgstr ""

#: ../../../library/profiling.sampling.rst:1563
msgid "`Firefox Profiler <https://profiler.firefox.com>`__"
msgstr ""

#: ../../../library/profiling.sampling.rst:1564
msgid ""
"Web-based profiler that accepts Gecko format output. See the `documentation "
"<https://profiler.firefox.com/docs/#/>`__ for usage details."
msgstr ""

#: ../../../library/profiling.sampling.rst:1567
msgid "`FlameGraph <https://github.com/brendangregg/FlameGraph>`__"
msgstr ""

#: ../../../library/profiling.sampling.rst:1568
msgid "Tools for generating flame graphs from collapsed stack format."
msgstr ""

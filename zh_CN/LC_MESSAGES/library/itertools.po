# SOME DESCRIPTIVE TITLE.
# Copyright (C) 1990-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 2.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-11 04:42+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../library/itertools.rst:3
msgid ":mod:`itertools` --- Functions creating iterators for efficient looping"
msgstr ""

#: ../../../library/itertools.rst:17
msgid ""
"This module implements a number of :term:`iterator` building blocks inspired "
"by constructs from APL, Haskell, and SML.  Each has been recast in a form "
"suitable for Python."
msgstr ""

#: ../../../library/itertools.rst:21
msgid ""
"The module standardizes a core set of fast, memory efficient tools that are "
"useful by themselves or in combination.  Together, they form an \"iterator "
"algebra\" making it possible to construct specialized tools succinctly and "
"efficiently in pure Python."
msgstr ""

#: ../../../library/itertools.rst:26
msgid ""
"For instance, SML provides a tabulation tool: ``tabulate(f)`` which produces "
"a sequence ``f(0), f(1), ...``.  The same effect can be achieved in Python "
"by combining :func:`imap` and :func:`count` to form ``imap(f, count())``."
msgstr ""

#: ../../../library/itertools.rst:30
msgid ""
"These tools and their built-in counterparts also work well with the high-"
"speed functions in the :mod:`operator` module.  For example, the "
"multiplication operator can be mapped across two vectors to form an "
"efficient dot-product: ``sum(imap(operator.mul, vector1, vector2))``."
msgstr ""

#: ../../../library/itertools.rst:36
msgid "**Infinite Iterators:**"
msgstr ""

#: ../../../library/itertools.rst:39 ../../../library/itertools.rst:49
#: ../../../library/itertools.rst:68
msgid "Iterator"
msgstr ""

#: ../../../library/itertools.rst:39 ../../../library/itertools.rst:49
#: ../../../library/itertools.rst:68
msgid "Arguments"
msgstr ""

#: ../../../library/itertools.rst:39 ../../../library/itertools.rst:49
#: ../../../library/itertools.rst:68
msgid "Results"
msgstr ""

#: ../../../library/itertools.rst:39 ../../../library/itertools.rst:49
msgid "Example"
msgstr ""

#: ../../../library/itertools.rst:41
msgid ":func:`count`"
msgstr ""

#: ../../../library/itertools.rst:41
msgid "start"
msgstr ""

#: ../../../library/itertools.rst:41
msgid "start, start+1, start+2, ..."
msgstr ""

#: ../../../library/itertools.rst:41
msgid "``count(10) --> 10 11 12 13 14 ...``"
msgstr ""

#: ../../../library/itertools.rst:42
msgid ":func:`cycle`"
msgstr ""

#: ../../../library/itertools.rst:42
msgid "p"
msgstr ""

#: ../../../library/itertools.rst:42
msgid "p0, p1, ... plast, p0, p1, ..."
msgstr ""

#: ../../../library/itertools.rst:42
msgid "``cycle('ABCD') --> A B C D A B C D ...``"
msgstr ""

#: ../../../library/itertools.rst:43
msgid ":func:`repeat`"
msgstr ""

#: ../../../library/itertools.rst:43
msgid "elem [,n]"
msgstr ""

#: ../../../library/itertools.rst:43
msgid "elem, elem, elem, ... endlessly or up to n times"
msgstr ""

#: ../../../library/itertools.rst:43
msgid "``repeat(10, 3) --> 10 10 10``"
msgstr ""

#: ../../../library/itertools.rst:46
msgid "**Iterators terminating on the shortest input sequence:**"
msgstr ""

#: ../../../library/itertools.rst:51
msgid ":func:`chain`"
msgstr ""

#: ../../../library/itertools.rst:51 ../../../library/itertools.rst:61
#: ../../../library/itertools.rst:62
msgid "p, q, ..."
msgstr ""

#: ../../../library/itertools.rst:51
msgid "p0, p1, ... plast, q0, q1, ..."
msgstr ""

#: ../../../library/itertools.rst:51
msgid "``chain('ABC', 'DEF') --> A B C D E F``"
msgstr ""

#: ../../../library/itertools.rst:52
msgid ":func:`dropwhile`"
msgstr ""

#: ../../../library/itertools.rst:52 ../../../library/itertools.rst:54
#: ../../../library/itertools.rst:55 ../../../library/itertools.rst:60
msgid "pred, seq"
msgstr ""

#: ../../../library/itertools.rst:52
msgid "seq[n], seq[n+1], starting when pred fails"
msgstr ""

#: ../../../library/itertools.rst:52
msgid "``dropwhile(lambda x: x<5, [1,4,6,4,1]) --> 6 4 1``"
msgstr ""

#: ../../../library/itertools.rst:53
msgid ":func:`groupby`"
msgstr ""

#: ../../../library/itertools.rst:53
msgid "iterable[, keyfunc]"
msgstr ""

#: ../../../library/itertools.rst:53
msgid "sub-iterators grouped by value of keyfunc(v)"
msgstr ""

#: ../../../library/itertools.rst:54
msgid ":func:`ifilter`"
msgstr ""

#: ../../../library/itertools.rst:54
msgid "elements of seq where pred(elem) is True"
msgstr ""

#: ../../../library/itertools.rst:54
msgid "``ifilter(lambda x: x%2, range(10)) --> 1 3 5 7 9``"
msgstr ""

#: ../../../library/itertools.rst:55
msgid ":func:`ifilterfalse`"
msgstr ""

#: ../../../library/itertools.rst:55
msgid "elements of seq where pred(elem) is False"
msgstr ""

#: ../../../library/itertools.rst:55
msgid "``ifilterfalse(lambda x: x%2, range(10)) --> 0 2 4 6 8``"
msgstr ""

#: ../../../library/itertools.rst:56
msgid ":func:`islice`"
msgstr ""

#: ../../../library/itertools.rst:56
msgid "seq, [start,] stop [, step]"
msgstr ""

#: ../../../library/itertools.rst:56
msgid "elements from seq[start:stop:step]"
msgstr ""

#: ../../../library/itertools.rst:56
msgid "``islice('ABCDEFG', 2, None) --> C D E F G``"
msgstr ""

#: ../../../library/itertools.rst:57
msgid ":func:`imap`"
msgstr ""

#: ../../../library/itertools.rst:57
msgid "func, p, q, ..."
msgstr ""

#: ../../../library/itertools.rst:57
msgid "func(p0, q0), func(p1, q1), ..."
msgstr ""

#: ../../../library/itertools.rst:57
msgid "``imap(pow, (2,3,10), (5,2,3)) --> 32 9 1000``"
msgstr ""

#: ../../../library/itertools.rst:58
msgid ":func:`starmap`"
msgstr ""

#: ../../../library/itertools.rst:58
msgid "func, seq"
msgstr ""

#: ../../../library/itertools.rst:58
msgid "func(\\*seq[0]), func(\\*seq[1]), ..."
msgstr ""

#: ../../../library/itertools.rst:58
msgid "``starmap(pow, [(2,5), (3,2), (10,3)]) --> 32 9 1000``"
msgstr ""

#: ../../../library/itertools.rst:59
msgid ":func:`tee`"
msgstr ""

#: ../../../library/itertools.rst:59
msgid "it, n"
msgstr ""

#: ../../../library/itertools.rst:59
msgid "it1, it2 , ... itn  splits one iterator into n"
msgstr ""

#: ../../../library/itertools.rst:60
msgid ":func:`takewhile`"
msgstr ""

#: ../../../library/itertools.rst:60
msgid "seq[0], seq[1], until pred fails"
msgstr ""

#: ../../../library/itertools.rst:60
msgid "``takewhile(lambda x: x<5, [1,4,6,4,1]) --> 1 4``"
msgstr ""

#: ../../../library/itertools.rst:61
msgid ":func:`izip`"
msgstr ""

#: ../../../library/itertools.rst:61 ../../../library/itertools.rst:62
msgid "(p[0], q[0]), (p[1], q[1]), ..."
msgstr ""

#: ../../../library/itertools.rst:61
msgid "``izip('ABCD', 'xy') --> Ax By``"
msgstr ""

#: ../../../library/itertools.rst:62
msgid ":func:`izip_longest`"
msgstr ""

#: ../../../library/itertools.rst:62
msgid "``izip_longest('ABCD', 'xy', fillvalue='-') --> Ax By C- D-``"
msgstr ""

#: ../../../library/itertools.rst:65
msgid "**Combinatoric generators:**"
msgstr ""

#: ../../../library/itertools.rst:70
msgid ":func:`product`"
msgstr ""

#: ../../../library/itertools.rst:70
msgid "p, q, ... [repeat=1]"
msgstr ""

#: ../../../library/itertools.rst:70
msgid "cartesian product, equivalent to a nested for-loop"
msgstr ""

#: ../../../library/itertools.rst:71
msgid ":func:`permutations`"
msgstr ""

#: ../../../library/itertools.rst:71
msgid "p[, r]"
msgstr ""

#: ../../../library/itertools.rst:71
msgid "r-length tuples, all possible orderings, no repeated elements"
msgstr ""

#: ../../../library/itertools.rst:72
msgid ":func:`combinations`"
msgstr ""

#: ../../../library/itertools.rst:72
msgid "p, r"
msgstr ""

#: ../../../library/itertools.rst:72
msgid "r-length tuples, in sorted order, no repeated elements"
msgstr ""

#: ../../../library/itertools.rst:74
msgid "``product('ABCD', repeat=2)``"
msgstr ""

#: ../../../library/itertools.rst:74
msgid "``AA AB AC AD BA BB BC BD CA CB CC CD DA DB DC DD``"
msgstr ""

#: ../../../library/itertools.rst:75
msgid "``permutations('ABCD', 2)``"
msgstr ""

#: ../../../library/itertools.rst:75
msgid "``AB AC AD BA BC BD CA CB CD DA DB DC``"
msgstr ""

#: ../../../library/itertools.rst:76
msgid "``combinations('ABCD', 2)``"
msgstr ""

#: ../../../library/itertools.rst:76
msgid "``AB AC AD BC BD CD``"
msgstr ""

#: ../../../library/itertools.rst:83
msgid "Itertool functions"
msgstr ""

#: ../../../library/itertools.rst:85
msgid ""
"The following module functions all construct and return iterators. Some "
"provide streams of infinite length, so they should only be accessed by "
"functions or loops that truncate the stream."
msgstr ""

#: ../../../library/itertools.rst:92
msgid ""
"Make an iterator that returns elements from the first iterable until it is "
"exhausted, then proceeds to the next iterable, until all of the iterables "
"are exhausted.  Used for treating consecutive sequences as a single "
"sequence. Equivalent to::"
msgstr ""

#: ../../../library/itertools.rst:106
msgid ""
"Alternate constructor for :func:`chain`.  Gets chained inputs from a single "
"iterable argument that is evaluated lazily.  Equivalent to::"
msgstr ""

#: ../../../library/itertools.rst:121
msgid "Return *r* length subsequences of elements from the input *iterable*."
msgstr ""

#: ../../../library/itertools.rst:123
msgid ""
"Combinations are emitted in lexicographic sort order.  So, if the input "
"*iterable* is sorted, the combination tuples will be produced in sorted "
"order."
msgstr ""

#: ../../../library/itertools.rst:127
msgid ""
"Elements are treated as unique based on their position, not on their value.  "
"So if the input elements are unique, there will be no repeat values in each "
"combination."
msgstr ""

#: ../../../library/itertools.rst:131 ../../../library/itertools.rst:425
msgid "Equivalent to::"
msgstr ""

#: ../../../library/itertools.rst:153
msgid ""
"The code for :func:`combinations` can be also expressed as a subsequence of :"
"func:`permutations` after filtering entries where the elements are not in "
"sorted order (according to their position in the input pool)::"
msgstr ""

#: ../../../library/itertools.rst:164
msgid ""
"The number of items returned is ``n! / r! / (n-r)!`` when ``0 <= r <= n`` or "
"zero when ``r > n``."
msgstr ""

#: ../../../library/itertools.rst:171
msgid ""
"Make an iterator that returns consecutive integers starting with *n*. If not "
"specified *n* defaults to zero.   Often used as an argument to :func:`imap` "
"to generate consecutive data points. Also, used with :func:`izip` to add "
"sequence numbers.  Equivalent to::"
msgstr ""

#: ../../../library/itertools.rst:185
msgid ""
"Make an iterator returning elements from the iterable and saving a copy of "
"each. When the iterable is exhausted, return elements from the saved copy.  "
"Repeats indefinitely.  Equivalent to::"
msgstr ""

#: ../../../library/itertools.rst:199
msgid ""
"Note, this member of the toolkit may require significant auxiliary storage "
"(depending on the length of the iterable)."
msgstr ""

#: ../../../library/itertools.rst:205
msgid ""
"Make an iterator that drops elements from the iterable as long as the "
"predicate is true; afterwards, returns every element.  Note, the iterator "
"does not produce *any* output until the predicate first becomes false, so it "
"may have a lengthy start-up time.  Equivalent to::"
msgstr ""

#: ../../../library/itertools.rst:223
msgid ""
"Make an iterator that returns consecutive keys and groups from the "
"*iterable*. The *key* is a function computing a key value for each element.  "
"If not specified or is ``None``, *key* defaults to an identity function and "
"returns the element unchanged.  Generally, the iterable needs to already be "
"sorted on the same key function."
msgstr ""

#: ../../../library/itertools.rst:229
msgid ""
"The operation of :func:`groupby` is similar to the ``uniq`` filter in Unix.  "
"It generates a break or new group every time the value of the key function "
"changes (which is why it is usually necessary to have sorted the data using "
"the same key function).  That behavior differs from SQL's GROUP BY which "
"aggregates common elements regardless of their input order."
msgstr ""

#: ../../../library/itertools.rst:235
msgid ""
"The returned group is itself an iterator that shares the underlying iterable "
"with :func:`groupby`.  Because the source is shared, when the :func:"
"`groupby` object is advanced, the previous group is no longer visible.  So, "
"if that data is needed later, it should be stored as a list::"
msgstr ""

#: ../../../library/itertools.rst:247
msgid ":func:`groupby` is equivalent to::"
msgstr ""

#: ../../../library/itertools.rst:277
msgid ""
"Make an iterator that filters elements from iterable returning only those "
"for which the predicate is ``True``. If *predicate* is ``None``, return the "
"items that are true. Equivalent to::"
msgstr ""

#: ../../../library/itertools.rst:292
msgid ""
"Make an iterator that filters elements from iterable returning only those "
"for which the predicate is ``False``. If *predicate* is ``None``, return the "
"items that are false. Equivalent to::"
msgstr ""

#: ../../../library/itertools.rst:307
msgid ""
"Make an iterator that computes the function using arguments from each of the "
"iterables.  If *function* is set to ``None``, then :func:`imap` returns the "
"arguments as a tuple.  Like :func:`map` but stops when the shortest iterable "
"is exhausted instead of filling in ``None`` for shorter iterables.  The "
"reason for the difference is that infinite iterator arguments are typically "
"an error for :func:`map` (because the output is fully evaluated) but "
"represent a common and useful way of supplying arguments to :func:`imap`. "
"Equivalent to::"
msgstr ""

#: ../../../library/itertools.rst:328
msgid ""
"Make an iterator that returns selected elements from the iterable. If "
"*start* is non-zero, then elements from the iterable are skipped until start "
"is reached. Afterward, elements are returned consecutively unless *step* is "
"set higher than one which results in items being skipped.  If *stop* is "
"``None``, then iteration continues until the iterator is exhausted, if at "
"all; otherwise, it stops at the specified position.  Unlike regular "
"slicing, :func:`islice` does not support negative values for *start*, "
"*stop*, or *step*.  Can be used to extract related fields from data where "
"the internal structure has been flattened (for example, a multi-line report "
"may list a name field on every third line).  Equivalent to::"
msgstr ""

#: ../../../library/itertools.rst:351
msgid ""
"If *start* is ``None``, then iteration starts at zero. If *step* is "
"``None``, then the step defaults to one."
msgstr ""

#: ../../../library/itertools.rst:354
msgid "accept ``None`` values for default *start* and *step*."
msgstr ""

#: ../../../library/itertools.rst:360
msgid ""
"Make an iterator that aggregates elements from each of the iterables. Like :"
"func:`zip` except that it returns an iterator instead of a list.  Used for "
"lock-step iteration over several iterables at a time.  Equivalent to::"
msgstr ""

#: ../../../library/itertools.rst:370
msgid ""
"When no iterables are specified, returns a zero length iterator instead of "
"raising a :exc:`TypeError` exception."
msgstr ""

#: ../../../library/itertools.rst:374
msgid ""
"The left-to-right evaluation order of the iterables is guaranteed. This "
"makes possible an idiom for clustering a data series into n-length groups "
"using ``izip(*[iter(s)]*n)``."
msgstr ""

#: ../../../library/itertools.rst:378
msgid ""
":func:`izip` should only be used with unequal length inputs when you don't "
"care about trailing, unmatched values from the longer iterables.  If those "
"values are important, use :func:`izip_longest` instead."
msgstr ""

#: ../../../library/itertools.rst:385
msgid ""
"Make an iterator that aggregates elements from each of the iterables. If the "
"iterables are of uneven length, missing values are filled-in with "
"*fillvalue*. Iteration continues until the longest iterable is exhausted.  "
"Equivalent to::"
msgstr ""

#: ../../../library/itertools.rst:402
msgid ""
"If one of the iterables is potentially infinite, then the :func:"
"`izip_longest` function should be wrapped with something that limits the "
"number of calls (for example :func:`islice` or :func:`takewhile`).  If not "
"specified, *fillvalue* defaults to ``None``."
msgstr ""

#: ../../../library/itertools.rst:411
msgid ""
"Return successive *r* length permutations of elements in the *iterable*."
msgstr ""

#: ../../../library/itertools.rst:413
msgid ""
"If *r* is not specified or is ``None``, then *r* defaults to the length of "
"the *iterable* and all possible full-length permutations are generated."
msgstr ""

#: ../../../library/itertools.rst:417
msgid ""
"Permutations are emitted in lexicographic sort order.  So, if the input "
"*iterable* is sorted, the permutation tuples will be produced in sorted "
"order."
msgstr ""

#: ../../../library/itertools.rst:421
msgid ""
"Elements are treated as unique based on their position, not on their value.  "
"So if the input elements are unique, there will be no repeat values in each "
"permutation."
msgstr ""

#: ../../../library/itertools.rst:452
msgid ""
"The code for :func:`permutations` can be also expressed as a subsequence of :"
"func:`product`, filtered to exclude entries with repeated elements (those "
"from the same position in the input pool)::"
msgstr ""

#: ../../../library/itertools.rst:464
msgid ""
"The number of items returned is ``n! / (n-r)!`` when ``0 <= r <= n`` or zero "
"when ``r > n``."
msgstr ""

#: ../../../library/itertools.rst:471
msgid "Cartesian product of input iterables."
msgstr ""

#: ../../../library/itertools.rst:473
msgid ""
"Equivalent to nested for-loops in a generator expression. For example, "
"``product(A, B)`` returns the same as ``((x,y) for x in A for y in B)``."
msgstr ""

#: ../../../library/itertools.rst:476
msgid ""
"The nested loops cycle like an odometer with the rightmost element advancing "
"on every iteration.  This pattern creates a lexicographic ordering so that "
"if the input's iterables are sorted, the product tuples are emitted in "
"sorted order."
msgstr ""

#: ../../../library/itertools.rst:481
msgid ""
"To compute the product of an iterable with itself, specify the number of "
"repetitions with the optional *repeat* keyword argument.  For example, "
"``product(A, repeat=4)`` means the same as ``product(A, A, A, A)``."
msgstr ""

#: ../../../library/itertools.rst:485
msgid ""
"This function is equivalent to the following code, except that the actual "
"implementation does not build up intermediate results in memory::"
msgstr ""

#: ../../../library/itertools.rst:502
msgid ""
"Make an iterator that returns *object* over and over again. Runs "
"indefinitely unless the *times* argument is specified. Used as argument to :"
"func:`imap` for invariant function parameters.  Also used with :func:`izip` "
"to create constant fields in a tuple record.  Equivalent to::"
msgstr ""

#: ../../../library/itertools.rst:519
msgid ""
"Make an iterator that computes the function using arguments obtained from "
"the iterable.  Used instead of :func:`imap` when argument parameters are "
"already grouped in tuples from a single iterable (the data has been \"pre-"
"zipped\").  The difference between :func:`imap` and :func:`starmap` "
"parallels the distinction between ``function(a,b)`` and ``function(*c)``. "
"Equivalent to::"
msgstr ""

#: ../../../library/itertools.rst:530
msgid ""
"Previously, :func:`starmap` required the function arguments to be tuples. "
"Now, any iterable is allowed."
msgstr ""

#: ../../../library/itertools.rst:536
msgid ""
"Make an iterator that returns elements from the iterable as long as the "
"predicate is true.  Equivalent to::"
msgstr ""

#: ../../../library/itertools.rst:550
msgid ""
"Return *n* independent iterators from a single iterable.  Equivalent to::"
msgstr ""

#: ../../../library/itertools.rst:564
msgid ""
"Once :func:`tee` has made a split, the original *iterable* should not be "
"used anywhere else; otherwise, the *iterable* could get advanced without the "
"tee objects being informed."
msgstr ""

#: ../../../library/itertools.rst:568
msgid ""
"This itertool may require significant auxiliary storage (depending on how "
"much temporary data needs to be stored). In general, if one iterator uses "
"most or all of the data before another iterator starts, it is faster to use :"
"func:`list` instead of :func:`tee`."
msgstr ""

#: ../../../library/itertools.rst:579
msgid "Examples"
msgstr ""

#: ../../../library/itertools.rst:581
msgid ""
"The following examples show common uses for each tool and demonstrate ways "
"they can be combined."
msgstr ""

#: ../../../library/itertools.rst:616
msgid "Recipes"
msgstr ""

#: ../../../library/itertools.rst:618
msgid ""
"This section shows recipes for creating an extended toolset using the "
"existing itertools as building blocks."
msgstr ""

#: ../../../library/itertools.rst:621
msgid ""
"The extended tools offer the same high performance as the underlying "
"toolset. The superior memory performance is kept by processing elements one "
"at a time rather than bringing the whole iterable into memory all at once. "
"Code volume is kept small by linking the tools together in a functional "
"style which helps eliminate temporary variables.  High speed is retained by "
"preferring \"vectorized\" building blocks over the use of for-loops and :"
"term:`generator`\\s which incur interpreter overhead."
msgstr ""

#: ../../../library/itertools.rst:807
msgid ""
"Note, many of the above recipes can be optimized by replacing global lookups "
"with local variables defined as default values.  For example, the "
"*dotproduct* recipe can be written as::"
msgstr ""

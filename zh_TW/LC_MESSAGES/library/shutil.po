# SOME DESCRIPTIVE TITLE.
# Copyright (C) 1990-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-11 04:42+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../library/shutil.rst:2
msgid ":mod:`shutil` --- High-level file operations"
msgstr ""

#: ../../../library/shutil.rst:13
msgid "**Source code:** :source:`Lib/shutil.py`"
msgstr ""

#: ../../../library/shutil.rst:17
msgid ""
"The :mod:`shutil` module offers a number of high-level operations on files "
"and collections of files.  In particular, functions are provided  which "
"support file copying and removal. For operations on individual files, see "
"also the :mod:`os` module."
msgstr ""

#: ../../../library/shutil.rst:24
msgid ""
"Even the higher-level file copying functions (:func:`shutil.copy`, :func:"
"`shutil.copy2`) cannot copy all file metadata."
msgstr ""

#: ../../../library/shutil.rst:27
msgid ""
"On POSIX platforms, this means that file owner and group are lost as well as "
"ACLs.  On Mac OS, the resource fork and other metadata are not used. This "
"means that resources will be lost and file type and creator codes will not "
"be correct. On Windows, file owners, ACLs and alternate data streams are not "
"copied."
msgstr ""

#: ../../../library/shutil.rst:37
msgid "Directory and files operations"
msgstr ""

#: ../../../library/shutil.rst:41
msgid ""
"Copy the contents of the file-like object *fsrc* to the file-like object "
"*fdst*. The integer *length*, if given, is the buffer size. In particular, a "
"negative *length* value means to copy the data without looping over the "
"source data in chunks; by default the data is read in chunks to avoid "
"uncontrolled memory consumption. Note that if the current file position of "
"the *fsrc* object is not 0, only the contents from the current file position "
"to the end of the file will be copied."
msgstr ""

#: ../../../library/shutil.rst:52
msgid ""
"Copy the contents (no metadata) of the file named *src* to a file named "
"*dst*.  *dst* must be the complete target file name; look at :func:`shutil."
"copy` for a copy that accepts a target directory path.  If *src* and *dst* "
"are the same files, :exc:`Error` is raised. The destination location must be "
"writable; otherwise,  an :exc:`IOError` exception will be raised. If *dst* "
"already exists, it will be replaced.   Special files such as character or "
"block devices and pipes cannot be copied with this function.  *src* and "
"*dst* are path names given as strings."
msgstr ""

#: ../../../library/shutil.rst:64
msgid ""
"Copy the permission bits from *src* to *dst*.  The file contents, owner, and "
"group are unaffected.  *src* and *dst* are path names given as strings."
msgstr ""

#: ../../../library/shutil.rst:70
msgid ""
"Copy the permission bits, last access time, last modification time, and "
"flags from *src* to *dst*.  The file contents, owner, and group are "
"unaffected.  *src* and *dst* are path names given as strings."
msgstr ""

#: ../../../library/shutil.rst:77
msgid ""
"Copy the file *src* to the file or directory *dst*.  If *dst* is a "
"directory, a file with the same basename as *src*  is created (or "
"overwritten) in the directory specified.  Permission bits are copied.  *src* "
"and *dst* are path names given as strings."
msgstr ""

#: ../../../library/shutil.rst:85
msgid ""
"Similar to :func:`shutil.copy`, but metadata is copied as well -- in fact, "
"this is just :func:`shutil.copy` followed by :func:`copystat`.  This is "
"similar to the Unix command :program:`cp -p`."
msgstr ""

#: ../../../library/shutil.rst:92
msgid ""
"This factory function creates a function that can be used as a callable for :"
"func:`copytree`\\'s *ignore* argument, ignoring files and directories that "
"match one of the glob-style *patterns* provided.  See the example below."
msgstr ""

#: ../../../library/shutil.rst:99
msgid ""
"Recursively copy an entire directory tree rooted at *src*.  The destination "
"directory, named by *dst*, must not already exist; it will be created as "
"well as missing parent directories.  Permissions and times of directories "
"are copied with :func:`copystat`, individual files are copied using :func:"
"`shutil.copy2`."
msgstr ""

#: ../../../library/shutil.rst:105
msgid ""
"If *symlinks* is true, symbolic links in the source tree are represented as "
"symbolic links in the new tree, but the metadata of the original links is "
"NOT copied; if false or omitted, the contents and metadata of the linked "
"files are copied to the new tree."
msgstr ""

#: ../../../library/shutil.rst:110
msgid ""
"When *symlinks* is false, if the file pointed by the symlink doesn't exist, "
"a exception will be added in the list of errors raised in a :exc:`Error` "
"exception at the end of the copy process. You can set the optional "
"*ignore_dangling_symlinks* flag to true if you want to silence this "
"exception. Notice that this option has no effect on platforms that don't "
"support :func:`os.symlink`."
msgstr ""

#: ../../../library/shutil.rst:117
msgid ""
"If *ignore* is given, it must be a callable that will receive as its "
"arguments the directory being visited by :func:`copytree`, and a list of its "
"contents, as returned by :func:`os.listdir`.  Since :func:`copytree` is "
"called recursively, the *ignore* callable will be called once for each "
"directory that is copied.  The callable must return a sequence of directory "
"and file names relative to the current directory (i.e. a subset of the items "
"in its second argument); these names will then be ignored in the copy "
"process.  :func:`ignore_patterns` can be used to create such a callable that "
"ignores names based on glob-style patterns."
msgstr ""

#: ../../../library/shutil.rst:127
msgid ""
"If exception(s) occur, an :exc:`Error` is raised with a list of reasons."
msgstr ""

#: ../../../library/shutil.rst:129
msgid ""
"If *copy_function* is given, it must be a callable that will be used to copy "
"each file. It will be called with the source path and the destination path "
"as arguments. By default, :func:`shutil.copy2` is used, but any function "
"that supports the same signature (like :func:`copy`) can be used."
msgstr ""

#: ../../../library/shutil.rst:134
msgid ""
"Added the *copy_function* argument to be able to provide a custom copy "
"function."
msgstr ""

#: ../../../library/shutil.rst:138
msgid ""
"Added the *ignore_dangling_symlinks* argument to silent dangling symlinks "
"errors when *symlinks* is false."
msgstr ""

#: ../../../library/shutil.rst:147
msgid ""
"Delete an entire directory tree; *path* must point to a directory (but not a "
"symbolic link to a directory).  If *ignore_errors* is true, errors resulting "
"from failed removals will be ignored; if false or omitted, such errors are "
"handled by calling a handler specified by *onerror* or, if that is omitted, "
"they raise an exception."
msgstr ""

#: ../../../library/shutil.rst:153
msgid ""
"If *onerror* is provided, it must be a callable that accepts three "
"parameters: *function*, *path*, and *excinfo*. The first parameter, "
"*function*, is the function which raised the exception; it will be :func:`os."
"path.islink`, :func:`os.listdir`, :func:`os.remove` or :func:`os.rmdir`.  "
"The second parameter, *path*, will be the path name passed to *function*.  "
"The third parameter, *excinfo*, will be the exception information return by :"
"func:`sys.exc_info`.  Exceptions raised by *onerror* will not be caught."
msgstr ""

#: ../../../library/shutil.rst:165
msgid ""
"Recursively move a file or directory (*src*) to another location (*dst*)."
msgstr ""

#: ../../../library/shutil.rst:167
msgid ""
"If the destination is a directory or a symlink to a directory, then *src* is "
"moved inside that directory."
msgstr ""

#: ../../../library/shutil.rst:170
msgid ""
"The destination directory must not already exist.  If the destination "
"already exists but is not a directory, it may be overwritten depending on :"
"func:`os.rename` semantics."
msgstr ""

#: ../../../library/shutil.rst:174
msgid ""
"If the destination is on the current filesystem, then :func:`os.rename` is "
"used.  Otherwise, *src* is copied (using :func:`shutil.copy2`) to *dst* and "
"then removed."
msgstr ""

#: ../../../library/shutil.rst:181
msgid ""
"This exception collects exceptions that are raised during a multi-file "
"operation. For :func:`copytree`, the exception argument is a list of 3-"
"tuples (*srcname*, *dstname*, *exception*)."
msgstr ""

#: ../../../library/shutil.rst:189
msgid "copytree example"
msgstr ""

#: ../../../library/shutil.rst:191
msgid ""
"This example is the implementation of the :func:`copytree` function, "
"described above, with the docstring omitted.  It demonstrates many of the "
"other functions provided by this module. ::"
msgstr ""

#: ../../../library/shutil.rst:227
msgid "Another example that uses the :func:`ignore_patterns` helper::"
msgstr ""

#: ../../../library/shutil.rst:233
msgid ""
"This will copy everything except ``.pyc`` files and files or directories "
"whose name starts with ``tmp``."
msgstr ""

#: ../../../library/shutil.rst:236
msgid "Another example that uses the *ignore* argument to add a logging call::"
msgstr ""

#: ../../../library/shutil.rst:251
msgid "Archiving operations"
msgstr ""

#: ../../../library/shutil.rst:253
msgid ""
"High-level utilities to create and read compressed and archived files are "
"also provided.  They rely on the :mod:`zipfile` and :mod:`tarfile` modules."
msgstr ""

#: ../../../library/shutil.rst:258
msgid "Create an archive file (such as zip or tar) and return its name."
msgstr ""

#: ../../../library/shutil.rst:260
msgid ""
"*base_name* is the name of the file to create, including the path, minus any "
"format-specific extension. *format* is the archive format: one of \"zip\", "
"\"tar\", \"bztar\" (if the :mod:`bz2` module is available) or \"gztar\"."
msgstr ""

#: ../../../library/shutil.rst:264
msgid ""
"*root_dir* is a directory that will be the root directory of the archive; "
"for example, we typically chdir into *root_dir* before creating the archive."
msgstr ""

#: ../../../library/shutil.rst:268
msgid ""
"*base_dir* is the directory where we start archiving from; i.e. *base_dir* "
"will be the common prefix of all files and directories in the archive."
msgstr ""

#: ../../../library/shutil.rst:272
msgid "*root_dir* and *base_dir* both default to the current directory."
msgstr ""

#: ../../../library/shutil.rst:274
msgid ""
"*owner* and *group* are used when creating a tar archive. By default, uses "
"the current owner and group."
msgstr ""

#: ../../../library/shutil.rst:277
msgid ""
"*logger* must be an object compatible with :pep:`282`, usually an instance "
"of :class:`logging.Logger`."
msgstr ""

#: ../../../library/shutil.rst:285
msgid ""
"Return a list of supported formats for archiving. Each element of the "
"returned sequence is a tuple ``(name, description)``"
msgstr ""

#: ../../../library/shutil.rst:288 ../../../library/shutil.rst:370
msgid "By default :mod:`shutil` provides these formats:"
msgstr ""

#: ../../../library/shutil.rst:290 ../../../library/shutil.rst:372
msgid "*gztar*: gzip'ed tar-file"
msgstr ""

#: ../../../library/shutil.rst:291 ../../../library/shutil.rst:373
msgid "*bztar*: bzip2'ed tar-file (if the :mod:`bz2` module is available.)"
msgstr ""

#: ../../../library/shutil.rst:292 ../../../library/shutil.rst:374
msgid "*tar*: uncompressed tar file"
msgstr ""

#: ../../../library/shutil.rst:293 ../../../library/shutil.rst:375
msgid "*zip*: ZIP file"
msgstr ""

#: ../../../library/shutil.rst:295
msgid ""
"You can register new formats or provide your own archiver for any existing "
"formats, by using :func:`register_archive_format`."
msgstr ""

#: ../../../library/shutil.rst:303
msgid ""
"Register an archiver for the format *name*. *function* is a callable that "
"will be used to invoke the archiver."
msgstr ""

#: ../../../library/shutil.rst:306
msgid ""
"If given, *extra_args* is a sequence of ``(name, value)`` pairs that will be "
"used as extra keywords arguments when the archiver callable is used."
msgstr ""

#: ../../../library/shutil.rst:309
msgid ""
"*description* is used by :func:`get_archive_formats` which returns the list "
"of archivers. Defaults to an empty list."
msgstr ""

#: ../../../library/shutil.rst:317
msgid "Remove the archive format *name* from the list of supported formats."
msgstr ""

#: ../../../library/shutil.rst:324
msgid "Unpack an archive. *filename* is the full path of the archive."
msgstr ""

#: ../../../library/shutil.rst:326
msgid ""
"*extract_dir* is the name of the target directory where the archive is "
"unpacked. If not provided, the current working directory is used."
msgstr ""

#: ../../../library/shutil.rst:329
msgid ""
"*format* is the archive format: one of \"zip\", \"tar\", or \"gztar\". Or "
"any other format registered with :func:`register_unpack_format`. If not "
"provided, :func:`unpack_archive` will use the archive file name extension "
"and see if an unpacker was registered for that extension. In case none is "
"found, a :exc:`ValueError` is raised."
msgstr ""

#: ../../../library/shutil.rst:340
msgid ""
"Registers an unpack format. *name* is the name of the format and "
"*extensions* is a list of extensions corresponding to the format, like ``."
"zip`` for Zip files."
msgstr ""

#: ../../../library/shutil.rst:344
msgid ""
"*function* is the callable that will be used to unpack archives. The "
"callable will receive the path of the archive, followed by the directory the "
"archive must be extracted to."
msgstr ""

#: ../../../library/shutil.rst:348
msgid ""
"When provided, *extra_args* is a sequence of ``(name, value)`` tuples that "
"will be passed as keywords arguments to the callable."
msgstr ""

#: ../../../library/shutil.rst:351
msgid ""
"*description* can be provided to describe the format, and will be returned "
"by the :func:`get_unpack_formats` function."
msgstr ""

#: ../../../library/shutil.rst:359
msgid "Unregister an unpack format. *name* is the name of the format."
msgstr ""

#: ../../../library/shutil.rst:366
msgid ""
"Return a list of all registered formats for unpacking. Each element of the "
"returned sequence is a tuple ``(name, extensions, description)``."
msgstr ""

#: ../../../library/shutil.rst:377
msgid ""
"You can register new formats or provide your own unpacker for any existing "
"formats, by using :func:`register_unpack_format`."
msgstr ""

#: ../../../library/shutil.rst:386
msgid "Archiving example"
msgstr ""

#: ../../../library/shutil.rst:388
msgid ""
"In this example, we create a gzip'ed tar-file archive containing all files "
"found in the :file:`.ssh` directory of the user::"
msgstr ""

#: ../../../library/shutil.rst:398
msgid "The resulting archive contains::"
msgstr ""

#: ../../../library/shutil.rst:9
msgid "file"
msgstr ""

#: ../../../library/shutil.rst:9
msgid "copying"
msgstr ""

#: ../../../library/shutil.rst:9
msgid "copying files"
msgstr ""

#: ../../../library/shutil.rst:145
msgid "directory"
msgstr ""

#: ../../../library/shutil.rst:145
msgid "deleting"
msgstr ""

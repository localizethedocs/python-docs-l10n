# SOME DESCRIPTIVE TITLE.
# Copyright (C) 1990-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-11 04:42+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../c-api/typeobj.rst:6
msgid "Type Objects"
msgstr ""

#: ../../../c-api/typeobj.rst:8
msgid ""
"Perhaps one of the most important structures of the Python object system is "
"the structure that defines a new type: the :c:type:`PyTypeObject` "
"structure.  Type objects can be handled using any of the :c:func:"
"`PyObject_\\*` or :c:func:`PyType_\\*` functions, but do not offer much "
"that's interesting to most Python applications. These objects are "
"fundamental to how objects behave, so they are very important to the "
"interpreter itself and to any extension module that implements new types."
msgstr ""

#: ../../../c-api/typeobj.rst:16
msgid ""
"Type objects are fairly large compared to most of the standard types. The "
"reason for the size is that each type object stores a large number of "
"values, mostly C function pointers, each of which implements a small part of "
"the type's functionality.  The fields of the type object are examined in "
"detail in this section.  The fields will be described in the order in which "
"they occur in the structure."
msgstr ""

#: ../../../c-api/typeobj.rst:23
msgid ""
"Typedefs: unaryfunc, binaryfunc, ternaryfunc, inquiry, intargfunc, "
"intintargfunc, intobjargproc, intintobjargproc, objobjargproc, destructor, "
"freefunc, printfunc, getattrfunc, getattrofunc, setattrfunc, setattrofunc, "
"reprfunc, hashfunc"
msgstr ""

#: ../../../c-api/typeobj.rst:28
msgid ""
"The structure definition for :c:type:`PyTypeObject` can be found in :file:"
"`Include/object.h`.  For convenience of reference, this repeats the "
"definition found there:"
msgstr ""

#: ../../../c-api/typeobj.rst:35
msgid ""
"The type object structure extends the :c:type:`PyVarObject` structure. The :"
"attr:`ob_size` field is used for dynamic types (created by  :func:"
"`type_new`, usually called from a class statement). Note that :c:data:"
"`PyType_Type` (the metatype) initializes :attr:`tp_itemsize`, which means "
"that its instances (i.e. type objects) *must* have the :attr:`ob_size` field."
msgstr ""

#: ../../../c-api/typeobj.rst:45
msgid ""
"These fields are only present when the macro ``Py_TRACE_REFS`` is defined. "
"Their initialization to *NULL* is taken care of by the "
"``PyObject_HEAD_INIT`` macro.  For statically allocated objects, these "
"fields always remain *NULL*. For dynamically allocated objects, these two "
"fields are used to link the object into a doubly-linked list of *all* live "
"objects on the heap.  This could be used for various debugging purposes; "
"currently the only use is to print the objects that are still alive at the "
"end of a run when the environment variable :envvar:`PYTHONDUMPREFS` is set."
msgstr ""

#: ../../../c-api/typeobj.rst:54
msgid "These fields are not inherited by subtypes."
msgstr ""

#: ../../../c-api/typeobj.rst:59
msgid ""
"This is the type object's reference count, initialized to ``1`` by the "
"``PyObject_HEAD_INIT`` macro.  Note that for statically allocated type "
"objects, the type's instances (objects whose :attr:`ob_type` points back to "
"the type) do *not* count as references.  But for dynamically allocated type "
"objects, the instances *do* count as references."
msgstr ""

#: ../../../c-api/typeobj.rst:65 ../../../c-api/typeobj.rst:94
#: ../../../c-api/typeobj.rst:121
msgid "This field is not inherited by subtypes."
msgstr ""

#: ../../../c-api/typeobj.rst:70
msgid ""
"This is the type's type, in other words its metatype.  It is initialized by "
"the argument to the ``PyObject_HEAD_INIT`` macro, and its value should "
"normally be ``&PyType_Type``.  However, for dynamically loadable extension "
"modules that must be usable on Windows (at least), the compiler complains "
"that this is not a valid initializer.  Therefore, the convention is to pass "
"*NULL* to the ``PyObject_HEAD_INIT`` macro and to initialize this field "
"explicitly at the start of the module's initialization function, before "
"doing anything else.  This is typically done like this::"
msgstr ""

#: ../../../c-api/typeobj.rst:81
msgid ""
"This should be done before any instances of the type are created. :c:func:"
"`PyType_Ready` checks if :attr:`ob_type` is *NULL*, and if so, initializes "
"it to the :attr:`ob_type` field of the base class. :c:func:`PyType_Ready` "
"will not change this field if it is non-zero."
msgstr ""

#: ../../../c-api/typeobj.rst:86 ../../../c-api/typeobj.rst:187
#: ../../../c-api/typeobj.rst:216 ../../../c-api/typeobj.rst:270
#: ../../../c-api/typeobj.rst:337 ../../../c-api/typeobj.rst:355
#: ../../../c-api/typeobj.rst:652 ../../../c-api/typeobj.rst:669
#: ../../../c-api/typeobj.rst:764 ../../../c-api/typeobj.rst:775
#: ../../../c-api/typeobj.rst:857 ../../../c-api/typeobj.rst:950
msgid "This field is inherited by subtypes."
msgstr ""

#: ../../../c-api/typeobj.rst:91
msgid ""
"For statically allocated type objects, this should be initialized to zero.  "
"For dynamically allocated type objects, this field has a special internal "
"meaning."
msgstr ""

#: ../../../c-api/typeobj.rst:99
msgid ""
"Pointer to a NUL-terminated string containing the name of the type. For "
"types that are accessible as module globals, the string should be the full "
"module name, followed by a dot, followed by the type name; for built-in "
"types, it should be just the type name.  If the module is a submodule of a "
"package, the full package name is part of the full module name.  For "
"example, a type named :class:`T` defined in module :mod:`M` in subpackage :"
"mod:`Q` in package :mod:`P` should have the :attr:`tp_name` initializer "
"``\"P.Q.M.T\"``."
msgstr ""

#: ../../../c-api/typeobj.rst:107
msgid ""
"For dynamically allocated type objects, this should just be the type name, "
"and the module name explicitly stored in the type dict as the value for key "
"``'__module__'``."
msgstr ""

#: ../../../c-api/typeobj.rst:111
msgid ""
"For statically allocated type objects, the tp_name field should contain a "
"dot. Everything before the last dot is made accessible as the :attr:"
"`__module__` attribute, and everything after the last dot is made accessible "
"as the :attr:`__name__` attribute."
msgstr ""

#: ../../../c-api/typeobj.rst:116
msgid ""
"If no dot is present, the entire :attr:`tp_name` field is made accessible as "
"the :attr:`__name__` attribute, and the :attr:`__module__` attribute is "
"undefined (unless explicitly set in the dictionary, as explained above).  "
"This means your type will be impossible to pickle."
msgstr ""

#: ../../../c-api/typeobj.rst:127
msgid ""
"These fields allow calculating the size in bytes of instances of the type."
msgstr ""

#: ../../../c-api/typeobj.rst:129
msgid ""
"There are two kinds of types: types with fixed-length instances have a zero :"
"attr:`tp_itemsize` field, types with variable-length instances have a non-"
"zero :attr:`tp_itemsize` field.  For a type with fixed-length instances, all "
"instances have the same size, given in :attr:`tp_basicsize`."
msgstr ""

#: ../../../c-api/typeobj.rst:134
msgid ""
"For a type with variable-length instances, the instances must have an :attr:"
"`ob_size` field, and the instance size is :attr:`tp_basicsize` plus N times :"
"attr:`tp_itemsize`, where N is the \"length\" of the object.  The value of N "
"is typically stored in the instance's :attr:`ob_size` field.  There are "
"exceptions:  for example, ints use a negative :attr:`ob_size` to indicate a "
"negative number, and N is ``abs(ob_size)`` there.  Also, the presence of an :"
"attr:`ob_size` field in the instance layout doesn't mean that the instance "
"structure is variable-length (for example, the structure for the list type "
"has fixed-length instances, yet those instances have a meaningful :attr:"
"`ob_size` field)."
msgstr ""

#: ../../../c-api/typeobj.rst:145
msgid ""
"The basic size includes the fields in the instance declared by the macro :c:"
"macro:`PyObject_HEAD` or :c:macro:`PyObject_VAR_HEAD` (whichever is used to "
"declare the instance struct) and this in turn includes the :attr:`_ob_prev` "
"and :attr:`_ob_next` fields if they are present.  This means that the only "
"correct way to get an initializer for the :attr:`tp_basicsize` is to use the "
"``sizeof`` operator on the struct used to declare the instance layout. The "
"basic size does not include the GC header size."
msgstr ""

#: ../../../c-api/typeobj.rst:153
msgid ""
"These fields are inherited separately by subtypes.  If the base type has a "
"non-zero :attr:`tp_itemsize`, it is generally not safe to set :attr:"
"`tp_itemsize` to a different non-zero value in a subtype (though this "
"depends on the implementation of the base type)."
msgstr ""

#: ../../../c-api/typeobj.rst:158
msgid ""
"A note about alignment: if the variable items require a particular "
"alignment, this should be taken care of by the value of :attr:"
"`tp_basicsize`.  Example: suppose a type implements an array of ``double``. :"
"attr:`tp_itemsize` is ``sizeof(double)``. It is the programmer's "
"responsibility that :attr:`tp_basicsize` is a multiple of ``sizeof(double)`` "
"(assuming this is the alignment requirement for ``double``)."
msgstr ""

#: ../../../c-api/typeobj.rst:168
msgid ""
"A pointer to the instance destructor function.  This function must be "
"defined unless the type guarantees that its instances will never be "
"deallocated (as is the case for the singletons ``None`` and ``Ellipsis``)."
msgstr ""

#: ../../../c-api/typeobj.rst:172
msgid ""
"The destructor function is called by the :c:func:`Py_DECREF` and :c:func:"
"`Py_XDECREF` macros when the new reference count is zero.  At this point, "
"the instance is still in existence, but there are no references to it.  The "
"destructor function should free all references which the instance owns, free "
"all memory buffers owned by the instance (using the freeing function "
"corresponding to the allocation function used to allocate the buffer), and "
"finally (as its last action) call the type's :attr:`tp_free` function.  If "
"the type is not subtypable (doesn't have the :const:`Py_TPFLAGS_BASETYPE` "
"flag bit set), it is permissible to call the object deallocator directly "
"instead of via :attr:`tp_free`.  The object deallocator should be the one "
"used to allocate the instance; this is normally :c:func:`PyObject_Del` if "
"the instance was allocated using :c:func:`PyObject_New` or :c:func:"
"`PyObject_VarNew`, or :c:func:`PyObject_GC_Del` if the instance was "
"allocated using :c:func:`PyObject_GC_New` or :c:func:`PyObject_GC_NewVar`."
msgstr ""

#: ../../../c-api/typeobj.rst:192
msgid "An optional pointer to the instance print function."
msgstr ""

#: ../../../c-api/typeobj.rst:194
msgid ""
"The print function is only called when the instance is printed to a *real* "
"file; when it is printed to a pseudo-file (like a :class:`StringIO` "
"instance), the instance's :attr:`tp_repr` or :attr:`tp_str` function is "
"called to convert it to a string.  These are also called when the type's :"
"attr:`tp_print` field is *NULL*.  A type should never implement :attr:"
"`tp_print` in a way that produces different output than :attr:`tp_repr` or :"
"attr:`tp_str` would."
msgstr ""

#: ../../../c-api/typeobj.rst:201
msgid ""
"The print function is called with the same signature as :c:func:"
"`PyObject_Print`: ``int tp_print(PyObject *self, FILE *file, int flags)``.  "
"The *self* argument is the instance to be printed.  The *file* argument is "
"the stdio file to which it is to be printed.  The *flags* argument is "
"composed of flag bits. The only flag bit currently defined is :const:"
"`Py_PRINT_RAW`. When the :const:`Py_PRINT_RAW` flag bit is set, the instance "
"should be printed the same way as :attr:`tp_str` would format it; when the :"
"const:`Py_PRINT_RAW` flag bit is clear, the instance should be printed the "
"same was as :attr:`tp_repr` would format it. It should return ``-1`` and set "
"an exception condition when an error occurred during the comparison."
msgstr ""

#: ../../../c-api/typeobj.rst:212
msgid ""
"It is possible that the :attr:`tp_print` field will be deprecated. In any "
"case, it is recommended not to define :attr:`tp_print`, but instead to rely "
"on :attr:`tp_repr` and :attr:`tp_str` for printing."
msgstr ""

#: ../../../c-api/typeobj.rst:221
msgid "An optional pointer to the get-attribute-string function."
msgstr ""

#: ../../../c-api/typeobj.rst:223
msgid ""
"This field is deprecated.  When it is defined, it should point to a function "
"that acts the same as the :attr:`tp_getattro` function, but taking a C "
"string instead of a Python string object to give the attribute name.  The "
"signature is the same as for :c:func:`PyObject_GetAttrString`."
msgstr ""

#: ../../../c-api/typeobj.rst:228
msgid ""
"This field is inherited by subtypes together with :attr:`tp_getattro`: a "
"subtype inherits both :attr:`tp_getattr` and :attr:`tp_getattro` from its "
"base type when the subtype's :attr:`tp_getattr` and :attr:`tp_getattro` are "
"both *NULL*."
msgstr ""

#: ../../../c-api/typeobj.rst:235
msgid "An optional pointer to the set-attribute-string function."
msgstr ""

#: ../../../c-api/typeobj.rst:237
msgid ""
"This field is deprecated.  When it is defined, it should point to a function "
"that acts the same as the :attr:`tp_setattro` function, but taking a C "
"string instead of a Python string object to give the attribute name.  The "
"signature is the same as for :c:func:`PyObject_SetAttrString`."
msgstr ""

#: ../../../c-api/typeobj.rst:242
msgid ""
"This field is inherited by subtypes together with :attr:`tp_setattro`: a "
"subtype inherits both :attr:`tp_setattr` and :attr:`tp_setattro` from its "
"base type when the subtype's :attr:`tp_setattr` and :attr:`tp_setattro` are "
"both *NULL*."
msgstr ""

#: ../../../c-api/typeobj.rst:249
msgid "Reserved slot, formerly known as tp_compare."
msgstr ""

#: ../../../c-api/typeobj.rst:256
msgid ""
"An optional pointer to a function that implements the built-in function :"
"func:`repr`."
msgstr ""

#: ../../../c-api/typeobj.rst:259
msgid ""
"The signature is the same as for :c:func:`PyObject_Repr`; it must return a "
"string or a Unicode object.  Ideally, this function should return a string "
"that, when passed to :func:`eval`, given a suitable environment, returns an "
"object with the same value.  If this is not feasible, it should return a "
"string starting with ``'<'`` and ending with ``'>'`` from which both the "
"type and the value of the object can be deduced."
msgstr ""

#: ../../../c-api/typeobj.rst:266
msgid ""
"When this field is not set, a string of the form ``<%s object at %p>`` is "
"returned, where ``%s`` is replaced by the type name, and ``%p`` by the "
"object's memory address."
msgstr ""

#: ../../../c-api/typeobj.rst:274
msgid ""
"Pointer to an additional structure that contains fields relevant only to "
"objects which implement the number protocol.  These fields are documented "
"in :ref:`number-structs`."
msgstr ""

#: ../../../c-api/typeobj.rst:278
msgid ""
"The :attr:`tp_as_number` field is not inherited, but the contained fields "
"are inherited individually."
msgstr ""

#: ../../../c-api/typeobj.rst:284
msgid ""
"Pointer to an additional structure that contains fields relevant only to "
"objects which implement the sequence protocol.  These fields are documented "
"in :ref:`sequence-structs`."
msgstr ""

#: ../../../c-api/typeobj.rst:288
msgid ""
"The :attr:`tp_as_sequence` field is not inherited, but the contained fields "
"are inherited individually."
msgstr ""

#: ../../../c-api/typeobj.rst:294
msgid ""
"Pointer to an additional structure that contains fields relevant only to "
"objects which implement the mapping protocol.  These fields are documented "
"in :ref:`mapping-structs`."
msgstr ""

#: ../../../c-api/typeobj.rst:298
msgid ""
"The :attr:`tp_as_mapping` field is not inherited, but the contained fields "
"are inherited individually."
msgstr ""

#: ../../../c-api/typeobj.rst:306
msgid ""
"An optional pointer to a function that implements the built-in function :"
"func:`hash`."
msgstr ""

#: ../../../c-api/typeobj.rst:309
msgid ""
"The signature is the same as for :c:func:`PyObject_Hash`; it must return a "
"value of the type Py_hash_t.  The value ``-1`` should not be returned as a "
"normal return value; when an error occurs during the computation of the hash "
"value, the function should set an exception and return ``-1``."
msgstr ""

#: ../../../c-api/typeobj.rst:314
msgid ""
"This field can be set explicitly to :c:func:`PyObject_HashNotImplemented` to "
"block inheritance of the hash method from a parent type. This is interpreted "
"as the equivalent of ``__hash__ = None`` at the Python level, causing "
"``isinstance(o, collections.Hashable)`` to correctly return ``False``. Note "
"that the converse is also true - setting ``__hash__ = None`` on a class at "
"the Python level will result in the ``tp_hash`` slot being set to :c:func:"
"`PyObject_HashNotImplemented`."
msgstr ""

#: ../../../c-api/typeobj.rst:322
msgid ""
"When this field is not set, an attempt to take the hash of the object "
"raises :exc:`TypeError`."
msgstr ""

#: ../../../c-api/typeobj.rst:325
msgid ""
"This field is inherited by subtypes together with :attr:`tp_richcompare`: a "
"subtype inherits both of :attr:`tp_richcompare` and :attr:`tp_hash`, when "
"the subtype's :attr:`tp_richcompare` and :attr:`tp_hash` are both *NULL*."
msgstr ""

#: ../../../c-api/typeobj.rst:333
msgid ""
"An optional pointer to a function that implements calling the object.  This "
"should be *NULL* if the object is not callable.  The signature is the same "
"as for :c:func:`PyObject_Call`."
msgstr ""

#: ../../../c-api/typeobj.rst:342
msgid ""
"An optional pointer to a function that implements the built-in operation :"
"func:`str`.  (Note that :class:`str` is a type now, and :func:`str` calls "
"the constructor for that type.  This constructor calls :c:func:"
"`PyObject_Str` to do the actual work, and :c:func:`PyObject_Str` will call "
"this handler.)"
msgstr ""

#: ../../../c-api/typeobj.rst:347
msgid ""
"The signature is the same as for :c:func:`PyObject_Str`; it must return a "
"string or a Unicode object.  This function should return a \"friendly\" "
"string representation of the object, as this is the representation that will "
"be used, among other things, by the :func:`print` function."
msgstr ""

#: ../../../c-api/typeobj.rst:352
msgid ""
"When this field is not set, :c:func:`PyObject_Repr` is called to return a "
"string representation."
msgstr ""

#: ../../../c-api/typeobj.rst:360
msgid "An optional pointer to the get-attribute function."
msgstr ""

#: ../../../c-api/typeobj.rst:362
msgid ""
"The signature is the same as for :c:func:`PyObject_GetAttr`.  It is usually "
"convenient to set this field to :c:func:`PyObject_GenericGetAttr`, which "
"implements the normal way of looking for object attributes."
msgstr ""

#: ../../../c-api/typeobj.rst:366
msgid ""
"This field is inherited by subtypes together with :attr:`tp_getattr`: a "
"subtype inherits both :attr:`tp_getattr` and :attr:`tp_getattro` from its "
"base type when the subtype's :attr:`tp_getattr` and :attr:`tp_getattro` are "
"both *NULL*."
msgstr ""

#: ../../../c-api/typeobj.rst:373
msgid "An optional pointer to the set-attribute function."
msgstr ""

#: ../../../c-api/typeobj.rst:375
msgid ""
"The signature is the same as for :c:func:`PyObject_SetAttr`.  It is usually "
"convenient to set this field to :c:func:`PyObject_GenericSetAttr`, which "
"implements the normal way of setting object attributes."
msgstr ""

#: ../../../c-api/typeobj.rst:379
msgid ""
"This field is inherited by subtypes together with :attr:`tp_setattr`: a "
"subtype inherits both :attr:`tp_setattr` and :attr:`tp_setattro` from its "
"base type when the subtype's :attr:`tp_setattr` and :attr:`tp_setattro` are "
"both *NULL*."
msgstr ""

#: ../../../c-api/typeobj.rst:386
msgid ""
"Pointer to an additional structure that contains fields relevant only to "
"objects which implement the buffer interface.  These fields are documented "
"in :ref:`buffer-structs`."
msgstr ""

#: ../../../c-api/typeobj.rst:390
msgid ""
"The :attr:`tp_as_buffer` field is not inherited, but the contained fields "
"are inherited individually."
msgstr ""

#: ../../../c-api/typeobj.rst:396
msgid ""
"This field is a bit mask of various flags.  Some flags indicate variant "
"semantics for certain situations; others are used to indicate that certain "
"fields in the type object (or in the extension structures referenced via :"
"attr:`tp_as_number`, :attr:`tp_as_sequence`, :attr:`tp_as_mapping`, and :"
"attr:`tp_as_buffer`) that were historically not always present are valid; if "
"such a flag bit is clear, the type fields it guards must not be accessed and "
"must be considered to have a zero or *NULL* value instead."
msgstr ""

#: ../../../c-api/typeobj.rst:404
msgid ""
"Inheritance of this field is complicated.  Most flag bits are inherited "
"individually, i.e. if the base type has a flag bit set, the subtype inherits "
"this flag bit.  The flag bits that pertain to extension structures are "
"strictly inherited if the extension structure is inherited, i.e. the base "
"type's value of the flag bit is copied into the subtype together with a "
"pointer to the extension structure.  The :const:`Py_TPFLAGS_HAVE_GC` flag "
"bit is inherited together with the :attr:`tp_traverse` and :attr:`tp_clear` "
"fields, i.e. if the :const:`Py_TPFLAGS_HAVE_GC` flag bit is clear in the "
"subtype and the :attr:`tp_traverse` and :attr:`tp_clear` fields in the "
"subtype exist and have *NULL* values."
msgstr ""

#: ../../../c-api/typeobj.rst:415
msgid ""
"The following bit masks are currently defined; these can be ORed together "
"using the ``|`` operator to form the value of the :attr:`tp_flags` field.  "
"The macro :c:func:`PyType_HasFeature` takes a type and a flags value, *tp* "
"and *f*, and checks whether ``tp->tp_flags & f`` is non-zero."
msgstr ""

#: ../../../c-api/typeobj.rst:423
msgid ""
"This bit is set when the type object itself is allocated on the heap.  In "
"this case, the :attr:`ob_type` field of its instances is considered a "
"reference to the type, and the type object is INCREF'ed when a new instance "
"is created, and DECREF'ed when an instance is destroyed (this does not apply "
"to instances of subtypes; only the type referenced by the instance's ob_type "
"gets INCREF'ed or DECREF'ed)."
msgstr ""

#: ../../../c-api/typeobj.rst:433
msgid ""
"This bit is set when the type can be used as the base type of another type.  "
"If this bit is clear, the type cannot be subtyped (similar to a \"final\" "
"class in Java)."
msgstr ""

#: ../../../c-api/typeobj.rst:440
msgid ""
"This bit is set when the type object has been fully initialized by :c:func:"
"`PyType_Ready`."
msgstr ""

#: ../../../c-api/typeobj.rst:446
msgid ""
"This bit is set while :c:func:`PyType_Ready` is in the process of "
"initializing the type object."
msgstr ""

#: ../../../c-api/typeobj.rst:452
msgid ""
"This bit is set when the object supports garbage collection.  If this bit is "
"set, instances must be created using :c:func:`PyObject_GC_New` and destroyed "
"using :c:func:`PyObject_GC_Del`.  More information in section :ref:"
"`supporting-cycle-detection`.  This bit also implies that the GC-related "
"fields :attr:`tp_traverse` and :attr:`tp_clear` are present in the type "
"object."
msgstr ""

#: ../../../c-api/typeobj.rst:462
msgid ""
"This is a bitmask of all the bits that pertain to the existence of certain "
"fields in the type object and its extension structures. Currently, it "
"includes the following bits: :const:`Py_TPFLAGS_HAVE_STACKLESS_EXTENSION`, :"
"const:`Py_TPFLAGS_HAVE_VERSION_TAG`."
msgstr ""

#: ../../../c-api/typeobj.rst:470
msgid ""
"An optional pointer to a NUL-terminated C string giving the docstring for "
"this type object.  This is exposed as the :attr:`__doc__` attribute on the "
"type and instances of the type."
msgstr ""

#: ../../../c-api/typeobj.rst:474
msgid "This field is *not* inherited by subtypes."
msgstr ""

#: ../../../c-api/typeobj.rst:479
msgid ""
"An optional pointer to a traversal function for the garbage collector.  This "
"is only used if the :const:`Py_TPFLAGS_HAVE_GC` flag bit is set.  More "
"information about Python's garbage collection scheme can be found in "
"section :ref:`supporting-cycle-detection`."
msgstr ""

#: ../../../c-api/typeobj.rst:484
msgid ""
"The :attr:`tp_traverse` pointer is used by the garbage collector to detect "
"reference cycles. A typical implementation of a :attr:`tp_traverse` function "
"simply calls :c:func:`Py_VISIT` on each of the instance's members that are "
"Python objects.  For example, this is function :c:func:`local_traverse` from "
"the :mod:`_thread` extension module::"
msgstr ""

#: ../../../c-api/typeobj.rst:499
msgid ""
"Note that :c:func:`Py_VISIT` is called only on those members that can "
"participate in reference cycles.  Although there is also a ``self->key`` "
"member, it can only be *NULL* or a Python string and therefore cannot be "
"part of a reference cycle."
msgstr ""

#: ../../../c-api/typeobj.rst:503
msgid ""
"On the other hand, even if you know a member can never be part of a cycle, "
"as a debugging aid you may want to visit it anyway just so the :mod:`gc` "
"module's :func:`get_referents` function will include it."
msgstr ""

#: ../../../c-api/typeobj.rst:507
msgid ""
"Note that :c:func:`Py_VISIT` requires the *visit* and *arg* parameters to :c:"
"func:`local_traverse` to have these specific names; don't name them just "
"anything."
msgstr ""

#: ../../../c-api/typeobj.rst:511
msgid ""
"This field is inherited by subtypes together with :attr:`tp_clear` and the :"
"const:`Py_TPFLAGS_HAVE_GC` flag bit: the flag bit, :attr:`tp_traverse`, and :"
"attr:`tp_clear` are all inherited from the base type if they are all zero in "
"the subtype."
msgstr ""

#: ../../../c-api/typeobj.rst:519
msgid ""
"An optional pointer to a clear function for the garbage collector. This is "
"only used if the :const:`Py_TPFLAGS_HAVE_GC` flag bit is set."
msgstr ""

#: ../../../c-api/typeobj.rst:522
msgid ""
"The :attr:`tp_clear` member function is used to break reference cycles in "
"cyclic garbage detected by the garbage collector.  Taken together, all :attr:"
"`tp_clear` functions in the system must combine to break all reference "
"cycles.  This is subtle, and if in any doubt supply a :attr:`tp_clear` "
"function.  For example, the tuple type does not implement a :attr:`tp_clear` "
"function, because it's possible to prove that no reference cycle can be "
"composed entirely of tuples. Therefore the :attr:`tp_clear` functions of "
"other types must be sufficient to break any cycle containing a tuple.  This "
"isn't immediately obvious, and there's rarely a good reason to avoid "
"implementing :attr:`tp_clear`."
msgstr ""

#: ../../../c-api/typeobj.rst:532
msgid ""
"Implementations of :attr:`tp_clear` should drop the instance's references to "
"those of its members that may be Python objects, and set its pointers to "
"those members to *NULL*, as in the following example::"
msgstr ""

#: ../../../c-api/typeobj.rst:546
msgid ""
"The :c:func:`Py_CLEAR` macro should be used, because clearing references is "
"delicate:  the reference to the contained object must not be decremented "
"until after the pointer to the contained object is set to *NULL*.  This is "
"because decrementing the reference count may cause the contained object to "
"become trash, triggering a chain of reclamation activity that may include "
"invoking arbitrary Python code (due to finalizers, or weakref callbacks, "
"associated with the contained object). If it's possible for such code to "
"reference *self* again, it's important that the pointer to the contained "
"object be *NULL* at that time, so that *self* knows the contained object can "
"no longer be used.  The :c:func:`Py_CLEAR` macro performs the operations in "
"a safe order."
msgstr ""

#: ../../../c-api/typeobj.rst:557
msgid ""
"Because the goal of :attr:`tp_clear` functions is to break reference cycles, "
"it's not necessary to clear contained objects like Python strings or Python "
"integers, which can't participate in reference cycles. On the other hand, it "
"may be convenient to clear all contained Python objects, and write the "
"type's :attr:`tp_dealloc` function to invoke :attr:`tp_clear`."
msgstr ""

#: ../../../c-api/typeobj.rst:563
msgid ""
"More information about Python's garbage collection scheme can be found in "
"section :ref:`supporting-cycle-detection`."
msgstr ""

#: ../../../c-api/typeobj.rst:566
msgid ""
"This field is inherited by subtypes together with :attr:`tp_traverse` and "
"the :const:`Py_TPFLAGS_HAVE_GC` flag bit: the flag bit, :attr:`tp_traverse`, "
"and :attr:`tp_clear` are all inherited from the base type if they are all "
"zero in the subtype."
msgstr ""

#: ../../../c-api/typeobj.rst:574
msgid ""
"An optional pointer to the rich comparison function, whose signature is "
"``PyObject *tp_richcompare(PyObject *a, PyObject *b, int op)``."
msgstr ""

#: ../../../c-api/typeobj.rst:577
msgid ""
"The function should return the result of the comparison (usually ``Py_True`` "
"or ``Py_False``).  If the comparison is undefined, it must return "
"``Py_NotImplemented``, if another error occurred it must return ``NULL`` and "
"set an exception condition."
msgstr ""

#: ../../../c-api/typeobj.rst:584
msgid ""
"If you want to implement a type for which only a limited set of comparisons "
"makes sense (e.g. ``==`` and ``!=``, but not ``<`` and friends), directly "
"raise :exc:`TypeError` in the rich comparison function."
msgstr ""

#: ../../../c-api/typeobj.rst:588
msgid ""
"This field is inherited by subtypes together with :attr:`tp_hash`: a subtype "
"inherits :attr:`tp_richcompare` and :attr:`tp_hash` when the subtype's :attr:"
"`tp_richcompare` and :attr:`tp_hash` are both *NULL*."
msgstr ""

#: ../../../c-api/typeobj.rst:593
msgid ""
"The following constants are defined to be used as the third argument for :"
"attr:`tp_richcompare` and for :c:func:`PyObject_RichCompare`:"
msgstr ""

#: ../../../c-api/typeobj.rst:597
msgid "Constant"
msgstr ""

#: ../../../c-api/typeobj.rst:597
msgid "Comparison"
msgstr ""

#: ../../../c-api/typeobj.rst:599
msgid ":const:`Py_LT`"
msgstr ""

#: ../../../c-api/typeobj.rst:599
msgid "``<``"
msgstr ""

#: ../../../c-api/typeobj.rst:601
msgid ":const:`Py_LE`"
msgstr ""

#: ../../../c-api/typeobj.rst:601
msgid "``<=``"
msgstr ""

#: ../../../c-api/typeobj.rst:603
msgid ":const:`Py_EQ`"
msgstr ""

#: ../../../c-api/typeobj.rst:603
msgid "``==``"
msgstr ""

#: ../../../c-api/typeobj.rst:605
msgid ":const:`Py_NE`"
msgstr ""

#: ../../../c-api/typeobj.rst:605
msgid "``!=``"
msgstr ""

#: ../../../c-api/typeobj.rst:607
msgid ":const:`Py_GT`"
msgstr ""

#: ../../../c-api/typeobj.rst:607
msgid "``>``"
msgstr ""

#: ../../../c-api/typeobj.rst:609
msgid ":const:`Py_GE`"
msgstr ""

#: ../../../c-api/typeobj.rst:609
msgid "``>=``"
msgstr ""

#: ../../../c-api/typeobj.rst:615
msgid ""
"If the instances of this type are weakly referenceable, this field is "
"greater than zero and contains the offset in the instance structure of the "
"weak reference list head (ignoring the GC header, if present); this offset "
"is used by :c:func:`PyObject_ClearWeakRefs` and the :c:func:`PyWeakref_\\*` "
"functions.  The instance structure needs to include a field of type :c:type:"
"`PyObject\\*` which is initialized to *NULL*."
msgstr ""

#: ../../../c-api/typeobj.rst:622
msgid ""
"Do not confuse this field with :attr:`tp_weaklist`; that is the list head "
"for weak references to the type object itself."
msgstr ""

#: ../../../c-api/typeobj.rst:625
msgid ""
"This field is inherited by subtypes, but see the rules listed below. A "
"subtype may override this offset; this means that the subtype uses a "
"different weak reference list head than the base type.  Since the list head "
"is always found via :attr:`tp_weaklistoffset`, this should not be a problem."
msgstr ""

#: ../../../c-api/typeobj.rst:630
msgid ""
"When a type defined by a class statement has no :attr:`__slots__` "
"declaration, and none of its base types are weakly referenceable, the type "
"is made weakly referenceable by adding a weak reference list head slot to "
"the instance layout and setting the :attr:`tp_weaklistoffset` of that slot's "
"offset."
msgstr ""

#: ../../../c-api/typeobj.rst:635
msgid ""
"When a type's :attr:`__slots__` declaration contains a slot named :attr:"
"`__weakref__`, that slot becomes the weak reference list head for instances "
"of the type, and the slot's offset is stored in the type's :attr:"
"`tp_weaklistoffset`."
msgstr ""

#: ../../../c-api/typeobj.rst:640
msgid ""
"When a type's :attr:`__slots__` declaration does not contain a slot named :"
"attr:`__weakref__`, the type inherits its :attr:`tp_weaklistoffset` from its "
"base type."
msgstr ""

#: ../../../c-api/typeobj.rst:646
msgid ""
"An optional pointer to a function that returns an iterator for the object.  "
"Its presence normally signals that the instances of this type are iterable "
"(although sequences may be iterable without this function)."
msgstr ""

#: ../../../c-api/typeobj.rst:650
msgid "This function has the same signature as :c:func:`PyObject_GetIter`."
msgstr ""

#: ../../../c-api/typeobj.rst:657
msgid ""
"An optional pointer to a function that returns the next item in an iterator. "
"When the iterator is exhausted, it must return *NULL*; a :exc:"
"`StopIteration` exception may or may not be set.  When another error occurs, "
"it must return *NULL* too.  Its presence signals that the instances of this "
"type are iterators."
msgstr ""

#: ../../../c-api/typeobj.rst:663
msgid ""
"Iterator types should also define the :attr:`tp_iter` function, and that "
"function should return the iterator instance itself (not a new iterator "
"instance)."
msgstr ""

#: ../../../c-api/typeobj.rst:667
msgid "This function has the same signature as :c:func:`PyIter_Next`."
msgstr ""

#: ../../../c-api/typeobj.rst:674
msgid ""
"An optional pointer to a static *NULL*-terminated array of :c:type:"
"`PyMethodDef` structures, declaring regular methods of this type."
msgstr ""

#: ../../../c-api/typeobj.rst:677
msgid ""
"For each entry in the array, an entry is added to the type's dictionary "
"(see :attr:`tp_dict` below) containing a method descriptor."
msgstr ""

#: ../../../c-api/typeobj.rst:680
msgid ""
"This field is not inherited by subtypes (methods are inherited through a "
"different mechanism)."
msgstr ""

#: ../../../c-api/typeobj.rst:686
msgid ""
"An optional pointer to a static *NULL*-terminated array of :c:type:"
"`PyMemberDef` structures, declaring regular data members (fields or slots) "
"of instances of this type."
msgstr ""

#: ../../../c-api/typeobj.rst:690
msgid ""
"For each entry in the array, an entry is added to the type's dictionary "
"(see :attr:`tp_dict` below) containing a member descriptor."
msgstr ""

#: ../../../c-api/typeobj.rst:693
msgid ""
"This field is not inherited by subtypes (members are inherited through a "
"different mechanism)."
msgstr ""

#: ../../../c-api/typeobj.rst:699
msgid ""
"An optional pointer to a static *NULL*-terminated array of :c:type:"
"`PyGetSetDef` structures, declaring computed attributes of instances of this "
"type."
msgstr ""

#: ../../../c-api/typeobj.rst:702
msgid ""
"For each entry in the array, an entry is added to the type's dictionary "
"(see :attr:`tp_dict` below) containing a getset descriptor."
msgstr ""

#: ../../../c-api/typeobj.rst:705
msgid ""
"This field is not inherited by subtypes (computed attributes are inherited "
"through a different mechanism)."
msgstr ""

#: ../../../c-api/typeobj.rst:710
msgid "Docs for PyGetSetDef::"
msgstr ""

#: ../../../c-api/typeobj.rst:726
msgid ""
"An optional pointer to a base type from which type properties are "
"inherited.  At this level, only single inheritance is supported; multiple "
"inheritance require dynamically creating a type object by calling the "
"metatype."
msgstr ""

#: ../../../c-api/typeobj.rst:730
msgid ""
"This field is not inherited by subtypes (obviously), but it defaults to "
"``&PyBaseObject_Type`` (which to Python programmers is known as the type :"
"class:`object`)."
msgstr ""

#: ../../../c-api/typeobj.rst:737
msgid "The type's dictionary is stored here by :c:func:`PyType_Ready`."
msgstr ""

#: ../../../c-api/typeobj.rst:739
msgid ""
"This field should normally be initialized to *NULL* before PyType_Ready is "
"called; it may also be initialized to a dictionary containing initial "
"attributes for the type.  Once :c:func:`PyType_Ready` has initialized the "
"type, extra attributes for the type may be added to this dictionary only if "
"they don't correspond to overloaded operations (like :meth:`__add__`)."
msgstr ""

#: ../../../c-api/typeobj.rst:745
msgid ""
"This field is not inherited by subtypes (though the attributes defined in "
"here are inherited through a different mechanism)."
msgstr ""

#: ../../../c-api/typeobj.rst:750
msgid ""
"It is not safe to use :c:func:`PyDict_SetItem` on or otherwise modify :attr:"
"`tp_dict` with the dictionary C-API."
msgstr ""

#: ../../../c-api/typeobj.rst:756
msgid "An optional pointer to a \"descriptor get\" function."
msgstr ""

#: ../../../c-api/typeobj.rst:758 ../../../c-api/typeobj.rst:771
#: ../../../c-api/typeobj.rst:842 ../../../c-api/typeobj.rst:864
#: ../../../c-api/typeobj.rst:895
msgid "The function signature is ::"
msgstr ""

#: ../../../c-api/typeobj.rst:769
msgid "An optional pointer to a \"descriptor set\" function."
msgstr ""

#: ../../../c-api/typeobj.rst:782
msgid ""
"If the instances of this type have a dictionary containing instance "
"variables, this field is non-zero and contains the offset in the instances "
"of the type of the instance variable dictionary; this offset is used by :c:"
"func:`PyObject_GenericGetAttr`."
msgstr ""

#: ../../../c-api/typeobj.rst:787
msgid ""
"Do not confuse this field with :attr:`tp_dict`; that is the dictionary for "
"attributes of the type object itself."
msgstr ""

#: ../../../c-api/typeobj.rst:790
msgid ""
"If the value of this field is greater than zero, it specifies the offset "
"from the start of the instance structure.  If the value is less than zero, "
"it specifies the offset from the *end* of the instance structure.  A "
"negative offset is more expensive to use, and should only be used when the "
"instance structure contains a variable-length part.  This is used for "
"example to add an instance variable dictionary to subtypes of :class:`str` "
"or :class:`tuple`. Note that the :attr:`tp_basicsize` field should account "
"for the dictionary added to the end in that case, even though the dictionary "
"is not included in the basic object layout.  On a system with a pointer size "
"of 4 bytes, :attr:`tp_dictoffset` should be set to ``-4`` to indicate that "
"the dictionary is at the very end of the structure."
msgstr ""

#: ../../../c-api/typeobj.rst:802
msgid ""
"The real dictionary offset in an instance can be computed from a negative :"
"attr:`tp_dictoffset` as follows::"
msgstr ""

#: ../../../c-api/typeobj.rst:809
msgid ""
"where :attr:`tp_basicsize`, :attr:`tp_itemsize` and :attr:`tp_dictoffset` "
"are taken from the type object, and :attr:`ob_size` is taken from the "
"instance.  The absolute value is taken because ints use the sign of :attr:"
"`ob_size` to store the sign of the number.  (There's never a need to do this "
"calculation yourself; it is done for you by :c:func:`_PyObject_GetDictPtr`.)"
msgstr ""

#: ../../../c-api/typeobj.rst:815
msgid ""
"This field is inherited by subtypes, but see the rules listed below. A "
"subtype may override this offset; this means that the subtype instances "
"store the dictionary at a difference offset than the base type.  Since the "
"dictionary is always found via :attr:`tp_dictoffset`, this should not be a "
"problem."
msgstr ""

#: ../../../c-api/typeobj.rst:820
msgid ""
"When a type defined by a class statement has no :attr:`__slots__` "
"declaration, and none of its base types has an instance variable dictionary, "
"a dictionary slot is added to the instance layout and the :attr:"
"`tp_dictoffset` is set to that slot's offset."
msgstr ""

#: ../../../c-api/typeobj.rst:825
msgid ""
"When a type defined by a class statement has a :attr:`__slots__` "
"declaration, the type inherits its :attr:`tp_dictoffset` from its base type."
msgstr ""

#: ../../../c-api/typeobj.rst:828
msgid ""
"(Adding a slot named :attr:`__dict__` to the :attr:`__slots__` declaration "
"does not have the expected effect, it just causes confusion.  Maybe this "
"should be added as a feature just like :attr:`__weakref__` though.)"
msgstr ""

#: ../../../c-api/typeobj.rst:835
msgid "An optional pointer to an instance initialization function."
msgstr ""

#: ../../../c-api/typeobj.rst:837
msgid ""
"This function corresponds to the :meth:`__init__` method of classes.  Like :"
"meth:`__init__`, it is possible to create an instance without calling :meth:"
"`__init__`, and it is possible to reinitialize an instance by calling its :"
"meth:`__init__` method again."
msgstr ""

#: ../../../c-api/typeobj.rst:846
msgid ""
"The self argument is the instance to be initialized; the *args* and *kwds* "
"arguments represent positional and keyword arguments of the call to :meth:"
"`__init__`."
msgstr ""

#: ../../../c-api/typeobj.rst:850
msgid ""
"The :attr:`tp_init` function, if not *NULL*, is called when an instance is "
"created normally by calling its type, after the type's :attr:`tp_new` "
"function has returned an instance of the type.  If the :attr:`tp_new` "
"function returns an instance of some other type that is not a subtype of the "
"original type, no :attr:`tp_init` function is called; if :attr:`tp_new` "
"returns an instance of a subtype of the original type, the subtype's :attr:"
"`tp_init` is called."
msgstr ""

#: ../../../c-api/typeobj.rst:862
msgid "An optional pointer to an instance allocation function."
msgstr ""

#: ../../../c-api/typeobj.rst:868
msgid ""
"The purpose of this function is to separate memory allocation from memory "
"initialization.  It should return a pointer to a block of memory of adequate "
"length for the instance, suitably aligned, and initialized to zeros, but "
"with :attr:`ob_refcnt` set to ``1`` and :attr:`ob_type` set to the type "
"argument.  If the type's :attr:`tp_itemsize` is non-zero, the object's :attr:"
"`ob_size` field should be initialized to *nitems* and the length of the "
"allocated memory block should be ``tp_basicsize + nitems*tp_itemsize``, "
"rounded up to a multiple of ``sizeof(void*)``; otherwise, *nitems* is not "
"used and the length of the block should be :attr:`tp_basicsize`."
msgstr ""

#: ../../../c-api/typeobj.rst:878
msgid ""
"Do not use this function to do any other instance initialization, not even "
"to allocate additional memory; that should be done by :attr:`tp_new`."
msgstr ""

#: ../../../c-api/typeobj.rst:881
msgid ""
"This field is inherited by static subtypes, but not by dynamic subtypes "
"(subtypes created by a class statement); in the latter, this field is always "
"set to :c:func:`PyType_GenericAlloc`, to force a standard heap allocation "
"strategy. That is also the recommended value for statically defined types."
msgstr ""

#: ../../../c-api/typeobj.rst:889
msgid "An optional pointer to an instance creation function."
msgstr ""

#: ../../../c-api/typeobj.rst:891
msgid ""
"If this function is *NULL* for a particular type, that type cannot be called "
"to create new instances; presumably there is some other way to create "
"instances, like a factory function."
msgstr ""

#: ../../../c-api/typeobj.rst:899
msgid ""
"The subtype argument is the type of the object being created; the *args* and "
"*kwds* arguments represent positional and keyword arguments of the call to "
"the type.  Note that subtype doesn't have to equal the type whose :attr:"
"`tp_new` function is called; it may be a subtype of that type (but not an "
"unrelated type)."
msgstr ""

#: ../../../c-api/typeobj.rst:905
msgid ""
"The :attr:`tp_new` function should call ``subtype->tp_alloc(subtype, "
"nitems)`` to allocate space for the object, and then do only as much further "
"initialization as is absolutely necessary.  Initialization that can safely "
"be ignored or repeated should be placed in the :attr:`tp_init` handler.  A "
"good rule of thumb is that for immutable types, all initialization should "
"take place in :attr:`tp_new`, while for mutable types, most initialization "
"should be deferred to :attr:`tp_init`."
msgstr ""

#: ../../../c-api/typeobj.rst:913
msgid ""
"This field is inherited by subtypes, except it is not inherited by static "
"types whose :attr:`tp_base` is *NULL* or ``&PyBaseObject_Type``."
msgstr ""

#: ../../../c-api/typeobj.rst:919
msgid ""
"An optional pointer to an instance deallocation function.  Its signature is :"
"c:type:`freefunc`::"
msgstr ""

#: ../../../c-api/typeobj.rst:924
msgid ""
"An initializer that is compatible with this signature is :c:func:"
"`PyObject_Free`."
msgstr ""

#: ../../../c-api/typeobj.rst:926
msgid ""
"This field is inherited by static subtypes, but not by dynamic subtypes "
"(subtypes created by a class statement); in the latter, this field is set to "
"a deallocator suitable to match :c:func:`PyType_GenericAlloc` and the value "
"of the :const:`Py_TPFLAGS_HAVE_GC` flag bit."
msgstr ""

#: ../../../c-api/typeobj.rst:934
msgid "An optional pointer to a function called by the garbage collector."
msgstr ""

#: ../../../c-api/typeobj.rst:936
msgid ""
"The garbage collector needs to know whether a particular object is "
"collectible or not.  Normally, it is sufficient to look at the object's "
"type's :attr:`tp_flags` field, and check the :const:`Py_TPFLAGS_HAVE_GC` "
"flag bit.  But some types have a mixture of statically and dynamically "
"allocated instances, and the statically allocated instances are not "
"collectible.  Such types should define this function; it should return ``1`` "
"for a collectible instance, and ``0`` for a non-collectible instance. The "
"signature is ::"
msgstr ""

#: ../../../c-api/typeobj.rst:946
msgid ""
"(The only example of this are types themselves.  The metatype, :c:data:"
"`PyType_Type`, defines this function to distinguish between statically and "
"dynamically allocated types.)"
msgstr ""

#: ../../../c-api/typeobj.rst:955
msgid "Tuple of base types."
msgstr ""

#: ../../../c-api/typeobj.rst:957
msgid ""
"This is set for types created by a class statement.  It should be *NULL* for "
"statically defined types."
msgstr ""

#: ../../../c-api/typeobj.rst:960
msgid "This field is not inherited."
msgstr ""

#: ../../../c-api/typeobj.rst:965
msgid ""
"Tuple containing the expanded set of base types, starting with the type "
"itself and ending with :class:`object`, in Method Resolution Order."
msgstr ""

#: ../../../c-api/typeobj.rst:968
msgid ""
"This field is not inherited; it is calculated fresh by :c:func:"
"`PyType_Ready`."
msgstr ""

#: ../../../c-api/typeobj.rst:973
msgid "Unused.  Not inherited.  Internal use only."
msgstr ""

#: ../../../c-api/typeobj.rst:978
msgid ""
"List of weak references to subclasses.  Not inherited.  Internal use only."
msgstr ""

#: ../../../c-api/typeobj.rst:983
msgid ""
"Weak reference list head, for weak references to this type object.  Not "
"inherited.  Internal use only."
msgstr ""

#: ../../../c-api/typeobj.rst:986
msgid ""
"The remaining fields are only defined if the feature test macro :const:"
"`COUNT_ALLOCS` is defined, and are for internal use only. They are "
"documented here for completeness.  None of these fields are inherited by "
"subtypes."
msgstr ""

#: ../../../c-api/typeobj.rst:994
msgid "Number of allocations."
msgstr ""

#: ../../../c-api/typeobj.rst:999
msgid "Number of frees."
msgstr ""

#: ../../../c-api/typeobj.rst:1004
msgid "Maximum simultaneously allocated objects."
msgstr ""

#: ../../../c-api/typeobj.rst:1009
msgid ""
"Pointer to the next type object with a non-zero :attr:`tp_allocs` field."
msgstr ""

#: ../../../c-api/typeobj.rst:1011
msgid ""
"Also, note that, in a garbage collected Python, tp_dealloc may be called "
"from any Python thread, not just the thread which created the object (if the "
"object becomes part of a refcount cycle, that cycle might be collected by a "
"garbage collection on any thread).  This is not a problem for Python API "
"calls, since the thread on which tp_dealloc is called will own the Global "
"Interpreter Lock (GIL). However, if the object being destroyed in turn "
"destroys objects from some other C or C++ library, care should be taken to "
"ensure that destroying those objects on the thread which called tp_dealloc "
"will not violate any assumptions of the library."
msgstr ""

#: ../../../c-api/typeobj.rst:1025
msgid "Number Object Structures"
msgstr ""

#: ../../../c-api/typeobj.rst:1032
msgid ""
"This structure holds pointers to the functions which an object uses to "
"implement the number protocol.  Each function is used by the function of "
"similar name documented in the :ref:`number` section."
msgstr ""

#: ../../../c-api/typeobj.rst:1036
msgid "Here is the structure definition::"
msgstr ""

#: ../../../c-api/typeobj.rst:1080
msgid ""
"Binary and ternary functions must check the type of all their operands, and "
"implement the necessary conversions (at least one of the operands is an "
"instance of the defined type).  If the operation is not defined for the "
"given operands, binary and ternary functions must return "
"``Py_NotImplemented``, if another error occurred they must return ``NULL`` "
"and set an exception."
msgstr ""

#: ../../../c-api/typeobj.rst:1089
msgid ""
"The :c:data:`nb_reserved` field should always be ``NULL``.  It was "
"previously called :c:data:`nb_long`, and was renamed in Python 3.0.1."
msgstr ""

#: ../../../c-api/typeobj.rst:1097
msgid "Mapping Object Structures"
msgstr ""

#: ../../../c-api/typeobj.rst:1104
msgid ""
"This structure holds pointers to the functions which an object uses to "
"implement the mapping protocol.  It has three members:"
msgstr ""

#: ../../../c-api/typeobj.rst:1109
msgid ""
"This function is used by :c:func:`PyMapping_Length` and :c:func:"
"`PyObject_Size`, and has the same signature.  This slot may be set to *NULL* "
"if the object has no defined length."
msgstr ""

#: ../../../c-api/typeobj.rst:1115
msgid ""
"This function is used by :c:func:`PyObject_GetItem` and has the same "
"signature.  This slot must be filled for the :c:func:`PyMapping_Check` "
"function to return ``1``, it can be *NULL* otherwise."
msgstr ""

#: ../../../c-api/typeobj.rst:1121
msgid ""
"This function is used by :c:func:`PyObject_SetItem` and has the same "
"signature.  If this slot is *NULL*, the object does not support item "
"assignment."
msgstr ""

#: ../../../c-api/typeobj.rst:1129
msgid "Sequence Object Structures"
msgstr ""

#: ../../../c-api/typeobj.rst:1136
msgid ""
"This structure holds pointers to the functions which an object uses to "
"implement the sequence protocol."
msgstr ""

#: ../../../c-api/typeobj.rst:1141
msgid ""
"This function is used by :c:func:`PySequence_Size` and :c:func:"
"`PyObject_Size`, and has the same signature."
msgstr ""

#: ../../../c-api/typeobj.rst:1146
msgid ""
"This function is used by :c:func:`PySequence_Concat` and has the same "
"signature.  It is also used by the ``+`` operator, after trying the numeric "
"addition via the :attr:`tp_as_number.nb_add` slot."
msgstr ""

#: ../../../c-api/typeobj.rst:1152
msgid ""
"This function is used by :c:func:`PySequence_Repeat` and has the same "
"signature.  It is also used by the ``*`` operator, after trying numeric "
"multiplication via the :attr:`tp_as_number.nb_mul` slot."
msgstr ""

#: ../../../c-api/typeobj.rst:1158
msgid ""
"This function is used by :c:func:`PySequence_GetItem` and has the same "
"signature.  This slot must be filled for the :c:func:`PySequence_Check` "
"function to return ``1``, it can be *NULL* otherwise."
msgstr ""

#: ../../../c-api/typeobj.rst:1162
msgid ""
"Negative indexes are handled as follows: if the :attr:`sq_length` slot is "
"filled, it is called and the sequence length is used to compute a positive "
"index which is passed to :attr:`sq_item`.  If :attr:`sq_length` is *NULL*, "
"the index is passed as is to the function."
msgstr ""

#: ../../../c-api/typeobj.rst:1169
msgid ""
"This function is used by :c:func:`PySequence_SetItem` and has the same "
"signature.  This slot may be left to *NULL* if the object does not support "
"item assignment."
msgstr ""

#: ../../../c-api/typeobj.rst:1175
msgid ""
"This function may be used by :c:func:`PySequence_Contains` and has the same "
"signature.  This slot may be left to *NULL*, in this case :c:func:"
"`PySequence_Contains` simply traverses the sequence until it finds a match."
msgstr ""

#: ../../../c-api/typeobj.rst:1182
msgid ""
"This function is used by :c:func:`PySequence_InPlaceConcat` and has the same "
"signature.  It should modify its first operand, and return it."
msgstr ""

#: ../../../c-api/typeobj.rst:1187
msgid ""
"This function is used by :c:func:`PySequence_InPlaceRepeat` and has the same "
"signature.  It should modify its first operand, and return it."
msgstr ""

#: ../../../c-api/typeobj.rst:1197
msgid "Buffer Object Structures"
msgstr ""

#: ../../../c-api/typeobj.rst:1203
msgid ""
"The :ref:`buffer interface <bufferobjects>` exports a model where an object "
"can expose its internal data."
msgstr ""

#: ../../../c-api/typeobj.rst:1206
msgid ""
"If an object does not export the buffer interface, then its :attr:"
"`tp_as_buffer` member in the :c:type:`PyTypeObject` structure should be "
"*NULL*.  Otherwise, the :attr:`tp_as_buffer` will point to a :c:type:"
"`PyBufferProcs` structure."
msgstr ""

#: ../../../c-api/typeobj.rst:1213
msgid ""
"Structure used to hold the function pointers which define an implementation "
"of the buffer protocol."
msgstr ""

#: ../../../c-api/typeobj.rst:1218
msgid ""
"This should fill a :c:type:`Py_buffer` with the necessary data for exporting "
"the type.  The signature of :data:`getbufferproc` is ``int (PyObject *obj, "
"Py_buffer *view, int flags)``.  *obj* is the object to export, *view* is "
"the :c:type:`Py_buffer` struct to fill, and *flags* gives the conditions the "
"caller wants the memory under.  (See :c:func:`PyObject_GetBuffer` for all "
"flags.)  :c:member:`bf_getbuffer` is responsible for filling *view* with the "
"appropriate information. (:c:func:`PyBuffer_FillView` can be used in simple "
"cases.)  See :c:type:`Py_buffer`\\s docs for what needs to be filled in."
msgstr ""

#: ../../../c-api/typeobj.rst:1231
msgid ""
"This should release the resources of the buffer.  The signature of :c:data:"
"`releasebufferproc` is ``void (PyObject *obj, Py_buffer *view)``. If the :c:"
"data:`bf_releasebuffer` function is not provided (i.e. it is *NULL*), then "
"it does not ever need to be called."
msgstr ""

#: ../../../c-api/typeobj.rst:1236
msgid ""
"The exporter of the buffer interface must make sure that any memory pointed "
"to in the :c:type:`Py_buffer` structure remains valid until releasebuffer is "
"called.  Exporters will need to define a :c:data:`bf_releasebuffer` function "
"if they can re-allocate their memory, strides, shape, suboffsets, or format "
"variables which they might share through the struct bufferinfo."
msgstr ""

#: ../../../c-api/typeobj.rst:1243
msgid "See :c:func:`PyBuffer_Release`."
msgstr ""

#: ../../../c-api/typeobj.rst:254
msgid "repr"
msgstr ""

#: ../../../c-api/typeobj.rst:304
msgid "hash"
msgstr ""

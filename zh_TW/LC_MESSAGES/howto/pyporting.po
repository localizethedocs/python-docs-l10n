# SOME DESCRIPTIVE TITLE.
# Copyright (C) 1990-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-11 04:42+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../howto/pyporting.rst:5
msgid "Porting Python 2 Code to Python 3"
msgstr ""

#: ../../../howto/pyporting.rst:0
msgid "author"
msgstr ""

#: ../../../howto/pyporting.rst:7
msgid "Brett Cannon"
msgstr ""

#: ../../../howto/pyporting.rst:None
msgid "Abstract"
msgstr ""

#: ../../../howto/pyporting.rst:11
msgid ""
"With Python 3 being the future of Python while Python 2 is still in active "
"use, it is good to have your project available for both major releases of "
"Python. This guide is meant to help you choose which strategy works best for "
"your project to support both Python 2 & 3 along with how to execute that "
"strategy."
msgstr ""

#: ../../../howto/pyporting.rst:17
msgid ""
"If you are looking to port an extension module instead of pure Python code, "
"please see :ref:`cporting-howto`."
msgstr ""

#: ../../../howto/pyporting.rst:22
msgid "Choosing a Strategy"
msgstr ""

#: ../../../howto/pyporting.rst:24
msgid ""
"When a project makes the decision that it's time to support both Python 2 & "
"3, a decision needs to be made as to how to go about accomplishing that "
"goal. The chosen strategy will depend on how large the project's existing "
"codebase is and how much divergence you want from your Python 2 codebase "
"from your Python 3 one (e.g., starting a new version with Python 3)."
msgstr ""

#: ../../../howto/pyporting.rst:30
msgid ""
"If your project is brand-new or does not have a large codebase, then you may "
"want to consider writing/porting :ref:`all of your code for Python 3 and use "
"3to2 <use_3to2>` to port your code for Python 2."
msgstr ""

#: ../../../howto/pyporting.rst:34
msgid ""
"If you would prefer to maintain a codebase which is semantically **and** "
"syntactically compatible with Python 2 & 3 simultaneously, you can write :"
"ref:`use_same_source`. While this tends to lead to somewhat non-idiomatic "
"code, it does mean you keep a rapid development process for you, the "
"developer."
msgstr ""

#: ../../../howto/pyporting.rst:39
msgid ""
"Finally, you do have the option of :ref:`using 2to3 <use_2to3>` to translate "
"Python 2 code into Python 3 code (with some manual help). This can take the "
"form of branching your code and using 2to3 to start a Python 3 branch. You "
"can also have users perform the translation at installation time "
"automatically so that you only have to maintain a Python 2 codebase."
msgstr ""

#: ../../../howto/pyporting.rst:45
msgid ""
"Regardless of which approach you choose, porting is not as hard or time-"
"consuming as you might initially think. You can also tackle the problem "
"piece-meal as a good portion of porting is simply updating your code to "
"follow current best practices in a Python 2/3 compatible way."
msgstr ""

#: ../../../howto/pyporting.rst:52
msgid "Universal Bits of Advice"
msgstr ""

#: ../../../howto/pyporting.rst:54
msgid ""
"Regardless of what strategy you pick, there are a few things you should "
"consider."
msgstr ""

#: ../../../howto/pyporting.rst:57
msgid ""
"One is make sure you have a robust test suite. You need to make sure "
"everything continues to work, just like when you support a new minor version "
"of Python. This means making sure your test suite is thorough and is ported "
"properly between Python 2 & 3. You will also most likely want to use "
"something like tox_ to automate testing between both a Python 2 and Python 3 "
"VM."
msgstr ""

#: ../../../howto/pyporting.rst:63
msgid ""
"Two, once your project has Python 3 support, make sure to add the proper "
"classifier on the Cheeseshop_ (PyPI_). To have your project listed as Python "
"3 compatible it must have the `Python 3 classifier <http://pypi.python.org/"
"pypi?:action=browse&c=533>`_ (from http://techspot.zzzeek.org/2011/01/24/"
"zzzeek-s-guide-to-python-3-porting/)::"
msgstr ""

#: ../../../howto/pyporting.rst:86
msgid ""
"Doing so will cause your project to show up in the `Python 3 packages list "
"<http://pypi.python.org/pypi?:action=browse&c=533&show=all>`_. You will know "
"you set the classifier properly as visiting your project page on the "
"Cheeseshop will show a Python 3 logo in the upper-left corner of the page."
msgstr ""

#: ../../../howto/pyporting.rst:92
msgid ""
"Three, the six_ project provides a library which helps iron out differences "
"between Python 2 & 3. If you find there is a sticky point that is a "
"continual point of contention in your translation or maintenance of code, "
"consider using a source-compatible solution relying on six. If you have to "
"create your own Python 2/3 compatible solution, you can use ``sys."
"version_info[0] >= 3`` as a guard."
msgstr ""

#: ../../../howto/pyporting.rst:99
msgid ""
"Four, read all the approaches. Just because some bit of advice applies to "
"one approach more than another doesn't mean that some advice doesn't apply "
"to other strategies."
msgstr ""

#: ../../../howto/pyporting.rst:103
msgid ""
"Five, drop support for older Python versions if possible. `Python 2.5`_ "
"introduced a lot of useful syntax and libraries which have become idiomatic "
"in Python 3. `Python 2.6`_ introduced future statements which makes "
"compatibility much easier if you are going from Python 2 to 3. `Python 2.7`_ "
"continues the trend in the stdlib. So choose the newest version of Python "
"which you believe can be your minimum support version and work from there."
msgstr ""

#: ../../../howto/pyporting.rst:127
msgid "Python 3 and 3to2"
msgstr ""

#: ../../../howto/pyporting.rst:129
msgid ""
"If you are starting a new project or your codebase is small enough, you may "
"want to consider writing your code for Python 3 and backporting to Python 2 "
"using 3to2_. Thanks to Python 3 being more strict about things than Python 2 "
"(e.g., bytes vs. strings), the source translation can be easier and more "
"straightforward than from Python 2 to 3. Plus it gives you more direct "
"experience developing in Python 3 which, since it is the future of Python, "
"is a good thing long-term."
msgstr ""

#: ../../../howto/pyporting.rst:137
msgid ""
"A drawback of this approach is that 3to2 is a third-party project. This "
"means that the Python core developers (and thus this guide) can make no "
"promises about how well 3to2 works at any time. There is nothing to suggest, "
"though, that 3to2 is not a high-quality project."
msgstr ""

#: ../../../howto/pyporting.rst:149
msgid "Python 2 and 2to3"
msgstr ""

#: ../../../howto/pyporting.rst:151
msgid ""
"Included with Python since 2.6, the 2to3_ tool (and :mod:`lib2to3` module) "
"helps with porting Python 2 to Python 3 by performing various source "
"translations. This is a perfect solution for projects which wish to branch "
"their Python 3 code from their Python 2 codebase and maintain them as "
"independent codebases. You can even begin preparing to use this approach "
"today by writing future-compatible Python code which works cleanly in Python "
"2 in conjunction with 2to3; all steps outlined below will work with Python 2 "
"code up to the point when the actual use of 2to3 occurs."
msgstr ""

#: ../../../howto/pyporting.rst:160
msgid ""
"Use of 2to3 as an on-demand translation step at install time is also "
"possible, preventing the need to maintain a separate Python 3 codebase, but "
"this approach does come with some drawbacks. While users will only have to "
"pay the translation cost once at installation, you as a developer will need "
"to pay the cost regularly during development. If your codebase is "
"sufficiently large enough then the translation step ends up acting like a "
"compilation step, robbing you of the rapid development process you are used "
"to with Python. Obviously the time required to translate a project will "
"vary, so do an experimental translation just to see how long it takes to "
"evaluate whether you prefer this approach compared to using :ref:"
"`use_same_source` or simply keeping a separate Python 3 codebase."
msgstr ""

#: ../../../howto/pyporting.rst:172
msgid ""
"Below are the typical steps taken by a project which uses a 2to3-based "
"approach to supporting Python 2 & 3."
msgstr ""

#: ../../../howto/pyporting.rst:177
msgid "Support Python 2.7"
msgstr ""

#: ../../../howto/pyporting.rst:179
msgid ""
"As a first step, make sure that your project is compatible with `Python "
"2.7`_. This is just good to do as Python 2.7 is the last release of Python 2 "
"and thus will be used for a rather long time. It also allows for use of the "
"``-3`` flag to Python to help discover places in your code which 2to3 cannot "
"handle but are known to cause issues."
msgstr ""

#: ../../../howto/pyporting.rst:186
msgid "Try to Support `Python 2.6`_ and Newer Only"
msgstr ""

#: ../../../howto/pyporting.rst:188
msgid ""
"While not possible for all projects, if you can support `Python 2.6`_ and "
"newer **only**, your life will be much easier. Various future statements, "
"stdlib additions, etc. exist only in Python 2.6 and later which greatly "
"assist in porting to Python 3. But if you project must keep support for "
"`Python 2.5`_ (or even `Python 2.4`_) then it is still possible to port to "
"Python 3."
msgstr ""

#: ../../../howto/pyporting.rst:194
msgid ""
"Below are the benefits you gain if you only have to support Python 2.6 and "
"newer. Some of these options are personal choice while others are "
"**strongly** recommended (the ones that are more for personal choice are "
"labeled as such).  If you continue to support older versions of Python then "
"you at least need to watch out for situations that these solutions fix."
msgstr ""

#: ../../../howto/pyporting.rst:202
msgid "``from __future__ import print_function``"
msgstr ""

#: ../../../howto/pyporting.rst:204
msgid ""
"This is a personal choice. 2to3 handles the translation from the print "
"statement to the print function rather well so this is an optional step. "
"This future statement does help, though, with getting used to typing "
"``print('Hello, World')`` instead of ``print 'Hello, World'``."
msgstr ""

#: ../../../howto/pyporting.rst:211
msgid "``from __future__ import unicode_literals``"
msgstr ""

#: ../../../howto/pyporting.rst:213
msgid ""
"Another personal choice. You can always mark what you want to be a (unicode) "
"string with a ``u`` prefix to get the same effect. But regardless of whether "
"you use this future statement or not, you **must** make sure you know "
"exactly which Python 2 strings you want to be bytes, and which are to be "
"strings. This means you should, **at minimum** mark all strings that are "
"meant to be text strings with a ``u`` prefix if you do not use this future "
"statement."
msgstr ""

#: ../../../howto/pyporting.rst:222
msgid "Bytes literals"
msgstr ""

#: ../../../howto/pyporting.rst:224
msgid ""
"This is a **very** important one. The ability to prefix Python 2 strings "
"that are meant to contain bytes with a ``b`` prefix help to very clearly "
"delineate what is and is not a Python 3 string. When you run 2to3 on code, "
"all Python 2 strings become Python 3 strings **unless** they are prefixed "
"with ``b``."
msgstr ""

#: ../../../howto/pyporting.rst:229
msgid ""
"There are some differences between byte literals in Python 2 and those in "
"Python 3 thanks to the bytes type just being an alias to ``str`` in Python "
"2. Probably the biggest \"gotcha\" is that indexing results in different "
"values. In Python 2, the value of ``b'py'[1]`` is ``'y'``, while in Python 3 "
"it's ``121``. You can avoid this disparity by always slicing at the size of "
"a single element: ``b'py'[1:2]`` is ``'y'`` in Python 2 and ``b'y'`` in "
"Python 3 (i.e., close enough)."
msgstr ""

#: ../../../howto/pyporting.rst:237
msgid ""
"You cannot concatenate bytes and strings in Python 3. But since Python 2 has "
"bytes aliased to ``str``, it will succeed: ``b'a' + u'b'`` works in Python "
"2, but ``b'a' + 'b'`` in Python 3 is a :exc:`TypeError`. A similar issue "
"also comes about when doing comparisons between bytes and strings."
msgstr ""

#: ../../../howto/pyporting.rst:244
msgid "Supporting `Python 2.5`_ and Newer Only"
msgstr ""

#: ../../../howto/pyporting.rst:246
msgid ""
"If you are supporting `Python 2.5`_ and newer there are still some features "
"of Python that you can utilize."
msgstr ""

#: ../../../howto/pyporting.rst:251
msgid "``from __future__ import absolute_import``"
msgstr ""

#: ../../../howto/pyporting.rst:253
msgid ""
"Implicit relative imports (e.g., importing ``spam.bacon`` from within ``spam."
"eggs`` with the statement ``import bacon``) does not work in Python 3. This "
"future statement moves away from that and allows the use of explicit "
"relative imports (e.g., ``from . import bacon``)."
msgstr ""

#: ../../../howto/pyporting.rst:258
msgid ""
"In `Python 2.5`_ you must use the __future__ statement to get to use "
"explicit relative imports and prevent implicit ones. In `Python 2.6`_ "
"explicit relative imports are available without the statement, but you still "
"want the __future__ statement to prevent implicit relative imports. In "
"`Python 2.7`_ the __future__ statement is not needed. In other words, unless "
"you are only supporting Python 2.7 or a version earlier than Python 2.5, use "
"the __future__ statement."
msgstr ""

#: ../../../howto/pyporting.rst:269
msgid "Handle Common \"Gotchas\""
msgstr ""

#: ../../../howto/pyporting.rst:271
msgid ""
"There are a few things that just consistently come up as sticking points for "
"people which 2to3 cannot handle automatically or can easily be done in "
"Python 2 to help modernize your code."
msgstr ""

#: ../../../howto/pyporting.rst:277
msgid "``from __future__ import division``"
msgstr ""

#: ../../../howto/pyporting.rst:279
msgid ""
"While the exact same outcome can be had by using the ``-Qnew`` argument to "
"Python, using this future statement lifts the requirement that your users "
"use the flag to get the expected behavior of division in Python 3 (e.g., "
"``1/2 == 0.5; 1//2 == 0``)."
msgstr ""

#: ../../../howto/pyporting.rst:287
msgid "Specify when opening a file as binary"
msgstr ""

#: ../../../howto/pyporting.rst:289
msgid ""
"Unless you have been working on Windows, there is a chance you have not "
"always bothered to add the ``b`` mode when opening a binary file (e.g., "
"``rb`` for binary reading).  Under Python 3, binary files and text files are "
"clearly distinct and mutually incompatible; see the :mod:`io` module for "
"details. Therefore, you **must** make a decision of whether a file will be "
"used for binary access (allowing to read and/or write bytes data) or text "
"access (allowing to read and/or write unicode data)."
msgstr ""

#: ../../../howto/pyporting.rst:298
msgid "Text files"
msgstr ""

#: ../../../howto/pyporting.rst:300
msgid ""
"Text files created using ``open()`` under Python 2 return byte strings, "
"while under Python 3 they return unicode strings.  Depending on your porting "
"strategy, this can be an issue."
msgstr ""

#: ../../../howto/pyporting.rst:304
msgid ""
"If you want text files to return unicode strings in Python 2, you have two "
"possibilities:"
msgstr ""

#: ../../../howto/pyporting.rst:307
msgid ""
"Under Python 2.6 and higher, use :func:`io.open`.  Since :func:`io.open` is "
"essentially the same function in both Python 2 and Python 3, it will help "
"iron out any issues that might arise."
msgstr ""

#: ../../../howto/pyporting.rst:311
msgid ""
"If pre-2.6 compatibility is needed, then you should use :func:`codecs.open` "
"instead.  This will make sure that you get back unicode strings in Python 2."
msgstr ""

#: ../../../howto/pyporting.rst:315
msgid "Subclass ``object``"
msgstr ""

#: ../../../howto/pyporting.rst:317
msgid ""
"New-style classes have been around since `Python 2.2`_. You need to make "
"sure you are subclassing from ``object`` to avoid odd edge cases involving "
"method resolution order, etc. This continues to be totally valid in Python 3 "
"(although unneeded as all classes implicitly inherit from ``object``)."
msgstr ""

#: ../../../howto/pyporting.rst:324
msgid "Deal With the Bytes/String Dichotomy"
msgstr ""

#: ../../../howto/pyporting.rst:326
msgid ""
"One of the biggest issues people have when porting code to Python 3 is "
"handling the bytes/string dichotomy. Because Python 2 allowed the ``str`` "
"type to hold textual data, people have over the years been rather loose in "
"their delineation of what ``str`` instances held text compared to bytes. In "
"Python 3 you cannot be so care-free anymore and need to properly handle the "
"difference. The key handling this issue is to make sure that **every** "
"string literal in your Python 2 code is either syntactically of functionally "
"marked as either bytes or text data. After this is done you then need to "
"make sure your APIs are designed to either handle a specific type or made to "
"be properly polymorphic."
msgstr ""

#: ../../../howto/pyporting.rst:338
msgid "Mark Up Python 2 String Literals"
msgstr ""

#: ../../../howto/pyporting.rst:340
msgid ""
"First thing you must do is designate every single string literal in Python 2 "
"as either textual or bytes data. If you are only supporting Python 2.6 or "
"newer, this can be accomplished by marking bytes literals with a ``b`` "
"prefix and then designating textual data with a ``u`` prefix or using the "
"``unicode_literals`` future statement."
msgstr ""

#: ../../../howto/pyporting.rst:346
msgid ""
"If your project supports versions of Python predating 2.6, then you should "
"use the six_ project and its ``b()`` function to denote bytes literals. For "
"text literals you can either use six's ``u()`` function or use a ``u`` "
"prefix."
msgstr ""

#: ../../../howto/pyporting.rst:352
msgid "Decide what APIs Will Accept"
msgstr ""

#: ../../../howto/pyporting.rst:354
msgid ""
"In Python 2 it was very easy to accidentally create an API that accepted "
"both bytes and textual data. But in Python 3, thanks to the more strict "
"handling of disparate types, this loose usage of bytes and text together "
"tends to fail."
msgstr ""

#: ../../../howto/pyporting.rst:358
msgid ""
"Take the dict ``{b'a': 'bytes', u'a': 'text'}`` in Python 2.6. It creates "
"the dict ``{u'a': 'text'}`` since ``b'a' == u'a'``. But in Python 3 the "
"equivalent dict creates ``{b'a': 'bytes', 'a': 'text'}``, i.e., no lost "
"data. Similar issues can crop up when transitioning Python 2 code to Python "
"3."
msgstr ""

#: ../../../howto/pyporting.rst:363
msgid ""
"This means you need to choose what an API is going to accept and create and "
"consistently stick to that API in both Python 2 and 3."
msgstr ""

#: ../../../howto/pyporting.rst:368
msgid "Bytes / Unicode Comparison"
msgstr ""

#: ../../../howto/pyporting.rst:370
msgid ""
"In Python 3, mixing bytes and unicode is forbidden in most situations; it "
"will raise a :class:`TypeError` where Python 2 would have attempted an "
"implicit coercion between types.  However, there is one case where it "
"doesn't and it can be very misleading::"
msgstr ""

#: ../../../howto/pyporting.rst:378
msgid ""
"This is because an equality comparison is required by the language to always "
"succeed (and return ``False`` for incompatible types).  However, this also "
"means that code incorrectly ported to Python 3 can display buggy behaviour "
"if such comparisons are silently executed.  To detect such situations, "
"Python 3 has a ``-b`` flag that will display a warning::"
msgstr ""

#: ../../../howto/pyporting.rst:389
msgid "To turn the warning into an exception, use the ``-bb`` flag instead::"
msgstr ""

#: ../../../howto/pyporting.rst:399
msgid "Indexing bytes objects"
msgstr ""

#: ../../../howto/pyporting.rst:401
msgid ""
"Another potentially surprising change is the indexing behaviour of bytes "
"objects in Python 3::"
msgstr ""

#: ../../../howto/pyporting.rst:407
msgid ""
"Indeed, Python 3 bytes objects (as well as :class:`bytearray` objects) are "
"sequences of integers.  But code converted from Python 2 will often assume "
"that indexing a bytestring produces another bytestring, not an integer.  To "
"reconcile both behaviours, use slicing::"
msgstr ""

#: ../../../howto/pyporting.rst:418
msgid ""
"The only remaining gotcha is that an out-of-bounds slice returns an empty "
"bytes object instead of raising ``IndexError``:"
msgstr ""

#: ../../../howto/pyporting.rst:430
msgid "``__str__()``/``__unicode__()``"
msgstr ""

#: ../../../howto/pyporting.rst:432
msgid ""
"In Python 2, objects can specify both a string and unicode representation of "
"themselves. In Python 3, though, there is only a string representation. This "
"becomes an issue as people can inadvertently do things in their "
"``__str__()`` methods which have unpredictable results (e.g., infinite "
"recursion if you happen to use the ``unicode(self).encode('utf8')`` idiom as "
"the body of your ``__str__()`` method)."
msgstr ""

#: ../../../howto/pyporting.rst:439
msgid ""
"There are two ways to solve this issue. One is to use a custom 2to3 fixer. "
"The blog post at http://lucumr.pocoo.org/2011/1/22/forwards-compatible-"
"python/ specifies how to do this. That will allow 2to3 to change all "
"instances of ``def __unicode(self): ...`` to ``def __str__(self): ...``. "
"This does require that you define your ``__str__()`` method in Python 2 "
"before your ``__unicode__()`` method."
msgstr ""

#: ../../../howto/pyporting.rst:446
msgid ""
"The other option is to use a mixin class. This allows you to only define a "
"``__unicode__()`` method for your class and let the mixin derive "
"``__str__()`` for you (code from http://lucumr.pocoo.org/2011/1/22/forwards-"
"compatible-python/)::"
msgstr ""

#: ../../../howto/pyporting.rst:473
msgid "Don't Index on Exceptions"
msgstr ""

#: ../../../howto/pyporting.rst:475
msgid "In Python 2, the following worked::"
msgstr ""

#: ../../../howto/pyporting.rst:483
msgid ""
"But in Python 3, indexing directly on an exception is an error. You need to "
"make sure to only index on the :attr:`BaseException.args` attribute which is "
"a sequence containing all arguments passed to the :meth:`__init__` method."
msgstr ""

#: ../../../howto/pyporting.rst:487
msgid "Even better is to use the documented attributes the exception provides."
msgstr ""

#: ../../../howto/pyporting.rst:490
msgid "Don't use ``__getslice__`` & Friends"
msgstr ""

#: ../../../howto/pyporting.rst:492
msgid ""
"Been deprecated for a while, but Python 3 finally drops support for "
"``__getslice__()``, etc. Move completely over to :meth:`__getitem__` and "
"friends."
msgstr ""

#: ../../../howto/pyporting.rst:498
msgid "Updating doctests"
msgstr ""

#: ../../../howto/pyporting.rst:500
msgid ""
"2to3_ will attempt to generate fixes for doctests that it comes across. It's "
"not perfect, though. If you wrote a monolithic set of doctests (e.g., a "
"single docstring containing all of your doctests), you should at least "
"consider breaking the doctests up into smaller pieces to make it more "
"manageable to fix. Otherwise it might very well be worth your time and "
"effort to port your tests to :mod:`unittest`."
msgstr ""

#: ../../../howto/pyporting.rst:509
msgid "Update `map` for imbalanced input sequences"
msgstr ""

#: ../../../howto/pyporting.rst:511
msgid ""
"With Python 2, `map` would pad input sequences of unequal length with `None` "
"values, returning a sequence as long as the longest input sequence."
msgstr ""

#: ../../../howto/pyporting.rst:514
msgid ""
"With Python 3, if the input sequences to `map` are of unequal length, `map` "
"will stop at the termination of the shortest of the sequences. For full "
"compatibility with `map` from Python 2.x, also wrap the sequences in :func:"
"`itertools.zip_longest`, e.g. ``map(func, *sequences)`` becomes "
"``list(map(func, itertools.zip_longest(*sequences)))``."
msgstr ""

#: ../../../howto/pyporting.rst:521
msgid "Eliminate ``-3`` Warnings"
msgstr ""

#: ../../../howto/pyporting.rst:523
msgid ""
"When you run your application's test suite, run it using the ``-3`` flag "
"passed to Python. This will cause various warnings to be raised during "
"execution about things that 2to3 cannot handle automatically (e.g., modules "
"that have been removed). Try to eliminate those warnings to make your code "
"even more portable to Python 3."
msgstr ""

#: ../../../howto/pyporting.rst:531
msgid "Run 2to3"
msgstr ""

#: ../../../howto/pyporting.rst:533
msgid ""
"Once you have made your Python 2 code future-compatible with Python 3, it's "
"time to use 2to3_ to actually port your code."
msgstr ""

#: ../../../howto/pyporting.rst:538
msgid "Manually"
msgstr ""

#: ../../../howto/pyporting.rst:540
msgid ""
"To manually convert source code using 2to3_, you use the ``2to3`` script "
"that is installed with Python 2.6 and later.::"
msgstr ""

#: ../../../howto/pyporting.rst:545
msgid ""
"This will cause 2to3 to write out a diff with all of the fixers applied for "
"the converted source code. If you would like 2to3 to go ahead and apply the "
"changes you can pass it the ``-w`` flag::"
msgstr ""

#: ../../../howto/pyporting.rst:551
msgid ""
"There are other flags available to control exactly which fixers are applied, "
"etc."
msgstr ""

#: ../../../howto/pyporting.rst:556
msgid "During Installation"
msgstr ""

#: ../../../howto/pyporting.rst:558
msgid ""
"When a user installs your project for Python 3, you can have either :mod:"
"`distutils` or Distribute_ run 2to3_ on your behalf. For distutils, use the "
"following idiom::"
msgstr ""

#: ../../../howto/pyporting.rst:571
msgid "For Distribute::"
msgstr ""

#: ../../../howto/pyporting.rst:577
msgid ""
"This will allow you to not have to distribute a separate Python 3 version of "
"your project. It does require, though, that when you perform development "
"that you at least build your project and use the built Python 3 source for "
"testing."
msgstr ""

#: ../../../howto/pyporting.rst:583
msgid "Verify & Test"
msgstr ""

#: ../../../howto/pyporting.rst:585
msgid ""
"At this point you should (hopefully) have your project converted in such a "
"way that it works in Python 3. Verify it by running your unit tests and "
"making sure nothing has gone awry. If you miss something then figure out how "
"to fix it in Python 3, backport to your Python 2 code, and run your code "
"through 2to3 again to verify the fix transforms properly."
msgstr ""

#: ../../../howto/pyporting.rst:599
msgid "Python 2/3 Compatible Source"
msgstr ""

#: ../../../howto/pyporting.rst:601
msgid ""
"While it may seem counter-intuitive, you can write Python code which is "
"source-compatible between Python 2 & 3. It does lead to code that is not "
"entirely idiomatic Python (e.g., having to extract the currently raised "
"exception from ``sys.exc_info()[1]``), but it can be run under Python 2 "
"**and** Python 3 without using 2to3_ as a translation step (although the "
"tool should be used to help find potential portability problems). This "
"allows you to continue to have a rapid development process regardless of "
"whether you are developing under Python 2 or Python 3. Whether this approach "
"or using :ref:`use_2to3` works best for you will be a per-project decision."
msgstr ""

#: ../../../howto/pyporting.rst:611
msgid ""
"To get a complete idea of what issues you will need to deal with, see the "
"`What's New in Python 3.0`_. Others have reorganized the data in other "
"formats such as http://docs.pythonsprints.com/python3_porting/py-porting."
"html ."
msgstr ""

#: ../../../howto/pyporting.rst:615
msgid ""
"The following are some steps to take to try to support both Python 2 & 3 "
"from the same source code."
msgstr ""

#: ../../../howto/pyporting.rst:623
msgid "Follow The Steps for Using 2to3_"
msgstr ""

#: ../../../howto/pyporting.rst:625
msgid ""
"All of the steps outlined in how to :ref:`port Python 2 code with 2to3 "
"<use_2to3>` apply to creating a Python 2/3 codebase. This includes trying "
"only support Python 2.6 or newer (the :mod:`__future__` statements work in "
"Python 3 without issue), eliminating warnings that are triggered by ``-3``, "
"etc."
msgstr ""

#: ../../../howto/pyporting.rst:631
msgid ""
"You should even consider running 2to3_ over your code (without committing "
"the changes). This will let you know where potential pain points are within "
"your code so that you can fix them properly before they become an issue."
msgstr ""

#: ../../../howto/pyporting.rst:637
msgid "Use six_"
msgstr ""

#: ../../../howto/pyporting.rst:639
msgid ""
"The six_ project contains many things to help you write portable Python "
"code. You should make sure to read its documentation from beginning to end "
"and use any and all features it provides. That way you will minimize any "
"mistakes you might make in writing cross-version code."
msgstr ""

#: ../../../howto/pyporting.rst:646
msgid "Capturing the Currently Raised Exception"
msgstr ""

#: ../../../howto/pyporting.rst:648
msgid ""
"One change between Python 2 and 3 that will require changing how you code "
"(if you support `Python 2.5`_ and earlier) is accessing the currently raised "
"exception.  In Python 2.5 and earlier the syntax to access the current "
"exception is::"
msgstr ""

#: ../../../howto/pyporting.rst:659
msgid ""
"This syntax changed in Python 3 (and backported to `Python 2.6`_ and later) "
"to::"
msgstr ""

#: ../../../howto/pyporting.rst:669
msgid ""
"Because of this syntax change you must change to capturing the current "
"exception to::"
msgstr ""

#: ../../../howto/pyporting.rst:680
msgid ""
"You can get more information about the raised exception from :func:`sys."
"exc_info` than simply the current exception instance, but you most likely "
"don't need it."
msgstr ""

#: ../../../howto/pyporting.rst:685
msgid ""
"In Python 3, the traceback is attached to the exception instance through the "
"``__traceback__`` attribute. If the instance is saved in a local variable "
"that persists outside of the ``except`` block, the traceback will create a "
"reference cycle with the current frame and its dictionary of local "
"variables.  This will delay reclaiming dead resources until the next cyclic :"
"term:`garbage collection` pass."
msgstr ""

#: ../../../howto/pyporting.rst:692
msgid ""
"In Python 2, this problem only occurs if you save the traceback itself (e.g. "
"the third element of the tuple returned by :func:`sys.exc_info`) in a "
"variable."
msgstr ""

#: ../../../howto/pyporting.rst:698
msgid "Other Resources"
msgstr ""

#: ../../../howto/pyporting.rst:700
msgid ""
"The authors of the following blog posts, wiki pages, and books deserve "
"special thanks for making public their tips for porting Python 2 code to "
"Python 3 (and thus helping provide information for this document):"
msgstr ""

#: ../../../howto/pyporting.rst:704
msgid "http://python3porting.com/"
msgstr ""

#: ../../../howto/pyporting.rst:705
msgid "http://docs.pythonsprints.com/python3_porting/py-porting.html"
msgstr ""

#: ../../../howto/pyporting.rst:706
msgid ""
"http://techspot.zzzeek.org/2011/01/24/zzzeek-s-guide-to-python-3-porting/"
msgstr ""

#: ../../../howto/pyporting.rst:707
msgid ""
"http://dabeaz.blogspot.com/2011/01/porting-py65-and-my-superboard-to.html"
msgstr ""

#: ../../../howto/pyporting.rst:708
msgid "http://lucumr.pocoo.org/2011/1/22/forwards-compatible-python/"
msgstr ""

#: ../../../howto/pyporting.rst:709
msgid "http://lucumr.pocoo.org/2010/2/11/porting-to-python-3-a-guide/"
msgstr ""

#: ../../../howto/pyporting.rst:710
msgid "http://wiki.python.org/moin/PortingPythonToPy3k"
msgstr ""

#: ../../../howto/pyporting.rst:712
msgid ""
"If you feel there is something missing from this document that should be "
"added, please email the python-porting_ mailing list."
msgstr ""

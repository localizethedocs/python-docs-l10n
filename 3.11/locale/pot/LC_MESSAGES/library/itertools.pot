# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-10 15:09+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../library/itertools.rst:2
msgid ":mod:`itertools` --- Functions creating iterators for efficient looping"
msgstr ""

#: ../../../library/itertools.rst:20
msgid ""
"This module implements a number of :term:`iterator` building blocks inspired "
"by constructs from APL, Haskell, and SML.  Each has been recast in a form "
"suitable for Python."
msgstr ""

#: ../../../library/itertools.rst:24
msgid ""
"The module standardizes a core set of fast, memory efficient tools that are "
"useful by themselves or in combination.  Together, they form an \"iterator "
"algebra\" making it possible to construct specialized tools succinctly and "
"efficiently in pure Python."
msgstr ""

#: ../../../library/itertools.rst:29
msgid ""
"For instance, SML provides a tabulation tool: ``tabulate(f)`` which produces "
"a sequence ``f(0), f(1), ...``.  The same effect can be achieved in Python "
"by combining :func:`map` and :func:`count` to form ``map(f, count())``."
msgstr ""

#: ../../../library/itertools.rst:33
msgid ""
"These tools and their built-in counterparts also work well with the high-"
"speed functions in the :mod:`operator` module.  For example, the "
"multiplication operator can be mapped across two vectors to form an "
"efficient dot-product: ``sum(starmap(operator.mul, zip(vec1, vec2, "
"strict=True)))``."
msgstr ""

#: ../../../library/itertools.rst:39
msgid "**Infinite iterators:**"
msgstr ""

#: ../../../library/itertools.rst:42 ../../../library/itertools.rst:52
#: ../../../library/itertools.rst:72
msgid "Iterator"
msgstr ""

#: ../../../library/itertools.rst:42 ../../../library/itertools.rst:52
#: ../../../library/itertools.rst:72
msgid "Arguments"
msgstr ""

#: ../../../library/itertools.rst:42 ../../../library/itertools.rst:52
#: ../../../library/itertools.rst:72 ../../../library/itertools.rst:81
msgid "Results"
msgstr ""

#: ../../../library/itertools.rst:42 ../../../library/itertools.rst:52
msgid "Example"
msgstr ""

#: ../../../library/itertools.rst:44
msgid ":func:`count`"
msgstr ""

#: ../../../library/itertools.rst:44
msgid "start, [step]"
msgstr ""

#: ../../../library/itertools.rst:44
msgid "start, start+step, start+2*step, ..."
msgstr ""

#: ../../../library/itertools.rst:44
msgid "``count(10) --> 10 11 12 13 14 ...``"
msgstr ""

#: ../../../library/itertools.rst:45
msgid ":func:`cycle`"
msgstr ""

#: ../../../library/itertools.rst:45
msgid "p"
msgstr ""

#: ../../../library/itertools.rst:45
msgid "p0, p1, ... plast, p0, p1, ..."
msgstr ""

#: ../../../library/itertools.rst:45
msgid "``cycle('ABCD') --> A B C D A B C D ...``"
msgstr ""

#: ../../../library/itertools.rst:46
msgid ":func:`repeat`"
msgstr ""

#: ../../../library/itertools.rst:46
msgid "elem [,n]"
msgstr ""

#: ../../../library/itertools.rst:46
msgid "elem, elem, elem, ... endlessly or up to n times"
msgstr ""

#: ../../../library/itertools.rst:46
msgid "``repeat(10, 3) --> 10 10 10``"
msgstr ""

#: ../../../library/itertools.rst:49
msgid "**Iterators terminating on the shortest input sequence:**"
msgstr ""

#: ../../../library/itertools.rst:54
msgid ":func:`accumulate`"
msgstr ""

#: ../../../library/itertools.rst:54
msgid "p [,func]"
msgstr ""

#: ../../../library/itertools.rst:54
msgid "p0, p0+p1, p0+p1+p2, ..."
msgstr ""

#: ../../../library/itertools.rst:54
msgid "``accumulate([1,2,3,4,5]) --> 1 3 6 10 15``"
msgstr ""

#: ../../../library/itertools.rst:55
msgid ":func:`chain`"
msgstr ""

#: ../../../library/itertools.rst:55 ../../../library/itertools.rst:66
msgid "p, q, ..."
msgstr ""

#: ../../../library/itertools.rst:55 ../../../library/itertools.rst:56
msgid "p0, p1, ... plast, q0, q1, ..."
msgstr ""

#: ../../../library/itertools.rst:55
msgid "``chain('ABC', 'DEF') --> A B C D E F``"
msgstr ""

#: ../../../library/itertools.rst:56
msgid ":func:`chain.from_iterable`"
msgstr ""

#: ../../../library/itertools.rst:56 ../../../library/itertools.rst:62
msgid "iterable"
msgstr ""

#: ../../../library/itertools.rst:56
msgid "``chain.from_iterable(['ABC', 'DEF']) --> A B C D E F``"
msgstr ""

#: ../../../library/itertools.rst:57
msgid ":func:`compress`"
msgstr ""

#: ../../../library/itertools.rst:57
msgid "data, selectors"
msgstr ""

#: ../../../library/itertools.rst:57
msgid "(d[0] if s[0]), (d[1] if s[1]), ..."
msgstr ""

#: ../../../library/itertools.rst:57
msgid "``compress('ABCDEF', [1,0,1,0,1,1]) --> A C E F``"
msgstr ""

#: ../../../library/itertools.rst:58
msgid ":func:`dropwhile`"
msgstr ""

#: ../../../library/itertools.rst:58 ../../../library/itertools.rst:59
#: ../../../library/itertools.rst:64
msgid "pred, seq"
msgstr ""

#: ../../../library/itertools.rst:58
msgid "seq[n], seq[n+1], starting when pred fails"
msgstr ""

#: ../../../library/itertools.rst:58
msgid "``dropwhile(lambda x: x<5, [1,4,6,4,1]) --> 6 4 1``"
msgstr ""

#: ../../../library/itertools.rst:59
msgid ":func:`filterfalse`"
msgstr ""

#: ../../../library/itertools.rst:59
msgid "elements of seq where pred(elem) is false"
msgstr ""

#: ../../../library/itertools.rst:59
msgid "``filterfalse(lambda x: x%2, range(10)) --> 0 2 4 6 8``"
msgstr ""

#: ../../../library/itertools.rst:60
msgid ":func:`groupby`"
msgstr ""

#: ../../../library/itertools.rst:60
msgid "iterable[, key]"
msgstr ""

#: ../../../library/itertools.rst:60
msgid "sub-iterators grouped by value of key(v)"
msgstr ""

#: ../../../library/itertools.rst:61
msgid ":func:`islice`"
msgstr ""

#: ../../../library/itertools.rst:61
msgid "seq, [start,] stop [, step]"
msgstr ""

#: ../../../library/itertools.rst:61
msgid "elements from seq[start:stop:step]"
msgstr ""

#: ../../../library/itertools.rst:61
msgid "``islice('ABCDEFG', 2, None) --> C D E F G``"
msgstr ""

#: ../../../library/itertools.rst:62
msgid ":func:`pairwise`"
msgstr ""

#: ../../../library/itertools.rst:62
msgid "(p[0], p[1]), (p[1], p[2])"
msgstr ""

#: ../../../library/itertools.rst:62
msgid "``pairwise('ABCDEFG') --> AB BC CD DE EF FG``"
msgstr ""

#: ../../../library/itertools.rst:63
msgid ":func:`starmap`"
msgstr ""

#: ../../../library/itertools.rst:63
msgid "func, seq"
msgstr ""

#: ../../../library/itertools.rst:63
msgid "func(\\*seq[0]), func(\\*seq[1]), ..."
msgstr ""

#: ../../../library/itertools.rst:63
msgid "``starmap(pow, [(2,5), (3,2), (10,3)]) --> 32 9 1000``"
msgstr ""

#: ../../../library/itertools.rst:64
msgid ":func:`takewhile`"
msgstr ""

#: ../../../library/itertools.rst:64
msgid "seq[0], seq[1], until pred fails"
msgstr ""

#: ../../../library/itertools.rst:64
msgid "``takewhile(lambda x: x<5, [1,4,6,4,1]) --> 1 4``"
msgstr ""

#: ../../../library/itertools.rst:65
msgid ":func:`tee`"
msgstr ""

#: ../../../library/itertools.rst:65
msgid "it, n"
msgstr ""

#: ../../../library/itertools.rst:65
msgid "it1, it2, ... itn  splits one iterator into n"
msgstr ""

#: ../../../library/itertools.rst:66
msgid ":func:`zip_longest`"
msgstr ""

#: ../../../library/itertools.rst:66
msgid "(p[0], q[0]), (p[1], q[1]), ..."
msgstr ""

#: ../../../library/itertools.rst:66
msgid "``zip_longest('ABCD', 'xy', fillvalue='-') --> Ax By C- D-``"
msgstr ""

#: ../../../library/itertools.rst:69
msgid "**Combinatoric iterators:**"
msgstr ""

#: ../../../library/itertools.rst:74
msgid ":func:`product`"
msgstr ""

#: ../../../library/itertools.rst:74
msgid "p, q, ... [repeat=1]"
msgstr ""

#: ../../../library/itertools.rst:74
msgid "cartesian product, equivalent to a nested for-loop"
msgstr ""

#: ../../../library/itertools.rst:75
msgid ":func:`permutations`"
msgstr ""

#: ../../../library/itertools.rst:75
msgid "p[, r]"
msgstr ""

#: ../../../library/itertools.rst:75
msgid "r-length tuples, all possible orderings, no repeated elements"
msgstr ""

#: ../../../library/itertools.rst:76
msgid ":func:`combinations`"
msgstr ""

#: ../../../library/itertools.rst:76 ../../../library/itertools.rst:77
msgid "p, r"
msgstr ""

#: ../../../library/itertools.rst:76
msgid "r-length tuples, in sorted order, no repeated elements"
msgstr ""

#: ../../../library/itertools.rst:77
msgid ":func:`combinations_with_replacement`"
msgstr ""

#: ../../../library/itertools.rst:77
msgid "r-length tuples, in sorted order, with repeated elements"
msgstr ""

#: ../../../library/itertools.rst:81
msgid "Examples"
msgstr ""

#: ../../../library/itertools.rst:83
msgid "``product('ABCD', repeat=2)``"
msgstr ""

#: ../../../library/itertools.rst:83
msgid "``AA AB AC AD BA BB BC BD CA CB CC CD DA DB DC DD``"
msgstr ""

#: ../../../library/itertools.rst:84
msgid "``permutations('ABCD', 2)``"
msgstr ""

#: ../../../library/itertools.rst:84
msgid "``AB AC AD BA BC BD CA CB CD DA DB DC``"
msgstr ""

#: ../../../library/itertools.rst:85
msgid "``combinations('ABCD', 2)``"
msgstr ""

#: ../../../library/itertools.rst:85
msgid "``AB AC AD BC BD CD``"
msgstr ""

#: ../../../library/itertools.rst:86
msgid "``combinations_with_replacement('ABCD', 2)``"
msgstr ""

#: ../../../library/itertools.rst:86
msgid "``AA AB AC AD BB BC BD CC CD DD``"
msgstr ""

#: ../../../library/itertools.rst:93
msgid "Itertool functions"
msgstr ""

#: ../../../library/itertools.rst:95
msgid ""
"The following module functions all construct and return iterators. Some "
"provide streams of infinite length, so they should only be accessed by "
"functions or loops that truncate the stream."
msgstr ""

#: ../../../library/itertools.rst:101
msgid ""
"Make an iterator that returns accumulated sums, or accumulated results of "
"other binary functions (specified via the optional *func* argument)."
msgstr ""

#: ../../../library/itertools.rst:105
msgid ""
"If *func* is supplied, it should be a function of two arguments. Elements of "
"the input *iterable* may be any type that can be accepted as arguments to "
"*func*. (For example, with the default operation of addition, elements may "
"be any addable type including :class:`~decimal.Decimal` or :class:"
"`~fractions.Fraction`.)"
msgstr ""

#: ../../../library/itertools.rst:112
msgid ""
"Usually, the number of elements output matches the input iterable. However, "
"if the keyword argument *initial* is provided, the accumulation leads off "
"with the *initial* value so that the output has one more element than the "
"input iterable."
msgstr ""

#: ../../../library/itertools.rst:117 ../../../library/itertools.rst:203
#: ../../../library/itertools.rst:252 ../../../library/itertools.rst:452
#: ../../../library/itertools.rst:488 ../../../library/itertools.rst:515
#: ../../../library/itertools.rst:595
msgid "Roughly equivalent to::"
msgstr ""

#: ../../../library/itertools.rst:119
msgid ""
"def accumulate(iterable, func=operator.add, *, initial=None):\n"
"    'Return running totals'\n"
"    # accumulate([1,2,3,4,5]) --> 1 3 6 10 15\n"
"    # accumulate([1,2,3,4,5], initial=100) --> 100 101 103 106 110 115\n"
"    # accumulate([1,2,3,4,5], operator.mul) --> 1 2 6 24 120\n"
"    it = iter(iterable)\n"
"    total = initial\n"
"    if initial is None:\n"
"        try:\n"
"            total = next(it)\n"
"        except StopIteration:\n"
"            return\n"
"    yield total\n"
"    for element in it:\n"
"        total = func(total, element)\n"
"        yield total"
msgstr ""

#: ../../../library/itertools.rst:136
msgid ""
"There are a number of uses for the *func* argument.  It can be set to :func:"
"`min` for a running minimum, :func:`max` for a running maximum, or :func:"
"`operator.mul` for a running product.  Amortization tables can be built by "
"accumulating interest and applying payments:"
msgstr ""

#: ../../../library/itertools.rst:141
msgid ""
">>> data = [3, 4, 6, 2, 1, 9, 0, 7, 5, 8]\n"
">>> list(accumulate(data, operator.mul))     # running product\n"
"[3, 12, 72, 144, 144, 1296, 0, 0, 0, 0]\n"
">>> list(accumulate(data, max))              # running maximum\n"
"[3, 4, 6, 6, 6, 9, 9, 9, 9, 9]\n"
"\n"
"# Amortize a 5% loan of 1000 with 4 annual payments of 90\n"
">>> cashflows = [1000, -90, -90, -90, -90]\n"
">>> list(accumulate(cashflows, lambda bal, pmt: bal*1.05 + pmt))\n"
"[1000, 960.0, 918.0, 873.9000000000001, 827.5950000000001]"
msgstr ""

#: ../../../library/itertools.rst:154
msgid ""
"See :func:`functools.reduce` for a similar function that returns only the "
"final accumulated value."
msgstr ""

#: ../../../library/itertools.rst:159
msgid "Added the optional *func* parameter."
msgstr ""

#: ../../../library/itertools.rst:162
msgid "Added the optional *initial* parameter."
msgstr ""

#: ../../../library/itertools.rst:167
msgid ""
"Make an iterator that returns elements from the first iterable until it is "
"exhausted, then proceeds to the next iterable, until all of the iterables "
"are exhausted.  Used for treating consecutive sequences as a single "
"sequence. Roughly equivalent to::"
msgstr ""

#: ../../../library/itertools.rst:172
msgid ""
"def chain(*iterables):\n"
"    # chain('ABC', 'DEF') --> A B C D E F\n"
"    for it in iterables:\n"
"        for element in it:\n"
"            yield element"
msgstr ""

#: ../../../library/itertools.rst:181
msgid ""
"Alternate constructor for :func:`chain`.  Gets chained inputs from a single "
"iterable argument that is evaluated lazily.  Roughly equivalent to::"
msgstr ""

#: ../../../library/itertools.rst:184
msgid ""
"def from_iterable(iterables):\n"
"    # chain.from_iterable(['ABC', 'DEF']) --> A B C D E F\n"
"    for it in iterables:\n"
"        for element in it:\n"
"            yield element"
msgstr ""

#: ../../../library/itertools.rst:193
msgid "Return *r* length subsequences of elements from the input *iterable*."
msgstr ""

#: ../../../library/itertools.rst:195 ../../../library/itertools.rst:244
msgid ""
"The combination tuples are emitted in lexicographic ordering according to "
"the order of the input *iterable*. So, if the input *iterable* is sorted, "
"the output tuples will be produced in sorted order."
msgstr ""

#: ../../../library/itertools.rst:199
msgid ""
"Elements are treated as unique based on their position, not on their value.  "
"So if the input elements are unique, there will be no repeated values in "
"each combination."
msgstr ""

#: ../../../library/itertools.rst:205
msgid ""
"def combinations(iterable, r):\n"
"    # combinations('ABCD', 2) --> AB AC AD BC BD CD\n"
"    # combinations(range(4), 3) --> 012 013 023 123\n"
"    pool = tuple(iterable)\n"
"    n = len(pool)\n"
"    if r > n:\n"
"        return\n"
"    indices = list(range(r))\n"
"    yield tuple(pool[i] for i in indices)\n"
"    while True:\n"
"        for i in reversed(range(r)):\n"
"            if indices[i] != i + n - r:\n"
"                break\n"
"        else:\n"
"            return\n"
"        indices[i] += 1\n"
"        for j in range(i+1, r):\n"
"            indices[j] = indices[j-1] + 1\n"
"        yield tuple(pool[i] for i in indices)"
msgstr ""

#: ../../../library/itertools.rst:225
msgid ""
"The code for :func:`combinations` can be also expressed as a subsequence of :"
"func:`permutations` after filtering entries where the elements are not in "
"sorted order (according to their position in the input pool)::"
msgstr ""

#: ../../../library/itertools.rst:229
msgid ""
"def combinations(iterable, r):\n"
"    pool = tuple(iterable)\n"
"    n = len(pool)\n"
"    for indices in permutations(range(n), r):\n"
"        if sorted(indices) == list(indices):\n"
"            yield tuple(pool[i] for i in indices)"
msgstr ""

#: ../../../library/itertools.rst:236
msgid ""
"The number of items returned is ``n! / r! / (n-r)!`` when ``0 <= r <= n`` or "
"zero when ``r > n``."
msgstr ""

#: ../../../library/itertools.rst:241
msgid ""
"Return *r* length subsequences of elements from the input *iterable* "
"allowing individual elements to be repeated more than once."
msgstr ""

#: ../../../library/itertools.rst:248
msgid ""
"Elements are treated as unique based on their position, not on their value.  "
"So if the input elements are unique, the generated combinations will also be "
"unique."
msgstr ""

#: ../../../library/itertools.rst:254
msgid ""
"def combinations_with_replacement(iterable, r):\n"
"    # combinations_with_replacement('ABC', 2) --> AA AB AC BB BC CC\n"
"    pool = tuple(iterable)\n"
"    n = len(pool)\n"
"    if not n and r:\n"
"        return\n"
"    indices = [0] * r\n"
"    yield tuple(pool[i] for i in indices)\n"
"    while True:\n"
"        for i in reversed(range(r)):\n"
"            if indices[i] != n - 1:\n"
"                break\n"
"        else:\n"
"            return\n"
"        indices[i:] = [indices[i] + 1] * (r - i)\n"
"        yield tuple(pool[i] for i in indices)"
msgstr ""

#: ../../../library/itertools.rst:271
msgid ""
"The code for :func:`combinations_with_replacement` can be also expressed as "
"a subsequence of :func:`product` after filtering entries where the elements "
"are not in sorted order (according to their position in the input pool)::"
msgstr ""

#: ../../../library/itertools.rst:275
msgid ""
"def combinations_with_replacement(iterable, r):\n"
"    pool = tuple(iterable)\n"
"    n = len(pool)\n"
"    for indices in product(range(n), repeat=r):\n"
"        if sorted(indices) == list(indices):\n"
"            yield tuple(pool[i] for i in indices)"
msgstr ""

#: ../../../library/itertools.rst:282
msgid ""
"The number of items returned is ``(n+r-1)! / r! / (n-1)!`` when ``n > 0``."
msgstr ""

#: ../../../library/itertools.rst:289
msgid ""
"Make an iterator that filters elements from *data* returning only those that "
"have a corresponding element in *selectors* that evaluates to ``True``. "
"Stops when either the *data* or *selectors* iterables has been exhausted. "
"Roughly equivalent to::"
msgstr ""

#: ../../../library/itertools.rst:294
msgid ""
"def compress(data, selectors):\n"
"    # compress('ABCDEF', [1,0,1,0,1,1]) --> A C E F\n"
"    return (d for d, s in zip(data, selectors) if s)"
msgstr ""

#: ../../../library/itertools.rst:303
msgid ""
"Make an iterator that returns evenly spaced values starting with number "
"*start*. Often used as an argument to :func:`map` to generate consecutive "
"data points. Also, used with :func:`zip` to add sequence numbers.  Roughly "
"equivalent to::"
msgstr ""

#: ../../../library/itertools.rst:307
msgid ""
"def count(start=0, step=1):\n"
"    # count(10) --> 10 11 12 13 14 ...\n"
"    # count(2.5, 0.5) --> 2.5 3.0 3.5 ...\n"
"    n = start\n"
"    while True:\n"
"        yield n\n"
"        n += step"
msgstr ""

#: ../../../library/itertools.rst:315
msgid ""
"When counting with floating point numbers, better accuracy can sometimes be "
"achieved by substituting multiplicative code such as: ``(start + step * i "
"for i in count())``."
msgstr ""

#: ../../../library/itertools.rst:319
msgid "Added *step* argument and allowed non-integer arguments."
msgstr ""

#: ../../../library/itertools.rst:324
msgid ""
"Make an iterator returning elements from the iterable and saving a copy of "
"each. When the iterable is exhausted, return elements from the saved copy.  "
"Repeats indefinitely.  Roughly equivalent to::"
msgstr ""

#: ../../../library/itertools.rst:328
msgid ""
"def cycle(iterable):\n"
"    # cycle('ABCD') --> A B C D A B C D A B C D ...\n"
"    saved = []\n"
"    for element in iterable:\n"
"        yield element\n"
"        saved.append(element)\n"
"    while saved:\n"
"        for element in saved:\n"
"              yield element"
msgstr ""

#: ../../../library/itertools.rst:338
msgid ""
"Note, this member of the toolkit may require significant auxiliary storage "
"(depending on the length of the iterable)."
msgstr ""

#: ../../../library/itertools.rst:344
msgid ""
"Make an iterator that drops elements from the iterable as long as the "
"predicate is true; afterwards, returns every element.  Note, the iterator "
"does not produce *any* output until the predicate first becomes false, so it "
"may have a lengthy start-up time.  Roughly equivalent to::"
msgstr ""

#: ../../../library/itertools.rst:349
msgid ""
"def dropwhile(predicate, iterable):\n"
"    # dropwhile(lambda x: x<5, [1,4,6,4,1]) --> 6 4 1\n"
"    iterable = iter(iterable)\n"
"    for x in iterable:\n"
"        if not predicate(x):\n"
"            yield x\n"
"            break\n"
"    for x in iterable:\n"
"        yield x"
msgstr ""

#: ../../../library/itertools.rst:361
msgid ""
"Make an iterator that filters elements from iterable returning only those "
"for which the predicate is false. If *predicate* is ``None``, return the "
"items that are false. Roughly equivalent to::"
msgstr ""

#: ../../../library/itertools.rst:365
msgid ""
"def filterfalse(predicate, iterable):\n"
"    # filterfalse(lambda x: x%2, range(10)) --> 0 2 4 6 8\n"
"    if predicate is None:\n"
"        predicate = bool\n"
"    for x in iterable:\n"
"        if not predicate(x):\n"
"            yield x"
msgstr ""

#: ../../../library/itertools.rst:376
msgid ""
"Make an iterator that returns consecutive keys and groups from the "
"*iterable*. The *key* is a function computing a key value for each element.  "
"If not specified or is ``None``, *key* defaults to an identity function and "
"returns the element unchanged.  Generally, the iterable needs to already be "
"sorted on the same key function."
msgstr ""

#: ../../../library/itertools.rst:382
msgid ""
"The operation of :func:`groupby` is similar to the ``uniq`` filter in Unix.  "
"It generates a break or new group every time the value of the key function "
"changes (which is why it is usually necessary to have sorted the data using "
"the same key function).  That behavior differs from SQL's GROUP BY which "
"aggregates common elements regardless of their input order."
msgstr ""

#: ../../../library/itertools.rst:388
msgid ""
"The returned group is itself an iterator that shares the underlying iterable "
"with :func:`groupby`.  Because the source is shared, when the :func:"
"`groupby` object is advanced, the previous group is no longer visible.  So, "
"if that data is needed later, it should be stored as a list::"
msgstr ""

#: ../../../library/itertools.rst:393
msgid ""
"groups = []\n"
"uniquekeys = []\n"
"data = sorted(data, key=keyfunc)\n"
"for k, g in groupby(data, keyfunc):\n"
"    groups.append(list(g))      # Store group iterator as a list\n"
"    uniquekeys.append(k)"
msgstr ""

#: ../../../library/itertools.rst:400
msgid ":func:`groupby` is roughly equivalent to::"
msgstr ""

#: ../../../library/itertools.rst:402
msgid ""
"class groupby:\n"
"    # [k for k, g in groupby('AAAABBBCCDAABBB')] --> A B C D A B\n"
"    # [list(g) for k, g in groupby('AAAABBBCCD')] --> AAAA BBB CC D\n"
"\n"
"    def __init__(self, iterable, key=None):\n"
"        if key is None:\n"
"            key = lambda x: x\n"
"        self.keyfunc = key\n"
"        self.it = iter(iterable)\n"
"        self.tgtkey = self.currkey = self.currvalue = object()\n"
"\n"
"    def __iter__(self):\n"
"        return self\n"
"\n"
"    def __next__(self):\n"
"        self.id = object()\n"
"        while self.currkey == self.tgtkey:\n"
"            self.currvalue = next(self.it)    # Exit on StopIteration\n"
"            self.currkey = self.keyfunc(self.currvalue)\n"
"        self.tgtkey = self.currkey\n"
"        return (self.currkey, self._grouper(self.tgtkey, self.id))\n"
"\n"
"    def _grouper(self, tgtkey, id):\n"
"        while self.id is id and self.currkey == tgtkey:\n"
"            yield self.currvalue\n"
"            try:\n"
"                self.currvalue = next(self.it)\n"
"            except StopIteration:\n"
"                return\n"
"            self.currkey = self.keyfunc(self.currvalue)"
msgstr ""

#: ../../../library/itertools.rst:437
msgid ""
"Make an iterator that returns selected elements from the iterable. If "
"*start* is non-zero, then elements from the iterable are skipped until start "
"is reached. Afterward, elements are returned consecutively unless *step* is "
"set higher than one which results in items being skipped.  If *stop* is "
"``None``, then iteration continues until the iterator is exhausted, if at "
"all; otherwise, it stops at the specified position."
msgstr ""

#: ../../../library/itertools.rst:444
msgid ""
"If *start* is ``None``, then iteration starts at zero. If *step* is "
"``None``, then the step defaults to one."
msgstr ""

#: ../../../library/itertools.rst:447
msgid ""
"Unlike regular slicing, :func:`islice` does not support negative values for "
"*start*, *stop*, or *step*.  Can be used to extract related fields from data "
"where the internal structure has been flattened (for example, a multi-line "
"report may list a name field on every third line)."
msgstr ""

#: ../../../library/itertools.rst:454
msgid ""
"def islice(iterable, *args):\n"
"    # islice('ABCDEFG', 2) --> A B\n"
"    # islice('ABCDEFG', 2, 4) --> C D\n"
"    # islice('ABCDEFG', 2, None) --> C D E F G\n"
"    # islice('ABCDEFG', 0, None, 2) --> A C E G\n"
"    s = slice(*args)\n"
"    start, stop, step = s.start or 0, s.stop or sys.maxsize, s.step or 1\n"
"    it = iter(range(start, stop, step))\n"
"    try:\n"
"        nexti = next(it)\n"
"    except StopIteration:\n"
"        # Consume *iterable* up to the *start* position.\n"
"        for i, element in zip(range(start), iterable):\n"
"            pass\n"
"        return\n"
"    try:\n"
"        for i, element in enumerate(iterable):\n"
"            if i == nexti:\n"
"                yield element\n"
"                nexti = next(it)\n"
"    except StopIteration:\n"
"        # Consume to *stop*.\n"
"        for i, element in zip(range(i + 1, stop), iterable):\n"
"            pass"
msgstr ""

#: ../../../library/itertools.rst:482
msgid "Return successive overlapping pairs taken from the input *iterable*."
msgstr ""

#: ../../../library/itertools.rst:484
msgid ""
"The number of 2-tuples in the output iterator will be one fewer than the "
"number of inputs.  It will be empty if the input iterable has fewer than two "
"values."
msgstr ""

#: ../../../library/itertools.rst:490
msgid ""
"def pairwise(iterable):\n"
"    # pairwise('ABCDEFG') --> AB BC CD DE EF FG\n"
"    a, b = tee(iterable)\n"
"    next(b, None)\n"
"    return zip(a, b)"
msgstr ""

#: ../../../library/itertools.rst:501
msgid ""
"Return successive *r* length permutations of elements in the *iterable*."
msgstr ""

#: ../../../library/itertools.rst:503
msgid ""
"If *r* is not specified or is ``None``, then *r* defaults to the length of "
"the *iterable* and all possible full-length permutations are generated."
msgstr ""

#: ../../../library/itertools.rst:507
msgid ""
"The permutation tuples are emitted in lexicographic order according to the "
"order of the input *iterable*. So, if the input *iterable* is sorted, the "
"output tuples will be produced in sorted order."
msgstr ""

#: ../../../library/itertools.rst:511
msgid ""
"Elements are treated as unique based on their position, not on their value.  "
"So if the input elements are unique, there will be no repeated values within "
"a permutation."
msgstr ""

#: ../../../library/itertools.rst:517
msgid ""
"def permutations(iterable, r=None):\n"
"    # permutations('ABCD', 2) --> AB AC AD BA BC BD CA CB CD DA DB DC\n"
"    # permutations(range(3)) --> 012 021 102 120 201 210\n"
"    pool = tuple(iterable)\n"
"    n = len(pool)\n"
"    r = n if r is None else r\n"
"    if r > n:\n"
"        return\n"
"    indices = list(range(n))\n"
"    cycles = list(range(n, n-r, -1))\n"
"    yield tuple(pool[i] for i in indices[:r])\n"
"    while n:\n"
"        for i in reversed(range(r)):\n"
"            cycles[i] -= 1\n"
"            if cycles[i] == 0:\n"
"                indices[i:] = indices[i+1:] + indices[i:i+1]\n"
"                cycles[i] = n - i\n"
"            else:\n"
"                j = cycles[i]\n"
"                indices[i], indices[-j] = indices[-j], indices[i]\n"
"                yield tuple(pool[i] for i in indices[:r])\n"
"                break\n"
"        else:\n"
"            return"
msgstr ""

#: ../../../library/itertools.rst:542
msgid ""
"The code for :func:`permutations` can be also expressed as a subsequence of :"
"func:`product`, filtered to exclude entries with repeated elements (those "
"from the same position in the input pool)::"
msgstr ""

#: ../../../library/itertools.rst:546
msgid ""
"def permutations(iterable, r=None):\n"
"    pool = tuple(iterable)\n"
"    n = len(pool)\n"
"    r = n if r is None else r\n"
"    for indices in product(range(n), repeat=r):\n"
"        if len(set(indices)) == r:\n"
"            yield tuple(pool[i] for i in indices)"
msgstr ""

#: ../../../library/itertools.rst:554
msgid ""
"The number of items returned is ``n! / (n-r)!`` when ``0 <= r <= n`` or zero "
"when ``r > n``."
msgstr ""

#: ../../../library/itertools.rst:559
msgid "Cartesian product of input iterables."
msgstr ""

#: ../../../library/itertools.rst:561
msgid ""
"Roughly equivalent to nested for-loops in a generator expression. For "
"example, ``product(A, B)`` returns the same as ``((x,y) for x in A for y in "
"B)``."
msgstr ""

#: ../../../library/itertools.rst:564
msgid ""
"The nested loops cycle like an odometer with the rightmost element advancing "
"on every iteration.  This pattern creates a lexicographic ordering so that "
"if the input's iterables are sorted, the product tuples are emitted in "
"sorted order."
msgstr ""

#: ../../../library/itertools.rst:569
msgid ""
"To compute the product of an iterable with itself, specify the number of "
"repetitions with the optional *repeat* keyword argument.  For example, "
"``product(A, repeat=4)`` means the same as ``product(A, A, A, A)``."
msgstr ""

#: ../../../library/itertools.rst:573
msgid ""
"This function is roughly equivalent to the following code, except that the "
"actual implementation does not build up intermediate results in memory::"
msgstr ""

#: ../../../library/itertools.rst:576
msgid ""
"def product(*args, repeat=1):\n"
"    # product('ABCD', 'xy') --> Ax Ay Bx By Cx Cy Dx Dy\n"
"    # product(range(2), repeat=3) --> 000 001 010 011 100 101 110 111\n"
"    pools = [tuple(pool) for pool in args] * repeat\n"
"    result = [[]]\n"
"    for pool in pools:\n"
"        result = [x+[y] for x in result for y in pool]\n"
"    for prod in result:\n"
"        yield tuple(prod)"
msgstr ""

#: ../../../library/itertools.rst:586
msgid ""
"Before :func:`product` runs, it completely consumes the input iterables, "
"keeping pools of values in memory to generate the products.  Accordingly, it "
"is only useful with finite inputs."
msgstr ""

#: ../../../library/itertools.rst:592
msgid ""
"Make an iterator that returns *object* over and over again. Runs "
"indefinitely unless the *times* argument is specified."
msgstr ""

#: ../../../library/itertools.rst:597
msgid ""
"def repeat(object, times=None):\n"
"    # repeat(10, 3) --> 10 10 10\n"
"    if times is None:\n"
"        while True:\n"
"            yield object\n"
"    else:\n"
"        for i in range(times):\n"
"            yield object"
msgstr ""

#: ../../../library/itertools.rst:606
msgid ""
"A common use for *repeat* is to supply a stream of constant values to *map* "
"or *zip*:"
msgstr ""

#: ../../../library/itertools.rst:609
msgid ""
">>> list(map(pow, range(10), repeat(2)))\n"
"[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]"
msgstr ""

#: ../../../library/itertools.rst:616
msgid ""
"Make an iterator that computes the function using arguments obtained from "
"the iterable.  Used instead of :func:`map` when argument parameters are "
"already grouped in tuples from a single iterable (when the data has been "
"\"pre-zipped\")."
msgstr ""

#: ../../../library/itertools.rst:621
msgid ""
"The difference between :func:`map` and :func:`starmap` parallels the "
"distinction between ``function(a,b)`` and ``function(*c)``. Roughly "
"equivalent to::"
msgstr ""

#: ../../../library/itertools.rst:625
msgid ""
"def starmap(function, iterable):\n"
"    # starmap(pow, [(2,5), (3,2), (10,3)]) --> 32 9 1000\n"
"    for args in iterable:\n"
"        yield function(*args)"
msgstr ""

#: ../../../library/itertools.rst:633
msgid ""
"Make an iterator that returns elements from the iterable as long as the "
"predicate is true.  Roughly equivalent to::"
msgstr ""

#: ../../../library/itertools.rst:636
msgid ""
"def takewhile(predicate, iterable):\n"
"    # takewhile(lambda x: x<5, [1,4,6,4,1]) --> 1 4\n"
"    for x in iterable:\n"
"        if predicate(x):\n"
"            yield x\n"
"        else:\n"
"            break"
msgstr ""

#: ../../../library/itertools.rst:647
msgid "Return *n* independent iterators from a single iterable."
msgstr ""

#: ../../../library/itertools.rst:649
msgid ""
"The following Python code helps explain what *tee* does (although the actual "
"implementation is more complex and uses only a single underlying :abbr:`FIFO "
"(first-in, first-out)` queue)::"
msgstr ""

#: ../../../library/itertools.rst:653
msgid ""
"def tee(iterable, n=2):\n"
"    it = iter(iterable)\n"
"    deques = [collections.deque() for i in range(n)]\n"
"    def gen(mydeque):\n"
"        while True:\n"
"            if not mydeque:             # when the local deque is empty\n"
"                try:\n"
"                    newval = next(it)   # fetch a new value and\n"
"                except StopIteration:\n"
"                    return\n"
"                for d in deques:        # load it to all the deques\n"
"                    d.append(newval)\n"
"            yield mydeque.popleft()\n"
"    return tuple(gen(d) for d in deques)"
msgstr ""

#: ../../../library/itertools.rst:668
msgid ""
"Once a :func:`tee` has been created, the original *iterable* should not be "
"used anywhere else; otherwise, the *iterable* could get advanced without the "
"tee objects being informed."
msgstr ""

#: ../../../library/itertools.rst:672
msgid ""
"``tee`` iterators are not threadsafe. A :exc:`RuntimeError` may be raised "
"when using simultaneously iterators returned by the same :func:`tee` call, "
"even if the original *iterable* is threadsafe."
msgstr ""

#: ../../../library/itertools.rst:676
msgid ""
"This itertool may require significant auxiliary storage (depending on how "
"much temporary data needs to be stored). In general, if one iterator uses "
"most or all of the data before another iterator starts, it is faster to use :"
"func:`list` instead of :func:`tee`."
msgstr ""

#: ../../../library/itertools.rst:684
msgid ""
"Make an iterator that aggregates elements from each of the iterables. If the "
"iterables are of uneven length, missing values are filled-in with "
"*fillvalue*. Iteration continues until the longest iterable is exhausted.  "
"Roughly equivalent to::"
msgstr ""

#: ../../../library/itertools.rst:688
msgid ""
"def zip_longest(*args, fillvalue=None):\n"
"    # zip_longest('ABCD', 'xy', fillvalue='-') --> Ax By C- D-\n"
"    iterators = [iter(it) for it in args]\n"
"    num_active = len(iterators)\n"
"    if not num_active:\n"
"        return\n"
"    while True:\n"
"        values = []\n"
"        for i, it in enumerate(iterators):\n"
"            try:\n"
"                value = next(it)\n"
"            except StopIteration:\n"
"                num_active -= 1\n"
"                if not num_active:\n"
"                    return\n"
"                iterators[i] = repeat(fillvalue)\n"
"                value = fillvalue\n"
"            values.append(value)\n"
"        yield tuple(values)"
msgstr ""

#: ../../../library/itertools.rst:708
msgid ""
"If one of the iterables is potentially infinite, then the :func:"
"`zip_longest` function should be wrapped with something that limits the "
"number of calls (for example :func:`islice` or :func:`takewhile`).  If not "
"specified, *fillvalue* defaults to ``None``."
msgstr ""

#: ../../../library/itertools.rst:717
msgid "Itertools Recipes"
msgstr ""

#: ../../../library/itertools.rst:719
msgid ""
"This section shows recipes for creating an extended toolset using the "
"existing itertools as building blocks."
msgstr ""

#: ../../../library/itertools.rst:722
msgid ""
"The primary purpose of the itertools recipes is educational.  The recipes "
"show various ways of thinking about individual tools — for example, that "
"``chain.from_iterable`` is related to the concept of flattening.  The "
"recipes also give ideas about ways that the tools can be combined — for "
"example, how ``compress()`` and ``range()`` can work together.  The recipes "
"also show patterns for using itertools with the :mod:`operator` and :mod:"
"`collections` modules as well as with the built-in itertools such as "
"``map()``, ``filter()``, ``reversed()``, and ``enumerate()``."
msgstr ""

#: ../../../library/itertools.rst:731
msgid ""
"A secondary purpose of the recipes is to serve as an incubator.  The "
"``accumulate()``, ``compress()``, and ``pairwise()`` itertools started out "
"as recipes.  Currently, the ``iter_index()`` recipe is being tested to see "
"whether it proves its worth."
msgstr ""

#: ../../../library/itertools.rst:736
msgid ""
"Substantially all of these recipes and many, many others can be installed "
"from the `more-itertools project <https://pypi.org/project/more-itertools/"
">`_ found on the Python Package Index::"
msgstr ""

#: ../../../library/itertools.rst:740
msgid "python -m pip install more-itertools"
msgstr ""

#: ../../../library/itertools.rst:742
msgid ""
"Many of the recipes offer the same high performance as the underlying "
"toolset. Superior memory performance is kept by processing elements one at a "
"time rather than bringing the whole iterable into memory all at once. Code "
"volume is kept small by linking the tools together in a functional style "
"which helps eliminate temporary variables.  High speed is retained by "
"preferring \"vectorized\" building blocks over the use of for-loops and :"
"term:`generator`\\s which incur interpreter overhead."
msgstr ""

#: ../../../library/itertools.rst:750
msgid ""
"import collections\n"
"import math\n"
"import operator\n"
"import random\n"
"\n"
"def take(n, iterable):\n"
"    \"Return first n items of the iterable as a list\"\n"
"    return list(islice(iterable, n))\n"
"\n"
"def prepend(value, iterable):\n"
"    \"Prepend a single value in front of an iterable\"\n"
"    # prepend(1, [2, 3, 4]) --> 1 2 3 4\n"
"    return chain([value], iterable)\n"
"\n"
"def tabulate(function, start=0):\n"
"    \"Return function(0), function(1), ...\"\n"
"    return map(function, count(start))\n"
"\n"
"def tail(n, iterable):\n"
"    \"Return an iterator over the last n items\"\n"
"    # tail(3, 'ABCDEFG') --> E F G\n"
"    return iter(collections.deque(iterable, maxlen=n))\n"
"\n"
"def consume(iterator, n=None):\n"
"    \"Advance the iterator n-steps ahead. If n is None, consume entirely.\"\n"
"    # Use functions that consume iterators at C speed.\n"
"    if n is None:\n"
"        # feed the entire iterator into a zero-length deque\n"
"        collections.deque(iterator, maxlen=0)\n"
"    else:\n"
"        # advance to the empty slice starting at position n\n"
"        next(islice(iterator, n, n), None)\n"
"\n"
"def nth(iterable, n, default=None):\n"
"    \"Returns the nth item or a default value\"\n"
"    return next(islice(iterable, n, None), default)\n"
"\n"
"def all_equal(iterable):\n"
"    \"Returns True if all the elements are equal to each other\"\n"
"    g = groupby(iterable)\n"
"    return next(g, True) and not next(g, False)\n"
"\n"
"def quantify(iterable, pred=bool):\n"
"    \"Count how many times the predicate is True\"\n"
"    return sum(map(pred, iterable))\n"
"\n"
"def ncycles(iterable, n):\n"
"    \"Returns the sequence elements n times\"\n"
"    return chain.from_iterable(repeat(tuple(iterable), n))\n"
"\n"
"def batched(iterable, n):\n"
"    \"Batch data into tuples of length n. The last batch may be shorter.\"\n"
"    # batched('ABCDEFG', 3) --> ABC DEF G\n"
"    if n < 1:\n"
"        raise ValueError('n must be at least one')\n"
"    it = iter(iterable)\n"
"    while batch := tuple(islice(it, n)):\n"
"        yield batch\n"
"\n"
"def grouper(iterable, n, *, incomplete='fill', fillvalue=None):\n"
"    \"Collect data into non-overlapping fixed-length chunks or blocks\"\n"
"    # grouper('ABCDEFG', 3, fillvalue='x') --> ABC DEF Gxx\n"
"    # grouper('ABCDEFG', 3, incomplete='strict') --> ABC DEF ValueError\n"
"    # grouper('ABCDEFG', 3, incomplete='ignore') --> ABC DEF\n"
"    args = [iter(iterable)] * n\n"
"    if incomplete == 'fill':\n"
"        return zip_longest(*args, fillvalue=fillvalue)\n"
"    if incomplete == 'strict':\n"
"        return zip(*args, strict=True)\n"
"    if incomplete == 'ignore':\n"
"        return zip(*args)\n"
"    else:\n"
"        raise ValueError('Expected fill, strict, or ignore')\n"
"\n"
"def sumprod(vec1, vec2):\n"
"    \"Compute a sum of products.\"\n"
"    return sum(starmap(operator.mul, zip(vec1, vec2, strict=True)))\n"
"\n"
"def sum_of_squares(it):\n"
"    \"Add up the squares of the input values.\"\n"
"    # sum_of_squares([10, 20, 30]) -> 1400\n"
"    return sumprod(*tee(it))\n"
"\n"
"def transpose(it):\n"
"    \"Swap the rows and columns of the input.\"\n"
"    # transpose([(1, 2, 3), (11, 22, 33)]) --> (1, 11) (2, 22) (3, 33)\n"
"    return zip(*it, strict=True)\n"
"\n"
"def matmul(m1, m2):\n"
"    \"Multiply two matrices.\"\n"
"    # matmul([(7, 5), (3, 5)], [[2, 5], [7, 9]]) --> (49, 80), (41, 60)\n"
"    n = len(m2[0])\n"
"    return batched(starmap(sumprod, product(m1, transpose(m2))), n)\n"
"\n"
"def convolve(signal, kernel):\n"
"    # See:  https://betterexplained.com/articles/intuitive-convolution/\n"
"    # convolve(data, [0.25, 0.25, 0.25, 0.25]) --> Moving average (blur)\n"
"    # convolve(data, [1, -1]) --> 1st finite difference (1st derivative)\n"
"    # convolve(data, [1, -2, 1]) --> 2nd finite difference (2nd derivative)\n"
"    kernel = tuple(kernel)[::-1]\n"
"    n = len(kernel)\n"
"    window = collections.deque([0], maxlen=n) * n\n"
"    for x in chain(signal, repeat(0, n-1)):\n"
"        window.append(x)\n"
"        yield sumprod(kernel, window)\n"
"\n"
"def polynomial_from_roots(roots):\n"
"    \"\"\"Compute a polynomial's coefficients from its roots.\n"
"\n"
"       (x - 5) (x + 4) (x - 3)  expands to:   x³ -4x² -17x + 60\n"
"    \"\"\"\n"
"    # polynomial_from_roots([5, -4, 3]) --> [1, -4, -17, 60]\n"
"    expansion = [1]\n"
"    for r in roots:\n"
"        expansion = convolve(expansion, (1, -r))\n"
"    return list(expansion)\n"
"\n"
"def polynomial_eval(coefficients, x):\n"
"    \"\"\"Evaluate a polynomial at a specific value.\n"
"\n"
"    Computes with better numeric stability than Horner's method.\n"
"    \"\"\"\n"
"    # Evaluate x³ -4x² -17x + 60 at x = 2.5\n"
"    # polynomial_eval([1, -4, -17, 60], x=2.5) --> 8.125\n"
"    n = len(coefficients)\n"
"    if n == 0:\n"
"        return x * 0  # coerce zero to the type of x\n"
"    powers = map(pow, repeat(x), reversed(range(n)))\n"
"    return sumprod(coefficients, powers)\n"
"\n"
"def iter_index(iterable, value, start=0):\n"
"    \"Return indices where a value occurs in a sequence or iterable.\"\n"
"    # iter_index('AABCADEAF', 'A') --> 0 1 4 7\n"
"    try:\n"
"        seq_index = iterable.index\n"
"    except AttributeError:\n"
"        # Slow path for general iterables\n"
"        it = islice(iterable, start, None)\n"
"        i = start - 1\n"
"        try:\n"
"            while True:\n"
"                yield (i := i + operator.indexOf(it, value) + 1)\n"
"        except ValueError:\n"
"            pass\n"
"    else:\n"
"        # Fast path for sequences\n"
"        i = start - 1\n"
"        try:\n"
"            while True:\n"
"                yield (i := seq_index(value, i+1))\n"
"        except ValueError:\n"
"            pass\n"
"\n"
"def sieve(n):\n"
"    \"Primes less than n\"\n"
"    # sieve(30) --> 2 3 5 7 11 13 17 19 23 29\n"
"    data = bytearray((0, 1)) * (n // 2)\n"
"    data[:3] = 0, 0, 0\n"
"    limit = math.isqrt(n) + 1\n"
"    for p in compress(range(limit), data):\n"
"        data[p*p : n : p+p] = bytes(len(range(p*p, n, p+p)))\n"
"    data[2] = 1\n"
"    return iter_index(data, 1) if n > 2 else iter([])\n"
"\n"
"def factor(n):\n"
"    \"Prime factors of n.\"\n"
"    # factor(99) --> 3 3 11\n"
"    for prime in sieve(math.isqrt(n) + 1):\n"
"        while True:\n"
"            quotient, remainder = divmod(n, prime)\n"
"            if remainder:\n"
"                break\n"
"            yield prime\n"
"            n = quotient\n"
"            if n == 1:\n"
"                return\n"
"    if n > 1:\n"
"        yield n\n"
"\n"
"def flatten(list_of_lists):\n"
"    \"Flatten one level of nesting\"\n"
"    return chain.from_iterable(list_of_lists)\n"
"\n"
"def repeatfunc(func, times=None, *args):\n"
"    \"\"\"Repeat calls to func with specified arguments.\n"
"\n"
"    Example:  repeatfunc(random.random)\n"
"    \"\"\"\n"
"    if times is None:\n"
"        return starmap(func, repeat(args))\n"
"    return starmap(func, repeat(args, times))\n"
"\n"
"def triplewise(iterable):\n"
"    \"Return overlapping triplets from an iterable\"\n"
"    # triplewise('ABCDEFG') --> ABC BCD CDE DEF EFG\n"
"    for (a, _), (b, c) in pairwise(pairwise(iterable)):\n"
"        yield a, b, c\n"
"\n"
"def sliding_window(iterable, n):\n"
"    # sliding_window('ABCDEFG', 4) --> ABCD BCDE CDEF DEFG\n"
"    it = iter(iterable)\n"
"    window = collections.deque(islice(it, n), maxlen=n)\n"
"    if len(window) == n:\n"
"        yield tuple(window)\n"
"    for x in it:\n"
"        window.append(x)\n"
"        yield tuple(window)\n"
"\n"
"def roundrobin(*iterables):\n"
"    \"roundrobin('ABC', 'D', 'EF') --> A D E B F C\"\n"
"    # Recipe credited to George Sakkis\n"
"    num_active = len(iterables)\n"
"    nexts = cycle(iter(it).__next__ for it in iterables)\n"
"    while num_active:\n"
"        try:\n"
"            for next in nexts:\n"
"                yield next()\n"
"        except StopIteration:\n"
"            # Remove the iterator we just exhausted from the cycle.\n"
"            num_active -= 1\n"
"            nexts = cycle(islice(nexts, num_active))\n"
"\n"
"def partition(pred, iterable):\n"
"    \"Use a predicate to partition entries into false entries and true "
"entries\"\n"
"    # partition(is_odd, range(10)) --> 0 2 4 6 8   and  1 3 5 7 9\n"
"    t1, t2 = tee(iterable)\n"
"    return filterfalse(pred, t1), filter(pred, t2)\n"
"\n"
"def before_and_after(predicate, it):\n"
"    \"\"\" Variant of takewhile() that allows complete\n"
"        access to the remainder of the iterator.\n"
"\n"
"        >>> it = iter('ABCdEfGhI')\n"
"        >>> all_upper, remainder = before_and_after(str.isupper, it)\n"
"        >>> ''.join(all_upper)\n"
"        'ABC'\n"
"        >>> ''.join(remainder)     # takewhile() would lose the 'd'\n"
"        'dEfGhI'\n"
"\n"
"        Note that the first iterator must be fully\n"
"        consumed before the second iterator can\n"
"        generate valid results.\n"
"    \"\"\"\n"
"    it = iter(it)\n"
"    transition = []\n"
"    def true_iterator():\n"
"        for elem in it:\n"
"            if predicate(elem):\n"
"                yield elem\n"
"            else:\n"
"                transition.append(elem)\n"
"                return\n"
"    def remainder_iterator():\n"
"        yield from transition\n"
"        yield from it\n"
"    return true_iterator(), remainder_iterator()\n"
"\n"
"def subslices(seq):\n"
"    \"Return all contiguous non-empty subslices of a sequence\"\n"
"    # subslices('ABCD') --> A AB ABC ABCD B BC BCD C CD D\n"
"    slices = starmap(slice, combinations(range(len(seq) + 1), 2))\n"
"    return map(operator.getitem, repeat(seq), slices)\n"
"\n"
"def powerset(iterable):\n"
"    \"powerset([1,2,3]) --> () (1,) (2,) (3,) (1,2) (1,3) (2,3) (1,2,3)\"\n"
"    s = list(iterable)\n"
"    return chain.from_iterable(combinations(s, r) for r in range(len(s)+1))\n"
"\n"
"def unique_everseen(iterable, key=None):\n"
"    \"List unique elements, preserving order. Remember all elements ever "
"seen.\"\n"
"    # unique_everseen('AAAABBBCCDAABBB') --> A B C D\n"
"    # unique_everseen('ABBcCAD', str.lower) --> A B c D\n"
"    seen = set()\n"
"    if key is None:\n"
"        for element in filterfalse(seen.__contains__, iterable):\n"
"            seen.add(element)\n"
"            yield element\n"
"        # For order preserving deduplication,\n"
"        # a faster but non-lazy solution is:\n"
"        #     yield from dict.fromkeys(iterable)\n"
"    else:\n"
"        for element in iterable:\n"
"            k = key(element)\n"
"            if k not in seen:\n"
"                seen.add(k)\n"
"                yield element\n"
"        # For use cases that allow the last matching element to be "
"returned,\n"
"        # a faster but non-lazy solution is:\n"
"        #      t1, t2 = tee(iterable)\n"
"        #      yield from dict(zip(map(key, t1), t2)).values()\n"
"\n"
"def unique_justseen(iterable, key=None):\n"
"    \"List unique elements, preserving order. Remember only the element just "
"seen.\"\n"
"    # unique_justseen('AAAABBBCCDAABBB') --> A B C D A B\n"
"    # unique_justseen('ABBcCAD', str.lower) --> A B c A D\n"
"    return map(next, map(operator.itemgetter(1), groupby(iterable, key)))\n"
"\n"
"def iter_except(func, exception, first=None):\n"
"    \"\"\" Call a function repeatedly until an exception is raised.\n"
"\n"
"    Converts a call-until-exception interface to an iterator interface.\n"
"    Like builtins.iter(func, sentinel) but uses an exception instead\n"
"    of a sentinel to end the loop.\n"
"\n"
"    Examples:\n"
"        iter_except(functools.partial(heappop, h), IndexError)   # priority "
"queue iterator\n"
"        iter_except(d.popitem, KeyError)                         # non-"
"blocking dict iterator\n"
"        iter_except(d.popleft, IndexError)                       # non-"
"blocking deque iterator\n"
"        iter_except(q.get_nowait, Queue.Empty)                   # loop over "
"a producer Queue\n"
"        iter_except(s.pop, KeyError)                             # non-"
"blocking set iterator\n"
"\n"
"    \"\"\"\n"
"    try:\n"
"        if first is not None:\n"
"            yield first()            # For database APIs needing an initial "
"cast to db.first()\n"
"        while True:\n"
"            yield func()\n"
"    except exception:\n"
"        pass\n"
"\n"
"def first_true(iterable, default=False, pred=None):\n"
"    \"\"\"Returns the first true value in the iterable.\n"
"\n"
"    If no true value is found, returns *default*\n"
"\n"
"    If *pred* is not None, returns the first item\n"
"    for which pred(item) is true.\n"
"\n"
"    \"\"\"\n"
"    # first_true([a,b,c], x) --> a or b or c or x\n"
"    # first_true([a,b], x, f) --> a if f(a) else b if f(b) else x\n"
"    return next(filter(pred, iterable), default)\n"
"\n"
"def nth_combination(iterable, r, index):\n"
"    \"Equivalent to list(combinations(iterable, r))[index]\"\n"
"    pool = tuple(iterable)\n"
"    n = len(pool)\n"
"    c = math.comb(n, r)\n"
"    if index < 0:\n"
"        index += c\n"
"    if index < 0 or index >= c:\n"
"        raise IndexError\n"
"    result = []\n"
"    while r:\n"
"        c, n, r = c*r//n, n-1, r-1\n"
"        while index >= c:\n"
"            index -= c\n"
"            c, n = c*(n-r)//n, n-1\n"
"        result.append(pool[-1-n])\n"
"    return tuple(result)"
msgstr ""

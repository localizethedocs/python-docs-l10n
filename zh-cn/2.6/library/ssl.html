
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" lang="zh_CN">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>17.3. ssl — SSL wrapper for socket objects &#8212; Python 2.6.9 文档</title>
    <link rel="stylesheet" href="../_static/pydoctheme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/language_data.js"></script>
    <script type="text/javascript" src="../_static/translations.js"></script>
    
    <link rel="canonical" href="https://projects.localizethedocs.org/python-docs-l10n/library/ssl.html" />
    <link rel="search" type="application/opensearchdescription+xml"
          title="在 Python 2.6.9 文档 中搜索"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="关于这些文档" href="../about.html" />
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="搜索" href="../search.html" />
    <link rel="copyright" title="版权所有" href="../copyright.html" />
    <link rel="next" title="17.4. signal — Set handlers for asynchronous events" href="signal.html" />
    <link rel="prev" title="17.2. socket — Low-level networking interface" href="socket.html" />
    
    <link rel="canonical" href="https://docs.python.org/3/library/ssl.html" />
    
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>

    <link rel="shortcut icon" type="image/png" href="../_static/py.png" />
    
    <script type="text/javascript" src="../_static/copybutton.js"></script>
    
     

            <script type="text/javascript" src="../_static/rtd_switcher.js"></script>
            <meta name="readthedocs-addons-api-version" content="1">
            <script type="text/javascript" src="../ltd-provenance.js"></script>
            <script type="text/javascript" src="../ltd-current.js"></script>
            <script type="text/javascript" src="../../../ltd-config.js"></script>
            <script type="text/javascript" src="../../../ltd-flyout.js"></script>

  </head><body>
  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>导航</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="总目录"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 模块索引"
             >模块</a> |</li>
        <li class="right" >
          <a href="signal.html" title="17.4. signal — Set handlers for asynchronous events"
             accesskey="N">下一页</a> |</li>
        <li class="right" >
          <a href="socket.html" title="17.2. socket — Low-level networking interface"
             accesskey="P">上一页</a> |</li>

    <li><img src="../_static/py.png" alt=""
             style="vertical-align: middle; margin-top: -1px"/></li>
    <li><a href="https://www.python.org/">Python</a> &#187;</li>
    

          <li id="cpython-language-and-version">
            <a href="../index.html">Python 2.6.9 文档</a> &#187;
          </li>

          <li class="nav-item nav-item-1"><a href="index.html" >The Python Standard Library</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="ipc.html" accesskey="U">17. Interprocess Communication and Networking</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="快速搜索" type="text" name="q" />
          <input type="submit" value="转向" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="module-ssl">
<span id="ssl-ssl-wrapper-for-socket-objects"></span><h1>17.3. <a class="reference internal" href="#module-ssl" title="ssl: SSL wrapper for socket objects"><code class="xref py py-mod docutils literal notranslate"><span class="pre">ssl</span></code></a> — SSL wrapper for socket objects<a class="headerlink" href="#module-ssl" title="永久链接至标题">¶</a></h1>
<div class="versionadded">
<p><span class="versionmodified">2.6 新版功能.</span></p>
</div>
<span class="target" id="index-0"></span><p id="index-1">This module provides access to Transport Layer Security (often known as “Secure
Sockets Layer”) encryption and peer authentication facilities for network
sockets, both client-side and server-side.  This module uses the OpenSSL
library. It is available on all modern Unix systems, Windows, Mac OS X, and
probably additional platforms, as long as OpenSSL is installed on that platform.</p>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p class="last">Some behavior may be platform dependent, since calls are made to the
operating system socket APIs.  The installed version of OpenSSL may also
cause variations in behavior.</p>
</div>
<p>This section documents the objects and functions in the <code class="docutils literal notranslate"><span class="pre">ssl</span></code> module; for more
general information about TLS, SSL, and certificates, the reader is referred to
the documents in the “See Also” section at the bottom.</p>
<p>This module provides a class, <code class="xref py py-class docutils literal notranslate"><span class="pre">ssl.SSLSocket</span></code>, which is derived from the
<a class="reference internal" href="socket.html#socket.socket" title="socket.socket"><code class="xref py py-class docutils literal notranslate"><span class="pre">socket.socket</span></code></a> type, and provides a socket-like wrapper that also
encrypts and decrypts the data going over the socket with SSL.  It supports
additional <code class="xref py py-meth docutils literal notranslate"><span class="pre">read()</span></code> and <code class="xref py py-meth docutils literal notranslate"><span class="pre">write()</span></code> methods, along with a method,
<code class="xref py py-meth docutils literal notranslate"><span class="pre">getpeercert()</span></code>, to retrieve the certificate of the other side of the
connection, and a method, <code class="xref py py-meth docutils literal notranslate"><span class="pre">cipher()</span></code>, to retrieve the cipher being used for
the secure connection.</p>
<div class="section" id="functions-constants-and-exceptions">
<h2>17.3.1. Functions, Constants, and Exceptions<a class="headerlink" href="#functions-constants-and-exceptions" title="永久链接至标题">¶</a></h2>
<dl class="exception">
<dt id="ssl.SSLError">
<em class="property">exception </em><code class="descclassname">ssl.</code><code class="descname">SSLError</code><a class="headerlink" href="#ssl.SSLError" title="永久链接至目标">¶</a></dt>
<dd><p>Raised to signal an error from the underlying SSL implementation.  This
signifies some problem in the higher-level encryption and authentication
layer that’s superimposed on the underlying network connection.  This error
is a subtype of <a class="reference internal" href="socket.html#socket.error" title="socket.error"><code class="xref py py-exc docutils literal notranslate"><span class="pre">socket.error</span></code></a>, which in turn is a subtype of
<a class="reference internal" href="exceptions.html#exceptions.IOError" title="exceptions.IOError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">IOError</span></code></a>.</p>
</dd></dl>

<dl class="function">
<dt id="ssl.wrap_socket">
<code class="descclassname">ssl.</code><code class="descname">wrap_socket</code><span class="sig-paren">(</span><em>sock</em>, <em>keyfile=None</em>, <em>certfile=None</em>, <em>server_side=False</em>, <em>cert_reqs=CERT_NONE</em>, <em>ssl_version={see docs}</em>, <em>ca_certs=None</em>, <em>do_handshake_on_connect=True</em>, <em>suppress_ragged_eofs=True</em><span class="sig-paren">)</span><a class="headerlink" href="#ssl.wrap_socket" title="永久链接至目标">¶</a></dt>
<dd><p>Takes an instance <code class="docutils literal notranslate"><span class="pre">sock</span></code> of <a class="reference internal" href="socket.html#socket.socket" title="socket.socket"><code class="xref py py-class docutils literal notranslate"><span class="pre">socket.socket</span></code></a>, and returns an instance
of <code class="xref py py-class docutils literal notranslate"><span class="pre">ssl.SSLSocket</span></code>, a subtype of <a class="reference internal" href="socket.html#socket.socket" title="socket.socket"><code class="xref py py-class docutils literal notranslate"><span class="pre">socket.socket</span></code></a>, which wraps
the underlying socket in an SSL context.  For client-side sockets, the
context construction is lazy; if the underlying socket isn’t connected yet,
the context construction will be performed after <code class="xref py py-meth docutils literal notranslate"><span class="pre">connect()</span></code> is called on
the socket.  For server-side sockets, if the socket has no remote peer, it is
assumed to be a listening socket, and the server-side SSL wrapping is
automatically performed on client connections accepted via the <code class="xref py py-meth docutils literal notranslate"><span class="pre">accept()</span></code>
method.  <a class="reference internal" href="#ssl.wrap_socket" title="ssl.wrap_socket"><code class="xref py py-func docutils literal notranslate"><span class="pre">wrap_socket()</span></code></a> may raise <a class="reference internal" href="#ssl.SSLError" title="ssl.SSLError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SSLError</span></code></a>.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">keyfile</span></code> and <code class="docutils literal notranslate"><span class="pre">certfile</span></code> parameters specify optional files which
contain a certificate to be used to identify the local side of the
connection.  See the discussion of <a class="reference internal" href="#ssl-certificates"><span class="std std-ref">Certificates</span></a> for more
information on how the certificate is stored in the <code class="docutils literal notranslate"><span class="pre">certfile</span></code>.</p>
<p>Often the private key is stored in the same file as the certificate; in this
case, only the <code class="docutils literal notranslate"><span class="pre">certfile</span></code> parameter need be passed.  If the private key is
stored in a separate file, both parameters must be used.  If the private key
is stored in the <code class="docutils literal notranslate"><span class="pre">certfile</span></code>, it should come before the first certificate in
the certificate chain:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">-----</span><span class="n">BEGIN</span> <span class="n">RSA</span> <span class="n">PRIVATE</span> <span class="n">KEY</span><span class="o">-----</span>
<span class="o">...</span> <span class="p">(</span><span class="n">private</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">base64</span> <span class="n">encoding</span><span class="p">)</span> <span class="o">...</span>
<span class="o">-----</span><span class="n">END</span> <span class="n">RSA</span> <span class="n">PRIVATE</span> <span class="n">KEY</span><span class="o">-----</span>
<span class="o">-----</span><span class="n">BEGIN</span> <span class="n">CERTIFICATE</span><span class="o">-----</span>
<span class="o">...</span> <span class="p">(</span><span class="n">certificate</span> <span class="ow">in</span> <span class="n">base64</span> <span class="n">PEM</span> <span class="n">encoding</span><span class="p">)</span> <span class="o">...</span>
<span class="o">-----</span><span class="n">END</span> <span class="n">CERTIFICATE</span><span class="o">-----</span>
</pre></div>
</div>
<p>The parameter <code class="docutils literal notranslate"><span class="pre">server_side</span></code> is a boolean which identifies whether
server-side or client-side behavior is desired from this socket.</p>
<p>The parameter <code class="docutils literal notranslate"><span class="pre">cert_reqs</span></code> specifies whether a certificate is required from
the other side of the connection, and whether it will be validated if
provided.  It must be one of the three values <a class="reference internal" href="#ssl.CERT_NONE" title="ssl.CERT_NONE"><code class="xref py py-const docutils literal notranslate"><span class="pre">CERT_NONE</span></code></a>
(certificates ignored), <a class="reference internal" href="#ssl.CERT_OPTIONAL" title="ssl.CERT_OPTIONAL"><code class="xref py py-const docutils literal notranslate"><span class="pre">CERT_OPTIONAL</span></code></a> (not required, but validated
if provided), or <a class="reference internal" href="#ssl.CERT_REQUIRED" title="ssl.CERT_REQUIRED"><code class="xref py py-const docutils literal notranslate"><span class="pre">CERT_REQUIRED</span></code></a> (required and validated).  If the
value of this parameter is not <a class="reference internal" href="#ssl.CERT_NONE" title="ssl.CERT_NONE"><code class="xref py py-const docutils literal notranslate"><span class="pre">CERT_NONE</span></code></a>, then the <code class="docutils literal notranslate"><span class="pre">ca_certs</span></code>
parameter must point to a file of CA certificates.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">ca_certs</span></code> file contains a set of concatenated “certification
authority” certificates, which are used to validate certificates passed from
the other end of the connection.  See the discussion of
<a class="reference internal" href="#ssl-certificates"><span class="std std-ref">Certificates</span></a> for more information about how to arrange the
certificates in this file.</p>
<p>The parameter <code class="docutils literal notranslate"><span class="pre">ssl_version</span></code> specifies which version of the SSL protocol to
use.  Typically, the server chooses a particular protocol version, and the
client must adapt to the server’s choice.  Most of the versions are not
interoperable with the other versions.  If not specified, for client-side
operation, the default SSL version is SSLv3; for server-side operation,
SSLv23.  These version selections provide the most compatibility with other
versions.</p>
<p>Here’s a table showing which versions in a client (down the side) can connect
to which versions in a server (along the top):</p>
<blockquote>
<div><table border="1" class="docutils">
<colgroup>
<col width="39%" />
<col width="15%" />
<col width="15%" />
<col width="16%" />
<col width="15%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><em>client</em> / <strong>server</strong></td>
<td><strong>SSLv2</strong></td>
<td><strong>SSLv3</strong></td>
<td><strong>SSLv23</strong></td>
<td><strong>TLSv1</strong></td>
</tr>
<tr class="row-even"><td><em>SSLv2</em></td>
<td>yes</td>
<td>no</td>
<td>yes*</td>
<td>no</td>
</tr>
<tr class="row-odd"><td><em>SSLv3</em></td>
<td>yes</td>
<td>yes</td>
<td>yes</td>
<td>no</td>
</tr>
<tr class="row-even"><td><em>SSLv23</em></td>
<td>yes</td>
<td>no</td>
<td>yes</td>
<td>no</td>
</tr>
<tr class="row-odd"><td><em>TLSv1</em></td>
<td>no</td>
<td>no</td>
<td>yes</td>
<td>yes</td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>In some older versions of OpenSSL (for instance, 0.9.7l on OS X 10.4), an
SSLv2 client could not connect to an SSLv23 server.</p>
<p>The parameter <code class="docutils literal notranslate"><span class="pre">do_handshake_on_connect</span></code> specifies whether to do the SSL
handshake automatically after doing a <code class="xref py py-meth docutils literal notranslate"><span class="pre">socket.connect()</span></code>, or whether the
application program will call it explicitly, by invoking the
<a class="reference internal" href="#ssl.SSLSocket.do_handshake" title="ssl.SSLSocket.do_handshake"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLSocket.do_handshake()</span></code></a> method.  Calling
<a class="reference internal" href="#ssl.SSLSocket.do_handshake" title="ssl.SSLSocket.do_handshake"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLSocket.do_handshake()</span></code></a> explicitly gives the program control over the
blocking behavior of the socket I/O involved in the handshake.</p>
<p>The parameter <code class="docutils literal notranslate"><span class="pre">suppress_ragged_eofs</span></code> specifies how the
<a class="reference internal" href="#ssl.SSLSocket.read" title="ssl.SSLSocket.read"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SSLSocket.read()</span></code></a> method should signal unexpected EOF from the other end
of the connection.  If specified as <a class="reference internal" href="constants.html#True" title="True"><code class="xref py py-const docutils literal notranslate"><span class="pre">True</span></code></a> (the default), it returns a
normal EOF in response to unexpected EOF errors raised from the underlying
socket; if <a class="reference internal" href="constants.html#False" title="False"><code class="xref py py-const docutils literal notranslate"><span class="pre">False</span></code></a>, it will raise the exceptions back to the caller.</p>
</dd></dl>

<dl class="function">
<dt id="ssl.RAND_status">
<code class="descclassname">ssl.</code><code class="descname">RAND_status</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ssl.RAND_status" title="永久链接至目标">¶</a></dt>
<dd><p>Returns True if the SSL pseudo-random number generator has been seeded with
‘enough’ randomness, and False otherwise.  You can use <a class="reference internal" href="#ssl.RAND_egd" title="ssl.RAND_egd"><code class="xref py py-func docutils literal notranslate"><span class="pre">ssl.RAND_egd()</span></code></a>
and <a class="reference internal" href="#ssl.RAND_add" title="ssl.RAND_add"><code class="xref py py-func docutils literal notranslate"><span class="pre">ssl.RAND_add()</span></code></a> to increase the randomness of the pseudo-random
number generator.</p>
</dd></dl>

<dl class="function">
<dt id="ssl.RAND_egd">
<code class="descclassname">ssl.</code><code class="descname">RAND_egd</code><span class="sig-paren">(</span><em>path</em><span class="sig-paren">)</span><a class="headerlink" href="#ssl.RAND_egd" title="永久链接至目标">¶</a></dt>
<dd><p>If you are running an entropy-gathering daemon (EGD) somewhere, and <code class="docutils literal notranslate"><span class="pre">path</span></code>
is the pathname of a socket connection open to it, this will read 256 bytes
of randomness from the socket, and add it to the SSL pseudo-random number
generator to increase the security of generated secret keys.  This is
typically only necessary on systems without better sources of randomness.</p>
<p>See <a class="reference external" href="http://egd.sourceforge.net/">http://egd.sourceforge.net/</a> or <a class="reference external" href="http://prngd.sourceforge.net/">http://prngd.sourceforge.net/</a> for sources
of entropy-gathering daemons.</p>
</dd></dl>

<dl class="function">
<dt id="ssl.RAND_add">
<code class="descclassname">ssl.</code><code class="descname">RAND_add</code><span class="sig-paren">(</span><em>bytes</em>, <em>entropy</em><span class="sig-paren">)</span><a class="headerlink" href="#ssl.RAND_add" title="永久链接至目标">¶</a></dt>
<dd><p>Mixes the given <code class="docutils literal notranslate"><span class="pre">bytes</span></code> into the SSL pseudo-random number generator.  The
parameter <code class="docutils literal notranslate"><span class="pre">entropy</span></code> (a float) is a lower bound on the entropy contained in
string (so you can always use <code class="xref py py-const docutils literal notranslate"><span class="pre">0.0</span></code>).  See <span class="target" id="index-2"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc1750.html"><strong>RFC 1750</strong></a> for more
information on sources of entropy.</p>
</dd></dl>

<dl class="function">
<dt id="ssl.cert_time_to_seconds">
<code class="descclassname">ssl.</code><code class="descname">cert_time_to_seconds</code><span class="sig-paren">(</span><em>timestring</em><span class="sig-paren">)</span><a class="headerlink" href="#ssl.cert_time_to_seconds" title="永久链接至目标">¶</a></dt>
<dd><p>Returns a floating-point value containing a normal seconds-after-the-epoch
time value, given the time-string representing the “notBefore” or “notAfter”
date from a certificate.</p>
<p>Here’s an example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">ssl</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ssl</span><span class="o">.</span><span class="n">cert_time_to_seconds</span><span class="p">(</span><span class="s2">&quot;May  9 00:00:00 2007 GMT&quot;</span><span class="p">)</span>
<span class="go">1178694000.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">time</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">time</span><span class="o">.</span><span class="n">ctime</span><span class="p">(</span><span class="n">ssl</span><span class="o">.</span><span class="n">cert_time_to_seconds</span><span class="p">(</span><span class="s2">&quot;May  9 00:00:00 2007 GMT&quot;</span><span class="p">))</span>
<span class="go">&#39;Wed May  9 00:00:00 2007&#39;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="ssl.get_server_certificate">
<code class="descclassname">ssl.</code><code class="descname">get_server_certificate</code><span class="sig-paren">(</span><em>addr</em>, <em>ssl_version=PROTOCOL_SSLv3</em>, <em>ca_certs=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ssl.get_server_certificate" title="永久链接至目标">¶</a></dt>
<dd><p>Given the address <code class="docutils literal notranslate"><span class="pre">addr</span></code> of an SSL-protected server, as a (<em>hostname</em>,
<em>port-number</em>) pair, fetches the server’s certificate, and returns it as a
PEM-encoded string.  If <code class="docutils literal notranslate"><span class="pre">ssl_version</span></code> is specified, uses that version of
the SSL protocol to attempt to connect to the server.  If <code class="docutils literal notranslate"><span class="pre">ca_certs</span></code> is
specified, it should be a file containing a list of root certificates, the
same format as used for the same parameter in <a class="reference internal" href="#ssl.wrap_socket" title="ssl.wrap_socket"><code class="xref py py-func docutils literal notranslate"><span class="pre">wrap_socket()</span></code></a>.  The call
will attempt to validate the server certificate against that set of root
certificates, and will fail if the validation attempt fails.</p>
</dd></dl>

<dl class="function">
<dt id="ssl.DER_cert_to_PEM_cert">
<code class="descclassname">ssl.</code><code class="descname">DER_cert_to_PEM_cert</code><span class="sig-paren">(</span><em>DER_cert_bytes</em><span class="sig-paren">)</span><a class="headerlink" href="#ssl.DER_cert_to_PEM_cert" title="永久链接至目标">¶</a></dt>
<dd><p>Given a certificate as a DER-encoded blob of bytes, returns a PEM-encoded
string version of the same certificate.</p>
</dd></dl>

<dl class="function">
<dt id="ssl.PEM_cert_to_DER_cert">
<code class="descclassname">ssl.</code><code class="descname">PEM_cert_to_DER_cert</code><span class="sig-paren">(</span><em>PEM_cert_string</em><span class="sig-paren">)</span><a class="headerlink" href="#ssl.PEM_cert_to_DER_cert" title="永久链接至目标">¶</a></dt>
<dd><p>Given a certificate as an ASCII PEM string, returns a DER-encoded sequence of
bytes for that same certificate.</p>
</dd></dl>

<dl class="data">
<dt id="ssl.CERT_NONE">
<code class="descclassname">ssl.</code><code class="descname">CERT_NONE</code><a class="headerlink" href="#ssl.CERT_NONE" title="永久链接至目标">¶</a></dt>
<dd><p>Value to pass to the <code class="docutils literal notranslate"><span class="pre">cert_reqs</span></code> parameter to <code class="xref py py-func docutils literal notranslate"><span class="pre">sslobject()</span></code> when no
certificates will be required or validated from the other side of the socket
connection.</p>
</dd></dl>

<dl class="data">
<dt id="ssl.CERT_OPTIONAL">
<code class="descclassname">ssl.</code><code class="descname">CERT_OPTIONAL</code><a class="headerlink" href="#ssl.CERT_OPTIONAL" title="永久链接至目标">¶</a></dt>
<dd><p>Value to pass to the <code class="docutils literal notranslate"><span class="pre">cert_reqs</span></code> parameter to <code class="xref py py-func docutils literal notranslate"><span class="pre">sslobject()</span></code> when no
certificates will be required from the other side of the socket connection,
but if they are provided, will be validated.  Note that use of this setting
requires a valid certificate validation file also be passed as a value of the
<code class="docutils literal notranslate"><span class="pre">ca_certs</span></code> parameter.</p>
</dd></dl>

<dl class="data">
<dt id="ssl.CERT_REQUIRED">
<code class="descclassname">ssl.</code><code class="descname">CERT_REQUIRED</code><a class="headerlink" href="#ssl.CERT_REQUIRED" title="永久链接至目标">¶</a></dt>
<dd><p>Value to pass to the <code class="docutils literal notranslate"><span class="pre">cert_reqs</span></code> parameter to <code class="xref py py-func docutils literal notranslate"><span class="pre">sslobject()</span></code> when
certificates will be required from the other side of the socket connection.
Note that use of this setting requires a valid certificate validation file
also be passed as a value of the <code class="docutils literal notranslate"><span class="pre">ca_certs</span></code> parameter.</p>
</dd></dl>

<dl class="data">
<dt id="ssl.PROTOCOL_SSLv2">
<code class="descclassname">ssl.</code><code class="descname">PROTOCOL_SSLv2</code><a class="headerlink" href="#ssl.PROTOCOL_SSLv2" title="永久链接至目标">¶</a></dt>
<dd><p>Selects SSL version 2 as the channel encryption protocol.</p>
<div class="admonition warning">
<p class="first admonition-title">警告</p>
<p class="last">SSL version 2 is insecure.  Its use is highly discouraged.</p>
</div>
</dd></dl>

<dl class="data">
<dt id="ssl.PROTOCOL_SSLv23">
<code class="descclassname">ssl.</code><code class="descname">PROTOCOL_SSLv23</code><a class="headerlink" href="#ssl.PROTOCOL_SSLv23" title="永久链接至目标">¶</a></dt>
<dd><p>Selects SSL version 2 or 3 as the channel encryption protocol.  This is a
setting to use with servers for maximum compatibility with the other end of
an SSL connection, but it may cause the specific ciphers chosen for the
encryption to be of fairly low quality.</p>
</dd></dl>

<dl class="data">
<dt id="ssl.PROTOCOL_SSLv3">
<code class="descclassname">ssl.</code><code class="descname">PROTOCOL_SSLv3</code><a class="headerlink" href="#ssl.PROTOCOL_SSLv3" title="永久链接至目标">¶</a></dt>
<dd><p>Selects SSL version 3 as the channel encryption protocol.  For clients, this
is the maximally compatible SSL variant.</p>
</dd></dl>

<dl class="data">
<dt id="ssl.PROTOCOL_TLSv1">
<code class="descclassname">ssl.</code><code class="descname">PROTOCOL_TLSv1</code><a class="headerlink" href="#ssl.PROTOCOL_TLSv1" title="永久链接至目标">¶</a></dt>
<dd><p>Selects TLS version 1 as the channel encryption protocol.  This is the most
modern version, and probably the best choice for maximum protection, if both
sides can speak it.</p>
</dd></dl>

</div>
<div class="section" id="sslsocket-objects">
<h2>17.3.2. SSLSocket Objects<a class="headerlink" href="#sslsocket-objects" title="永久链接至标题">¶</a></h2>
<dl class="method">
<dt id="ssl.SSLSocket.read">
<code class="descclassname">SSLSocket.</code><code class="descname">read</code><span class="sig-paren">(</span><span class="optional">[</span><em>nbytes=1024</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#ssl.SSLSocket.read" title="永久链接至目标">¶</a></dt>
<dd><p>Reads up to <code class="docutils literal notranslate"><span class="pre">nbytes</span></code> bytes from the SSL-encrypted channel and returns them.</p>
</dd></dl>

<dl class="method">
<dt id="ssl.SSLSocket.write">
<code class="descclassname">SSLSocket.</code><code class="descname">write</code><span class="sig-paren">(</span><em>data</em><span class="sig-paren">)</span><a class="headerlink" href="#ssl.SSLSocket.write" title="永久链接至目标">¶</a></dt>
<dd><p>Writes the <code class="docutils literal notranslate"><span class="pre">data</span></code> to the other side of the connection, using the SSL
channel to encrypt.  Returns the number of bytes written.</p>
</dd></dl>

<dl class="method">
<dt id="ssl.SSLSocket.getpeercert">
<code class="descclassname">SSLSocket.</code><code class="descname">getpeercert</code><span class="sig-paren">(</span><em>binary_form=False</em><span class="sig-paren">)</span><a class="headerlink" href="#ssl.SSLSocket.getpeercert" title="永久链接至目标">¶</a></dt>
<dd><p>If there is no certificate for the peer on the other end of the connection,
returns <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
<p>If the parameter <code class="docutils literal notranslate"><span class="pre">binary_form</span></code> is <a class="reference internal" href="constants.html#False" title="False"><code class="xref py py-const docutils literal notranslate"><span class="pre">False</span></code></a>, and a certificate was
received from the peer, this method returns a <a class="reference internal" href="stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a> instance.  If the
certificate was not validated, the dict is empty.  If the certificate was
validated, it returns a dict with the keys <code class="docutils literal notranslate"><span class="pre">subject</span></code> (the principal for
which the certificate was issued), and <code class="docutils literal notranslate"><span class="pre">notAfter</span></code> (the time after which the
certificate should not be trusted).  The certificate was already validated,
so the <code class="docutils literal notranslate"><span class="pre">notBefore</span></code> and <code class="docutils literal notranslate"><span class="pre">issuer</span></code> fields are not returned.  If a
certificate contains an instance of the <em>Subject Alternative Name</em> extension
(see <span class="target" id="index-3"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc3280.html"><strong>RFC 3280</strong></a>), there will also be a <code class="docutils literal notranslate"><span class="pre">subjectAltName</span></code> key in the
dictionary.</p>
<p>The “subject” field is a tuple containing the sequence of relative
distinguished names (RDNs) given in the certificate’s data structure for the
principal, and each RDN is a sequence of name-value pairs:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">{</span><span class="s1">&#39;notAfter&#39;</span><span class="p">:</span> <span class="s1">&#39;Feb 16 16:54:50 2013 GMT&#39;</span><span class="p">,</span>
 <span class="s1">&#39;subject&#39;</span><span class="p">:</span> <span class="p">(((</span><span class="s1">&#39;countryName&#39;</span><span class="p">,</span> <span class="sa">u</span><span class="s1">&#39;US&#39;</span><span class="p">),),</span>
             <span class="p">((</span><span class="s1">&#39;stateOrProvinceName&#39;</span><span class="p">,</span> <span class="sa">u</span><span class="s1">&#39;Delaware&#39;</span><span class="p">),),</span>
             <span class="p">((</span><span class="s1">&#39;localityName&#39;</span><span class="p">,</span> <span class="sa">u</span><span class="s1">&#39;Wilmington&#39;</span><span class="p">),),</span>
             <span class="p">((</span><span class="s1">&#39;organizationName&#39;</span><span class="p">,</span> <span class="sa">u</span><span class="s1">&#39;Python Software Foundation&#39;</span><span class="p">),),</span>
             <span class="p">((</span><span class="s1">&#39;organizationalUnitName&#39;</span><span class="p">,</span> <span class="sa">u</span><span class="s1">&#39;SSL&#39;</span><span class="p">),),</span>
             <span class="p">((</span><span class="s1">&#39;commonName&#39;</span><span class="p">,</span> <span class="sa">u</span><span class="s1">&#39;somemachine.python.org&#39;</span><span class="p">),))}</span>
</pre></div>
</div>
<p>If the <code class="docutils literal notranslate"><span class="pre">binary_form</span></code> parameter is <a class="reference internal" href="constants.html#True" title="True"><code class="xref py py-const docutils literal notranslate"><span class="pre">True</span></code></a>, and a certificate was
provided, this method returns the DER-encoded form of the entire certificate
as a sequence of bytes, or <a class="reference internal" href="constants.html#None" title="None"><code class="xref py py-const docutils literal notranslate"><span class="pre">None</span></code></a> if the peer did not provide a
certificate.  This return value is independent of validation; if validation
was required (<a class="reference internal" href="#ssl.CERT_OPTIONAL" title="ssl.CERT_OPTIONAL"><code class="xref py py-const docutils literal notranslate"><span class="pre">CERT_OPTIONAL</span></code></a> or <a class="reference internal" href="#ssl.CERT_REQUIRED" title="ssl.CERT_REQUIRED"><code class="xref py py-const docutils literal notranslate"><span class="pre">CERT_REQUIRED</span></code></a>), it will have
been validated, but if <a class="reference internal" href="#ssl.CERT_NONE" title="ssl.CERT_NONE"><code class="xref py py-const docutils literal notranslate"><span class="pre">CERT_NONE</span></code></a> was used to establish the
connection, the certificate, if present, will not have been validated.</p>
</dd></dl>

<dl class="method">
<dt id="ssl.SSLSocket.cipher">
<code class="descclassname">SSLSocket.</code><code class="descname">cipher</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ssl.SSLSocket.cipher" title="永久链接至目标">¶</a></dt>
<dd><p>Returns a three-value tuple containing the name of the cipher being used, the
version of the SSL protocol that defines its use, and the number of secret
bits being used.  If no connection has been established, returns <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="ssl.SSLSocket.do_handshake">
<code class="descclassname">SSLSocket.</code><code class="descname">do_handshake</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ssl.SSLSocket.do_handshake" title="永久链接至目标">¶</a></dt>
<dd><p>Perform a TLS/SSL handshake.  If this is used with a non-blocking socket, it
may raise <a class="reference internal" href="#ssl.SSLError" title="ssl.SSLError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SSLError</span></code></a> with an <code class="docutils literal notranslate"><span class="pre">arg[0]</span></code> of <code class="xref py py-const docutils literal notranslate"><span class="pre">SSL_ERROR_WANT_READ</span></code>
or <code class="xref py py-const docutils literal notranslate"><span class="pre">SSL_ERROR_WANT_WRITE</span></code>, in which case it must be called again until
it completes successfully.  For example, to simulate the behavior of a
blocking socket, one might write:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">s</span><span class="o">.</span><span class="n">do_handshake</span><span class="p">()</span>
        <span class="k">break</span>
    <span class="k">except</span> <span class="n">ssl</span><span class="o">.</span><span class="n">SSLError</span><span class="p">,</span> <span class="n">err</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">err</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">ssl</span><span class="o">.</span><span class="n">SSL_ERROR_WANT_READ</span><span class="p">:</span>
            <span class="n">select</span><span class="o">.</span><span class="n">select</span><span class="p">([</span><span class="n">s</span><span class="p">],</span> <span class="p">[],</span> <span class="p">[])</span>
        <span class="k">elif</span> <span class="n">err</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">ssl</span><span class="o">.</span><span class="n">SSL_ERROR_WANT_WRITE</span><span class="p">:</span>
            <span class="n">select</span><span class="o">.</span><span class="n">select</span><span class="p">([],</span> <span class="p">[</span><span class="n">s</span><span class="p">],</span> <span class="p">[])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="ssl.SSLSocket.unwrap">
<code class="descclassname">SSLSocket.</code><code class="descname">unwrap</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ssl.SSLSocket.unwrap" title="永久链接至目标">¶</a></dt>
<dd><p>Performs the SSL shutdown handshake, which removes the TLS layer from the
underlying socket, and returns the underlying socket object.  This can be
used to go from encrypted operation over a connection to unencrypted.  The
socket instance returned should always be used for further communication with
the other side of the connection, rather than the original socket instance
(which may not function properly after the unwrap).</p>
</dd></dl>

<span class="target" id="index-4"></span></div>
<div class="section" id="certificates">
<span id="ssl-certificates"></span><span id="index-5"></span><h2>17.3.3. Certificates<a class="headerlink" href="#certificates" title="永久链接至标题">¶</a></h2>
<p>Certificates in general are part of a public-key / private-key system.  In this
system, each <em>principal</em>, (which may be a machine, or a person, or an
organization) is assigned a unique two-part encryption key.  One part of the key
is public, and is called the <em>public key</em>; the other part is kept secret, and is
called the <em>private key</em>.  The two parts are related, in that if you encrypt a
message with one of the parts, you can decrypt it with the other part, and
<strong>only</strong> with the other part.</p>
<p>A certificate contains information about two principals.  It contains the name
of a <em>subject</em>, and the subject’s public key.  It also contains a statement by a
second principal, the <em>issuer</em>, that the subject is who he claims to be, and
that this is indeed the subject’s public key.  The issuer’s statement is signed
with the issuer’s private key, which only the issuer knows.  However, anyone can
verify the issuer’s statement by finding the issuer’s public key, decrypting the
statement with it, and comparing it to the other information in the certificate.
The certificate also contains information about the time period over which it is
valid.  This is expressed as two fields, called “notBefore” and “notAfter”.</p>
<p>In the Python use of certificates, a client or server can use a certificate to
prove who they are.  The other side of a network connection can also be required
to produce a certificate, and that certificate can be validated to the
satisfaction of the client or server that requires such validation.  The
connection attempt can be set to raise an exception if the validation fails.
Validation is done automatically, by the underlying OpenSSL framework; the
application need not concern itself with its mechanics.  But the application
does usually need to provide sets of certificates to allow this process to take
place.</p>
<p>Python uses files to contain certificates.  They should be formatted as “PEM”
(see <span class="target" id="index-6"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc1422.html"><strong>RFC 1422</strong></a>), which is a base-64 encoded form wrapped with a header line
and a footer line:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">-----</span><span class="n">BEGIN</span> <span class="n">CERTIFICATE</span><span class="o">-----</span>
<span class="o">...</span> <span class="p">(</span><span class="n">certificate</span> <span class="ow">in</span> <span class="n">base64</span> <span class="n">PEM</span> <span class="n">encoding</span><span class="p">)</span> <span class="o">...</span>
<span class="o">-----</span><span class="n">END</span> <span class="n">CERTIFICATE</span><span class="o">-----</span>
</pre></div>
</div>
<p>The Python files which contain certificates can contain a sequence of
certificates, sometimes called a <em>certificate chain</em>.  This chain should start
with the specific certificate for the principal who “is” the client or server,
and then the certificate for the issuer of that certificate, and then the
certificate for the issuer of <em>that</em> certificate, and so on up the chain till
you get to a certificate which is <em>self-signed</em>, that is, a certificate which
has the same subject and issuer, sometimes called a <em>root certificate</em>.  The
certificates should just be concatenated together in the certificate file.  For
example, suppose we had a three certificate chain, from our server certificate
to the certificate of the certification authority that signed our server
certificate, to the root certificate of the agency which issued the
certification authority’s certificate:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">-----</span><span class="n">BEGIN</span> <span class="n">CERTIFICATE</span><span class="o">-----</span>
<span class="o">...</span> <span class="p">(</span><span class="n">certificate</span> <span class="k">for</span> <span class="n">your</span> <span class="n">server</span><span class="p">)</span><span class="o">...</span>
<span class="o">-----</span><span class="n">END</span> <span class="n">CERTIFICATE</span><span class="o">-----</span>
<span class="o">-----</span><span class="n">BEGIN</span> <span class="n">CERTIFICATE</span><span class="o">-----</span>
<span class="o">...</span> <span class="p">(</span><span class="n">the</span> <span class="n">certificate</span> <span class="k">for</span> <span class="n">the</span> <span class="n">CA</span><span class="p">)</span><span class="o">...</span>
<span class="o">-----</span><span class="n">END</span> <span class="n">CERTIFICATE</span><span class="o">-----</span>
<span class="o">-----</span><span class="n">BEGIN</span> <span class="n">CERTIFICATE</span><span class="o">-----</span>
<span class="o">...</span> <span class="p">(</span><span class="n">the</span> <span class="n">root</span> <span class="n">certificate</span> <span class="k">for</span> <span class="n">the</span> <span class="n">CA</span><span class="s1">&#39;s issuer)...</span>
<span class="o">-----</span><span class="n">END</span> <span class="n">CERTIFICATE</span><span class="o">-----</span>
</pre></div>
</div>
<p>If you are going to require validation of the other side of the connection’s
certificate, you need to provide a “CA certs” file, filled with the certificate
chains for each issuer you are willing to trust.  Again, this file just contains
these chains concatenated together.  For validation, Python will use the first
chain it finds in the file which matches.</p>
<p>Some “standard” root certificates are available from various certification
authorities: <a class="reference external" href="http://www.cacert.org/index.php?id=3">CACert.org</a>, <a class="reference external" href="http://www.thawte.com/roots/">Thawte</a>, <a class="reference external" href="http://www.verisign.com/support/roots.html">Verisign</a>, <a class="reference external" href="http://www.PositiveSSL.com/ssl-certificate-support/cert_installation/UTN-USERFirst-Hardware.crt">Positive SSL</a>
(used by python.org), <a class="reference external" href="http://www.geotrust.com/resources/root_certificates/index.asp">Equifax and GeoTrust</a>.</p>
<p>In general, if you are using SSL3 or TLS1, you don’t need to put the full chain
in your “CA certs” file; you only need the root certificates, and the remote
peer is supposed to furnish the other certificates necessary to chain from its
certificate to a root certificate.  See <span class="target" id="index-7"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc4158.html"><strong>RFC 4158</strong></a> for more discussion of the
way in which certification chains can be built.</p>
<p>If you are going to create a server that provides SSL-encrypted connection
services, you will need to acquire a certificate for that service.  There are
many ways of acquiring appropriate certificates, such as buying one from a
certification authority.  Another common practice is to generate a self-signed
certificate.  The simplest way to do this is with the OpenSSL package, using
something like the following:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">%</span> <span class="n">openssl</span> <span class="n">req</span> <span class="o">-</span><span class="n">new</span> <span class="o">-</span><span class="n">x509</span> <span class="o">-</span><span class="n">days</span> <span class="mi">365</span> <span class="o">-</span><span class="n">nodes</span> <span class="o">-</span><span class="n">out</span> <span class="n">cert</span><span class="o">.</span><span class="n">pem</span> <span class="o">-</span><span class="n">keyout</span> <span class="n">cert</span><span class="o">.</span><span class="n">pem</span>
<span class="n">Generating</span> <span class="n">a</span> <span class="mi">1024</span> <span class="n">bit</span> <span class="n">RSA</span> <span class="n">private</span> <span class="n">key</span>
<span class="o">.......++++++</span>
<span class="o">.............................++++++</span>
<span class="n">writing</span> <span class="n">new</span> <span class="n">private</span> <span class="n">key</span> <span class="n">to</span> <span class="s1">&#39;cert.pem&#39;</span>
<span class="o">-----</span>
<span class="n">You</span> <span class="n">are</span> <span class="n">about</span> <span class="n">to</span> <span class="n">be</span> <span class="n">asked</span> <span class="n">to</span> <span class="n">enter</span> <span class="n">information</span> <span class="n">that</span> <span class="n">will</span> <span class="n">be</span> <span class="n">incorporated</span>
<span class="n">into</span> <span class="n">your</span> <span class="n">certificate</span> <span class="n">request</span><span class="o">.</span>
<span class="n">What</span> <span class="n">you</span> <span class="n">are</span> <span class="n">about</span> <span class="n">to</span> <span class="n">enter</span> <span class="ow">is</span> <span class="n">what</span> <span class="ow">is</span> <span class="n">called</span> <span class="n">a</span> <span class="n">Distinguished</span> <span class="n">Name</span> <span class="ow">or</span> <span class="n">a</span> <span class="n">DN</span><span class="o">.</span>
<span class="n">There</span> <span class="n">are</span> <span class="n">quite</span> <span class="n">a</span> <span class="n">few</span> <span class="n">fields</span> <span class="n">but</span> <span class="n">you</span> <span class="n">can</span> <span class="n">leave</span> <span class="n">some</span> <span class="n">blank</span>
<span class="n">For</span> <span class="n">some</span> <span class="n">fields</span> <span class="n">there</span> <span class="n">will</span> <span class="n">be</span> <span class="n">a</span> <span class="n">default</span> <span class="n">value</span><span class="p">,</span>
<span class="n">If</span> <span class="n">you</span> <span class="n">enter</span> <span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="n">the</span> <span class="n">field</span> <span class="n">will</span> <span class="n">be</span> <span class="n">left</span> <span class="n">blank</span><span class="o">.</span>
<span class="o">-----</span>
<span class="n">Country</span> <span class="n">Name</span> <span class="p">(</span><span class="mi">2</span> <span class="n">letter</span> <span class="n">code</span><span class="p">)</span> <span class="p">[</span><span class="n">AU</span><span class="p">]:</span><span class="n">US</span>
<span class="n">State</span> <span class="ow">or</span> <span class="n">Province</span> <span class="n">Name</span> <span class="p">(</span><span class="n">full</span> <span class="n">name</span><span class="p">)</span> <span class="p">[</span><span class="n">Some</span><span class="o">-</span><span class="n">State</span><span class="p">]:</span><span class="n">MyState</span>
<span class="n">Locality</span> <span class="n">Name</span> <span class="p">(</span><span class="n">eg</span><span class="p">,</span> <span class="n">city</span><span class="p">)</span> <span class="p">[]:</span><span class="n">Some</span> <span class="n">City</span>
<span class="n">Organization</span> <span class="n">Name</span> <span class="p">(</span><span class="n">eg</span><span class="p">,</span> <span class="n">company</span><span class="p">)</span> <span class="p">[</span><span class="n">Internet</span> <span class="n">Widgits</span> <span class="n">Pty</span> <span class="n">Ltd</span><span class="p">]:</span><span class="n">My</span> <span class="n">Organization</span><span class="p">,</span> <span class="n">Inc</span><span class="o">.</span>
<span class="n">Organizational</span> <span class="n">Unit</span> <span class="n">Name</span> <span class="p">(</span><span class="n">eg</span><span class="p">,</span> <span class="n">section</span><span class="p">)</span> <span class="p">[]:</span><span class="n">My</span> <span class="n">Group</span>
<span class="n">Common</span> <span class="n">Name</span> <span class="p">(</span><span class="n">eg</span><span class="p">,</span> <span class="n">YOUR</span> <span class="n">name</span><span class="p">)</span> <span class="p">[]:</span><span class="n">myserver</span><span class="o">.</span><span class="n">mygroup</span><span class="o">.</span><span class="n">myorganization</span><span class="o">.</span><span class="n">com</span>
<span class="n">Email</span> <span class="n">Address</span> <span class="p">[]:</span><span class="n">ops</span><span class="nd">@myserver</span><span class="o">.</span><span class="n">mygroup</span><span class="o">.</span><span class="n">myorganization</span><span class="o">.</span><span class="n">com</span>
<span class="o">%</span>
</pre></div>
</div>
<p>The disadvantage of a self-signed certificate is that it is its own root
certificate, and no one else will have it in their cache of known (and trusted)
root certificates.</p>
</div>
<div class="section" id="examples">
<h2>17.3.4. Examples<a class="headerlink" href="#examples" title="永久链接至标题">¶</a></h2>
<div class="section" id="testing-for-ssl-support">
<h3>17.3.4.1. Testing for SSL support<a class="headerlink" href="#testing-for-ssl-support" title="永久链接至标题">¶</a></h3>
<p>To test for the presence of SSL support in a Python installation, user code
should use the following idiom:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">try</span><span class="p">:</span>
   <span class="kn">import</span> <span class="nn">ssl</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
   <span class="k">pass</span>
<span class="k">else</span><span class="p">:</span>
   <span class="p">[</span> <span class="n">do</span> <span class="n">something</span> <span class="n">that</span> <span class="n">requires</span> <span class="n">SSL</span> <span class="n">support</span> <span class="p">]</span>
</pre></div>
</div>
</div>
<div class="section" id="client-side-operation">
<h3>17.3.4.2. Client-side operation<a class="headerlink" href="#client-side-operation" title="永久链接至标题">¶</a></h3>
<p>This example connects to an SSL server, prints the server’s address and
certificate, sends some bytes, and reads part of the response:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">socket</span><span class="o">,</span> <span class="nn">ssl</span><span class="o">,</span> <span class="nn">pprint</span>

<span class="n">s</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="n">socket</span><span class="p">(</span><span class="n">socket</span><span class="o">.</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">socket</span><span class="o">.</span><span class="n">SOCK_STREAM</span><span class="p">)</span>

<span class="c1"># require a certificate from the server</span>
<span class="n">ssl_sock</span> <span class="o">=</span> <span class="n">ssl</span><span class="o">.</span><span class="n">wrap_socket</span><span class="p">(</span><span class="n">s</span><span class="p">,</span>
                           <span class="n">ca_certs</span><span class="o">=</span><span class="s2">&quot;/etc/ca_certs_file&quot;</span><span class="p">,</span>
                           <span class="n">cert_reqs</span><span class="o">=</span><span class="n">ssl</span><span class="o">.</span><span class="n">CERT_REQUIRED</span><span class="p">)</span>

<span class="n">ssl_sock</span><span class="o">.</span><span class="n">connect</span><span class="p">((</span><span class="s1">&#39;www.verisign.com&#39;</span><span class="p">,</span> <span class="mi">443</span><span class="p">))</span>

<span class="nb">print</span> <span class="nb">repr</span><span class="p">(</span><span class="n">ssl_sock</span><span class="o">.</span><span class="n">getpeername</span><span class="p">())</span>
<span class="nb">print</span> <span class="n">ssl_sock</span><span class="o">.</span><span class="n">cipher</span><span class="p">()</span>
<span class="nb">print</span> <span class="n">pprint</span><span class="o">.</span><span class="n">pformat</span><span class="p">(</span><span class="n">ssl_sock</span><span class="o">.</span><span class="n">getpeercert</span><span class="p">())</span>

<span class="c1"># Set a simple HTTP request -- use httplib in actual code.</span>
<span class="n">ssl_sock</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;GET / HTTP/1.0</span><span class="se">\r</span>
<span class="s2">Host: www.verisign.com</span><span class="se">\r\n\r\n</span><span class="s2">&quot;&quot;&quot;</span><span class="p">)</span>

<span class="c1"># Read a chunk of data.  Will not necessarily</span>
<span class="c1"># read all the data returned by the server.</span>
<span class="n">data</span> <span class="o">=</span> <span class="n">ssl_sock</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>

<span class="c1"># note that closing the SSLSocket will also close the underlying socket</span>
<span class="n">ssl_sock</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
<p>As of September 6, 2007, the certificate printed by this program looked like
this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">{</span><span class="s1">&#39;notAfter&#39;</span><span class="p">:</span> <span class="s1">&#39;May  8 23:59:59 2009 GMT&#39;</span><span class="p">,</span>
 <span class="s1">&#39;subject&#39;</span><span class="p">:</span> <span class="p">(((</span><span class="s1">&#39;serialNumber&#39;</span><span class="p">,</span> <span class="sa">u</span><span class="s1">&#39;2497886&#39;</span><span class="p">),),</span>
             <span class="p">((</span><span class="s1">&#39;1.3.6.1.4.1.311.60.2.1.3&#39;</span><span class="p">,</span> <span class="sa">u</span><span class="s1">&#39;US&#39;</span><span class="p">),),</span>
             <span class="p">((</span><span class="s1">&#39;1.3.6.1.4.1.311.60.2.1.2&#39;</span><span class="p">,</span> <span class="sa">u</span><span class="s1">&#39;Delaware&#39;</span><span class="p">),),</span>
             <span class="p">((</span><span class="s1">&#39;countryName&#39;</span><span class="p">,</span> <span class="sa">u</span><span class="s1">&#39;US&#39;</span><span class="p">),),</span>
             <span class="p">((</span><span class="s1">&#39;postalCode&#39;</span><span class="p">,</span> <span class="sa">u</span><span class="s1">&#39;94043&#39;</span><span class="p">),),</span>
             <span class="p">((</span><span class="s1">&#39;stateOrProvinceName&#39;</span><span class="p">,</span> <span class="sa">u</span><span class="s1">&#39;California&#39;</span><span class="p">),),</span>
             <span class="p">((</span><span class="s1">&#39;localityName&#39;</span><span class="p">,</span> <span class="sa">u</span><span class="s1">&#39;Mountain View&#39;</span><span class="p">),),</span>
             <span class="p">((</span><span class="s1">&#39;streetAddress&#39;</span><span class="p">,</span> <span class="sa">u</span><span class="s1">&#39;487 East Middlefield Road&#39;</span><span class="p">),),</span>
             <span class="p">((</span><span class="s1">&#39;organizationName&#39;</span><span class="p">,</span> <span class="sa">u</span><span class="s1">&#39;VeriSign, Inc.&#39;</span><span class="p">),),</span>
             <span class="p">((</span><span class="s1">&#39;organizationalUnitName&#39;</span><span class="p">,</span>
               <span class="sa">u</span><span class="s1">&#39;Production Security Services&#39;</span><span class="p">),),</span>
             <span class="p">((</span><span class="s1">&#39;organizationalUnitName&#39;</span><span class="p">,</span>
               <span class="sa">u</span><span class="s1">&#39;Terms of use at www.verisign.com/rpa (c)06&#39;</span><span class="p">),),</span>
             <span class="p">((</span><span class="s1">&#39;commonName&#39;</span><span class="p">,</span> <span class="sa">u</span><span class="s1">&#39;www.verisign.com&#39;</span><span class="p">),))}</span>
</pre></div>
</div>
<p>which is a fairly poorly-formed <code class="docutils literal notranslate"><span class="pre">subject</span></code> field.</p>
</div>
<div class="section" id="server-side-operation">
<h3>17.3.4.3. Server-side operation<a class="headerlink" href="#server-side-operation" title="永久链接至标题">¶</a></h3>
<p>For server operation, typically you’d need to have a server certificate, and
private key, each in a file.  You’d open a socket, bind it to a port, call
<code class="xref py py-meth docutils literal notranslate"><span class="pre">listen()</span></code> on it, then start waiting for clients to connect:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">socket</span><span class="o">,</span> <span class="nn">ssl</span>

<span class="n">bindsocket</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="n">socket</span><span class="p">()</span>
<span class="n">bindsocket</span><span class="o">.</span><span class="n">bind</span><span class="p">((</span><span class="s1">&#39;myaddr.mydomain.com&#39;</span><span class="p">,</span> <span class="mi">10023</span><span class="p">))</span>
<span class="n">bindsocket</span><span class="o">.</span><span class="n">listen</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
</pre></div>
</div>
<p>When one did, you’d call <code class="xref py py-meth docutils literal notranslate"><span class="pre">accept()</span></code> on the socket to get the new socket from
the other end, and use <a class="reference internal" href="#ssl.wrap_socket" title="ssl.wrap_socket"><code class="xref py py-func docutils literal notranslate"><span class="pre">wrap_socket()</span></code></a> to create a server-side SSL context
for it:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
   <span class="n">newsocket</span><span class="p">,</span> <span class="n">fromaddr</span> <span class="o">=</span> <span class="n">bindsocket</span><span class="o">.</span><span class="n">accept</span><span class="p">()</span>
   <span class="n">connstream</span> <span class="o">=</span> <span class="n">ssl</span><span class="o">.</span><span class="n">wrap_socket</span><span class="p">(</span><span class="n">newsocket</span><span class="p">,</span>
                                <span class="n">server_side</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                <span class="n">certfile</span><span class="o">=</span><span class="s2">&quot;mycertfile&quot;</span><span class="p">,</span>
                                <span class="n">keyfile</span><span class="o">=</span><span class="s2">&quot;mykeyfile&quot;</span><span class="p">,</span>
                                <span class="n">ssl_version</span><span class="o">=</span><span class="n">ssl</span><span class="o">.</span><span class="n">PROTOCOL_TLSv1</span><span class="p">)</span>
   <span class="n">deal_with_client</span><span class="p">(</span><span class="n">connstream</span><span class="p">)</span>
</pre></div>
</div>
<p>Then you’d read data from the <code class="docutils literal notranslate"><span class="pre">connstream</span></code> and do something with it till you
are finished with the client (or the client is finished with you):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">deal_with_client</span><span class="p">(</span><span class="n">connstream</span><span class="p">):</span>

   <span class="n">data</span> <span class="o">=</span> <span class="n">connstream</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
   <span class="c1"># null data means the client is finished with us</span>
   <span class="k">while</span> <span class="n">data</span><span class="p">:</span>
      <span class="k">if</span> <span class="ow">not</span> <span class="n">do_something</span><span class="p">(</span><span class="n">connstream</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
         <span class="c1"># we&#39;ll assume do_something returns False</span>
         <span class="c1"># when we&#39;re finished with client</span>
         <span class="k">break</span>
      <span class="n">data</span> <span class="o">=</span> <span class="n">connstream</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
   <span class="c1"># finished with client</span>
   <span class="n">connstream</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
<p>And go back to listening for new client connections.</p>
<div class="admonition seealso">
<p class="first admonition-title">参见</p>
<dl class="last docutils">
<dt>Class <a class="reference internal" href="socket.html#socket.socket" title="socket.socket"><code class="xref py py-class docutils literal notranslate"><span class="pre">socket.socket</span></code></a></dt>
<dd>Documentation of underlying <a class="reference internal" href="socket.html#module-socket" title="socket: Low-level networking interface."><code class="xref py py-mod docutils literal notranslate"><span class="pre">socket</span></code></a> class</dd>
<dt><a class="reference external" href="http://old.pseudonym.org/ssl/wwwj-index.html">Introducing SSL and Certificates using OpenSSL</a></dt>
<dd>Frederick J. Hirsch</dd>
<dt><a class="reference external" href="http://www.ietf.org/rfc/rfc1422">RFC 1422: Privacy Enhancement for Internet Electronic Mail: Part II: Certificate-Based Key Management</a></dt>
<dd>Steve Kent</dd>
<dt><a class="reference external" href="http://www.ietf.org/rfc/rfc1750">RFC 1750: Randomness Recommendations for Security</a></dt>
<dd>D. Eastlake et. al.</dd>
<dt><a class="reference external" href="http://www.ietf.org/rfc/rfc3280">RFC 3280: Internet X.509 Public Key Infrastructure Certificate and CRL Profile</a></dt>
<dd>Housley et. al.</dd>
</dl>
</div>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">17.3. <code class="docutils literal notranslate"><span class="pre">ssl</span></code> — SSL wrapper for socket objects</a><ul>
<li><a class="reference internal" href="#functions-constants-and-exceptions">17.3.1. Functions, Constants, and Exceptions</a></li>
<li><a class="reference internal" href="#sslsocket-objects">17.3.2. SSLSocket Objects</a></li>
<li><a class="reference internal" href="#certificates">17.3.3. Certificates</a></li>
<li><a class="reference internal" href="#examples">17.3.4. Examples</a><ul>
<li><a class="reference internal" href="#testing-for-ssl-support">17.3.4.1. Testing for SSL support</a></li>
<li><a class="reference internal" href="#client-side-operation">17.3.4.2. Client-side operation</a></li>
<li><a class="reference internal" href="#server-side-operation">17.3.4.3. Server-side operation</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>上一个主题</h4>
  <p class="topless"><a href="socket.html"
                        title="上一章">17.2. <code class="docutils literal notranslate"><span class="pre">socket</span></code> — Low-level networking interface</a></p>
  <h4>下一个主题</h4>
  <p class="topless"><a href="signal.html"
                        title="下一章">17.4. <code class="docutils literal notranslate"><span class="pre">signal</span></code> — Set handlers for asynchronous events</a></p>
  <div role="note" aria-label="source link">
    <h3>本页</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/library/ssl.rst.txt"
            rel="nofollow">显示源代码</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>快速搜索</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="转向" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>导航</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="总目录"
             >索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 模块索引"
             >模块</a> |</li>
        <li class="right" >
          <a href="signal.html" title="17.4. signal — Set handlers for asynchronous events"
             >下一页</a> |</li>
        <li class="right" >
          <a href="socket.html" title="17.2. socket — Low-level networking interface"
             >上一页</a> |</li>

    <li><img src="../_static/py.png" alt=""
             style="vertical-align: middle; margin-top: -1px"/></li>
    <li><a href="https://www.python.org/">Python</a> &#187;</li>
    

          <li id="cpython-language-and-version">
            <a href="../index.html">Python 2.6.9 文档</a> &#187;
          </li>

          <li class="nav-item nav-item-1"><a href="index.html" >The Python Standard Library</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="ipc.html" >17. Interprocess Communication and Networking</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="快速搜索" type="text" name="q" />
          <input type="submit" value="转向" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">版权所有</a> 1990-2026, Python Software Foundation.
    <br />

    The Python Software Foundation is a non-profit corporation.
<a href="https://www.python.org/psf/donations/">Please donate.</a>
<br />
    <br />

    最后更新于 2月 24, 2026.
    
    <br />

    Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.8.4.
    </div>

  </body>
</html>
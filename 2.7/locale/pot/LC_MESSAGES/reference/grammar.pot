# SOME DESCRIPTIVE TITLE.
# Copyright (C) 1990-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 2.7\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-10 15:08+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: /home/runner/work/python-docs-l10n/python-docs-l10n/out/repo/Doc/reference/grammar.rst:2
msgid "Full Grammar specification"
msgstr ""

#: /home/runner/work/python-docs-l10n/python-docs-l10n/out/repo/Doc/reference/grammar.rst:4
msgid ""
"This is the full Python grammar, as it is read by the parser generator and "
"used to parse Python source files:"
msgstr ""

#: /home/runner/work/python-docs-l10n/python-docs-l10n/out/repo/Doc/reference/grammar.rst:7
msgid ""
"# Grammar for Python\n"
"\n"
"# Note:  Changing the grammar specified in this file will most likely\n"
"#        require corresponding changes in the parser module\n"
"#        (../Modules/parsermodule.c).  If you can't make the changes to\n"
"#        that module yourself, please co-ordinate the required changes\n"
"#        with someone who can; ask around on python-dev for help.  Fred\n"
"#        Drake <fdrake@acm.org> will probably be listening there.\n"
"\n"
"# NOTE WELL: You should also follow all the steps listed in PEP 306,\n"
"# \"How to Change Python's Grammar\"\n"
"\n"
"# Start symbols for the grammar:\n"
"#       single_input is a single interactive statement;\n"
"#       file_input is a module or sequence of commands read from an input "
"file;\n"
"#       eval_input is the input for the eval() and input() functions.\n"
"# NB: compound_stmt in single_input is followed by extra NEWLINE!\n"
"single_input: NEWLINE | simple_stmt | compound_stmt NEWLINE\n"
"file_input: (NEWLINE | stmt)* ENDMARKER\n"
"eval_input: testlist NEWLINE* ENDMARKER\n"
"\n"
"decorator: '@' dotted_name [ '(' [arglist] ')' ] NEWLINE\n"
"decorators: decorator+\n"
"decorated: decorators (classdef | funcdef)\n"
"funcdef: 'def' NAME parameters ':' suite\n"
"parameters: '(' [varargslist] ')'\n"
"varargslist: ((fpdef ['=' test] ',')*\n"
"              ('*' NAME [',' '**' NAME] | '**' NAME) |\n"
"              fpdef ['=' test] (',' fpdef ['=' test])* [','])\n"
"fpdef: NAME | '(' fplist ')'\n"
"fplist: fpdef (',' fpdef)* [',']\n"
"\n"
"stmt: simple_stmt | compound_stmt\n"
"simple_stmt: small_stmt (';' small_stmt)* [';'] NEWLINE\n"
"small_stmt: (expr_stmt | print_stmt  | del_stmt | pass_stmt | flow_stmt |\n"
"             import_stmt | global_stmt | exec_stmt | assert_stmt)\n"
"expr_stmt: testlist (augassign (yield_expr|testlist) |\n"
"                     ('=' (yield_expr|testlist))*)\n"
"augassign: ('+=' | '-=' | '*=' | '/=' | '%=' | '&=' | '|=' | '^=' |\n"
"            '<<=' | '>>=' | '**=' | '//=')\n"
"# For normal assignments, additional restrictions enforced by the "
"interpreter\n"
"print_stmt: 'print' ( [ test (',' test)* [','] ] |\n"
"                      '>>' test [ (',' test)+ [','] ] )\n"
"del_stmt: 'del' exprlist\n"
"pass_stmt: 'pass'\n"
"flow_stmt: break_stmt | continue_stmt | return_stmt | raise_stmt | "
"yield_stmt\n"
"break_stmt: 'break'\n"
"continue_stmt: 'continue'\n"
"return_stmt: 'return' [testlist]\n"
"yield_stmt: yield_expr\n"
"raise_stmt: 'raise' [test [',' test [',' test]]]\n"
"import_stmt: import_name | import_from\n"
"import_name: 'import' dotted_as_names\n"
"import_from: ('from' ('.'* dotted_name | '.'+)\n"
"              'import' ('*' | '(' import_as_names ')' | import_as_names))\n"
"import_as_name: NAME ['as' NAME]\n"
"dotted_as_name: dotted_name ['as' NAME]\n"
"import_as_names: import_as_name (',' import_as_name)* [',']\n"
"dotted_as_names: dotted_as_name (',' dotted_as_name)*\n"
"dotted_name: NAME ('.' NAME)*\n"
"global_stmt: 'global' NAME (',' NAME)*\n"
"exec_stmt: 'exec' expr ['in' test [',' test]]\n"
"assert_stmt: 'assert' test [',' test]\n"
"\n"
"compound_stmt: if_stmt | while_stmt | for_stmt | try_stmt | with_stmt | "
"funcdef | classdef | decorated\n"
"if_stmt: 'if' test ':' suite ('elif' test ':' suite)* ['else' ':' suite]\n"
"while_stmt: 'while' test ':' suite ['else' ':' suite]\n"
"for_stmt: 'for' exprlist 'in' testlist ':' suite ['else' ':' suite]\n"
"try_stmt: ('try' ':' suite\n"
"           ((except_clause ':' suite)+\n"
"            ['else' ':' suite]\n"
"            ['finally' ':' suite] |\n"
"           'finally' ':' suite))\n"
"with_stmt: 'with' with_item (',' with_item)*  ':' suite\n"
"with_item: test ['as' expr]\n"
"# NB compile.c makes sure that the default except clause is last\n"
"except_clause: 'except' [test [('as' | ',') test]]\n"
"suite: simple_stmt | NEWLINE INDENT stmt+ DEDENT\n"
"\n"
"# Backward compatibility cruft to support:\n"
"# [ x for x in lambda: True, lambda: False if x() ]\n"
"# even while also allowing:\n"
"# lambda x: 5 if x else 2\n"
"# (But not a mix of the two)\n"
"testlist_safe: old_test [(',' old_test)+ [',']]\n"
"old_test: or_test | old_lambdef\n"
"old_lambdef: 'lambda' [varargslist] ':' old_test\n"
"\n"
"test: or_test ['if' or_test 'else' test] | lambdef\n"
"or_test: and_test ('or' and_test)*\n"
"and_test: not_test ('and' not_test)*\n"
"not_test: 'not' not_test | comparison\n"
"comparison: expr (comp_op expr)*\n"
"comp_op: '<'|'>'|'=='|'>='|'<='|'<>'|'!='|'in'|'not' 'in'|'is'|'is' 'not'\n"
"expr: xor_expr ('|' xor_expr)*\n"
"xor_expr: and_expr ('^' and_expr)*\n"
"and_expr: shift_expr ('&' shift_expr)*\n"
"shift_expr: arith_expr (('<<'|'>>') arith_expr)*\n"
"arith_expr: term (('+'|'-') term)*\n"
"term: factor (('*'|'/'|'%'|'//') factor)*\n"
"factor: ('+'|'-'|'~') factor | power\n"
"power: atom trailer* ['**' factor]\n"
"atom: ('(' [yield_expr|testlist_comp] ')' |\n"
"       '[' [listmaker] ']' |\n"
"       '{' [dictorsetmaker] '}' |\n"
"       '`' testlist1 '`' |\n"
"       NAME | NUMBER | STRING+)\n"
"listmaker: test ( list_for | (',' test)* [','] )\n"
"testlist_comp: test ( comp_for | (',' test)* [','] )\n"
"lambdef: 'lambda' [varargslist] ':' test\n"
"trailer: '(' [arglist] ')' | '[' subscriptlist ']' | '.' NAME\n"
"subscriptlist: subscript (',' subscript)* [',']\n"
"subscript: '.' '.' '.' | test | [test] ':' [test] [sliceop]\n"
"sliceop: ':' [test]\n"
"exprlist: expr (',' expr)* [',']\n"
"testlist: test (',' test)* [',']\n"
"dictorsetmaker: ( (test ':' test (comp_for | (',' test ':' test)* [','])) |\n"
"                  (test (comp_for | (',' test)* [','])) )\n"
"\n"
"classdef: 'class' NAME ['(' [testlist] ')'] ':' suite\n"
"\n"
"arglist: (argument ',')* (argument [',']\n"
"                         |'*' test (',' argument)* [',' '**' test] \n"
"                         |'**' test)\n"
"# The reason that keywords are test nodes instead of NAME is that using "
"NAME\n"
"# results in an ambiguity. ast.c makes sure it's a NAME.\n"
"argument: test [comp_for] | test '=' test\n"
"\n"
"list_iter: list_for | list_if\n"
"list_for: 'for' exprlist 'in' testlist_safe [list_iter]\n"
"list_if: 'if' old_test [list_iter]\n"
"\n"
"comp_iter: comp_for | comp_if\n"
"comp_for: 'for' exprlist 'in' or_test [comp_iter]\n"
"comp_if: 'if' old_test [comp_iter]\n"
"\n"
"testlist1: test (',' test)*\n"
"\n"
"# not used in grammar, but may appear in \"node\" passed from Parser to "
"Compiler\n"
"encoding_decl: NAME\n"
"\n"
"yield_expr: 'yield' [testlist]\n"
msgstr ""

# SOME DESCRIPTIVE TITLE.
# Copyright (C) 1990-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-10 15:11+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../library/datetime.rst:2
msgid ":mod:`datetime` --- Basic date and time types"
msgstr ""

#: ../../../library/datetime.rst:12
msgid ""
"The :mod:`datetime` module supplies classes for manipulating dates and times "
"in both simple and complex ways.  While date and time arithmetic is "
"supported, the focus of the implementation is on efficient member extraction "
"for output formatting and manipulation. For related functionality, see also "
"the :mod:`time` and :mod:`calendar` modules."
msgstr ""

#: ../../../library/datetime.rst:18
msgid ""
"There are two kinds of date and time objects: \"naive\" and \"aware\". This "
"distinction refers to whether the object has any notion of time zone, "
"daylight saving time, or other kind of algorithmic or political time "
"adjustment.  Whether a naive :class:`datetime` object represents Coordinated "
"Universal Time (UTC), local time, or time in some other timezone is purely "
"up to the program, just like it's up to the program whether a particular "
"number represents metres, miles, or mass.  Naive :class:`datetime` objects "
"are easy to understand and to work with, at the cost of ignoring some "
"aspects of reality."
msgstr ""

#: ../../../library/datetime.rst:27
msgid ""
"For applications requiring more, :class:`datetime` and :class:`time` objects "
"have an optional time zone information member, :attr:`tzinfo`, that can "
"contain an instance of a subclass of the abstract :class:`tzinfo` class.  "
"These :class:`tzinfo` objects capture information about the offset from UTC "
"time, the time zone name, and whether Daylight Saving Time is in effect.  "
"Note that no concrete :class:`tzinfo` classes are supplied by the :mod:"
"`datetime` module. Supporting timezones at whatever level of detail is "
"required is up to the application.  The rules for time adjustment across the "
"world are more political than rational, and there is no standard suitable "
"for every application."
msgstr ""

#: ../../../library/datetime.rst:37
msgid "The :mod:`datetime` module exports the following constants:"
msgstr ""

#: ../../../library/datetime.rst:42
msgid ""
"The smallest year number allowed in a :class:`date` or :class:`datetime` "
"object. :const:`MINYEAR` is ``1``."
msgstr ""

#: ../../../library/datetime.rst:48
msgid ""
"The largest year number allowed in a :class:`date` or :class:`datetime` "
"object. :const:`MAXYEAR` is ``9999``."
msgstr ""

#: ../../../library/datetime.rst:55
msgid "Module :mod:`calendar`"
msgstr ""

#: ../../../library/datetime.rst:55
msgid "General calendar related functions."
msgstr ""

#: ../../../library/datetime.rst:57
msgid "Module :mod:`time`"
msgstr ""

#: ../../../library/datetime.rst:58
msgid "Time access and conversions."
msgstr ""

#: ../../../library/datetime.rst:62
msgid "Available Types"
msgstr ""

#: ../../../library/datetime.rst:67
msgid ""
"An idealized naive date, assuming the current Gregorian calendar always was, "
"and always will be, in effect. Attributes: :attr:`year`, :attr:`month`, and :"
"attr:`day`."
msgstr ""

#: ../../../library/datetime.rst:74
msgid ""
"An idealized time, independent of any particular day, assuming that every "
"day has exactly 24\\*60\\*60 seconds (there is no notion of \"leap seconds\" "
"here). Attributes: :attr:`hour`, :attr:`minute`, :attr:`second`, :attr:"
"`microsecond`, and :attr:`tzinfo`."
msgstr ""

#: ../../../library/datetime.rst:82
msgid ""
"A combination of a date and a time. Attributes: :attr:`year`, :attr:"
"`month`, :attr:`day`, :attr:`hour`, :attr:`minute`, :attr:`second`, :attr:"
"`microsecond`, and :attr:`tzinfo`."
msgstr ""

#: ../../../library/datetime.rst:89
msgid ""
"A duration expressing the difference between two :class:`date`, :class:"
"`time`, or :class:`datetime` instances to microsecond resolution."
msgstr ""

#: ../../../library/datetime.rst:95
msgid ""
"An abstract base class for time zone information objects.  These are used by "
"the :class:`datetime` and :class:`time` classes to provide a customizable "
"notion of time adjustment (for example, to account for time zone and/or "
"daylight saving time)."
msgstr ""

#: ../../../library/datetime.rst:100
msgid "Objects of these types are immutable."
msgstr ""

#: ../../../library/datetime.rst:102
msgid "Objects of the :class:`date` type are always naive."
msgstr ""

#: ../../../library/datetime.rst:104
msgid ""
"An object *d* of type :class:`time` or :class:`datetime` may be naive or "
"aware. *d* is aware if ``d.tzinfo`` is not ``None`` and ``d.tzinfo."
"utcoffset(d)`` does not return ``None``.  If ``d.tzinfo`` is ``None``, or if "
"``d.tzinfo`` is not ``None`` but ``d.tzinfo.utcoffset(d)`` returns ``None``, "
"*d* is naive."
msgstr ""

#: ../../../library/datetime.rst:109
msgid ""
"The distinction between naive and aware doesn't apply to :class:`timedelta` "
"objects."
msgstr ""

#: ../../../library/datetime.rst:112
msgid "Subclass relationships::"
msgstr ""

#: ../../../library/datetime.rst:114
msgid ""
"object\n"
"    timedelta\n"
"    tzinfo\n"
"    time\n"
"    date\n"
"        datetime"
msgstr ""

#: ../../../library/datetime.rst:125
msgid ":class:`timedelta` Objects"
msgstr ""

#: ../../../library/datetime.rst:127
msgid ""
"A :class:`timedelta` object represents a duration, the difference between "
"two dates or times."
msgstr ""

#: ../../../library/datetime.rst:133
msgid ""
"All arguments are optional and default to ``0``.  Arguments may be integers "
"or floats, and may be positive or negative."
msgstr ""

#: ../../../library/datetime.rst:136
msgid ""
"Only *days*, *seconds* and *microseconds* are stored internally.  Arguments "
"are converted to those units:"
msgstr ""

#: ../../../library/datetime.rst:139
msgid "A millisecond is converted to 1000 microseconds."
msgstr ""

#: ../../../library/datetime.rst:140
msgid "A minute is converted to 60 seconds."
msgstr ""

#: ../../../library/datetime.rst:141
msgid "An hour is converted to 3600 seconds."
msgstr ""

#: ../../../library/datetime.rst:142
msgid "A week is converted to 7 days."
msgstr ""

#: ../../../library/datetime.rst:144
msgid ""
"and days, seconds and microseconds are then normalized so that the "
"representation is unique, with"
msgstr ""

#: ../../../library/datetime.rst:147
msgid "``0 <= microseconds < 1000000``"
msgstr ""

#: ../../../library/datetime.rst:148
msgid "``0 <= seconds < 3600*24`` (the number of seconds in one day)"
msgstr ""

#: ../../../library/datetime.rst:149
msgid "``-999999999 <= days <= 999999999``"
msgstr ""

#: ../../../library/datetime.rst:151
msgid ""
"If any argument is a float and there are fractional microseconds, the "
"fractional microseconds left over from all arguments are combined and their "
"sum is rounded to the nearest microsecond.  If no argument is a float, the "
"conversion and normalization processes are exact (no information is lost)."
msgstr ""

#: ../../../library/datetime.rst:156
msgid ""
"If the normalized value of days lies outside the indicated range, :exc:"
"`OverflowError` is raised."
msgstr ""

#: ../../../library/datetime.rst:159
msgid ""
"Note that normalization of negative values may be surprising at first. For "
"example,"
msgstr ""

#: ../../../library/datetime.rst:167
msgid "Class attributes are:"
msgstr ""

#: ../../../library/datetime.rst:172
msgid "The most negative :class:`timedelta` object, ``timedelta(-999999999)``."
msgstr ""

#: ../../../library/datetime.rst:177
msgid ""
"The most positive :class:`timedelta` object, ``timedelta(days=999999999, "
"hours=23, minutes=59, seconds=59, microseconds=999999)``."
msgstr ""

#: ../../../library/datetime.rst:183
msgid ""
"The smallest possible difference between non-equal :class:`timedelta` "
"objects, ``timedelta(microseconds=1)``."
msgstr ""

#: ../../../library/datetime.rst:186
msgid ""
"Note that, because of normalization, ``timedelta.max`` > ``-timedelta.min``. "
"``-timedelta.max`` is not representable as a :class:`timedelta` object."
msgstr ""

#: ../../../library/datetime.rst:189 ../../../library/datetime.rst:357
#: ../../../library/datetime.rst:696 ../../../library/datetime.rst:1137
msgid "Instance attributes (read-only):"
msgstr ""

#: ../../../library/datetime.rst:192
msgid "Attribute"
msgstr ""

#: ../../../library/datetime.rst:192
msgid "Value"
msgstr ""

#: ../../../library/datetime.rst:194
msgid "``days``"
msgstr ""

#: ../../../library/datetime.rst:194
msgid "Between -999999999 and 999999999 inclusive"
msgstr ""

#: ../../../library/datetime.rst:196
msgid "``seconds``"
msgstr ""

#: ../../../library/datetime.rst:196
msgid "Between 0 and 86399 inclusive"
msgstr ""

#: ../../../library/datetime.rst:198
msgid "``microseconds``"
msgstr ""

#: ../../../library/datetime.rst:198
msgid "Between 0 and 999999 inclusive"
msgstr ""

#: ../../../library/datetime.rst:201 ../../../library/datetime.rst:374
#: ../../../library/datetime.rst:739 ../../../library/datetime.rst:1165
msgid "Supported operations:"
msgstr ""

#: ../../../library/datetime.rst:206 ../../../library/datetime.rst:377
#: ../../../library/datetime.rst:742
msgid "Operation"
msgstr ""

#: ../../../library/datetime.rst:206 ../../../library/datetime.rst:377
#: ../../../library/datetime.rst:742
msgid "Result"
msgstr ""

#: ../../../library/datetime.rst:208
msgid "``t1 = t2 + t3``"
msgstr ""

#: ../../../library/datetime.rst:208
msgid ""
"Sum of *t2* and *t3*. Afterwards *t1*-*t2* == *t3* and *t1*-*t3* == *t2* are "
"true. (1)"
msgstr ""

#: ../../../library/datetime.rst:211
msgid "``t1 = t2 - t3``"
msgstr ""

#: ../../../library/datetime.rst:211
msgid ""
"Difference of *t2* and *t3*. Afterwards *t1* == *t2* - *t3* and *t2* == *t1* "
"+ *t3* are true. (1)"
msgstr ""

#: ../../../library/datetime.rst:215
msgid "``t1 = t2 * i or t1 = i * t2``"
msgstr ""

#: ../../../library/datetime.rst:215
msgid ""
"Delta multiplied by an integer. Afterwards *t1* // i == *t2* is true, "
"provided ``i != 0``."
msgstr ""

#: ../../../library/datetime.rst:219
msgid "In general, *t1* \\* i == *t1* \\* (i-1) + *t1* is true. (1)"
msgstr ""

#: ../../../library/datetime.rst:222
msgid "``t1 = t2 // i``"
msgstr ""

#: ../../../library/datetime.rst:222
msgid "The floor is computed and the remainder (if any) is thrown away. (3)"
msgstr ""

#: ../../../library/datetime.rst:225
msgid "``+t1``"
msgstr ""

#: ../../../library/datetime.rst:225
msgid "Returns a :class:`timedelta` object with the same value. (2)"
msgstr ""

#: ../../../library/datetime.rst:228
msgid "``-t1``"
msgstr ""

#: ../../../library/datetime.rst:228
msgid ""
"equivalent to :class:`timedelta`\\ (-*t1.days*, -*t1.seconds*, -*t1."
"microseconds*), and to *t1*\\* -1. (1)(4)"
msgstr ""

#: ../../../library/datetime.rst:232
msgid "``abs(t)``"
msgstr ""

#: ../../../library/datetime.rst:232
msgid ""
"equivalent to +*t* when ``t.days >= 0``, and to -*t* when ``t.days < 0``. (2)"
msgstr ""

#: ../../../library/datetime.rst:236 ../../../library/datetime.rst:391
#: ../../../library/datetime.rst:1610
msgid "Notes:"
msgstr ""

#: ../../../library/datetime.rst:239
msgid "This is exact, but may overflow."
msgstr ""

#: ../../../library/datetime.rst:242
msgid "This is exact, and cannot overflow."
msgstr ""

#: ../../../library/datetime.rst:245
msgid "Division by 0 raises :exc:`ZeroDivisionError`."
msgstr ""

#: ../../../library/datetime.rst:248
msgid "-*timedelta.max* is not representable as a :class:`timedelta` object."
msgstr ""

#: ../../../library/datetime.rst:250
msgid ""
"In addition to the operations listed above :class:`timedelta` objects "
"support certain additions and subtractions with :class:`date` and :class:"
"`datetime` objects (see below)."
msgstr ""

#: ../../../library/datetime.rst:254
msgid ""
"Comparisons of :class:`timedelta` objects are supported with the :class:"
"`timedelta` object representing the smaller duration considered to be the "
"smaller timedelta. In order to stop mixed-type comparisons from falling back "
"to the default comparison by object address, when a :class:`timedelta` "
"object is compared to an object of a different type, :exc:`TypeError` is "
"raised unless the comparison is ``==`` or ``!=``.  The latter cases return :"
"const:`False` or :const:`True`, respectively."
msgstr ""

#: ../../../library/datetime.rst:262
msgid ""
":class:`timedelta` objects are :term:`hashable` (usable as dictionary keys), "
"support efficient pickling, and in Boolean contexts, a :class:`timedelta` "
"object is considered to be true if and only if it isn't equal to "
"``timedelta(0)``."
msgstr ""

#: ../../../library/datetime.rst:266
msgid "Example usage:"
msgstr ""

#: ../../../library/datetime.rst:290
msgid ":class:`date` Objects"
msgstr ""

#: ../../../library/datetime.rst:292
msgid ""
"A :class:`date` object represents a date (year, month and day) in an "
"idealized calendar, the current Gregorian calendar indefinitely extended in "
"both directions.  January 1 of year 1 is called day number 1, January 2 of "
"year 1 is called day number 2, and so on.  This matches the definition of "
"the \"proleptic Gregorian\" calendar in Dershowitz and Reingold's book "
"Calendrical Calculations, where it's the base calendar for all "
"computations.  See the book for algorithms for converting between proleptic "
"Gregorian ordinals and many other calendar systems."
msgstr ""

#: ../../../library/datetime.rst:304
msgid ""
"All arguments are required.  Arguments may be integers, in the following "
"ranges:"
msgstr ""

#: ../../../library/datetime.rst:307 ../../../library/datetime.rst:579
msgid "``MINYEAR <= year <= MAXYEAR``"
msgstr ""

#: ../../../library/datetime.rst:308 ../../../library/datetime.rst:580
msgid "``1 <= month <= 12``"
msgstr ""

#: ../../../library/datetime.rst:309 ../../../library/datetime.rst:581
msgid "``1 <= day <= number of days in the given month and year``"
msgstr ""

#: ../../../library/datetime.rst:311 ../../../library/datetime.rst:587
msgid ""
"If an argument outside those ranges is given, :exc:`ValueError` is raised."
msgstr ""

#: ../../../library/datetime.rst:313 ../../../library/datetime.rst:589
msgid "Other constructors, all class methods:"
msgstr ""

#: ../../../library/datetime.rst:318
msgid ""
"Return the current local date.  This is equivalent to ``date."
"fromtimestamp(time.time())``."
msgstr ""

#: ../../../library/datetime.rst:324
msgid ""
"Return the local date corresponding to the POSIX timestamp, such as is "
"returned by :func:`time.time`.  This may raise :exc:`ValueError`, if the "
"timestamp is out of the range of values supported by the platform C :cfunc:"
"`localtime` function. It's common for this to be restricted to years from "
"1970 through 2038.  Note that on non-POSIX systems that include leap seconds "
"in their notion of a timestamp, leap seconds are ignored by :meth:"
"`fromtimestamp`."
msgstr ""

#: ../../../library/datetime.rst:334
msgid ""
"Return the date corresponding to the proleptic Gregorian ordinal, where "
"January 1 of year 1 has ordinal 1.  :exc:`ValueError` is raised unless ``1 "
"<= ordinal <= date.max.toordinal()``. For any date *d*, ``date.fromordinal(d."
"toordinal()) == d``."
msgstr ""

#: ../../../library/datetime.rst:339 ../../../library/datetime.rst:676
#: ../../../library/datetime.rst:1118
msgid "Class attributes:"
msgstr ""

#: ../../../library/datetime.rst:344
msgid "The earliest representable date, ``date(MINYEAR, 1, 1)``."
msgstr ""

#: ../../../library/datetime.rst:349
msgid "The latest representable date, ``date(MAXYEAR, 12, 31)``."
msgstr ""

#: ../../../library/datetime.rst:354
msgid ""
"The smallest possible difference between non-equal date objects, "
"``timedelta(days=1)``."
msgstr ""

#: ../../../library/datetime.rst:362 ../../../library/datetime.rst:701
msgid "Between :const:`MINYEAR` and :const:`MAXYEAR` inclusive."
msgstr ""

#: ../../../library/datetime.rst:367 ../../../library/datetime.rst:706
msgid "Between 1 and 12 inclusive."
msgstr ""

#: ../../../library/datetime.rst:372 ../../../library/datetime.rst:711
msgid "Between 1 and the number of days in the given month of the given year."
msgstr ""

#: ../../../library/datetime.rst:379
msgid "``date2 = date1 + timedelta``"
msgstr ""

#: ../../../library/datetime.rst:379
msgid "*date2* is ``timedelta.days`` days removed from *date1*.  (1)"
msgstr ""

#: ../../../library/datetime.rst:382
msgid "``date2 = date1 - timedelta``"
msgstr ""

#: ../../../library/datetime.rst:382
msgid "Computes *date2* such that ``date2 + timedelta == date1``. (2)"
msgstr ""

#: ../../../library/datetime.rst:385
msgid "``timedelta = date1 - date2``"
msgstr ""

#: ../../../library/datetime.rst:385 ../../../library/datetime.rst:748
#: ../../../library/datetime.rst:1566
msgid "\\(3)"
msgstr ""

#: ../../../library/datetime.rst:387
msgid "``date1 < date2``"
msgstr ""

#: ../../../library/datetime.rst:387
msgid ""
"*date1* is considered less than *date2* when *date1* precedes *date2* in "
"time. (4)"
msgstr ""

#: ../../../library/datetime.rst:394
msgid ""
"*date2* is moved forward in time if ``timedelta.days > 0``, or backward if "
"``timedelta.days < 0``.  Afterward ``date2 - date1 == timedelta.days``. "
"``timedelta.seconds`` and ``timedelta.microseconds`` are ignored. :exc:"
"`OverflowError` is raised if ``date2.year`` would be smaller than :const:"
"`MINYEAR` or larger than :const:`MAXYEAR`."
msgstr ""

#: ../../../library/datetime.rst:401
msgid ""
"This isn't quite equivalent to date1 + (-timedelta), because -timedelta in "
"isolation can overflow in cases where date1 - timedelta does not. "
"``timedelta.seconds`` and ``timedelta.microseconds`` are ignored."
msgstr ""

#: ../../../library/datetime.rst:406
msgid ""
"This is exact, and cannot overflow.  timedelta.seconds and timedelta."
"microseconds are 0, and date2 + timedelta == date1 after."
msgstr ""

#: ../../../library/datetime.rst:410
msgid ""
"In other words, ``date1 < date2`` if and only if ``date1.toordinal() < date2."
"toordinal()``. In order to stop comparison from falling back to the default "
"scheme of comparing object addresses, date comparison normally raises :exc:"
"`TypeError` if the other comparand isn't also a :class:`date` object. "
"However, ``NotImplemented`` is returned instead if the other comparand has "
"a :meth:`timetuple` attribute.  This hook gives other kinds of date objects "
"a chance at implementing mixed-type comparison. If not, when a :class:`date` "
"object is compared to an object of a different type, :exc:`TypeError` is "
"raised unless the comparison is ``==`` or ``!=``.  The latter cases return :"
"const:`False` or :const:`True`, respectively."
msgstr ""

#: ../../../library/datetime.rst:421
msgid ""
"Dates can be used as dictionary keys. In Boolean contexts, all :class:`date` "
"objects are considered to be true."
msgstr ""

#: ../../../library/datetime.rst:424 ../../../library/datetime.rst:810
#: ../../../library/datetime.rst:1187
msgid "Instance methods:"
msgstr ""

#: ../../../library/datetime.rst:429
msgid ""
"Return a date with the same value, except for those members given new values "
"by whichever keyword arguments are specified.  For example, if ``d == "
"date(2002, 12, 31)``, then ``d.replace(day=26) == date(2002, 12, 26)``."
msgstr ""

#: ../../../library/datetime.rst:436
msgid ""
"Return a :class:`time.struct_time` such as returned by :func:`time."
"localtime`. The hours, minutes and seconds are 0, and the DST flag is -1. "
"``d.timetuple()`` is equivalent to ``time.struct_time((d.year, d.month, d."
"day, 0, 0, 0, d.weekday(), d.toordinal() - date(d.year, 1, 1).toordinal() + "
"1, -1))``"
msgstr ""

#: ../../../library/datetime.rst:444
msgid ""
"Return the proleptic Gregorian ordinal of the date, where January 1 of year "
"1 has ordinal 1.  For any :class:`date` object *d*, ``date.fromordinal(d."
"toordinal()) == d``."
msgstr ""

#: ../../../library/datetime.rst:451
msgid ""
"Return the day of the week as an integer, where Monday is 0 and Sunday is 6. "
"For example, ``date(2002, 12, 4).weekday() == 2``, a Wednesday. See also :"
"meth:`isoweekday`."
msgstr ""

#: ../../../library/datetime.rst:458
msgid ""
"Return the day of the week as an integer, where Monday is 1 and Sunday is 7. "
"For example, ``date(2002, 12, 4).isoweekday() == 3``, a Wednesday. See also :"
"meth:`weekday`, :meth:`isocalendar`."
msgstr ""

#: ../../../library/datetime.rst:465
msgid "Return a 3-tuple, (ISO year, ISO week number, ISO weekday)."
msgstr ""

#: ../../../library/datetime.rst:467
msgid ""
"The ISO calendar is a widely used variant of the Gregorian calendar. See "
"http://www.phys.uu.nl/ vgent/calendar/isocalendar.htm for a good explanation."
msgstr ""

#: ../../../library/datetime.rst:470
msgid ""
"The ISO year consists of 52 or 53 full weeks, and where a week starts on a "
"Monday and ends on a Sunday.  The first week of an ISO year is the first "
"(Gregorian) calendar week of a year containing a Thursday. This is called "
"week number 1, and the ISO year of that Thursday is the same as its "
"Gregorian year."
msgstr ""

#: ../../../library/datetime.rst:475
msgid ""
"For example, 2004 begins on a Thursday, so the first week of ISO year 2004 "
"begins on Monday, 29 Dec 2003 and ends on Sunday, 4 Jan 2004, so that "
"``date(2003, 12, 29).isocalendar() == (2004, 1, 1)`` and ``date(2004, 1, 4)."
"isocalendar() == (2004, 1, 7)``."
msgstr ""

#: ../../../library/datetime.rst:483
msgid ""
"Return a string representing the date in ISO 8601 format, 'YYYY-MM-DD'.  For "
"example, ``date(2002, 12, 4).isoformat() == '2002-12-04'``."
msgstr ""

#: ../../../library/datetime.rst:489
msgid "For a date *d*, ``str(d)`` is equivalent to ``d.isoformat()``."
msgstr ""

#: ../../../library/datetime.rst:494
msgid ""
"Return a string representing the date, for example ``date(2002, 12, 4)."
"ctime() == 'Wed Dec 4 00:00:00 2002'``. ``d.ctime()`` is equivalent to "
"``time.ctime(time.mktime(d.timetuple()))`` on platforms where the native C :"
"cfunc:`ctime` function (which :func:`time.ctime` invokes, but which :meth:"
"`date.ctime` does not invoke) conforms to the C standard."
msgstr ""

#: ../../../library/datetime.rst:503
msgid ""
"Return a string representing the date, controlled by an explicit format "
"string. Format codes referring to hours, minutes or seconds will see 0 "
"values. See section :ref:`strftime-behavior`."
msgstr ""

#: ../../../library/datetime.rst:507
msgid "Example of counting days to an event::"
msgstr ""

#: ../../../library/datetime.rst:509
msgid ""
">>> import time\n"
">>> from datetime import date\n"
">>> today = date.today()\n"
">>> today\n"
"datetime.date(2007, 12, 5)\n"
">>> today == date.fromtimestamp(time.time())\n"
"True\n"
">>> my_birthday = date(today.year, 6, 24)\n"
">>> if my_birthday < today:\n"
"...     my_birthday = my_birthday.replace(year=today.year + 1)\n"
">>> my_birthday\n"
"datetime.date(2008, 6, 24)\n"
">>> time_to_birthday = abs(my_birthday - today)\n"
">>> time_to_birthday.days\n"
"202"
msgstr ""

#: ../../../library/datetime.rst:525
msgid "Example of working with :class:`date`:"
msgstr ""

#: ../../../library/datetime.rst:527
msgid ""
">>> from datetime import date\n"
">>> d = date.fromordinal(730920) # 730920th day after 1. 1. 0001\n"
">>> d\n"
"datetime.date(2002, 3, 11)\n"
">>> t = d.timetuple()\n"
">>> for i in t:     \n"
"...     print(i)\n"
"2002                # year\n"
"3                   # month\n"
"11                  # day\n"
"0\n"
"0\n"
"0\n"
"0                   # weekday (0 = Monday)\n"
"70                  # 70th day in the year\n"
"-1\n"
">>> ic = d.isocalendar()\n"
">>> for i in ic:    \n"
"...     print(i)\n"
"2002                # ISO year\n"
"11                  # ISO week number\n"
"1                   # ISO day number ( 1 = Monday )\n"
">>> d.isoformat()\n"
"'2002-03-11'\n"
">>> d.strftime(\"%d/%m/%y\")\n"
"'11/03/02'\n"
">>> d.strftime(\"%A %d. %B %Y\")\n"
"'Monday 11. March 2002'"
msgstr ""

#: ../../../library/datetime.rst:562
msgid ":class:`datetime` Objects"
msgstr ""

#: ../../../library/datetime.rst:564
msgid ""
"A :class:`datetime` object is a single object containing all the information "
"from a :class:`date` object and a :class:`time` object.  Like a :class:"
"`date` object, :class:`datetime` assumes the current Gregorian calendar "
"extended in both directions; like a time object, :class:`datetime` assumes "
"there are exactly 3600\\*24 seconds in every day."
msgstr ""

#: ../../../library/datetime.rst:570
msgid "Constructor:"
msgstr ""

#: ../../../library/datetime.rst:575
msgid ""
"The year, month and day arguments are required.  *tzinfo* may be ``None``, "
"or an instance of a :class:`tzinfo` subclass.  The remaining arguments may "
"be integers, in the following ranges:"
msgstr ""

#: ../../../library/datetime.rst:582 ../../../library/datetime.rst:1110
msgid "``0 <= hour < 24``"
msgstr ""

#: ../../../library/datetime.rst:583 ../../../library/datetime.rst:1111
msgid "``0 <= minute < 60``"
msgstr ""

#: ../../../library/datetime.rst:584 ../../../library/datetime.rst:1112
msgid "``0 <= second < 60``"
msgstr ""

#: ../../../library/datetime.rst:585
msgid "``0 <= microsecond < 1000000``"
msgstr ""

#: ../../../library/datetime.rst:594
msgid ""
"Return the current local datetime, with :attr:`tzinfo` ``None``. This is "
"equivalent to ``datetime.fromtimestamp(time.time())``. See also :meth:"
"`now`, :meth:`fromtimestamp`."
msgstr ""

#: ../../../library/datetime.rst:601
msgid ""
"Return the current local date and time.  If optional argument *tz* is "
"``None`` or not specified, this is like :meth:`today`, but, if possible, "
"supplies more precision than can be gotten from going through a :func:`time."
"time` timestamp (for example, this may be possible on platforms supplying "
"the C :cfunc:`gettimeofday` function)."
msgstr ""

#: ../../../library/datetime.rst:607
msgid ""
"Else *tz* must be an instance of a class :class:`tzinfo` subclass, and the "
"current date and time are converted to *tz*'s time zone.  In this case the "
"result is equivalent to ``tz.fromutc(datetime.utcnow()."
"replace(tzinfo=tz))``. See also :meth:`today`, :meth:`utcnow`."
msgstr ""

#: ../../../library/datetime.rst:615
msgid ""
"Return the current UTC date and time, with :attr:`tzinfo` ``None``. This is "
"like :meth:`now`, but returns the current UTC date and time, as a naive :"
"class:`datetime` object. See also :meth:`now`."
msgstr ""

#: ../../../library/datetime.rst:622
msgid ""
"Return the local date and time corresponding to the POSIX timestamp, such as "
"is returned by :func:`time.time`. If optional argument *tz* is ``None`` or "
"not specified, the timestamp is converted to the platform's local date and "
"time, and the returned :class:`datetime` object is naive."
msgstr ""

#: ../../../library/datetime.rst:627
msgid ""
"Else *tz* must be an instance of a class :class:`tzinfo` subclass, and the "
"timestamp is converted to *tz*'s time zone.  In this case the result is "
"equivalent to ``tz.fromutc(datetime.utcfromtimestamp(timestamp)."
"replace(tzinfo=tz))``."
msgstr ""

#: ../../../library/datetime.rst:632
msgid ""
":meth:`fromtimestamp` may raise :exc:`ValueError`, if the timestamp is out "
"of the range of values supported by the platform C :cfunc:`localtime` or :"
"cfunc:`gmtime` functions.  It's common for this to be restricted to years in "
"1970 through 2038. Note that on non-POSIX systems that include leap seconds "
"in their notion of a timestamp, leap seconds are ignored by :meth:"
"`fromtimestamp`, and then it's possible to have two timestamps differing by "
"a second that yield identical :class:`datetime` objects. See also :meth:"
"`utcfromtimestamp`."
msgstr ""

#: ../../../library/datetime.rst:643
msgid ""
"Return the UTC :class:`datetime` corresponding to the POSIX timestamp, with :"
"attr:`tzinfo` ``None``. This may raise :exc:`ValueError`, if the timestamp "
"is out of the range of values supported by the platform C :cfunc:`gmtime` "
"function. It's common for this to be restricted to years in 1970 through "
"2038. See also :meth:`fromtimestamp`."
msgstr ""

#: ../../../library/datetime.rst:652
msgid ""
"Return the :class:`datetime` corresponding to the proleptic Gregorian "
"ordinal, where January 1 of year 1 has ordinal 1. :exc:`ValueError` is "
"raised unless ``1 <= ordinal <= datetime.max.toordinal()``.  The hour, "
"minute, second and microsecond of the result are all 0, and :attr:`tzinfo` "
"is ``None``."
msgstr ""

#: ../../../library/datetime.rst:660
msgid ""
"Return a new :class:`datetime` object whose date members are equal to the "
"given :class:`date` object's, and whose time and :attr:`tzinfo` members are "
"equal to the given :class:`time` object's. For any :class:`datetime` object "
"*d*, ``d == datetime.combine(d.date(), d.timetz())``.  If date is a :class:"
"`datetime` object, its time and :attr:`tzinfo` members are ignored."
msgstr ""

#: ../../../library/datetime.rst:669
msgid ""
"Return a :class:`datetime` corresponding to *date_string*, parsed according "
"to *format*.  This is equivalent to ``datetime(*(time.strptime(date_string, "
"format)[0:6]))``. :exc:`ValueError` is raised if the date_string and format "
"can't be parsed by :func:`time.strptime` or if it returns a value which "
"isn't a time tuple."
msgstr ""

#: ../../../library/datetime.rst:681
msgid ""
"The earliest representable :class:`datetime`, ``datetime(MINYEAR, 1, 1, "
"tzinfo=None)``."
msgstr ""

#: ../../../library/datetime.rst:687
msgid ""
"The latest representable :class:`datetime`, ``datetime(MAXYEAR, 12, 31, 23, "
"59, 59, 999999, tzinfo=None)``."
msgstr ""

#: ../../../library/datetime.rst:693
msgid ""
"The smallest possible difference between non-equal :class:`datetime` "
"objects, ``timedelta(microseconds=1)``."
msgstr ""

#: ../../../library/datetime.rst:716 ../../../library/datetime.rst:1142
msgid "In ``range(24)``."
msgstr ""

#: ../../../library/datetime.rst:721 ../../../library/datetime.rst:726
#: ../../../library/datetime.rst:1147 ../../../library/datetime.rst:1152
msgid "In ``range(60)``."
msgstr ""

#: ../../../library/datetime.rst:731 ../../../library/datetime.rst:1157
msgid "In ``range(1000000)``."
msgstr ""

#: ../../../library/datetime.rst:736
msgid ""
"The object passed as the *tzinfo* argument to the :class:`datetime` "
"constructor, or ``None`` if none was passed."
msgstr ""

#: ../../../library/datetime.rst:744
msgid "``datetime2 = datetime1 + timedelta``"
msgstr ""

#: ../../../library/datetime.rst:744 ../../../library/datetime.rst:1544
msgid "\\(1)"
msgstr ""

#: ../../../library/datetime.rst:746
msgid "``datetime2 = datetime1 - timedelta``"
msgstr ""

#: ../../../library/datetime.rst:746 ../../../library/datetime.rst:1563
msgid "\\(2)"
msgstr ""

#: ../../../library/datetime.rst:748
msgid "``timedelta = datetime1 - datetime2``"
msgstr ""

#: ../../../library/datetime.rst:750
msgid "``datetime1 < datetime2``"
msgstr ""

#: ../../../library/datetime.rst:750
msgid "Compares :class:`datetime` to :class:`datetime`. (4)"
msgstr ""

#: ../../../library/datetime.rst:755
msgid ""
"datetime2 is a duration of timedelta removed from datetime1, moving forward "
"in time if ``timedelta.days`` > 0, or backward if ``timedelta.days`` < 0.  "
"The result has the same :attr:`tzinfo` member as the input datetime, and "
"datetime2 - datetime1 == timedelta after. :exc:`OverflowError` is raised if "
"datetime2.year would be smaller than :const:`MINYEAR` or larger than :const:"
"`MAXYEAR`. Note that no time zone adjustments are done even if the input is "
"an aware object."
msgstr ""

#: ../../../library/datetime.rst:763
msgid ""
"Computes the datetime2 such that datetime2 + timedelta == datetime1. As for "
"addition, the result has the same :attr:`tzinfo` member as the input "
"datetime, and no time zone adjustments are done even if the input is aware. "
"This isn't quite equivalent to datetime1 + (-timedelta), because -timedelta "
"in isolation can overflow in cases where datetime1 - timedelta does not."
msgstr ""

#: ../../../library/datetime.rst:770
msgid ""
"Subtraction of a :class:`datetime` from a :class:`datetime` is defined only "
"if both operands are naive, or if both are aware.  If one is aware and the "
"other is naive, :exc:`TypeError` is raised."
msgstr ""

#: ../../../library/datetime.rst:774
msgid ""
"If both are naive, or both are aware and have the same :attr:`tzinfo` "
"member, the :attr:`tzinfo` members are ignored, and the result is a :class:"
"`timedelta` object *t* such that ``datetime2 + t == datetime1``.  No time "
"zone adjustments are done in this case."
msgstr ""

#: ../../../library/datetime.rst:779
msgid ""
"If both are aware and have different :attr:`tzinfo` members, ``a-b`` acts as "
"if *a* and *b* were first converted to naive UTC datetimes first.  The "
"result is ``(a.replace(tzinfo=None) - a.utcoffset()) - (b."
"replace(tzinfo=None) - b.utcoffset())`` except that the implementation never "
"overflows."
msgstr ""

#: ../../../library/datetime.rst:785
msgid ""
"*datetime1* is considered less than *datetime2* when *datetime1* precedes "
"*datetime2* in time."
msgstr ""

#: ../../../library/datetime.rst:788
msgid ""
"If one comparand is naive and the other is aware, :exc:`TypeError` is "
"raised. If both comparands are aware, and have the same :attr:`tzinfo` "
"member, the common :attr:`tzinfo` member is ignored and the base datetimes "
"are compared.  If both comparands are aware and have different :attr:"
"`tzinfo` members, the comparands are first adjusted by subtracting their UTC "
"offsets (obtained from ``self.utcoffset()``)."
msgstr ""

#: ../../../library/datetime.rst:797
msgid ""
"In order to stop comparison from falling back to the default scheme of "
"comparing object addresses, datetime comparison normally raises :exc:"
"`TypeError` if the other comparand isn't also a :class:`datetime` object.  "
"However, ``NotImplemented`` is returned instead if the other comparand has "
"a :meth:`timetuple` attribute.  This hook gives other kinds of date objects "
"a chance at implementing mixed-type comparison.  If not, when a :class:"
"`datetime` object is compared to an object of a different type, :exc:"
"`TypeError` is raised unless the comparison is ``==`` or ``!=``.  The latter "
"cases return :const:`False` or :const:`True`, respectively."
msgstr ""

#: ../../../library/datetime.rst:807
msgid ""
":class:`datetime` objects can be used as dictionary keys. In Boolean "
"contexts, all :class:`datetime` objects are considered to be true."
msgstr ""

#: ../../../library/datetime.rst:815
msgid "Return :class:`date` object with same year, month and day."
msgstr ""

#: ../../../library/datetime.rst:820
msgid ""
"Return :class:`time` object with same hour, minute, second and microsecond. :"
"attr:`tzinfo` is ``None``.  See also method :meth:`timetz`."
msgstr ""

#: ../../../library/datetime.rst:826
msgid ""
"Return :class:`time` object with same hour, minute, second, microsecond, and "
"tzinfo members.  See also method :meth:`time`."
msgstr ""

#: ../../../library/datetime.rst:832
msgid ""
"Return a datetime with the same members, except for those members given new "
"values by whichever keyword arguments are specified.  Note that "
"``tzinfo=None`` can be specified to create a naive datetime from an aware "
"datetime with no conversion of date and time members."
msgstr ""

#: ../../../library/datetime.rst:840
msgid ""
"Return a :class:`datetime` object with new :attr:`tzinfo` member *tz*, "
"adjusting the date and time members so the result is the same UTC time as "
"*self*, but in *tz*'s local time."
msgstr ""

#: ../../../library/datetime.rst:844
msgid ""
"*tz* must be an instance of a :class:`tzinfo` subclass, and its :meth:"
"`utcoffset` and :meth:`dst` methods must not return ``None``.  *self* must "
"be aware (``self.tzinfo`` must not be ``None``, and ``self.utcoffset()`` "
"must not return ``None``)."
msgstr ""

#: ../../../library/datetime.rst:849
msgid ""
"If ``self.tzinfo`` is *tz*, ``self.astimezone(tz)`` is equal to *self*:  no "
"adjustment of date or time members is performed. Else the result is local "
"time in time zone *tz*, representing the same UTC time as *self*:  after "
"``astz = dt.astimezone(tz)``, ``astz - astz.utcoffset()`` will usually have "
"the same date and time members as ``dt - dt.utcoffset()``. The discussion of "
"class :class:`tzinfo` explains the cases at Daylight Saving Time transition "
"boundaries where this cannot be achieved (an issue only if *tz* models both "
"standard and daylight time)."
msgstr ""

#: ../../../library/datetime.rst:858
msgid ""
"If you merely want to attach a time zone object *tz* to a datetime *dt* "
"without adjustment of date and time members, use ``dt.replace(tzinfo=tz)``.  "
"If you merely want to remove the time zone object from an aware datetime "
"*dt* without conversion of date and time members, use ``dt."
"replace(tzinfo=None)``."
msgstr ""

#: ../../../library/datetime.rst:863
msgid ""
"Note that the default :meth:`tzinfo.fromutc` method can be overridden in a :"
"class:`tzinfo` subclass to affect the result returned by :meth:`astimezone`. "
"Ignoring error cases, :meth:`astimezone` acts like::"
msgstr ""

#: ../../../library/datetime.rst:867
msgid ""
"def astimezone(self, tz):\n"
"    if self.tzinfo is tz:\n"
"        return self\n"
"    # Convert self to UTC, and attach the new time zone object.\n"
"    utc = (self - self.utcoffset()).replace(tzinfo=tz)\n"
"    # Convert from UTC to tz's local time.\n"
"    return tz.fromutc(utc)"
msgstr ""

#: ../../../library/datetime.rst:878
msgid ""
"If :attr:`tzinfo` is ``None``, returns ``None``, else returns ``self.tzinfo."
"utcoffset(self)``, and raises an exception if the latter doesn't return "
"``None``, or a :class:`timedelta` object representing a whole number of "
"minutes with magnitude less than one day."
msgstr ""

#: ../../../library/datetime.rst:886
msgid ""
"If :attr:`tzinfo` is ``None``, returns ``None``, else returns ``self.tzinfo."
"dst(self)``, and raises an exception if the latter doesn't return ``None``, "
"or a :class:`timedelta` object representing a whole number of minutes with "
"magnitude less than one day."
msgstr ""

#: ../../../library/datetime.rst:894
msgid ""
"If :attr:`tzinfo` is ``None``, returns ``None``, else returns ``self.tzinfo."
"tzname(self)``, raises an exception if the latter doesn't return ``None`` or "
"a string object,"
msgstr ""

#: ../../../library/datetime.rst:901
msgid ""
"Return a :class:`time.struct_time` such as returned by :func:`time."
"localtime`. ``d.timetuple()`` is equivalent to ``time.struct_time((d.year, d."
"month, d.day, d.hour, d.minute, d.second, d.weekday(), d.toordinal() - "
"date(d.year, 1, 1).toordinal() + 1, dst))`` The :attr:`tm_isdst` flag of the "
"result is set according to the :meth:`dst` method:  :attr:`tzinfo` is "
"``None`` or :meth:`dst` returns ``None``, :attr:`tm_isdst` is set to  "
"``-1``; else if :meth:`dst` returns a non-zero value, :attr:`tm_isdst` is "
"set to ``1``; else ``tm_isdst`` is set to ``0``."
msgstr ""

#: ../../../library/datetime.rst:913
msgid ""
"If :class:`datetime` instance *d* is naive, this is the same as ``d."
"timetuple()`` except that :attr:`tm_isdst` is forced to 0 regardless of what "
"``d.dst()`` returns.  DST is never in effect for a UTC time."
msgstr ""

#: ../../../library/datetime.rst:917
msgid ""
"If *d* is aware, *d* is normalized to UTC time, by subtracting ``d."
"utcoffset()``, and a :class:`time.struct_time` for the normalized time is "
"returned.  :attr:`tm_isdst` is forced to 0. Note that the result's :attr:"
"`tm_year` member may be :const:`MINYEAR`\\ -1 or :const:`MAXYEAR`\\ +1, if "
"*d*.year was ``MINYEAR`` or ``MAXYEAR`` and UTC adjustment spills over a "
"year boundary."
msgstr ""

#: ../../../library/datetime.rst:927
msgid ""
"Return the proleptic Gregorian ordinal of the date.  The same as ``self."
"date().toordinal()``."
msgstr ""

#: ../../../library/datetime.rst:933
msgid ""
"Return the day of the week as an integer, where Monday is 0 and Sunday is 6. "
"The same as ``self.date().weekday()``. See also :meth:`isoweekday`."
msgstr ""

#: ../../../library/datetime.rst:939
msgid ""
"Return the day of the week as an integer, where Monday is 1 and Sunday is 7. "
"The same as ``self.date().isoweekday()``. See also :meth:`weekday`, :meth:"
"`isocalendar`."
msgstr ""

#: ../../../library/datetime.rst:946
msgid ""
"Return a 3-tuple, (ISO year, ISO week number, ISO weekday).  The same as "
"``self.date().isocalendar()``."
msgstr ""

#: ../../../library/datetime.rst:952
msgid ""
"Return a string representing the date and time in ISO 8601 format, YYYY-MM-"
"DDTHH:MM:SS.mmmmmm or, if :attr:`microsecond` is 0, YYYY-MM-DDTHH:MM:SS"
msgstr ""

#: ../../../library/datetime.rst:956
msgid ""
"If :meth:`utcoffset` does not return ``None``, a 6-character string is "
"appended, giving the UTC offset in (signed) hours and minutes: YYYY-MM-DDTHH:"
"MM:SS.mmmmmm+HH:MM or, if :attr:`microsecond` is 0 YYYY-MM-DDTHH:MM:SS+HH:MM"
msgstr ""

#: ../../../library/datetime.rst:961
msgid ""
"The optional argument *sep* (default ``'T'``) is a one-character separator, "
"placed between the date and time portions of the result.  For example,"
msgstr ""

#: ../../../library/datetime.rst:974
msgid ""
"For a :class:`datetime` instance *d*, ``str(d)`` is equivalent to ``d."
"isoformat(' ')``."
msgstr ""

#: ../../../library/datetime.rst:980
msgid ""
"Return a string representing the date and time, for example ``datetime(2002, "
"12, 4, 20, 30, 40).ctime() == 'Wed Dec  4 20:30:40 2002'``. ``d.ctime()`` is "
"equivalent to ``time.ctime(time.mktime(d.timetuple()))`` on platforms where "
"the native C :cfunc:`ctime` function (which :func:`time.ctime` invokes, but "
"which :meth:`datetime.ctime` does not invoke) conforms to the C standard."
msgstr ""

#: ../../../library/datetime.rst:989
msgid ""
"Return a string representing the date and time, controlled by an explicit "
"format string.  See section :ref:`strftime-behavior`."
msgstr ""

#: ../../../library/datetime.rst:992
msgid "Examples of working with datetime objects:"
msgstr ""

#: ../../../library/datetime.rst:994
msgid ""
">>> from datetime import datetime, date, time\n"
">>> # Using datetime.combine()\n"
">>> d = date(2005, 7, 14)\n"
">>> t = time(12, 30)\n"
">>> datetime.combine(d, t)\n"
"datetime.datetime(2005, 7, 14, 12, 30)\n"
">>> # Using datetime.now() or datetime.utcnow()\n"
">>> datetime.now()   \n"
"datetime.datetime(2007, 12, 6, 16, 29, 43, 79043)   # GMT +1\n"
">>> datetime.utcnow()   \n"
"datetime.datetime(2007, 12, 6, 15, 29, 43, 79060)\n"
">>> # Using datetime.strptime()\n"
">>> dt = datetime.strptime(\"21/11/06 16:30\", \"%d/%m/%y %H:%M\")\n"
">>> dt\n"
"datetime.datetime(2006, 11, 21, 16, 30)\n"
">>> # Using datetime.timetuple() to get tuple of all attributes\n"
">>> tt = dt.timetuple()\n"
">>> for it in tt:   \n"
"...     print(it)\n"
"...\n"
"2006    # year\n"
"11      # month\n"
"21      # day\n"
"16      # hour\n"
"30      # minute\n"
"0       # second\n"
"1       # weekday (0 = Monday)\n"
"325     # number of days since 1st January\n"
"-1      # dst - method tzinfo.dst() returned None\n"
">>> # Date in ISO format\n"
">>> ic = dt.isocalendar()\n"
">>> for it in ic:   \n"
"...     print(it)\n"
"...\n"
"2006    # ISO year\n"
"47      # ISO week\n"
"2       # ISO weekday\n"
">>> # Formatting datetime\n"
">>> dt.strftime(\"%A, %d. %B %Y %I:%M%p\")\n"
"'Tuesday, 21. November 2006 04:30PM'"
msgstr ""

#: ../../../library/datetime.rst:1037
msgid "Using datetime with tzinfo:"
msgstr ""

#: ../../../library/datetime.rst:1098
msgid ":class:`time` Objects"
msgstr ""

#: ../../../library/datetime.rst:1100
msgid ""
"A time object represents a (local) time of day, independent of any "
"particular day, and subject to adjustment via a :class:`tzinfo` object."
msgstr ""

#: ../../../library/datetime.rst:1106
msgid ""
"All arguments are optional.  *tzinfo* may be ``None``, or an instance of a :"
"class:`tzinfo` subclass.  The remaining arguments may be integers, in the "
"following ranges:"
msgstr ""

#: ../../../library/datetime.rst:1113
msgid "``0 <= microsecond < 1000000``."
msgstr ""

#: ../../../library/datetime.rst:1115
msgid ""
"If an argument outside those ranges is given, :exc:`ValueError` is raised.  "
"All default to ``0`` except *tzinfo*, which defaults to :const:`None`."
msgstr ""

#: ../../../library/datetime.rst:1123
msgid "The earliest representable :class:`time`, ``time(0, 0, 0, 0)``."
msgstr ""

#: ../../../library/datetime.rst:1128
msgid "The latest representable :class:`time`, ``time(23, 59, 59, 999999)``."
msgstr ""

#: ../../../library/datetime.rst:1133
msgid ""
"The smallest possible difference between non-equal :class:`time` objects, "
"``timedelta(microseconds=1)``, although note that arithmetic on :class:"
"`time` objects is not supported."
msgstr ""

#: ../../../library/datetime.rst:1162
msgid ""
"The object passed as the tzinfo argument to the :class:`time` constructor, "
"or ``None`` if none was passed."
msgstr ""

#: ../../../library/datetime.rst:1167
msgid ""
"comparison of :class:`time` to :class:`time`, where *a* is considered less "
"than *b* when *a* precedes *b* in time.  If one comparand is naive and the "
"other is aware, :exc:`TypeError` is raised.  If both comparands are aware, "
"and have the same :attr:`tzinfo` member, the common :attr:`tzinfo` member is "
"ignored and the base times are compared.  If both comparands are aware and "
"have different :attr:`tzinfo` members, the comparands are first adjusted by "
"subtracting their UTC offsets (obtained from ``self.utcoffset()``). In order "
"to stop mixed-type comparisons from falling back to the default comparison "
"by object address, when a :class:`time` object is compared to an object of a "
"different type, :exc:`TypeError` is raised unless the comparison is ``==`` "
"or ``!=``.  The latter cases return :const:`False` or :const:`True`, "
"respectively."
msgstr ""

#: ../../../library/datetime.rst:1179
msgid "hash, use as dict key"
msgstr ""

#: ../../../library/datetime.rst:1181
msgid "efficient pickling"
msgstr ""

#: ../../../library/datetime.rst:1183
msgid ""
"in Boolean contexts, a :class:`time` object is considered to be true if and "
"only if, after converting it to minutes and subtracting :meth:`utcoffset` "
"(or ``0`` if that's ``None``), the result is non-zero."
msgstr ""

#: ../../../library/datetime.rst:1192
msgid ""
"Return a :class:`time` with the same value, except for those members given "
"new values by whichever keyword arguments are specified.  Note that "
"``tzinfo=None`` can be specified to create a naive :class:`time` from an "
"aware :class:`time`, without conversion of the time members."
msgstr ""

#: ../../../library/datetime.rst:1200
msgid ""
"Return a string representing the time in ISO 8601 format, HH:MM:SS.mmmmmm "
"or, if self.microsecond is 0, HH:MM:SS If :meth:`utcoffset` does not return "
"``None``, a 6-character string is appended, giving the UTC offset in "
"(signed) hours and minutes: HH:MM:SS.mmmmmm+HH:MM or, if self.microsecond is "
"0, HH:MM:SS+HH:MM"
msgstr ""

#: ../../../library/datetime.rst:1208
msgid "For a time *t*, ``str(t)`` is equivalent to ``t.isoformat()``."
msgstr ""

#: ../../../library/datetime.rst:1213
msgid ""
"Return a string representing the time, controlled by an explicit format "
"string. See section :ref:`strftime-behavior`."
msgstr ""

#: ../../../library/datetime.rst:1219
msgid ""
"If :attr:`tzinfo` is ``None``, returns ``None``, else returns ``self.tzinfo."
"utcoffset(None)``, and raises an exception if the latter doesn't return "
"``None`` or a :class:`timedelta` object representing a whole number of "
"minutes with magnitude less than one day."
msgstr ""

#: ../../../library/datetime.rst:1227
msgid ""
"If :attr:`tzinfo` is ``None``, returns ``None``, else returns ``self.tzinfo."
"dst(None)``, and raises an exception if the latter doesn't return ``None``, "
"or a :class:`timedelta` object representing a whole number of minutes with "
"magnitude less than one day."
msgstr ""

#: ../../../library/datetime.rst:1235
msgid ""
"If :attr:`tzinfo` is ``None``, returns ``None``, else returns ``self.tzinfo."
"tzname(None)``, or raises an exception if the latter doesn't return ``None`` "
"or a string object."
msgstr ""

#: ../../../library/datetime.rst:1239
msgid "Example:"
msgstr ""

#: ../../../library/datetime.rst:1267
msgid ":class:`tzinfo` Objects"
msgstr ""

#: ../../../library/datetime.rst:1269
msgid ""
":class:`tzinfo` is an abstract base class, meaning that this class should "
"not be instantiated directly.  You need to derive a concrete subclass, and "
"(at least) supply implementations of the standard :class:`tzinfo` methods "
"needed by the :class:`datetime` methods you use.  The :mod:`datetime` module "
"does not supply any concrete subclasses of :class:`tzinfo`."
msgstr ""

#: ../../../library/datetime.rst:1275
msgid ""
"An instance of (a concrete subclass of) :class:`tzinfo` can be passed to the "
"constructors for :class:`datetime` and :class:`time` objects. The latter "
"objects view their members as being in local time, and the :class:`tzinfo` "
"object supports methods revealing offset of local time from UTC, the name of "
"the time zone, and DST offset, all relative to a date or time object passed "
"to them."
msgstr ""

#: ../../../library/datetime.rst:1281
msgid ""
"Special requirement for pickling:  A :class:`tzinfo` subclass must have an :"
"meth:`__init__` method that can be called with no arguments, else it can be "
"pickled but possibly not unpickled again.  This is a technical requirement "
"that may be relaxed in the future."
msgstr ""

#: ../../../library/datetime.rst:1286
msgid ""
"A concrete subclass of :class:`tzinfo` may need to implement the following "
"methods.  Exactly which methods are needed depends on the uses made of "
"aware :mod:`datetime` objects.  If in doubt, simply implement all of them."
msgstr ""

#: ../../../library/datetime.rst:1293
msgid ""
"Return offset of local time from UTC, in minutes east of UTC.  If local time "
"is west of UTC, this should be negative.  Note that this is intended to be "
"the total offset from UTC; for example, if a :class:`tzinfo` object "
"represents both time zone and DST adjustments, :meth:`utcoffset` should "
"return their sum.  If the UTC offset isn't known, return ``None``.  Else the "
"value returned must be a :class:`timedelta` object specifying a whole number "
"of minutes in the range -1439 to 1439 inclusive (1440 = 24\\*60; the "
"magnitude of the offset must be less than one day).  Most implementations "
"of :meth:`utcoffset` will probably look like one of these two::"
msgstr ""

#: ../../../library/datetime.rst:1303
msgid ""
"return CONSTANT                 # fixed-offset class\n"
"return CONSTANT + self.dst(dt)  # daylight-aware class"
msgstr ""

#: ../../../library/datetime.rst:1306
msgid ""
"If :meth:`utcoffset` does not return ``None``, :meth:`dst` should not return "
"``None`` either."
msgstr ""

#: ../../../library/datetime.rst:1309
msgid ""
"The default implementation of :meth:`utcoffset` raises :exc:"
"`NotImplementedError`."
msgstr ""

#: ../../../library/datetime.rst:1315
msgid ""
"Return the daylight saving time (DST) adjustment, in minutes east of UTC, or "
"``None`` if DST information isn't known.  Return ``timedelta(0)`` if DST is "
"not in effect. If DST is in effect, return the offset as a :class:"
"`timedelta` object (see :meth:`utcoffset` for details). Note that DST "
"offset, if applicable, has already been added to the UTC offset returned by :"
"meth:`utcoffset`, so there's no need to consult :meth:`dst` unless you're "
"interested in obtaining DST info separately.  For example, :meth:`datetime."
"timetuple` calls its :attr:`tzinfo` member's :meth:`dst` method to determine "
"how the :attr:`tm_isdst` flag should be set, and :meth:`tzinfo.fromutc` "
"calls :meth:`dst` to account for DST changes when crossing time zones."
msgstr ""

#: ../../../library/datetime.rst:1326
msgid ""
"An instance *tz* of a :class:`tzinfo` subclass that models both standard and "
"daylight times must be consistent in this sense:"
msgstr ""

#: ../../../library/datetime.rst:1329
msgid "``tz.utcoffset(dt) - tz.dst(dt)``"
msgstr ""

#: ../../../library/datetime.rst:1331
msgid ""
"must return the same result for every :class:`datetime` *dt* with ``dt."
"tzinfo == tz``  For sane :class:`tzinfo` subclasses, this expression yields "
"the time zone's \"standard offset\", which should not depend on the date or "
"the time, but only on geographic location.  The implementation of :meth:"
"`datetime.astimezone` relies on this, but cannot detect violations; it's the "
"programmer's responsibility to ensure it.  If a :class:`tzinfo` subclass "
"cannot guarantee this, it may be able to override the default implementation "
"of :meth:`tzinfo.fromutc` to work correctly with :meth:`astimezone` "
"regardless."
msgstr ""

#: ../../../library/datetime.rst:1340
msgid ""
"Most implementations of :meth:`dst` will probably look like one of these "
"two::"
msgstr ""

#: ../../../library/datetime.rst:1342
msgid ""
"def dst(self):\n"
"    # a fixed-offset class:  doesn't account for DST\n"
"    return timedelta(0)"
msgstr ""

#: ../../../library/datetime.rst:1346
msgid "or ::"
msgstr ""

#: ../../../library/datetime.rst:1348
msgid ""
"def dst(self):\n"
"    # Code to set dston and dstoff to the time zone's DST\n"
"    # transition times based on the input dt.year, and expressed\n"
"    # in standard local time.  Then\n"
"\n"
"    if dston <= dt.replace(tzinfo=None) < dstoff:\n"
"        return timedelta(hours=1)\n"
"    else:\n"
"        return timedelta(0)"
msgstr ""

#: ../../../library/datetime.rst:1358
msgid ""
"The default implementation of :meth:`dst` raises :exc:`NotImplementedError`."
msgstr ""

#: ../../../library/datetime.rst:1363
msgid ""
"Return the time zone name corresponding to the :class:`datetime` object "
"*dt*, as a string. Nothing about string names is defined by the :mod:"
"`datetime` module, and there's no requirement that it mean anything in "
"particular.  For example, \"GMT\", \"UTC\", \"-500\", \"-5:00\", \"EDT\", "
"\"US/Eastern\", \"America/New York\" are all valid replies.  Return ``None`` "
"if a string name isn't known.  Note that this is a method rather than a "
"fixed string primarily because some :class:`tzinfo` subclasses will wish to "
"return different names depending on the specific value of *dt* passed, "
"especially if the :class:`tzinfo` class is accounting for daylight time."
msgstr ""

#: ../../../library/datetime.rst:1373
msgid ""
"The default implementation of :meth:`tzname` raises :exc:"
"`NotImplementedError`."
msgstr ""

#: ../../../library/datetime.rst:1375
msgid ""
"These methods are called by a :class:`datetime` or :class:`time` object, in "
"response to their methods of the same names.  A :class:`datetime` object "
"passes itself as the argument, and a :class:`time` object passes ``None`` as "
"the argument.  A :class:`tzinfo` subclass's methods should therefore be "
"prepared to accept a *dt* argument of ``None``, or of class :class:"
"`datetime`."
msgstr ""

#: ../../../library/datetime.rst:1381
msgid ""
"When ``None`` is passed, it's up to the class designer to decide the best "
"response.  For example, returning ``None`` is appropriate if the class "
"wishes to say that time objects don't participate in the :class:`tzinfo` "
"protocols.  It may be more useful for ``utcoffset(None)`` to return the "
"standard UTC offset, as there is no other convention for discovering the "
"standard offset."
msgstr ""

#: ../../../library/datetime.rst:1387
msgid ""
"When a :class:`datetime` object is passed in response to a :class:`datetime` "
"method, ``dt.tzinfo`` is the same object as *self*.  :class:`tzinfo` methods "
"can rely on this, unless user code calls :class:`tzinfo` methods directly.  "
"The intent is that the :class:`tzinfo` methods interpret *dt* as being in "
"local time, and not need worry about objects in other timezones."
msgstr ""

#: ../../../library/datetime.rst:1393
msgid ""
"There is one more :class:`tzinfo` method that a subclass may wish to "
"override:"
msgstr ""

#: ../../../library/datetime.rst:1398
msgid ""
"This is called from the default :class:`datetime.astimezone()` "
"implementation. When called from that, ``dt.tzinfo`` is *self*, and *dt*'s "
"date and time members are to be viewed as expressing a UTC time.  The "
"purpose of :meth:`fromutc` is to adjust the date and time members, returning "
"an equivalent datetime in *self*'s local time."
msgstr ""

#: ../../../library/datetime.rst:1404
msgid ""
"Most :class:`tzinfo` subclasses should be able to inherit the default :meth:"
"`fromutc` implementation without problems.  It's strong enough to handle "
"fixed-offset time zones, and time zones accounting for both standard and "
"daylight time, and the latter even if the DST transition times differ in "
"different years.  An example of a time zone the default :meth:`fromutc` "
"implementation may not handle correctly in all cases is one where the "
"standard offset (from UTC) depends on the specific date and time passed, "
"which can happen for political reasons. The default implementations of :meth:"
"`astimezone` and :meth:`fromutc` may not produce the result you want if the "
"result is one of the hours straddling the moment the standard offset changes."
msgstr ""

#: ../../../library/datetime.rst:1415
msgid ""
"Skipping code for error cases, the default :meth:`fromutc` implementation "
"acts like::"
msgstr ""

#: ../../../library/datetime.rst:1418
msgid ""
"def fromutc(self, dt):\n"
"    # raise ValueError error if dt.tzinfo is not self\n"
"    dtoff = dt.utcoffset()\n"
"    dtdst = dt.dst()\n"
"    # raise ValueError if dtoff is None or dtdst is None\n"
"    delta = dtoff - dtdst  # this is self's standard offset\n"
"    if delta:\n"
"        dt += delta   # convert to standard local time\n"
"        dtdst = dt.dst()\n"
"        # raise ValueError if dtdst is None\n"
"    if dtdst:\n"
"        return dt + dtdst\n"
"    else:\n"
"        return dt"
msgstr ""

#: ../../../library/datetime.rst:1433
msgid "Example :class:`tzinfo` classes:"
msgstr ""

#: ../../../library/datetime.rst:1435
msgid ""
"from datetime import tzinfo, timedelta, datetime\n"
"\n"
"ZERO = timedelta(0)\n"
"HOUR = timedelta(hours=1)\n"
"\n"
"# A UTC class.\n"
"\n"
"class UTC(tzinfo):\n"
"    \"\"\"UTC\"\"\"\n"
"\n"
"    def utcoffset(self, dt):\n"
"        return ZERO\n"
"\n"
"    def tzname(self, dt):\n"
"        return \"UTC\"\n"
"\n"
"    def dst(self, dt):\n"
"        return ZERO\n"
"\n"
"utc = UTC()\n"
"\n"
"# A class building tzinfo objects for fixed-offset time zones.\n"
"# Note that FixedOffset(0, \"UTC\") is a different way to build a\n"
"# UTC tzinfo object.\n"
"\n"
"class FixedOffset(tzinfo):\n"
"    \"\"\"Fixed offset in minutes east from UTC.\"\"\"\n"
"\n"
"    def __init__(self, offset, name):\n"
"        self.__offset = timedelta(minutes = offset)\n"
"        self.__name = name\n"
"\n"
"    def utcoffset(self, dt):\n"
"        return self.__offset\n"
"\n"
"    def tzname(self, dt):\n"
"        return self.__name\n"
"\n"
"    def dst(self, dt):\n"
"        return ZERO\n"
"\n"
"# A class capturing the platform's idea of local time.\n"
"\n"
"import time as _time\n"
"\n"
"STDOFFSET = timedelta(seconds = -_time.timezone)\n"
"if _time.daylight:\n"
"    DSTOFFSET = timedelta(seconds = -_time.altzone)\n"
"else:\n"
"    DSTOFFSET = STDOFFSET\n"
"\n"
"DSTDIFF = DSTOFFSET - STDOFFSET\n"
"\n"
"class LocalTimezone(tzinfo):\n"
"\n"
"    def utcoffset(self, dt):\n"
"        if self._isdst(dt):\n"
"            return DSTOFFSET\n"
"        else:\n"
"            return STDOFFSET\n"
"\n"
"    def dst(self, dt):\n"
"        if self._isdst(dt):\n"
"            return DSTDIFF\n"
"        else:\n"
"            return ZERO\n"
"\n"
"    def tzname(self, dt):\n"
"        return _time.tzname[self._isdst(dt)]\n"
"\n"
"    def _isdst(self, dt):\n"
"        tt = (dt.year, dt.month, dt.day,\n"
"              dt.hour, dt.minute, dt.second,\n"
"              dt.weekday(), 0, -1)\n"
"        stamp = _time.mktime(tt)\n"
"        tt = _time.localtime(stamp)\n"
"        return tt.tm_isdst > 0\n"
"\n"
"Local = LocalTimezone()\n"
"\n"
"\n"
"# A complete implementation of current DST rules for major US time zones.\n"
"\n"
"def first_sunday_on_or_after(dt):\n"
"    days_to_go = 6 - dt.weekday()\n"
"    if days_to_go:\n"
"        dt += timedelta(days_to_go)\n"
"    return dt\n"
"\n"
"\n"
"# US DST Rules\n"
"#\n"
"# This is a simplified (i.e., wrong for a few cases) set of rules for US\n"
"# DST start and end times. For a complete and up-to-date set of DST rules\n"
"# and timezone definitions, visit the Olson Database (or try pytz):\n"
"# http://www.twinsun.com/tz/tz-link.htm\n"
"# http://sourceforge.net/projects/pytz/ (might not be up-to-date)\n"
"#\n"
"# In the US, since 2007, DST starts at 2am (standard time) on the second\n"
"# Sunday in March, which is the first Sunday on or after Mar 8.\n"
"DSTSTART_2007 = datetime(1, 3, 8, 2)\n"
"# and ends at 2am (DST time; 1am standard time) on the first Sunday of Nov.\n"
"DSTEND_2007 = datetime(1, 11, 1, 1)\n"
"# From 1987 to 2006, DST used to start at 2am (standard time) on the first\n"
"# Sunday in April and to end at 2am (DST time; 1am standard time) on the "
"last\n"
"# Sunday of October, which is the first Sunday on or after Oct 25.\n"
"DSTSTART_1987_2006 = datetime(1, 4, 1, 2)\n"
"DSTEND_1987_2006 = datetime(1, 10, 25, 1)\n"
"# From 1967 to 1986, DST used to start at 2am (standard time) on the last\n"
"# Sunday in April (the one on or after April 24) and to end at 2am (DST "
"time;\n"
"# 1am standard time) on the last Sunday of October, which is the first "
"Sunday\n"
"# on or after Oct 25.\n"
"DSTSTART_1967_1986 = datetime(1, 4, 24, 2)\n"
"DSTEND_1967_1986 = DSTEND_1987_2006\n"
"\n"
"class USTimeZone(tzinfo):\n"
"\n"
"    def __init__(self, hours, reprname, stdname, dstname):\n"
"        self.stdoffset = timedelta(hours=hours)\n"
"        self.reprname = reprname\n"
"        self.stdname = stdname\n"
"        self.dstname = dstname\n"
"\n"
"    def __repr__(self):\n"
"        return self.reprname\n"
"\n"
"    def tzname(self, dt):\n"
"        if self.dst(dt):\n"
"            return self.dstname\n"
"        else:\n"
"            return self.stdname\n"
"\n"
"    def utcoffset(self, dt):\n"
"        return self.stdoffset + self.dst(dt)\n"
"\n"
"    def dst(self, dt):\n"
"        if dt is None or dt.tzinfo is None:\n"
"            # An exception may be sensible here, in one or both cases.\n"
"            # It depends on how you want to treat them.  The default\n"
"            # fromutc() implementation (called by the default astimezone()\n"
"            # implementation) passes a datetime with dt.tzinfo is self.\n"
"            return ZERO\n"
"        assert dt.tzinfo is self\n"
"\n"
"        # Find start and end times for US DST. For years before 1967, "
"return\n"
"        # ZERO for no DST.\n"
"        if 2006 < dt.year:\n"
"            dststart, dstend = DSTSTART_2007, DSTEND_2007\n"
"        elif 1986 < dt.year < 2007:\n"
"            dststart, dstend = DSTSTART_1987_2006, DSTEND_1987_2006\n"
"        elif 1966 < dt.year < 1987:\n"
"            dststart, dstend = DSTSTART_1967_1986, DSTEND_1967_1986\n"
"        else:\n"
"            return ZERO\n"
"\n"
"        start = first_sunday_on_or_after(dststart.replace(year=dt.year))\n"
"        end = first_sunday_on_or_after(dstend.replace(year=dt.year))\n"
"\n"
"        # Can't compare naive to aware objects, so strip the timezone from\n"
"        # dt first.\n"
"        if start <= dt.replace(tzinfo=None) < end:\n"
"            return HOUR\n"
"        else:\n"
"            return ZERO\n"
"\n"
"Eastern  = USTimeZone(-5, \"Eastern\",  \"EST\", \"EDT\")\n"
"Central  = USTimeZone(-6, \"Central\",  \"CST\", \"CDT\")\n"
"Mountain = USTimeZone(-7, \"Mountain\", \"MST\", \"MDT\")\n"
"Pacific  = USTimeZone(-8, \"Pacific\",  \"PST\", \"PDT\")\n"
msgstr ""

#: ../../../library/datetime.rst:1438
msgid ""
"Note that there are unavoidable subtleties twice per year in a :class:"
"`tzinfo` subclass accounting for both standard and daylight time, at the DST "
"transition points.  For concreteness, consider US Eastern (UTC -0500), where "
"EDT begins the minute after 1:59 (EST) on the first Sunday in April, and "
"ends the minute after 1:59 (EDT) on the last Sunday in October::"
msgstr ""

#: ../../../library/datetime.rst:1444
msgid ""
"  UTC   3:MM  4:MM  5:MM  6:MM  7:MM  8:MM\n"
"  EST  22:MM 23:MM  0:MM  1:MM  2:MM  3:MM\n"
"  EDT  23:MM  0:MM  1:MM  2:MM  3:MM  4:MM\n"
"\n"
"start  22:MM 23:MM  0:MM  1:MM  3:MM  4:MM\n"
"\n"
"  end  23:MM  0:MM  1:MM  1:MM  2:MM  3:MM"
msgstr ""

#: ../../../library/datetime.rst:1452
msgid ""
"When DST starts (the \"start\" line), the local wall clock leaps from 1:59 "
"to 3:00.  A wall time of the form 2:MM doesn't really make sense on that "
"day, so ``astimezone(Eastern)`` won't deliver a result with ``hour == 2`` on "
"the day DST begins.  In order for :meth:`astimezone` to make this guarantee, "
"the :meth:`rzinfo.dst` method must consider times in the \"missing hour\" (2:"
"MM for Eastern) to be in daylight time."
msgstr ""

#: ../../../library/datetime.rst:1459
msgid ""
"When DST ends (the \"end\" line), there's a potentially worse problem: "
"there's an hour that can't be spelled unambiguously in local wall time: the "
"last hour of daylight time.  In Eastern, that's times of the form 5:MM UTC "
"on the day daylight time ends.  The local wall clock leaps from 1:59 "
"(daylight time) back to 1:00 (standard time) again. Local times of the form "
"1:MM are ambiguous. :meth:`astimezone` mimics the local clock's behavior by "
"mapping two adjacent UTC hours into the same local hour then.  In the "
"Eastern example, UTC times of the form 5:MM and 6:MM both map to 1:MM when "
"converted to Eastern.  In order for :meth:`astimezone` to make this "
"guarantee, the :meth:`tzinfo.dst` method must consider times in the "
"\"repeated hour\" to be in standard time.  This is easily arranged, as in "
"the example, by expressing DST switch times in the time zone's standard "
"local time."
msgstr ""

#: ../../../library/datetime.rst:1472
msgid ""
"Applications that can't bear such ambiguities should avoid using hybrid :"
"class:`tzinfo` subclasses; there are no ambiguities when using UTC, or any "
"other fixed-offset :class:`tzinfo` subclass (such as a class representing "
"only EST (fixed offset -5 hours), or only EDT (fixed offset -4 hours))."
msgstr ""

#: ../../../library/datetime.rst:1481
msgid ":meth:`strftime` Behavior"
msgstr ""

#: ../../../library/datetime.rst:1483
msgid ""
":class:`date`, :class:`datetime`, and :class:`time` objects all support a "
"``strftime(format)`` method, to create a string representing the time under "
"the control of an explicit format string.  Broadly speaking, ``d."
"strftime(fmt)`` acts like the :mod:`time` module's ``time.strftime(fmt, d."
"timetuple())`` although not all objects support a :meth:`timetuple` method."
msgstr ""

#: ../../../library/datetime.rst:1489
msgid ""
"For :class:`time` objects, the format codes for year, month, and day should "
"not be used, as time objects have no such values.  If they're used anyway, "
"``1900`` is substituted for the year, and ``0`` for the month and day."
msgstr ""

#: ../../../library/datetime.rst:1493
msgid ""
"For :class:`date` objects, the format codes for hours, minutes, seconds, and "
"microseconds should not be used, as :class:`date` objects have no such "
"values.  If they're used anyway, ``0`` is substituted for them."
msgstr ""

#: ../../../library/datetime.rst:1497
msgid ""
"For a naive object, the ``%z`` and ``%Z`` format codes are replaced by empty "
"strings."
msgstr ""

#: ../../../library/datetime.rst:1500
msgid "For an aware object:"
msgstr ""

#: ../../../library/datetime.rst:1507 ../../../library/datetime.rst:1600
msgid "``%z``"
msgstr ""

#: ../../../library/datetime.rst:1503
msgid ""
":meth:`utcoffset` is transformed into a 5-character string of the form +HHMM "
"or -HHMM, where HH is a 2-digit string giving the number of UTC offset "
"hours, and MM is a 2-digit string giving the number of UTC offset minutes.  "
"For example, if :meth:`utcoffset` returns ``timedelta(hours=-3, "
"minutes=-30)``, ``%z`` is replaced with the string ``'-0330'``."
msgstr ""

#: ../../../library/datetime.rst:1511 ../../../library/datetime.rst:1604
msgid "``%Z``"
msgstr ""

#: ../../../library/datetime.rst:1510
msgid ""
"If :meth:`tzname` returns ``None``, ``%Z`` is replaced by an empty string. "
"Otherwise ``%Z`` is replaced by the returned value, which must be a string."
msgstr ""

#: ../../../library/datetime.rst:1513
msgid ""
"The full set of format codes supported varies across platforms, because "
"Python calls the platform C library's :func:`strftime` function, and "
"platform variations are common."
msgstr ""

#: ../../../library/datetime.rst:1517
msgid ""
"The following is a list of all the format codes that the C standard (1989 "
"version) requires, and these work on all platforms with a standard C "
"implementation.  Note that the 1999 version of the C standard added "
"additional format codes."
msgstr ""

#: ../../../library/datetime.rst:1522
msgid ""
"The exact range of years for which :meth:`strftime` works also varies across "
"platforms.  Regardless of platform, years before 1900 cannot be used."
msgstr ""

#: ../../../library/datetime.rst:1526
msgid "Directive"
msgstr ""

#: ../../../library/datetime.rst:1526
msgid "Meaning"
msgstr ""

#: ../../../library/datetime.rst:1526
msgid "Notes"
msgstr ""

#: ../../../library/datetime.rst:1528
msgid "``%a``"
msgstr ""

#: ../../../library/datetime.rst:1528
msgid "Locale's abbreviated weekday name."
msgstr ""

#: ../../../library/datetime.rst:1531
msgid "``%A``"
msgstr ""

#: ../../../library/datetime.rst:1531
msgid "Locale's full weekday name."
msgstr ""

#: ../../../library/datetime.rst:1533
msgid "``%b``"
msgstr ""

#: ../../../library/datetime.rst:1533
msgid "Locale's abbreviated month name."
msgstr ""

#: ../../../library/datetime.rst:1536
msgid "``%B``"
msgstr ""

#: ../../../library/datetime.rst:1536
msgid "Locale's full month name."
msgstr ""

#: ../../../library/datetime.rst:1538
msgid "``%c``"
msgstr ""

#: ../../../library/datetime.rst:1538
msgid "Locale's appropriate date and time representation."
msgstr ""

#: ../../../library/datetime.rst:1541
msgid "``%d``"
msgstr ""

#: ../../../library/datetime.rst:1541
msgid "Day of the month as a decimal number [01,31]."
msgstr ""

#: ../../../library/datetime.rst:1544
msgid "``%f``"
msgstr ""

#: ../../../library/datetime.rst:1544
msgid "Microsecond as a decimal number [0,999999], zero-padded on the left"
msgstr ""

#: ../../../library/datetime.rst:1548
msgid "``%H``"
msgstr ""

#: ../../../library/datetime.rst:1548
msgid "Hour (24-hour clock) as a decimal number [00,23]."
msgstr ""

#: ../../../library/datetime.rst:1551
msgid "``%I``"
msgstr ""

#: ../../../library/datetime.rst:1551
msgid "Hour (12-hour clock) as a decimal number [01,12]."
msgstr ""

#: ../../../library/datetime.rst:1554
msgid "``%j``"
msgstr ""

#: ../../../library/datetime.rst:1554
msgid "Day of the year as a decimal number [001,366]."
msgstr ""

#: ../../../library/datetime.rst:1557
msgid "``%m``"
msgstr ""

#: ../../../library/datetime.rst:1557
msgid "Month as a decimal number [01,12]."
msgstr ""

#: ../../../library/datetime.rst:1560
msgid "``%M``"
msgstr ""

#: ../../../library/datetime.rst:1560
msgid "Minute as a decimal number [00,59]."
msgstr ""

#: ../../../library/datetime.rst:1563
msgid "``%p``"
msgstr ""

#: ../../../library/datetime.rst:1563
msgid "Locale's equivalent of either AM or PM."
msgstr ""

#: ../../../library/datetime.rst:1566
msgid "``%S``"
msgstr ""

#: ../../../library/datetime.rst:1566
msgid "Second as a decimal number [00,61]."
msgstr ""

#: ../../../library/datetime.rst:1569
msgid "``%U``"
msgstr ""

#: ../../../library/datetime.rst:1569
msgid ""
"Week number of the year (Sunday as the first day of the week) as a decimal "
"number [00,53].  All days in a new year preceding the first Sunday are "
"considered to be in week 0."
msgstr ""

#: ../../../library/datetime.rst:1569 ../../../library/datetime.rst:1580
msgid "\\(4)"
msgstr ""

#: ../../../library/datetime.rst:1577
msgid "``%w``"
msgstr ""

#: ../../../library/datetime.rst:1577
msgid "Weekday as a decimal number [0(Sunday),6]."
msgstr ""

#: ../../../library/datetime.rst:1580
msgid "``%W``"
msgstr ""

#: ../../../library/datetime.rst:1580
msgid ""
"Week number of the year (Monday as the first day of the week) as a decimal "
"number [00,53].  All days in a new year preceding the first Monday are "
"considered to be in week 0."
msgstr ""

#: ../../../library/datetime.rst:1588
msgid "``%x``"
msgstr ""

#: ../../../library/datetime.rst:1588
msgid "Locale's appropriate date representation."
msgstr ""

#: ../../../library/datetime.rst:1591
msgid "``%X``"
msgstr ""

#: ../../../library/datetime.rst:1591
msgid "Locale's appropriate time representation."
msgstr ""

#: ../../../library/datetime.rst:1594
msgid "``%y``"
msgstr ""

#: ../../../library/datetime.rst:1594
msgid "Year without century as a decimal number [00,99]."
msgstr ""

#: ../../../library/datetime.rst:1597
msgid "``%Y``"
msgstr ""

#: ../../../library/datetime.rst:1597
msgid "Year with century as a decimal number."
msgstr ""

#: ../../../library/datetime.rst:1600
msgid ""
"UTC offset in the form +HHMM or -HHMM (empty string if the the object is "
"naive)."
msgstr ""

#: ../../../library/datetime.rst:1600
msgid "\\(5)"
msgstr ""

#: ../../../library/datetime.rst:1604
msgid "Time zone name (empty string if the object is naive)."
msgstr ""

#: ../../../library/datetime.rst:1607
msgid "``%%``"
msgstr ""

#: ../../../library/datetime.rst:1607
msgid "A literal ``'%'`` character."
msgstr ""

#: ../../../library/datetime.rst:1613
msgid ""
"When used with the :func:`strptime` function, the ``%f`` directive accepts "
"from one to six digits and zero pads on the right.  ``%f`` is an extension "
"to the set of format characters in the C standard (but implemented "
"separately in datetime objects, and therefore always available)."
msgstr ""

#: ../../../library/datetime.rst:1620
msgid ""
"When used with the :func:`strptime` function, the ``%p`` directive only "
"affects the output hour field if the ``%I`` directive is used to parse the "
"hour."
msgstr ""

#: ../../../library/datetime.rst:1624
msgid ""
"The range really is ``0`` to ``61``; this accounts for leap seconds and the "
"(very rare) double leap seconds."
msgstr ""

#: ../../../library/datetime.rst:1628
msgid ""
"When used with the :func:`strptime` function, ``%U`` and ``%W`` are only "
"used in calculations when the day of the week and the year are specified."
msgstr ""

#: ../../../library/datetime.rst:1632
msgid ""
"For example, if :meth:`utcoffset` returns ``timedelta(hours=-3, "
"minutes=-30)``, ``%z`` is replaced with the string ``'-0330'``."
msgstr ""

# SOME DESCRIPTIVE TITLE.
# Copyright (C) 1990-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-10 15:11+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../library/decimal.rst:3
msgid ":mod:`decimal` --- Decimal fixed point and floating point arithmetic"
msgstr ""

#: ../../../library/decimal.rst:24
msgid ""
"The :mod:`decimal` module provides support for decimal floating point "
"arithmetic.  It offers several advantages over the :class:`float` datatype:"
msgstr ""

#: ../../../library/decimal.rst:27
msgid ""
"Decimal \"is based on a floating-point model which was designed with people "
"in mind, and necessarily has a paramount guiding principle -- computers must "
"provide an arithmetic that works in the same way as the arithmetic that "
"people learn at school.\" -- excerpt from the decimal arithmetic "
"specification."
msgstr ""

#: ../../../library/decimal.rst:32
msgid ""
"Decimal numbers can be represented exactly.  In contrast, numbers like :"
"const:`1.1` do not have an exact representation in binary floating point. "
"End users typically would not expect :const:`1.1` to display as :const:"
"`1.1000000000000001` as it does with binary floating point."
msgstr ""

#: ../../../library/decimal.rst:37
msgid ""
"The exactness carries over into arithmetic.  In decimal floating point, "
"``0.1 + 0.1 + 0.1 - 0.3`` is exactly equal to zero.  In binary floating "
"point, the result is :const:`5.5511151231257827e-017`.  While near to zero, "
"the differences prevent reliable equality testing and differences can "
"accumulate. For this reason, decimal is preferred in accounting applications "
"which have strict equality invariants."
msgstr ""

#: ../../../library/decimal.rst:44
msgid ""
"The decimal module incorporates a notion of significant places so that "
"``1.30 + 1.20`` is :const:`2.50`.  The trailing zero is kept to indicate "
"significance. This is the customary presentation for monetary applications. "
"For multiplication, the \"schoolbook\" approach uses all the figures in the "
"multiplicands.  For instance, ``1.3 * 1.2`` gives :const:`1.56` while ``1.30 "
"* 1.20`` gives :const:`1.5600`."
msgstr ""

#: ../../../library/decimal.rst:51
msgid ""
"Unlike hardware based binary floating point, the decimal module has a user "
"alterable precision (defaulting to 28 places) which can be as large as "
"needed for a given problem:"
msgstr ""

#: ../../../library/decimal.rst:62
msgid ""
"Both binary and decimal floating point are implemented in terms of published "
"standards.  While the built-in float type exposes only a modest portion of "
"its capabilities, the decimal module exposes all required parts of the "
"standard. When needed, the programmer has full control over rounding and "
"signal handling. This includes an option to enforce exact arithmetic by "
"using exceptions to block any inexact operations."
msgstr ""

#: ../../../library/decimal.rst:69
msgid ""
"The decimal module was designed to support \"without prejudice, both exact "
"unrounded decimal arithmetic (sometimes called fixed-point arithmetic) and "
"rounded floating-point arithmetic.\"  -- excerpt from the decimal arithmetic "
"specification."
msgstr ""

#: ../../../library/decimal.rst:74
msgid ""
"The module design is centered around three concepts:  the decimal number, "
"the context for arithmetic, and signals."
msgstr ""

#: ../../../library/decimal.rst:77
msgid ""
"A decimal number is immutable.  It has a sign, coefficient digits, and an "
"exponent.  To preserve significance, the coefficient digits do not truncate "
"trailing zeros.  Decimals also include special values such as :const:"
"`Infinity`, :const:`-Infinity`, and :const:`NaN`.  The standard also "
"differentiates :const:`-0` from :const:`+0`."
msgstr ""

#: ../../../library/decimal.rst:83
msgid ""
"The context for arithmetic is an environment specifying precision, rounding "
"rules, limits on exponents, flags indicating the results of operations, and "
"trap enablers which determine whether signals are treated as exceptions.  "
"Rounding options include :const:`ROUND_CEILING`, :const:`ROUND_DOWN`, :const:"
"`ROUND_FLOOR`, :const:`ROUND_HALF_DOWN`, :const:`ROUND_HALF_EVEN`, :const:"
"`ROUND_HALF_UP`, :const:`ROUND_UP`, and :const:`ROUND_05UP`."
msgstr ""

#: ../../../library/decimal.rst:90
msgid ""
"Signals are groups of exceptional conditions arising during the course of "
"computation.  Depending on the needs of the application, signals may be "
"ignored, considered as informational, or treated as exceptions. The signals "
"in the decimal module are: :const:`Clamped`, :const:`InvalidOperation`, :"
"const:`DivisionByZero`, :const:`Inexact`, :const:`Rounded`, :const:"
"`Subnormal`, :const:`Overflow`, and :const:`Underflow`."
msgstr ""

#: ../../../library/decimal.rst:97
msgid ""
"For each signal there is a flag and a trap enabler.  When a signal is "
"encountered, its flag is set to one, then, if the trap enabler is set to "
"one, an exception is raised.  Flags are sticky, so the user needs to reset "
"them before monitoring a calculation."
msgstr ""

#: ../../../library/decimal.rst:105
msgid ""
"IBM's General Decimal Arithmetic Specification, `The General Decimal "
"Arithmetic Specification <http://www2.hursley.ibm.com/decimal/decarith."
"html>`_."
msgstr ""

#: ../../../library/decimal.rst:108
msgid ""
"IEEE standard 854-1987, `Unofficial IEEE 854 Text <http://754r.ucbtest.org/"
"standards/854.pdf>`_."
msgstr ""

#: ../../../library/decimal.rst:117
msgid "Quick-start Tutorial"
msgstr ""

#: ../../../library/decimal.rst:119
msgid ""
"The usual start to using decimals is importing the module, viewing the "
"current context with :func:`getcontext` and, if necessary, setting new "
"values for precision, rounding, or enabled traps::"
msgstr ""

#: ../../../library/decimal.rst:123
msgid ""
">>> from decimal import *\n"
">>> getcontext()\n"
"Context(prec=28, rounding=ROUND_HALF_EVEN, Emin=-999999999, Emax=999999999,\n"
"        capitals=1, flags=[], traps=[Overflow, DivisionByZero,\n"
"        InvalidOperation])\n"
"\n"
">>> getcontext().prec = 7       # Set a new precision"
msgstr ""

#: ../../../library/decimal.rst:131
msgid ""
"Decimal instances can be constructed from integers, strings, or tuples.  To "
"create a Decimal from a :class:`float`, first convert it to a string.  This "
"serves as an explicit reminder of the details of the conversion (including "
"representation error).  Decimal numbers include special values such as :"
"const:`NaN` which stands for \"Not a number\", positive and negative :const:"
"`Infinity`, and :const:`-0`."
msgstr ""

#: ../../../library/decimal.rst:154
msgid ""
"The significance of a new Decimal is determined solely by the number of "
"digits input.  Context precision and rounding only come into play during "
"arithmetic operations."
msgstr ""

#: ../../../library/decimal.rst:158
msgid ""
">>> getcontext().prec = 6\n"
">>> Decimal('3.0')\n"
"Decimal('3.0')\n"
">>> Decimal('3.1415926535')\n"
"Decimal('3.1415926535')\n"
">>> Decimal('3.1415926535') + Decimal('2.7182818285')\n"
"Decimal('5.85987')\n"
">>> getcontext().rounding = ROUND_UP\n"
">>> Decimal('3.1415926535') + Decimal('2.7182818285')\n"
"Decimal('5.85988')"
msgstr ""

#: ../../../library/decimal.rst:171
msgid ""
"Decimals interact well with much of the rest of Python.  Here is a small "
"decimal floating point flying circus:"
msgstr ""

#: ../../../library/decimal.rst:174
msgid ""
">>> data = list(map(Decimal, '1.34 1.87 3.45 2.35 1.00 0.03 9.25'.split()))\n"
">>> max(data)\n"
"Decimal('9.25')\n"
">>> min(data)\n"
"Decimal('0.03')\n"
">>> sorted(data)\n"
"[Decimal('0.03'), Decimal('1.00'), Decimal('1.34'), Decimal('1.87'),\n"
" Decimal('2.35'), Decimal('3.45'), Decimal('9.25')]\n"
">>> sum(data)\n"
"Decimal('19.29')\n"
">>> a,b,c = data[:3]\n"
">>> str(a)\n"
"'1.34'\n"
">>> float(a)\n"
"1.3400000000000001\n"
">>> round(a, 1)     # round() first converts to binary floating point\n"
"1.3\n"
">>> int(a)\n"
"1\n"
">>> a * 5\n"
"Decimal('6.70')\n"
">>> a * b\n"
"Decimal('2.5058')\n"
">>> c % a\n"
"Decimal('0.77')"
msgstr ""

#: ../../../library/decimal.rst:203
msgid "And some mathematical functions are also available to Decimal:"
msgstr ""

#: ../../../library/decimal.rst:215
msgid ""
"The :meth:`quantize` method rounds a number to a fixed exponent.  This "
"method is useful for monetary applications that often round results to a "
"fixed number of places:"
msgstr ""

#: ../../../library/decimal.rst:224
msgid ""
"As shown above, the :func:`getcontext` function accesses the current context "
"and allows the settings to be changed.  This approach meets the needs of "
"most applications."
msgstr ""

#: ../../../library/decimal.rst:228
msgid ""
"For more advanced work, it may be useful to create alternate contexts using "
"the Context() constructor.  To make an alternate active, use the :func:"
"`setcontext` function."
msgstr ""

#: ../../../library/decimal.rst:232
msgid ""
"In accordance with the standard, the :mod:`Decimal` module provides two "
"ready to use standard contexts, :const:`BasicContext` and :const:"
"`ExtendedContext`. The former is especially useful for debugging because "
"many of the traps are enabled:"
msgstr ""

#: ../../../library/decimal.rst:237
msgid ""
">>> myothercontext = Context(prec=60, rounding=ROUND_HALF_DOWN)\n"
">>> setcontext(myothercontext)\n"
">>> Decimal(1) / Decimal(7)\n"
"Decimal('0.142857142857142857142857142857142857142857142857142857142857')\n"
"\n"
">>> ExtendedContext\n"
"Context(prec=9, rounding=ROUND_HALF_EVEN, Emin=-999999999, Emax=999999999,\n"
"        capitals=1, flags=[], traps=[])\n"
">>> setcontext(ExtendedContext)\n"
">>> Decimal(1) / Decimal(7)\n"
"Decimal('0.142857143')\n"
">>> Decimal(42) / Decimal(0)\n"
"Decimal('Infinity')\n"
"\n"
">>> setcontext(BasicContext)\n"
">>> Decimal(42) / Decimal(0)\n"
"Traceback (most recent call last):\n"
"  File \"<pyshell#143>\", line 1, in -toplevel-\n"
"    Decimal(42) / Decimal(0)\n"
"DivisionByZero: x / 0"
msgstr ""

#: ../../../library/decimal.rst:261
msgid ""
"Contexts also have signal flags for monitoring exceptional conditions "
"encountered during computations.  The flags remain set until explicitly "
"cleared, so it is best to clear the flags before each set of monitored "
"computations by using the :meth:`clear_flags` method. ::"
msgstr ""

#: ../../../library/decimal.rst:266
msgid ""
">>> setcontext(ExtendedContext)\n"
">>> getcontext().clear_flags()\n"
">>> Decimal(355) / Decimal(113)\n"
"Decimal('3.14159292')\n"
">>> getcontext()\n"
"Context(prec=9, rounding=ROUND_HALF_EVEN, Emin=-999999999, Emax=999999999,\n"
"        capitals=1, flags=[Inexact, Rounded], traps=[])"
msgstr ""

#: ../../../library/decimal.rst:274
msgid ""
"The *flags* entry shows that the rational approximation to :const:`Pi` was "
"rounded (digits beyond the context precision were thrown away) and that the "
"result is inexact (some of the discarded digits were non-zero)."
msgstr ""

#: ../../../library/decimal.rst:278
msgid ""
"Individual traps are set using the dictionary in the :attr:`traps` field of "
"a context:"
msgstr ""

#: ../../../library/decimal.rst:281
msgid ""
">>> setcontext(ExtendedContext)\n"
">>> Decimal(1) / Decimal(0)\n"
"Decimal('Infinity')\n"
">>> getcontext().traps[DivisionByZero] = 1\n"
">>> Decimal(1) / Decimal(0)\n"
"Traceback (most recent call last):\n"
"  File \"<pyshell#112>\", line 1, in -toplevel-\n"
"    Decimal(1) / Decimal(0)\n"
"DivisionByZero: x / 0"
msgstr ""

#: ../../../library/decimal.rst:293
msgid ""
"Most programs adjust the current context only once, at the beginning of the "
"program.  And, in many applications, data is converted to :class:`Decimal` "
"with a single cast inside a loop.  With context set and decimals created, "
"the bulk of the program manipulates the data no differently than with other "
"Python numeric types."
msgstr ""

#: ../../../library/decimal.rst:305
msgid "Decimal objects"
msgstr ""

#: ../../../library/decimal.rst:310
msgid "Construct a new :class:`Decimal` object based from *value*."
msgstr ""

#: ../../../library/decimal.rst:312
msgid ""
"*value* can be an integer, string, tuple, or another :class:`Decimal` "
"object. If no *value* is given, returns ``Decimal('0')``.  If *value* is a "
"string, it should conform to the decimal numeric string syntax after leading "
"and trailing whitespace characters are removed::"
msgstr ""

#: ../../../library/decimal.rst:317
msgid ""
"sign           ::=  '+' | '-'\n"
"digit          ::=  '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | "
"'9'\n"
"indicator      ::=  'e' | 'E'\n"
"digits         ::=  digit [digit]...\n"
"decimal-part   ::=  digits '.' [digits] | ['.'] digits\n"
"exponent-part  ::=  indicator [sign] digits\n"
"infinity       ::=  'Infinity' | 'Inf'\n"
"nan            ::=  'NaN' [digits] | 'sNaN' [digits]\n"
"numeric-value  ::=  decimal-part [exponent-part] | infinity\n"
"numeric-string ::=  [sign] numeric-value | [sign] nan"
msgstr ""

#: ../../../library/decimal.rst:328
msgid ""
"If *value* is a :class:`tuple`, it should have three components, a sign (:"
"const:`0` for positive or :const:`1` for negative), a :class:`tuple` of "
"digits, and an integer exponent. For example, ``Decimal((0, (1, 4, 1, 4), "
"-3))`` returns ``Decimal('1.414')``."
msgstr ""

#: ../../../library/decimal.rst:333
msgid ""
"The *context* precision does not affect how many digits are stored. That is "
"determined exclusively by the number of digits in *value*. For example, "
"``Decimal('3.00000')`` records all five zeros even if the context precision "
"is only three."
msgstr ""

#: ../../../library/decimal.rst:338
msgid ""
"The purpose of the *context* argument is determining what to do if *value* "
"is a malformed string.  If the context traps :const:`InvalidOperation`, an "
"exception is raised; otherwise, the constructor returns a new Decimal with "
"the value of :const:`NaN`."
msgstr ""

#: ../../../library/decimal.rst:343
msgid "Once constructed, :class:`Decimal` objects are immutable."
msgstr ""

#: ../../../library/decimal.rst:345
msgid ""
"Decimal floating point objects share many properties with the other built-in "
"numeric types such as :class:`float` and :class:`int`.  All of the usual "
"math operations and special methods apply.  Likewise, decimal objects can be "
"copied, pickled, printed, used as dictionary keys, used as set elements, "
"compared, sorted, and coerced to another type (such as :class:`float` or :"
"class:`long`)."
msgstr ""

#: ../../../library/decimal.rst:352
msgid ""
"In addition to the standard numeric properties, decimal floating point "
"objects also have a number of specialized methods:"
msgstr ""

#: ../../../library/decimal.rst:358
msgid ""
"Return the adjusted exponent after shifting out the coefficient's rightmost "
"digits until only the lead digit remains: ``Decimal('321e+5').adjusted()`` "
"returns seven.  Used for determining the position of the most significant "
"digit with respect to the decimal point."
msgstr ""

#: ../../../library/decimal.rst:366
msgid ""
"Return a :term:`named tuple` representation of the number: "
"``DecimalTuple(sign, digits, exponent)``."
msgstr ""

#: ../../../library/decimal.rst:372
msgid ""
"Return the canonical encoding of the argument.  Currently, the encoding of "
"a :class:`Decimal` instance is always canonical, so this operation returns "
"its argument unchanged."
msgstr ""

#: ../../../library/decimal.rst:378
msgid ""
"Compare the values of two Decimal instances.  :meth:`compare` returns a "
"Decimal instance, and if either operand is a NaN then the result is a NaN::"
msgstr ""

#: ../../../library/decimal.rst:382
msgid ""
"a or b is a NaN  ==> Decimal('NaN')\n"
"a < b            ==> Decimal('-1')\n"
"a == b           ==> Decimal('0')\n"
"a > b            ==> Decimal('1')"
msgstr ""

#: ../../../library/decimal.rst:389
msgid ""
"This operation is identical to the :meth:`compare` method, except that all "
"NaNs signal.  That is, if neither operand is a signaling NaN then any quiet "
"NaN operand is treated as though it were a signaling NaN."
msgstr ""

#: ../../../library/decimal.rst:395
msgid ""
"Compare two operands using their abstract representation rather than their "
"numerical value.  Similar to the :meth:`compare` method, but the result "
"gives a total ordering on :class:`Decimal` instances.  Two :class:`Decimal` "
"instances with the same numeric value but different representations compare "
"unequal in this ordering:"
msgstr ""

#: ../../../library/decimal.rst:404
msgid ""
"Quiet and signaling NaNs are also included in the total ordering.  The "
"result of this function is ``Decimal('0')`` if both operands have the same "
"representation, ``Decimal('-1')`` if the first operand is lower in the total "
"order than the second, and ``Decimal('1')`` if the first operand is higher "
"in the total order than the second operand.  See the specification for "
"details of the total order."
msgstr ""

#: ../../../library/decimal.rst:413
msgid ""
"Compare two operands using their abstract representation rather than their "
"value as in :meth:`compare_total`, but ignoring the sign of each operand. "
"``x.compare_total_mag(y)`` is equivalent to ``x.copy_abs().compare_total(y."
"copy_abs())``."
msgstr ""

#: ../../../library/decimal.rst:420
msgid ""
"Just returns self, this method is only to comply with the Decimal "
"Specification."
msgstr ""

#: ../../../library/decimal.rst:425
msgid ""
"Return the absolute value of the argument.  This operation is unaffected by "
"the context and is quiet: no flags are changed and no rounding is performed."
msgstr ""

#: ../../../library/decimal.rst:431
msgid ""
"Return the negation of the argument.  This operation is unaffected by the "
"context and is quiet: no flags are changed and no rounding is performed."
msgstr ""

#: ../../../library/decimal.rst:436
msgid ""
"Return a copy of the first operand with the sign set to be the same as the "
"sign of the second operand.  For example:"
msgstr ""

#: ../../../library/decimal.rst:442
msgid ""
"This operation is unaffected by the context and is quiet: no flags are "
"changed and no rounding is performed."
msgstr ""

#: ../../../library/decimal.rst:447
msgid ""
"Return the value of the (natural) exponential function ``e**x`` at the given "
"number.  The result is correctly rounded using the :const:`ROUND_HALF_EVEN` "
"rounding mode."
msgstr ""

#: ../../../library/decimal.rst:458
msgid ""
"Fused multiply-add.  Return self*other+third with no rounding of the "
"intermediate product self*other."
msgstr ""

#: ../../../library/decimal.rst:466
msgid ""
"Return :const:`True` if the argument is canonical and :const:`False` "
"otherwise.  Currently, a :class:`Decimal` instance is always canonical, so "
"this operation always returns :const:`True`."
msgstr ""

#: ../../../library/decimal.rst:472
msgid ""
"Return :const:`True` if the argument is a finite number, and :const:`False` "
"if the argument is an infinity or a NaN."
msgstr ""

#: ../../../library/decimal.rst:477
msgid ""
"Return :const:`True` if the argument is either positive or negative infinity "
"and :const:`False` otherwise."
msgstr ""

#: ../../../library/decimal.rst:482
msgid ""
"Return :const:`True` if the argument is a (quiet or signaling) NaN and :"
"const:`False` otherwise."
msgstr ""

#: ../../../library/decimal.rst:487
msgid ""
"Return :const:`True` if the argument is a *normal* finite number.  Return :"
"const:`False` if the argument is zero, subnormal, infinite or a NaN."
msgstr ""

#: ../../../library/decimal.rst:492
msgid ""
"Return :const:`True` if the argument is a quiet NaN, and :const:`False` "
"otherwise."
msgstr ""

#: ../../../library/decimal.rst:497
msgid ""
"Return :const:`True` if the argument has a negative sign and :const:`False` "
"otherwise.  Note that zeros and NaNs can both carry signs."
msgstr ""

#: ../../../library/decimal.rst:502
msgid ""
"Return :const:`True` if the argument is a signaling NaN and :const:`False` "
"otherwise."
msgstr ""

#: ../../../library/decimal.rst:507
msgid ""
"Return :const:`True` if the argument is subnormal, and :const:`False` "
"otherwise."
msgstr ""

#: ../../../library/decimal.rst:512
msgid ""
"Return :const:`True` if the argument is a (positive or negative) zero and :"
"const:`False` otherwise."
msgstr ""

#: ../../../library/decimal.rst:517
msgid ""
"Return the natural (base e) logarithm of the operand.  The result is "
"correctly rounded using the :const:`ROUND_HALF_EVEN` rounding mode."
msgstr ""

#: ../../../library/decimal.rst:522
msgid ""
"Return the base ten logarithm of the operand.  The result is correctly "
"rounded using the :const:`ROUND_HALF_EVEN` rounding mode."
msgstr ""

#: ../../../library/decimal.rst:527
msgid ""
"For a nonzero number, return the adjusted exponent of its operand as a :"
"class:`Decimal` instance.  If the operand is a zero then ``Decimal('-"
"Infinity')`` is returned and the :const:`DivisionByZero` flag is raised.  If "
"the operand is an infinity then ``Decimal('Infinity')`` is returned."
msgstr ""

#: ../../../library/decimal.rst:535
msgid ""
":meth:`logical_and` is a logical operation which takes two *logical "
"operands* (see :ref:`logical_operands_label`).  The result is the digit-wise "
"``and`` of the two operands."
msgstr ""

#: ../../../library/decimal.rst:541
msgid ""
":meth:`logical_invert` is a logical operation.  The argument must be a "
"*logical operand* (see :ref:`logical_operands_label`).  The result is the "
"digit-wise inversion of the operand."
msgstr ""

#: ../../../library/decimal.rst:547
msgid ""
":meth:`logical_or` is a logical operation which takes two *logical operands* "
"(see :ref:`logical_operands_label`).  The result is the digit-wise ``or`` of "
"the two operands."
msgstr ""

#: ../../../library/decimal.rst:553
msgid ""
":meth:`logical_xor` is a logical operation which takes two *logical "
"operands* (see :ref:`logical_operands_label`).  The result is the digit-wise "
"exclusive or of the two operands."
msgstr ""

#: ../../../library/decimal.rst:559
msgid ""
"Like ``max(self, other)`` except that the context rounding rule is applied "
"before returning and that :const:`NaN` values are either signaled or ignored "
"(depending on the context and whether they are signaling or quiet)."
msgstr ""

#: ../../../library/decimal.rst:566
msgid ""
"Similar to the :meth:`max` method, but the comparison is done using the "
"absolute values of the operands."
msgstr ""

#: ../../../library/decimal.rst:571
msgid ""
"Like ``min(self, other)`` except that the context rounding rule is applied "
"before returning and that :const:`NaN` values are either signaled or ignored "
"(depending on the context and whether they are signaling or quiet)."
msgstr ""

#: ../../../library/decimal.rst:578
msgid ""
"Similar to the :meth:`min` method, but the comparison is done using the "
"absolute values of the operands."
msgstr ""

#: ../../../library/decimal.rst:583
msgid ""
"Return the largest number representable in the given context (or in the "
"current thread's context if no context is given) that is smaller than the "
"given operand."
msgstr ""

#: ../../../library/decimal.rst:589
msgid ""
"Return the smallest number representable in the given context (or in the "
"current thread's context if no context is given) that is larger than the "
"given operand."
msgstr ""

#: ../../../library/decimal.rst:595
msgid ""
"If the two operands are unequal, return the number closest to the first "
"operand in the direction of the second operand.  If both operands are "
"numerically equal, return a copy of the first operand with the sign set to "
"be the same as the sign of the second operand."
msgstr ""

#: ../../../library/decimal.rst:602
msgid ""
"Normalize the number by stripping the rightmost trailing zeros and "
"converting any result equal to :const:`Decimal('0')` to :const:"
"`Decimal('0e0')`. Used for producing canonical values for members of an "
"equivalence class. For example, ``Decimal('32.100')`` and "
"``Decimal('0.321000e+2')`` both normalize to the equivalent value "
"``Decimal('32.1')``."
msgstr ""

#: ../../../library/decimal.rst:611
msgid ""
"Return a string describing the *class* of the operand.  The returned value "
"is one of the following ten strings."
msgstr ""

#: ../../../library/decimal.rst:614
msgid "``\"-Infinity\"``, indicating that the operand is negative infinity."
msgstr ""

#: ../../../library/decimal.rst:615
msgid ""
"``\"-Normal\"``, indicating that the operand is a negative normal number."
msgstr ""

#: ../../../library/decimal.rst:616
msgid ""
"``\"-Subnormal\"``, indicating that the operand is negative and subnormal."
msgstr ""

#: ../../../library/decimal.rst:617
msgid "``\"-Zero\"``, indicating that the operand is a negative zero."
msgstr ""

#: ../../../library/decimal.rst:618
msgid "``\"+Zero\"``, indicating that the operand is a positive zero."
msgstr ""

#: ../../../library/decimal.rst:619
msgid ""
"``\"+Subnormal\"``, indicating that the operand is positive and subnormal."
msgstr ""

#: ../../../library/decimal.rst:620
msgid ""
"``\"+Normal\"``, indicating that the operand is a positive normal number."
msgstr ""

#: ../../../library/decimal.rst:621
msgid "``\"+Infinity\"``, indicating that the operand is positive infinity."
msgstr ""

#: ../../../library/decimal.rst:622
msgid "``\"NaN\"``, indicating that the operand is a quiet NaN (Not a Number)."
msgstr ""

#: ../../../library/decimal.rst:623
msgid "``\"sNaN\"``, indicating that the operand is a signaling NaN."
msgstr ""

#: ../../../library/decimal.rst:627
msgid ""
"Return a value equal to the first operand after rounding and having the "
"exponent of the second operand."
msgstr ""

#: ../../../library/decimal.rst:633
msgid ""
"Unlike other operations, if the length of the coefficient after the quantize "
"operation would be greater than precision, then an :const:`InvalidOperation` "
"is signaled. This guarantees that, unless there is an error condition, the "
"quantized exponent is always equal to that of the right-hand operand."
msgstr ""

#: ../../../library/decimal.rst:639
msgid ""
"Also unlike other operations, quantize never signals Underflow, even if the "
"result is subnormal and inexact."
msgstr ""

#: ../../../library/decimal.rst:642
msgid ""
"If the exponent of the second operand is larger than that of the first then "
"rounding may be necessary.  In this case, the rounding mode is determined by "
"the ``rounding`` argument if given, else by the given ``context`` argument; "
"if neither argument is given the rounding mode of the current thread's "
"context is used."
msgstr ""

#: ../../../library/decimal.rst:648
msgid ""
"If *watchexp* is set (default), then an error is returned whenever the "
"resulting exponent is greater than :attr:`Emax` or less than :attr:`Etiny`."
msgstr ""

#: ../../../library/decimal.rst:654
msgid ""
"Return ``Decimal(10)``, the radix (base) in which the :class:`Decimal` class "
"does all its arithmetic.  Included for compatibility with the specification."
msgstr ""

#: ../../../library/decimal.rst:660
msgid ""
"Compute the modulo as either a positive or negative value depending on which "
"is closest to zero.  For instance, ``Decimal(10).remainder_near(6)`` returns "
"``Decimal('-2')`` which is closer to zero than ``Decimal('4')``."
msgstr ""

#: ../../../library/decimal.rst:664
msgid ""
"If both are equally close, the one chosen will have the same sign as *self*."
msgstr ""

#: ../../../library/decimal.rst:669
msgid ""
"Return the result of rotating the digits of the first operand by an amount "
"specified by the second operand.  The second operand must be an integer in "
"the range -precision through precision.  The absolute value of the second "
"operand gives the number of places to rotate.  If the second operand is "
"positive then rotation is to the left; otherwise rotation is to the right. "
"The coefficient of the first operand is padded on the left with zeros to "
"length precision if necessary.  The sign and exponent of the first operand "
"are unchanged."
msgstr ""

#: ../../../library/decimal.rst:680
msgid ""
"Test whether self and other have the same exponent or whether both are :"
"const:`NaN`."
msgstr ""

#: ../../../library/decimal.rst:685
msgid ""
"Return the first operand with exponent adjusted by the second. Equivalently, "
"return the first operand multiplied by ``10**other``.  The second operand "
"must be an integer."
msgstr ""

#: ../../../library/decimal.rst:691
msgid ""
"Return the result of shifting the digits of the first operand by an amount "
"specified by the second operand.  The second operand must be an integer in "
"the range -precision through precision.  The absolute value of the second "
"operand gives the number of places to shift.  If the second operand is "
"positive then the shift is to the left; otherwise the shift is to the "
"right.  Digits shifted into the coefficient are zeros.  The sign and "
"exponent of the first operand are unchanged."
msgstr ""

#: ../../../library/decimal.rst:701
msgid "Return the square root of the argument to full precision."
msgstr ""

#: ../../../library/decimal.rst:706
msgid "Convert to an engineering-type string."
msgstr ""

#: ../../../library/decimal.rst:708
msgid ""
"Engineering notation has an exponent which is a multiple of 3, so there are "
"up to 3 digits left of the decimal place.  For example, converts "
"``Decimal('123E+1')`` to ``Decimal('1.23E+3')``"
msgstr ""

#: ../../../library/decimal.rst:714
msgid ""
"Identical to the :meth:`to_integral_value` method.  The ``to_integral`` name "
"has been kept for compatibility with older versions."
msgstr ""

#: ../../../library/decimal.rst:719
msgid ""
"Round to the nearest integer, signaling :const:`Inexact` or :const:`Rounded` "
"as appropriate if rounding occurs.  The rounding mode is determined by the "
"``rounding`` parameter if given, else by the given ``context``.  If neither "
"parameter is given then the rounding mode of the current context is used."
msgstr ""

#: ../../../library/decimal.rst:727
msgid ""
"Round to the nearest integer without signaling :const:`Inexact` or :const:"
"`Rounded`.  If given, applies *rounding*; otherwise, uses the rounding "
"method in either the supplied *context* or the current context."
msgstr ""

#: ../../../library/decimal.rst:735
msgid "Logical operands"
msgstr ""

#: ../../../library/decimal.rst:737
msgid ""
"The :meth:`logical_and`, :meth:`logical_invert`, :meth:`logical_or`, and :"
"meth:`logical_xor` methods expect their arguments to be *logical operands*.  "
"A *logical operand* is a :class:`Decimal` instance whose exponent and sign "
"are both zero, and whose digits are all either :const:`0` or :const:`1`."
msgstr ""

#: ../../../library/decimal.rst:749
msgid "Context objects"
msgstr ""

#: ../../../library/decimal.rst:751
msgid ""
"Contexts are environments for arithmetic operations.  They govern precision, "
"set rules for rounding, determine which signals are treated as exceptions, "
"and limit the range for exponents."
msgstr ""

#: ../../../library/decimal.rst:755
msgid ""
"Each thread has its own current context which is accessed or changed using "
"the :func:`getcontext` and :func:`setcontext` functions:"
msgstr ""

#: ../../../library/decimal.rst:761
msgid "Return the current context for the active thread."
msgstr ""

#: ../../../library/decimal.rst:766
msgid "Set the current context for the active thread to *c*."
msgstr ""

#: ../../../library/decimal.rst:768
msgid ""
"You can also use the :keyword:`with` statement and the :func:`localcontext` "
"function to temporarily change the active context."
msgstr ""

#: ../../../library/decimal.rst:773
msgid ""
"Return a context manager that will set the current context for the active "
"thread to a copy of *c* on entry to the with-statement and restore the "
"previous context when exiting the with-statement. If no context is "
"specified, a copy of the current context is used."
msgstr ""

#: ../../../library/decimal.rst:778
msgid ""
"For example, the following code sets the current decimal precision to 42 "
"places, performs a calculation, and then automatically restores the previous "
"context::"
msgstr ""

#: ../../../library/decimal.rst:781
msgid ""
"from decimal import localcontext\n"
"\n"
"with localcontext() as ctx:\n"
"    ctx.prec = 42   # Perform a high precision calculation\n"
"    s = calculate_something()\n"
"s = +s  # Round the final result back to the default precision"
msgstr ""

#: ../../../library/decimal.rst:788
msgid ""
"New contexts can also be created using the :class:`Context` constructor "
"described below. In addition, the module provides three pre-made contexts:"
msgstr ""

#: ../../../library/decimal.rst:794
msgid ""
"This is a standard context defined by the General Decimal Arithmetic "
"Specification.  Precision is set to nine.  Rounding is set to :const:"
"`ROUND_HALF_UP`.  All flags are cleared.  All traps are enabled (treated as "
"exceptions) except :const:`Inexact`, :const:`Rounded`, and :const:"
"`Subnormal`."
msgstr ""

#: ../../../library/decimal.rst:800
msgid ""
"Because many of the traps are enabled, this context is useful for debugging."
msgstr ""

#: ../../../library/decimal.rst:805
msgid ""
"This is a standard context defined by the General Decimal Arithmetic "
"Specification.  Precision is set to nine.  Rounding is set to :const:"
"`ROUND_HALF_EVEN`.  All flags are cleared.  No traps are enabled (so that "
"exceptions are not raised during computations)."
msgstr ""

#: ../../../library/decimal.rst:810
msgid ""
"Because the traps are disabled, this context is useful for applications that "
"prefer to have result value of :const:`NaN` or :const:`Infinity` instead of "
"raising exceptions.  This allows an application to complete a run in the "
"presence of conditions that would otherwise halt the program."
msgstr ""

#: ../../../library/decimal.rst:818
msgid ""
"This context is used by the :class:`Context` constructor as a prototype for "
"new contexts.  Changing a field (such a precision) has the effect of "
"changing the default for new contexts creating by the :class:`Context` "
"constructor."
msgstr ""

#: ../../../library/decimal.rst:822
msgid ""
"This context is most useful in multi-threaded environments.  Changing one of "
"the fields before threads are started has the effect of setting system-wide "
"defaults.  Changing the fields after threads have started is not recommended "
"as it would require thread synchronization to prevent race conditions."
msgstr ""

#: ../../../library/decimal.rst:827
msgid ""
"In single threaded environments, it is preferable to not use this context at "
"all.  Instead, simply create contexts explicitly as described below."
msgstr ""

#: ../../../library/decimal.rst:830
msgid ""
"The default values are precision=28, rounding=ROUND_HALF_EVEN, and enabled "
"traps for Overflow, InvalidOperation, and DivisionByZero."
msgstr ""

#: ../../../library/decimal.rst:833
msgid ""
"In addition to the three supplied contexts, new contexts can be created with "
"the :class:`Context` constructor."
msgstr ""

#: ../../../library/decimal.rst:839
msgid ""
"Creates a new context.  If a field is not specified or is :const:`None`, the "
"default values are copied from the :const:`DefaultContext`.  If the *flags* "
"field is not specified or is :const:`None`, all flags are cleared."
msgstr ""

#: ../../../library/decimal.rst:843
msgid ""
"The *prec* field is a positive integer that sets the precision for "
"arithmetic operations in the context."
msgstr ""

#: ../../../library/decimal.rst:846
msgid "The *rounding* option is one of:"
msgstr ""

#: ../../../library/decimal.rst:848
msgid ":const:`ROUND_CEILING` (towards :const:`Infinity`),"
msgstr ""

#: ../../../library/decimal.rst:849
msgid ":const:`ROUND_DOWN` (towards zero),"
msgstr ""

#: ../../../library/decimal.rst:850
msgid ":const:`ROUND_FLOOR` (towards :const:`-Infinity`),"
msgstr ""

#: ../../../library/decimal.rst:851
msgid ":const:`ROUND_HALF_DOWN` (to nearest with ties going towards zero),"
msgstr ""

#: ../../../library/decimal.rst:852
msgid ""
":const:`ROUND_HALF_EVEN` (to nearest with ties going to nearest even "
"integer),"
msgstr ""

#: ../../../library/decimal.rst:853
msgid ":const:`ROUND_HALF_UP` (to nearest with ties going away from zero), or"
msgstr ""

#: ../../../library/decimal.rst:854
msgid ":const:`ROUND_UP` (away from zero)."
msgstr ""

#: ../../../library/decimal.rst:855
msgid ""
":const:`ROUND_05UP` (away from zero if last digit after rounding towards "
"zero would have been 0 or 5; otherwise towards zero)"
msgstr ""

#: ../../../library/decimal.rst:858
msgid ""
"The *traps* and *flags* fields list any signals to be set. Generally, new "
"contexts should only set traps and leave the flags clear."
msgstr ""

#: ../../../library/decimal.rst:861
msgid ""
"The *Emin* and *Emax* fields are integers specifying the outer limits "
"allowable for exponents."
msgstr ""

#: ../../../library/decimal.rst:864
msgid ""
"The *capitals* field is either :const:`0` or :const:`1` (the default). If "
"set to :const:`1`, exponents are printed with a capital :const:`E`; "
"otherwise, a lowercase :const:`e` is used: :const:`Decimal('6.02e+23')`."
msgstr ""

#: ../../../library/decimal.rst:869
msgid ""
"The :class:`Context` class defines several general purpose methods as well "
"as a large number of methods for doing arithmetic directly in a given "
"context. In addition, for each of the :class:`Decimal` methods described "
"above (with the exception of the :meth:`adjusted` and :meth:`as_tuple` "
"methods) there is a corresponding :class:`Context` method.  For example, ``C."
"exp(x)`` is equivalent to ``x.exp(context=C)``."
msgstr ""

#: ../../../library/decimal.rst:879
msgid "Resets all of the flags to :const:`0`."
msgstr ""

#: ../../../library/decimal.rst:883
msgid "Return a duplicate of the context."
msgstr ""

#: ../../../library/decimal.rst:887
msgid "Return a copy of the Decimal instance num."
msgstr ""

#: ../../../library/decimal.rst:891
msgid ""
"Creates a new Decimal instance from *num* but using *self* as context. "
"Unlike the :class:`Decimal` constructor, the context precision, rounding "
"method, flags, and traps are applied to the conversion."
msgstr ""

#: ../../../library/decimal.rst:895
msgid ""
"This is useful because constants are often given to a greater precision than "
"is needed by the application.  Another benefit is that rounding immediately "
"eliminates unintended effects from digits beyond the current precision. In "
"the following example, using unrounded inputs means that adding zero to a "
"sum can change the result:"
msgstr ""

#: ../../../library/decimal.rst:901
msgid ""
">>> getcontext().prec = 3\n"
">>> Decimal('3.4445') + Decimal('1.0023')\n"
"Decimal('4.45')\n"
">>> Decimal('3.4445') + Decimal(0) + Decimal('1.0023')\n"
"Decimal('4.44')"
msgstr ""

#: ../../../library/decimal.rst:909
msgid ""
"This method implements the to-number operation of the IBM specification. If "
"the argument is a string, no leading or trailing whitespace is permitted."
msgstr ""

#: ../../../library/decimal.rst:915
msgid ""
"Returns a value equal to ``Emin - prec + 1`` which is the minimum exponent "
"value for subnormal results.  When underflow occurs, the exponent is set to :"
"const:`Etiny`."
msgstr ""

#: ../../../library/decimal.rst:922
msgid "Returns a value equal to ``Emax - prec + 1``."
msgstr ""

#: ../../../library/decimal.rst:924
msgid ""
"The usual approach to working with decimals is to create :class:`Decimal` "
"instances and then apply arithmetic operations which take place within the "
"current context for the active thread.  An alternative approach is to use "
"context methods for calculating within a specific context.  The methods are "
"similar to those for the :class:`Decimal` class and are only briefly "
"recounted here."
msgstr ""

#: ../../../library/decimal.rst:934
msgid "Returns the absolute value of *x*."
msgstr ""

#: ../../../library/decimal.rst:939
msgid "Return the sum of *x* and *y*."
msgstr ""

#: ../../../library/decimal.rst:944
msgid "Returns the same Decimal object *x*."
msgstr ""

#: ../../../library/decimal.rst:949
msgid "Compares *x* and *y* numerically."
msgstr ""

#: ../../../library/decimal.rst:954
msgid "Compares the values of the two operands numerically."
msgstr ""

#: ../../../library/decimal.rst:959
msgid "Compares two operands using their abstract representation."
msgstr ""

#: ../../../library/decimal.rst:964
msgid ""
"Compares two operands using their abstract representation, ignoring sign."
msgstr ""

#: ../../../library/decimal.rst:969
msgid "Returns a copy of *x* with the sign set to 0."
msgstr ""

#: ../../../library/decimal.rst:974
msgid "Returns a copy of *x* with the sign inverted."
msgstr ""

#: ../../../library/decimal.rst:979
msgid "Copies the sign from *y* to *x*."
msgstr ""

#: ../../../library/decimal.rst:984
msgid "Return *x* divided by *y*."
msgstr ""

#: ../../../library/decimal.rst:989
msgid "Return *x* divided by *y*, truncated to an integer."
msgstr ""

#: ../../../library/decimal.rst:994
msgid "Divides two numbers and returns the integer part of the result."
msgstr ""

#: ../../../library/decimal.rst:999
msgid "Returns `e ** x`."
msgstr ""

#: ../../../library/decimal.rst:1004
msgid "Returns *x* multiplied by *y*, plus *z*."
msgstr ""

#: ../../../library/decimal.rst:1009
msgid "Returns True if *x* is canonical; otherwise returns False."
msgstr ""

#: ../../../library/decimal.rst:1014
msgid "Returns True if *x* is finite; otherwise returns False."
msgstr ""

#: ../../../library/decimal.rst:1019
msgid "Returns True if *x* is infinite; otherwise returns False."
msgstr ""

#: ../../../library/decimal.rst:1024
msgid "Returns True if *x* is a qNaN or sNaN; otherwise returns False."
msgstr ""

#: ../../../library/decimal.rst:1029
msgid "Returns True if *x* is a normal number; otherwise returns False."
msgstr ""

#: ../../../library/decimal.rst:1034
msgid "Returns True if *x* is a quiet NaN; otherwise returns False."
msgstr ""

#: ../../../library/decimal.rst:1039
msgid "Returns True if *x* is negative; otherwise returns False."
msgstr ""

#: ../../../library/decimal.rst:1044
msgid "Returns True if *x* is a signaling NaN; otherwise returns False."
msgstr ""

#: ../../../library/decimal.rst:1049
msgid "Returns True if *x* is subnormal; otherwise returns False."
msgstr ""

#: ../../../library/decimal.rst:1054
msgid "Returns True if *x* is a zero; otherwise returns False."
msgstr ""

#: ../../../library/decimal.rst:1059
msgid "Returns the natural (base e) logarithm of *x*."
msgstr ""

#: ../../../library/decimal.rst:1064
msgid "Returns the base 10 logarithm of *x*."
msgstr ""

#: ../../../library/decimal.rst:1069
msgid "Returns the exponent of the magnitude of the operand's MSD."
msgstr ""

#: ../../../library/decimal.rst:1074
msgid "Applies the logical operation *and* between each operand's digits."
msgstr ""

#: ../../../library/decimal.rst:1079
msgid "Invert all the digits in *x*."
msgstr ""

#: ../../../library/decimal.rst:1084
msgid "Applies the logical operation *or* between each operand's digits."
msgstr ""

#: ../../../library/decimal.rst:1089
msgid "Applies the logical operation *xor* between each operand's digits."
msgstr ""

#: ../../../library/decimal.rst:1094
msgid "Compares two values numerically and returns the maximum."
msgstr ""

#: ../../../library/decimal.rst:1099 ../../../library/decimal.rst:1109
msgid "Compares the values numerically with their sign ignored."
msgstr ""

#: ../../../library/decimal.rst:1104
msgid "Compares two values numerically and returns the minimum."
msgstr ""

#: ../../../library/decimal.rst:1114
msgid "Minus corresponds to the unary prefix minus operator in Python."
msgstr ""

#: ../../../library/decimal.rst:1119
msgid "Return the product of *x* and *y*."
msgstr ""

#: ../../../library/decimal.rst:1124
msgid "Returns the largest representable number smaller than *x*."
msgstr ""

#: ../../../library/decimal.rst:1129
msgid "Returns the smallest representable number larger than *x*."
msgstr ""

#: ../../../library/decimal.rst:1134
msgid "Returns the number closest to *x*, in direction towards *y*."
msgstr ""

#: ../../../library/decimal.rst:1139
msgid "Reduces *x* to its simplest form."
msgstr ""

#: ../../../library/decimal.rst:1144
msgid "Returns an indication of the class of *x*."
msgstr ""

#: ../../../library/decimal.rst:1149
msgid ""
"Plus corresponds to the unary prefix plus operator in Python.  This "
"operation applies the context precision and rounding, so it is *not* an "
"identity operation."
msgstr ""

#: ../../../library/decimal.rst:1156
msgid "Return ``x`` to the power of ``y``, reduced modulo ``modulo`` if given."
msgstr ""

#: ../../../library/decimal.rst:1158
msgid ""
"With two arguments, compute ``x**y``.  If ``x`` is negative then ``y`` must "
"be integral.  The result will be inexact unless ``y`` is integral and the "
"result is finite and can be expressed exactly in 'precision' digits. The "
"result should always be correctly rounded, using the rounding mode of the "
"current thread's context."
msgstr ""

#: ../../../library/decimal.rst:1164
msgid ""
"With three arguments, compute ``(x**y) % modulo``.  For the three argument "
"form, the following restrictions on the arguments hold:"
msgstr ""

#: ../../../library/decimal.rst:1167
msgid "all three arguments must be integral"
msgstr ""

#: ../../../library/decimal.rst:1168
msgid "``y`` must be nonnegative"
msgstr ""

#: ../../../library/decimal.rst:1169
msgid "at least one of ``x`` or ``y`` must be nonzero"
msgstr ""

#: ../../../library/decimal.rst:1170
msgid "``modulo`` must be nonzero and have at most 'precision' digits"
msgstr ""

#: ../../../library/decimal.rst:1172
msgid ""
"The result of ``Context.power(x, y, modulo)`` is identical to the result "
"that would be obtained by computing ``(x**y) % modulo`` with unbounded "
"precision, but is computed more efficiently.  It is always exact."
msgstr ""

#: ../../../library/decimal.rst:1179
msgid "Returns a value equal to *x* (rounded), having the exponent of *y*."
msgstr ""

#: ../../../library/decimal.rst:1184
msgid "Just returns 10, as this is Decimal, :)"
msgstr ""

#: ../../../library/decimal.rst:1189
msgid "Returns the remainder from integer division."
msgstr ""

#: ../../../library/decimal.rst:1191
msgid ""
"The sign of the result, if non-zero, is the same as that of the original "
"dividend."
msgstr ""

#: ../../../library/decimal.rst:1197
msgid ""
"Returns ``x - y * n``, where *n* is the integer nearest the exact value of "
"``x / y`` (if the result is 0 then its sign will be the sign of *x*)."
msgstr ""

#: ../../../library/decimal.rst:1203
msgid "Returns a rotated copy of *x*, *y* times."
msgstr ""

#: ../../../library/decimal.rst:1208
msgid "Returns True if the two operands have the same exponent."
msgstr ""

#: ../../../library/decimal.rst:1213
msgid "Returns the first operand after adding the second value its exp."
msgstr ""

#: ../../../library/decimal.rst:1218
msgid "Returns a shifted copy of *x*, *y* times."
msgstr ""

#: ../../../library/decimal.rst:1223
msgid "Square root of a non-negative number to context precision."
msgstr ""

#: ../../../library/decimal.rst:1228
msgid "Return the difference between *x* and *y*."
msgstr ""

#: ../../../library/decimal.rst:1233
msgid "Converts a number to a string, using scientific notation."
msgstr ""

#: ../../../library/decimal.rst:1238
msgid "Rounds to an integer."
msgstr ""

#: ../../../library/decimal.rst:1243
msgid "Converts a number to a string using scientific notation."
msgstr ""

#: ../../../library/decimal.rst:1251
msgid "Signals"
msgstr ""

#: ../../../library/decimal.rst:1253
msgid ""
"Signals represent conditions that arise during computation. Each corresponds "
"to one context flag and one context trap enabler."
msgstr ""

#: ../../../library/decimal.rst:1256
msgid ""
"The context flag is set whenever the condition is encountered. After the "
"computation, flags may be checked for informational purposes (for instance, "
"to determine whether a computation was exact). After checking the flags, be "
"sure to clear all flags before starting the next computation."
msgstr ""

#: ../../../library/decimal.rst:1261
msgid ""
"If the context's trap enabler is set for the signal, then the condition "
"causes a Python exception to be raised.  For example, if the :class:"
"`DivisionByZero` trap is set, then a :exc:`DivisionByZero` exception is "
"raised upon encountering the condition."
msgstr ""

#: ../../../library/decimal.rst:1269
msgid "Altered an exponent to fit representation constraints."
msgstr ""

#: ../../../library/decimal.rst:1271
msgid ""
"Typically, clamping occurs when an exponent falls outside the context's :"
"attr:`Emin` and :attr:`Emax` limits.  If possible, the exponent is reduced "
"to fit by adding zeros to the coefficient."
msgstr ""

#: ../../../library/decimal.rst:1278
msgid "Base class for other signals and a subclass of :exc:`ArithmeticError`."
msgstr ""

#: ../../../library/decimal.rst:1283
msgid "Signals the division of a non-infinite number by zero."
msgstr ""

#: ../../../library/decimal.rst:1285
msgid ""
"Can occur with division, modulo division, or when raising a number to a "
"negative power.  If this signal is not trapped, returns :const:`Infinity` "
"or :const:`-Infinity` with the sign determined by the inputs to the "
"calculation."
msgstr ""

#: ../../../library/decimal.rst:1292
msgid "Indicates that rounding occurred and the result is not exact."
msgstr ""

#: ../../../library/decimal.rst:1294
msgid ""
"Signals when non-zero digits were discarded during rounding. The rounded "
"result is returned.  The signal flag or trap is used to detect when results "
"are inexact."
msgstr ""

#: ../../../library/decimal.rst:1301
msgid "An invalid operation was performed."
msgstr ""

#: ../../../library/decimal.rst:1303
msgid ""
"Indicates that an operation was requested that does not make sense. If not "
"trapped, returns :const:`NaN`.  Possible causes include::"
msgstr ""

#: ../../../library/decimal.rst:1306
msgid ""
"Infinity - Infinity\n"
"0 * Infinity\n"
"Infinity / Infinity\n"
"x % 0\n"
"Infinity % x\n"
"x._rescale( non-integer )\n"
"sqrt(-x) and x > 0\n"
"0 ** 0\n"
"x ** (non-integer)\n"
"x ** Infinity"
msgstr ""

#: ../../../library/decimal.rst:1320
msgid "Numerical overflow."
msgstr ""

#: ../../../library/decimal.rst:1322
msgid ""
"Indicates the exponent is larger than :attr:`Emax` after rounding has "
"occurred.  If not trapped, the result depends on the rounding mode, either "
"pulling inward to the largest representable finite number or rounding "
"outward to :const:`Infinity`.  In either case, :class:`Inexact` and :class:"
"`Rounded` are also signaled."
msgstr ""

#: ../../../library/decimal.rst:1331
msgid "Rounding occurred though possibly no information was lost."
msgstr ""

#: ../../../library/decimal.rst:1333
msgid ""
"Signaled whenever rounding discards digits; even if those digits are zero "
"(such as rounding :const:`5.00` to :const:`5.0`).  If not trapped, returns "
"the result unchanged.  This signal is used to detect loss of significant "
"digits."
msgstr ""

#: ../../../library/decimal.rst:1341
msgid "Exponent was lower than :attr:`Emin` prior to rounding."
msgstr ""

#: ../../../library/decimal.rst:1343
msgid ""
"Occurs when an operation result is subnormal (the exponent is too small). If "
"not trapped, returns the result unchanged."
msgstr ""

#: ../../../library/decimal.rst:1349
msgid "Numerical underflow with result rounded to zero."
msgstr ""

#: ../../../library/decimal.rst:1351
msgid ""
"Occurs when a subnormal result is pushed to zero by rounding. :class:"
"`Inexact` and :class:`Subnormal` are also signaled."
msgstr ""

#: ../../../library/decimal.rst:1354
msgid "The following table summarizes the hierarchy of signals::"
msgstr ""

#: ../../../library/decimal.rst:1356
msgid ""
"exceptions.ArithmeticError(exceptions.Exception)\n"
"    DecimalException\n"
"        Clamped\n"
"        DivisionByZero(DecimalException, exceptions.ZeroDivisionError)\n"
"        Inexact\n"
"            Overflow(Inexact, Rounded)\n"
"            Underflow(Inexact, Rounded, Subnormal)\n"
"        InvalidOperation\n"
"        Rounded\n"
"        Subnormal"
msgstr ""

#: ../../../library/decimal.rst:1373
msgid "Floating Point Notes"
msgstr ""

#: ../../../library/decimal.rst:1377
msgid "Mitigating round-off error with increased precision"
msgstr ""

#: ../../../library/decimal.rst:1379
msgid ""
"The use of decimal floating point eliminates decimal representation error "
"(making it possible to represent :const:`0.1` exactly); however, some "
"operations can still incur round-off error when non-zero digits exceed the "
"fixed precision."
msgstr ""

#: ../../../library/decimal.rst:1383
msgid ""
"The effects of round-off error can be amplified by the addition or "
"subtraction of nearly offsetting quantities resulting in loss of "
"significance.  Knuth provides two instructive examples where rounded "
"floating point arithmetic with insufficient precision causes the breakdown "
"of the associative and distributive properties of addition:"
msgstr ""

#: ../../../library/decimal.rst:1389
msgid ""
"# Examples from Seminumerical Algorithms, Section 4.2.2.\n"
">>> from decimal import Decimal, getcontext\n"
">>> getcontext().prec = 8\n"
"\n"
">>> u, v, w = Decimal(11111113), Decimal(-11111111), Decimal('7.51111111')\n"
">>> (u + v) + w\n"
"Decimal('9.5111111')\n"
">>> u + (v + w)\n"
"Decimal('10')\n"
"\n"
">>> u, v, w = Decimal(20000), Decimal(-6), Decimal('6.0000003')\n"
">>> (u*v) + (u*w)\n"
"Decimal('0.01')\n"
">>> u * (v+w)\n"
"Decimal('0.0060000')"
msgstr ""

#: ../../../library/decimal.rst:1407
msgid ""
"The :mod:`decimal` module makes it possible to restore the identities by "
"expanding the precision sufficiently to avoid loss of significance:"
msgstr ""

#: ../../../library/decimal.rst:1410
msgid ""
">>> getcontext().prec = 20\n"
">>> u, v, w = Decimal(11111113), Decimal(-11111111), Decimal('7.51111111')\n"
">>> (u + v) + w\n"
"Decimal('9.51111111')\n"
">>> u + (v + w)\n"
"Decimal('9.51111111')\n"
">>>\n"
">>> u, v, w = Decimal(20000), Decimal(-6), Decimal('6.0000003')\n"
">>> (u*v) + (u*w)\n"
"Decimal('0.0060000')\n"
">>> u * (v+w)\n"
"Decimal('0.0060000')"
msgstr ""

#: ../../../library/decimal.rst:1427
msgid "Special values"
msgstr ""

#: ../../../library/decimal.rst:1429
msgid ""
"The number system for the :mod:`decimal` module provides special values "
"including :const:`NaN`, :const:`sNaN`, :const:`-Infinity`, :const:"
"`Infinity`, and two zeros, :const:`+0` and :const:`-0`."
msgstr ""

#: ../../../library/decimal.rst:1433
msgid ""
"Infinities can be constructed directly with:  ``Decimal('Infinity')``. Also, "
"they can arise from dividing by zero when the :exc:`DivisionByZero` signal "
"is not trapped.  Likewise, when the :exc:`Overflow` signal is not trapped, "
"infinity can result from rounding beyond the limits of the largest "
"representable number."
msgstr ""

#: ../../../library/decimal.rst:1438
msgid ""
"The infinities are signed (affine) and can be used in arithmetic operations "
"where they get treated as very large, indeterminate numbers.  For instance, "
"adding a constant to infinity gives another infinite result."
msgstr ""

#: ../../../library/decimal.rst:1442
msgid ""
"Some operations are indeterminate and return :const:`NaN`, or if the :exc:"
"`InvalidOperation` signal is trapped, raise an exception.  For example, "
"``0/0`` returns :const:`NaN` which means \"not a number\".  This variety of :"
"const:`NaN` is quiet and, once created, will flow through other computations "
"always resulting in another :const:`NaN`.  This behavior can be useful for a "
"series of computations that occasionally have missing inputs --- it allows "
"the calculation to proceed while flagging specific results as invalid."
msgstr ""

#: ../../../library/decimal.rst:1450
msgid ""
"A variant is :const:`sNaN` which signals rather than remaining quiet after "
"every operation.  This is a useful return value when an invalid result needs "
"to interrupt a calculation for special handling."
msgstr ""

#: ../../../library/decimal.rst:1454
msgid ""
"The behavior of Python's comparison operators can be a little surprising "
"where a :const:`NaN` is involved.  A test for equality where one of the "
"operands is a quiet or signaling :const:`NaN` always returns :const:`False` "
"(even when doing ``Decimal('NaN')==Decimal('NaN')``), while a test for "
"inequality always returns :const:`True`.  An attempt to compare two Decimals "
"using any of the ``<``, ``<=``, ``>`` or ``>=`` operators will raise the :"
"exc:`InvalidOperation` signal if either operand is a :const:`NaN`, and "
"return :const:`False` if this signal is not trapped.  Note that the General "
"Decimal Arithmetic specification does not specify the behavior of direct "
"comparisons; these rules for comparisons involving a :const:`NaN` were taken "
"from the IEEE 854 standard (see Table 3 in section 5.7).  To ensure strict "
"standards-compliance, use the :meth:`compare` and :meth:`compare-signal` "
"methods instead."
msgstr ""

#: ../../../library/decimal.rst:1467
msgid ""
"The signed zeros can result from calculations that underflow. They keep the "
"sign that would have resulted if the calculation had been carried out to "
"greater precision.  Since their magnitude is zero, both positive and "
"negative zeros are treated as equal and their sign is informational."
msgstr ""

#: ../../../library/decimal.rst:1472
msgid ""
"In addition to the two signed zeros which are distinct yet equal, there are "
"various representations of zero with differing precisions yet equivalent in "
"value.  This takes a bit of getting used to.  For an eye accustomed to "
"normalized floating point representations, it is not immediately obvious "
"that the following calculation returns a value equal to zero:"
msgstr ""

#: ../../../library/decimal.rst:1487
msgid "Working with threads"
msgstr ""

#: ../../../library/decimal.rst:1489
msgid ""
"The :func:`getcontext` function accesses a different :class:`Context` object "
"for each thread.  Having separate thread contexts means that threads may "
"make changes (such as ``getcontext.prec=10``) without interfering with other "
"threads."
msgstr ""

#: ../../../library/decimal.rst:1493
msgid ""
"Likewise, the :func:`setcontext` function automatically assigns its target "
"to the current thread."
msgstr ""

#: ../../../library/decimal.rst:1496
msgid ""
"If :func:`setcontext` has not been called before :func:`getcontext`, then :"
"func:`getcontext` will automatically create a new context for use in the "
"current thread."
msgstr ""

#: ../../../library/decimal.rst:1500
msgid ""
"The new context is copied from a prototype context called *DefaultContext*. "
"To control the defaults so that each thread will use the same values "
"throughout the application, directly modify the *DefaultContext* object. "
"This should be done *before* any threads are started so that there won't be "
"a race condition between threads calling :func:`getcontext`. For example::"
msgstr ""

#: ../../../library/decimal.rst:1506
msgid ""
"# Set applicationwide defaults for all threads about to be launched\n"
"DefaultContext.prec = 12\n"
"DefaultContext.rounding = ROUND_DOWN\n"
"DefaultContext.traps = ExtendedContext.traps.copy()\n"
"DefaultContext.traps[InvalidOperation] = 1\n"
"setcontext(DefaultContext)\n"
"\n"
"# Afterwards, the threads can be started\n"
"t1.start()\n"
"t2.start()\n"
"t3.start()\n"
" . . ."
msgstr ""

#: ../../../library/decimal.rst:1525
msgid "Recipes"
msgstr ""

#: ../../../library/decimal.rst:1527
msgid ""
"Here are a few recipes that serve as utility functions and that demonstrate "
"ways to work with the :class:`Decimal` class::"
msgstr ""

#: ../../../library/decimal.rst:1530
msgid ""
"def moneyfmt(value, places=2, curr='', sep=',', dp='.',\n"
"             pos='', neg='-', trailneg=''):\n"
"    \"\"\"Convert Decimal to a money formatted string.\n"
"\n"
"    places:  required number of places after the decimal point\n"
"    curr:    optional currency symbol before the sign (may be blank)\n"
"    sep:     optional grouping separator (comma, period, space, or blank)\n"
"    dp:      decimal point indicator (comma or period)\n"
"             only specify as blank when places is zero\n"
"    pos:     optional sign for positive numbers: '+', space or blank\n"
"    neg:     optional sign for negative numbers: '-', '(', space or blank\n"
"    trailneg:optional trailing minus indicator:  '-', ')', space or blank\n"
"\n"
"    >>> d = Decimal('-1234567.8901')\n"
"    >>> moneyfmt(d, curr='$')\n"
"    '-$1,234,567.89'\n"
"    >>> moneyfmt(d, places=0, sep='.', dp='', neg='', trailneg='-')\n"
"    '1.234.568-'\n"
"    >>> moneyfmt(d, curr='$', neg='(', trailneg=')')\n"
"    '($1,234,567.89)'\n"
"    >>> moneyfmt(Decimal(123456789), sep=' ')\n"
"    '123 456 789.00'\n"
"    >>> moneyfmt(Decimal('-0.02'), neg='<', trailneg='>')\n"
"    '<0.02>'\n"
"\n"
"    \"\"\"\n"
"    q = Decimal(10) ** -places      # 2 places --> '0.01'\n"
"    sign, digits, exp = value.quantize(q).as_tuple()\n"
"    result = []\n"
"    digits = list(map(str, digits))\n"
"    build, next = result.append, digits.pop\n"
"    if sign:\n"
"        build(trailneg)\n"
"    for i in range(places):\n"
"        build(next() if digits else '0')\n"
"    build(dp)\n"
"    if not digits:\n"
"        build('0')\n"
"    i = 0\n"
"    while digits:\n"
"        build(next())\n"
"        i += 1\n"
"        if i == 3 and digits:\n"
"            i = 0\n"
"            build(sep)\n"
"    build(curr)\n"
"    build(neg if sign else pos)\n"
"    return ''.join(reversed(result))\n"
"\n"
"def pi():\n"
"    \"\"\"Compute Pi to the current precision.\n"
"\n"
"    >>> print(pi())\n"
"    3.141592653589793238462643383\n"
"\n"
"    \"\"\"\n"
"    getcontext().prec += 2  # extra digits for intermediate steps\n"
"    three = Decimal(3)      # substitute \"three=3.0\" for regular floats\n"
"    lasts, t, s, n, na, d, da = 0, three, 3, 1, 0, 0, 24\n"
"    while s != lasts:\n"
"        lasts = s\n"
"        n, na = n+na, na+8\n"
"        d, da = d+da, da+32\n"
"        t = (t * n) / d\n"
"        s += t\n"
"    getcontext().prec -= 2\n"
"    return +s               # unary plus applies the new precision\n"
"\n"
"def exp(x):\n"
"    \"\"\"Return e raised to the power of x.  Result type matches input "
"type.\n"
"\n"
"    >>> print(exp(Decimal(1)))\n"
"    2.718281828459045235360287471\n"
"    >>> print(exp(Decimal(2)))\n"
"    7.389056098930650227230427461\n"
"    >>> print(exp(2.0))\n"
"    7.38905609893\n"
"    >>> print(exp(2+0j))\n"
"    (7.38905609893+0j)\n"
"\n"
"    \"\"\"\n"
"    getcontext().prec += 2\n"
"    i, lasts, s, fact, num = 0, 0, 1, 1, 1\n"
"    while s != lasts:\n"
"        lasts = s\n"
"        i += 1\n"
"        fact *= i\n"
"        num *= x\n"
"        s += num / fact\n"
"    getcontext().prec -= 2\n"
"    return +s\n"
"\n"
"def cos(x):\n"
"    \"\"\"Return the cosine of x as measured in radians.\n"
"\n"
"    >>> print(cos(Decimal('0.5')))\n"
"    0.8775825618903727161162815826\n"
"    >>> print(cos(0.5))\n"
"    0.87758256189\n"
"    >>> print(cos(0.5+0j))\n"
"    (0.87758256189+0j)\n"
"\n"
"    \"\"\"\n"
"    getcontext().prec += 2\n"
"    i, lasts, s, fact, num, sign = 0, 0, 1, 1, 1, 1\n"
"    while s != lasts:\n"
"        lasts = s\n"
"        i += 2\n"
"        fact *= i * (i-1)\n"
"        num *= x * x\n"
"        sign *= -1\n"
"        s += num / fact * sign\n"
"    getcontext().prec -= 2\n"
"    return +s\n"
"\n"
"def sin(x):\n"
"    \"\"\"Return the sine of x as measured in radians.\n"
"\n"
"    >>> print(sin(Decimal('0.5')))\n"
"    0.4794255386042030002732879352\n"
"    >>> print(sin(0.5))\n"
"    0.479425538604\n"
"    >>> print(sin(0.5+0j))\n"
"    (0.479425538604+0j)\n"
"\n"
"    \"\"\"\n"
"    getcontext().prec += 2\n"
"    i, lasts, s, fact, num, sign = 1, 0, x, 1, x, 1\n"
"    while s != lasts:\n"
"        lasts = s\n"
"        i += 2\n"
"        fact *= i * (i-1)\n"
"        num *= x * x\n"
"        sign *= -1\n"
"        s += num / fact * sign\n"
"    getcontext().prec -= 2\n"
"    return +s"
msgstr ""

#: ../../../library/decimal.rst:1675
msgid "Decimal FAQ"
msgstr ""

#: ../../../library/decimal.rst:1677
msgid ""
"Q. It is cumbersome to type ``decimal.Decimal('1234.5')``.  Is there a way "
"to minimize typing when using the interactive interpreter?"
msgstr ""

#: ../../../library/decimal.rst:1680
msgid "A. Some users abbreviate the constructor to just a single letter:"
msgstr ""

#: ../../../library/decimal.rst:1686
msgid ""
"Q. In a fixed-point application with two decimal places, some inputs have "
"many places and need to be rounded.  Others are not supposed to have excess "
"digits and need to be validated.  What methods should be used?"
msgstr ""

#: ../../../library/decimal.rst:1690
msgid ""
"A. The :meth:`quantize` method rounds to a fixed number of decimal places. "
"If the :const:`Inexact` trap is set, it is also useful for validation:"
msgstr ""

#: ../../../library/decimal.rst:1708
msgid ""
"Q. Once I have valid two place inputs, how do I maintain that invariant "
"throughout an application?"
msgstr ""

#: ../../../library/decimal.rst:1711
msgid ""
"A. Some operations like addition, subtraction, and multiplication by an "
"integer will automatically preserve fixed point.  Others operations, like "
"division and non-integer multiplication, will change the number of decimal "
"places and need to be followed-up with a :meth:`quantize` step:"
msgstr ""

#: ../../../library/decimal.rst:1729
msgid ""
"In developing fixed-point applications, it is convenient to define functions "
"to handle the :meth:`quantize` step:"
msgstr ""

#: ../../../library/decimal.rst:1742
msgid ""
"Q. There are many ways to express the same value.  The numbers :const:"
"`200`, :const:`200.000`, :const:`2E2`, and :const:`.02E+4` all have the same "
"value at various precisions. Is there a way to transform them to a single "
"recognizable canonical value?"
msgstr ""

#: ../../../library/decimal.rst:1747
msgid ""
"A. The :meth:`normalize` method maps all equivalent values to a single "
"representative:"
msgstr ""

#: ../../../library/decimal.rst:1754
msgid ""
"Q. Some decimal values always print with exponential notation.  Is there a "
"way to get a non-exponential representation?"
msgstr ""

#: ../../../library/decimal.rst:1757
msgid ""
"A. For some values, exponential notation is the only way to express the "
"number of significant places in the coefficient.  For example, expressing :"
"const:`5.0E+3` as :const:`5000` keeps the value constant but cannot show the "
"original's two-place significance."
msgstr ""

#: ../../../library/decimal.rst:1762
msgid ""
"If an application does not care about tracking significance, it is easy to "
"remove the exponent and trailing zeroes, losing significance, but keeping "
"the value unchanged:"
msgstr ""

#: ../../../library/decimal.rst:1772
msgid "Q. Is there a way to convert a regular float to a :class:`Decimal`?"
msgstr ""

#: ../../../library/decimal.rst:1774
msgid ""
"A. Yes, all binary floating point numbers can be exactly expressed as a "
"Decimal.  An exact conversion may take more precision than intuition would "
"suggest, so we trap :const:`Inexact` to signal a need for more precision:"
msgstr ""

#: ../../../library/decimal.rst:1778
msgid ""
"def float_to_decimal(f):\n"
"    \"Convert a floating point number to a Decimal with no loss of "
"information\"\n"
"    n, d = f.as_integer_ratio()\n"
"    with localcontext() as ctx:\n"
"        ctx.traps[Inexact] = True\n"
"        while True:\n"
"            try:\n"
"               return Decimal(n) / Decimal(d)\n"
"            except Inexact:\n"
"                ctx.prec += 1"
msgstr ""

#: ../../../library/decimal.rst:1791
msgid ""
">>> float_to_decimal(math.pi)\n"
"Decimal('3.141592653589793115997963468544185161590576171875')"
msgstr ""

#: ../../../library/decimal.rst:1796
msgid ""
"Q. Why isn't the :func:`float_to_decimal` routine included in the module?"
msgstr ""

#: ../../../library/decimal.rst:1798
msgid ""
"A. There is some question about whether it is advisable to mix binary and "
"decimal floating point.  Also, its use requires some care to avoid the "
"representation issues associated with binary floating point:"
msgstr ""

#: ../../../library/decimal.rst:1805
msgid ""
"Q. Within a complex calculation, how can I make sure that I haven't gotten a "
"spurious result because of insufficient precision or rounding anomalies."
msgstr ""

#: ../../../library/decimal.rst:1808
msgid ""
"A. The decimal module makes it easy to test results.  A best practice is to "
"re-run calculations using greater precision and with various rounding modes. "
"Widely differing results indicate insufficient precision, rounding mode "
"issues, ill-conditioned inputs, or a numerically unstable algorithm."
msgstr ""

#: ../../../library/decimal.rst:1813
msgid ""
"Q. I noticed that context precision is applied to the results of operations "
"but not to the inputs.  Is there anything to watch out for when mixing "
"values of different precisions?"
msgstr ""

#: ../../../library/decimal.rst:1817
msgid ""
"A. Yes.  The principle is that all values are considered to be exact and so "
"is the arithmetic on those values.  Only the results are rounded.  The "
"advantage for inputs is that \"what you type is what you get\".  A "
"disadvantage is that the results can look odd if you forget that the inputs "
"haven't been rounded:"
msgstr ""

#: ../../../library/decimal.rst:1822
msgid ""
">>> getcontext().prec = 3\n"
">>> Decimal('3.104') + Decimal('2.104')\n"
"Decimal('5.21')\n"
">>> Decimal('3.104') + Decimal('0.000') + Decimal('2.104')\n"
"Decimal('5.20')"
msgstr ""

#: ../../../library/decimal.rst:1830
msgid ""
"The solution is either to increase precision or to force rounding of inputs "
"using the unary plus operation:"
msgstr ""

#: ../../../library/decimal.rst:1833
msgid ""
">>> getcontext().prec = 3\n"
">>> +Decimal('1.23456789')      # unary plus triggers rounding\n"
"Decimal('1.23')"
msgstr ""

#: ../../../library/decimal.rst:1839
msgid ""
"Alternatively, inputs can be rounded upon creation using the :meth:`Context."
"create_decimal` method:"
msgstr ""

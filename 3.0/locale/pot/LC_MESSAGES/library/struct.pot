# SOME DESCRIPTIVE TITLE.
# Copyright (C) 1990-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-10 15:11+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../library/struct.rst:3
msgid ":mod:`struct` --- Interpret bytes as packed binary data"
msgstr ""

#: ../../../library/struct.rst:12
msgid ""
"This module performs conversions between Python values and C structs "
"represented as Python :class:`bytes` objects.  It uses :dfn:`format strings` "
"(explained below) as compact descriptions of the lay-out of the C structs "
"and the intended conversion to/from Python values.  This can be used in "
"handling binary data stored in files or from network connections, among "
"other sources."
msgstr ""

#: ../../../library/struct.rst:18
msgid "The module defines the following exception and functions:"
msgstr ""

#: ../../../library/struct.rst:23
msgid ""
"Exception raised on various occasions; argument is a string describing what "
"is wrong."
msgstr ""

#: ../../../library/struct.rst:29
msgid ""
"Return a bytes containing the values ``v1, v2, ...`` packed according to the "
"given format.  The arguments must match the values required by the format "
"exactly."
msgstr ""

#: ../../../library/struct.rst:36
msgid ""
"Pack the values ``v1, v2, ...`` according to the given format, write the "
"packed bytes into the writable *buffer* starting at *offset*. Note that the "
"offset is a required argument."
msgstr ""

#: ../../../library/struct.rst:43
msgid ""
"Unpack the bytes (presumably packed by ``pack(fmt, ...)``) according to the "
"given format.  The result is a tuple even if it contains exactly one item.  "
"The bytes must contain exactly the amount of data required by the format "
"(``len(bytes)`` must equal ``calcsize(fmt)``)."
msgstr ""

#: ../../../library/struct.rst:51
msgid ""
"Unpack the *buffer* according to tthe given format. The result is a tuple "
"even if it contains exactly one item. The *buffer* must contain at least the "
"amount of data required by the format (``len(buffer[offset:])`` must be at "
"least ``calcsize(fmt)``)."
msgstr ""

#: ../../../library/struct.rst:59
msgid ""
"Return the size of the struct (and hence of the bytes) corresponding to the "
"given format."
msgstr ""

#: ../../../library/struct.rst:62
msgid ""
"Format characters have the following meaning; the conversion between C and "
"Python values should be obvious given their types:"
msgstr ""

#: ../../../library/struct.rst:66
msgid "Format"
msgstr ""

#: ../../../library/struct.rst:66
msgid "C Type"
msgstr ""

#: ../../../library/struct.rst:66
msgid "Python"
msgstr ""

#: ../../../library/struct.rst:66
msgid "Notes"
msgstr ""

#: ../../../library/struct.rst:68
msgid "``x``"
msgstr ""

#: ../../../library/struct.rst:68
msgid "pad byte"
msgstr ""

#: ../../../library/struct.rst:68
msgid "no value"
msgstr ""

#: ../../../library/struct.rst:70
msgid "``c``"
msgstr ""

#: ../../../library/struct.rst:70
msgid ":ctype:`char`"
msgstr ""

#: ../../../library/struct.rst:70
msgid "bytes of length 1"
msgstr ""

#: ../../../library/struct.rst:72
msgid "``b``"
msgstr ""

#: ../../../library/struct.rst:72
msgid ":ctype:`signed char`"
msgstr ""

#: ../../../library/struct.rst:72 ../../../library/struct.rst:74
#: ../../../library/struct.rst:78 ../../../library/struct.rst:80
#: ../../../library/struct.rst:82 ../../../library/struct.rst:84
#: ../../../library/struct.rst:86 ../../../library/struct.rst:88
#: ../../../library/struct.rst:90 ../../../library/struct.rst:92
#: ../../../library/struct.rst:103
msgid "integer"
msgstr ""

#: ../../../library/struct.rst:72 ../../../library/struct.rst:99
#: ../../../library/struct.rst:101
msgid "\\(1)"
msgstr ""

#: ../../../library/struct.rst:74
msgid "``B``"
msgstr ""

#: ../../../library/struct.rst:74
msgid ":ctype:`unsigned char`"
msgstr ""

#: ../../../library/struct.rst:76
msgid "``?``"
msgstr ""

#: ../../../library/struct.rst:76
msgid ":ctype:`_Bool`"
msgstr ""

#: ../../../library/struct.rst:76
msgid "bool"
msgstr ""

#: ../../../library/struct.rst:76
msgid "\\(2)"
msgstr ""

#: ../../../library/struct.rst:78
msgid "``h``"
msgstr ""

#: ../../../library/struct.rst:78
msgid ":ctype:`short`"
msgstr ""

#: ../../../library/struct.rst:80
msgid "``H``"
msgstr ""

#: ../../../library/struct.rst:80
msgid ":ctype:`unsigned short`"
msgstr ""

#: ../../../library/struct.rst:82
msgid "``i``"
msgstr ""

#: ../../../library/struct.rst:82
msgid ":ctype:`int`"
msgstr ""

#: ../../../library/struct.rst:84
msgid "``I``"
msgstr ""

#: ../../../library/struct.rst:84
msgid ":ctype:`unsigned int`"
msgstr ""

#: ../../../library/struct.rst:86
msgid "``l``"
msgstr ""

#: ../../../library/struct.rst:86
msgid ":ctype:`long`"
msgstr ""

#: ../../../library/struct.rst:88
msgid "``L``"
msgstr ""

#: ../../../library/struct.rst:88
msgid ":ctype:`unsigned long`"
msgstr ""

#: ../../../library/struct.rst:90
msgid "``q``"
msgstr ""

#: ../../../library/struct.rst:90
msgid ":ctype:`long long`"
msgstr ""

#: ../../../library/struct.rst:90 ../../../library/struct.rst:92
msgid "\\(3)"
msgstr ""

#: ../../../library/struct.rst:92
msgid "``Q``"
msgstr ""

#: ../../../library/struct.rst:92
msgid ":ctype:`unsigned long long`"
msgstr ""

#: ../../../library/struct.rst:95
msgid "``f``"
msgstr ""

#: ../../../library/struct.rst:95
msgid ":ctype:`float`"
msgstr ""

#: ../../../library/struct.rst:95 ../../../library/struct.rst:97
msgid "float"
msgstr ""

#: ../../../library/struct.rst:97
msgid "``d``"
msgstr ""

#: ../../../library/struct.rst:97
msgid ":ctype:`double`"
msgstr ""

#: ../../../library/struct.rst:99
msgid "``s``"
msgstr ""

#: ../../../library/struct.rst:99 ../../../library/struct.rst:101
msgid ":ctype:`char[]`"
msgstr ""

#: ../../../library/struct.rst:99 ../../../library/struct.rst:101
msgid "bytes"
msgstr ""

#: ../../../library/struct.rst:101
msgid "``p``"
msgstr ""

#: ../../../library/struct.rst:103
msgid "``P``"
msgstr ""

#: ../../../library/struct.rst:103
msgid ":ctype:`void \\*`"
msgstr ""

#: ../../../library/struct.rst:106
msgid "Notes:"
msgstr ""

#: ../../../library/struct.rst:109
msgid ""
"The ``c``, ``s`` and ``p`` conversion codes operate on :class:`bytes` "
"objects, but packing with such codes also supports :class:`str` objects, "
"which are encoded using UTF-8."
msgstr ""

#: ../../../library/struct.rst:114
msgid ""
"The ``'?'`` conversion code corresponds to the :ctype:`_Bool` type defined "
"by C99. If this type is not available, it is simulated using a :ctype:"
"`char`. In standard mode, it is always represented by one byte."
msgstr ""

#: ../../../library/struct.rst:119
msgid ""
"The ``'q'`` and ``'Q'`` conversion codes are available in native mode only "
"if the platform C compiler supports C :ctype:`long long`, or, on Windows, :"
"ctype:`__int64`.  They are always available in standard modes."
msgstr ""

#: ../../../library/struct.rst:123
msgid ""
"A format character may be preceded by an integral repeat count.  For "
"example, the format string ``'4h'`` means exactly the same as ``'hhhh'``."
msgstr ""

#: ../../../library/struct.rst:126
msgid ""
"Whitespace characters between formats are ignored; a count and its format "
"must not contain whitespace though."
msgstr ""

#: ../../../library/struct.rst:129
msgid ""
"For the ``'s'`` format character, the count is interpreted as the length of "
"the bytes, not a repeat count like for the other format characters; for "
"example, ``'10s'`` means a single 10-byte string, while ``'10c'`` means 10 "
"characters. For packing, the string is truncated or padded with null bytes "
"as appropriate to make it fit. For unpacking, the resulting bytes object "
"always has exactly the specified number of bytes.  As a special case, "
"``'0s'`` means a single, empty string (while ``'0c'`` means 0 characters)."
msgstr ""

#: ../../../library/struct.rst:137
msgid ""
"The ``'p'`` format character encodes a \"Pascal string\", meaning a short "
"variable-length string stored in a fixed number of bytes. The count is the "
"total number of bytes stored.  The first byte stored is the length of the "
"string, or 255, whichever is smaller.  The bytes of the string follow.  If "
"the string passed in to :func:`pack` is too long (longer than the count "
"minus 1), only the leading count-1 bytes of the string are stored.  If the "
"string is shorter than count-1, it is padded with null bytes so that exactly "
"count bytes in all are used.  Note that for :func:`unpack`, the ``'p'`` "
"format character consumes count bytes, but that the string returned can "
"never contain more than 255 bytes."
msgstr ""

#: ../../../library/struct.rst:149
msgid ""
"For the ``'?'`` format character, the return value is either :const:`True` "
"or :const:`False`. When packing, the truth value of the argument object is "
"used. Either 0 or 1 in the native or standard bool representation will be "
"packed, and any non-zero value will be True when unpacking."
msgstr ""

#: ../../../library/struct.rst:154
msgid ""
"By default, C numbers are represented in the machine's native format and "
"byte order, and properly aligned by skipping pad bytes if necessary "
"(according to the rules used by the C compiler)."
msgstr ""

#: ../../../library/struct.rst:158
msgid ""
"Alternatively, the first character of the format string can be used to "
"indicate the byte order, size and alignment of the packed data, according to "
"the following table:"
msgstr ""

#: ../../../library/struct.rst:163
msgid "Character"
msgstr ""

#: ../../../library/struct.rst:163
msgid "Byte order"
msgstr ""

#: ../../../library/struct.rst:163
msgid "Size and alignment"
msgstr ""

#: ../../../library/struct.rst:165
msgid "``@``"
msgstr ""

#: ../../../library/struct.rst:165 ../../../library/struct.rst:167
msgid "native"
msgstr ""

#: ../../../library/struct.rst:167
msgid "``=``"
msgstr ""

#: ../../../library/struct.rst:167 ../../../library/struct.rst:169
#: ../../../library/struct.rst:171 ../../../library/struct.rst:173
msgid "standard"
msgstr ""

#: ../../../library/struct.rst:169
msgid "``<``"
msgstr ""

#: ../../../library/struct.rst:169
msgid "little-endian"
msgstr ""

#: ../../../library/struct.rst:171
msgid "``>``"
msgstr ""

#: ../../../library/struct.rst:171
msgid "big-endian"
msgstr ""

#: ../../../library/struct.rst:173
msgid "``!``"
msgstr ""

#: ../../../library/struct.rst:173
msgid "network (= big-endian)"
msgstr ""

#: ../../../library/struct.rst:176
msgid "If the first character is not one of these, ``'@'`` is assumed."
msgstr ""

#: ../../../library/struct.rst:178
msgid ""
"Native byte order is big-endian or little-endian, depending on the host "
"system. For example, Motorola and Sun processors are big-endian; Intel and "
"DEC processors are little-endian."
msgstr ""

#: ../../../library/struct.rst:182
msgid ""
"Native size and alignment are determined using the C compiler's ``sizeof`` "
"expression.  This is always combined with native byte order."
msgstr ""

#: ../../../library/struct.rst:185
msgid ""
"Standard size and alignment are as follows: no alignment is required for any "
"type (so you have to use pad bytes); :ctype:`short` is 2 bytes; :ctype:`int` "
"and :ctype:`long` are 4 bytes; :ctype:`long long` (:ctype:`__int64` on "
"Windows) is 8 bytes; :ctype:`float` and :ctype:`double` are 32-bit and 64-"
"bit IEEE floating point numbers, respectively. :ctype:`_Bool` is 1 byte."
msgstr ""

#: ../../../library/struct.rst:191
msgid ""
"Note the difference between ``'@'`` and ``'='``: both use native byte order, "
"but the size and alignment of the latter is standardized."
msgstr ""

#: ../../../library/struct.rst:194
msgid ""
"The form ``'!'`` is available for those poor souls who claim they can't "
"remember whether network byte order is big-endian or little-endian."
msgstr ""

#: ../../../library/struct.rst:197
msgid ""
"There is no way to indicate non-native byte order (force byte-swapping); use "
"the appropriate choice of ``'<'`` or ``'>'``."
msgstr ""

#: ../../../library/struct.rst:200
msgid ""
"The ``'P'`` format character is only available for the native byte ordering "
"(selected as the default or with the ``'@'`` byte order character). The byte "
"order character ``'='`` chooses to use little- or big-endian ordering based "
"on the host system. The struct module does not interpret this as native "
"ordering, so the ``'P'`` format is not available."
msgstr ""

#: ../../../library/struct.rst:206
msgid ""
"Examples (all using native byte order, size and alignment, on a big-endian "
"machine)::"
msgstr ""

#: ../../../library/struct.rst:209
msgid ""
">>> from struct import *\n"
">>> pack('hhl', 1, 2, 3)\n"
"b'\\x00\\x01\\x00\\x02\\x00\\x00\\x00\\x03'\n"
">>> unpack('hhl', b'\\x00\\x01\\x00\\x02\\x00\\x00\\x00\\x03')\n"
"(1, 2, 3)\n"
">>> calcsize('hhl')\n"
"8"
msgstr ""

#: ../../../library/struct.rst:217
msgid ""
"Hint: to align the end of a structure to the alignment requirement of a "
"particular type, end the format with the code for that type with a repeat "
"count of zero.  For example, the format ``'llh0l'`` specifies two pad bytes "
"at the end, assuming longs are aligned on 4-byte boundaries.  This only "
"works when native size and alignment are in effect; standard size and "
"alignment does not enforce any alignment."
msgstr ""

#: ../../../library/struct.rst:224
msgid ""
"Unpacked fields can be named by assigning them to variables or by wrapping "
"the result in a named tuple::"
msgstr ""

#: ../../../library/struct.rst:227
msgid ""
">>> record = b'raymond   \\x32\\x12\\x08\\x01\\x08'\n"
">>> name, serialnum, school, gradelevel = unpack('<10sHHb', record)\n"
"\n"
">>> from collections import namedtuple\n"
">>> Student = namedtuple('Student', 'name serialnum school gradelevel')\n"
">>> Student._make(unpack('<10sHHb', record))\n"
"Student(name=b'raymond   ', serialnum=4658, school=264, gradelevel=8)"
msgstr ""

#: ../../../library/struct.rst:238
msgid "Module :mod:`array`"
msgstr ""

#: ../../../library/struct.rst:238
msgid "Packed binary storage of homogeneous data."
msgstr ""

#: ../../../library/struct.rst:240
msgid "Module :mod:`xdrlib`"
msgstr ""

#: ../../../library/struct.rst:241
msgid "Packing and unpacking of XDR data."
msgstr ""

#: ../../../library/struct.rst:247
msgid "Struct Objects"
msgstr ""

#: ../../../library/struct.rst:249
msgid "The :mod:`struct` module also defines the following type:"
msgstr ""

#: ../../../library/struct.rst:254
msgid ""
"Return a new Struct object which writes and reads binary data according to "
"the format string *format*.  Creating a Struct object once and calling its "
"methods is more efficient than calling the :mod:`struct` functions with the "
"same format since the format string only needs to be compiled once."
msgstr ""

#: ../../../library/struct.rst:260
msgid "Compiled Struct objects support the following methods and attributes:"
msgstr ""

#: ../../../library/struct.rst:264
msgid ""
"Identical to the :func:`pack` function, using the compiled format. "
"(``len(result)`` will equal :attr:`self.size`.)"
msgstr ""

#: ../../../library/struct.rst:270
msgid "Identical to the :func:`pack_into` function, using the compiled format."
msgstr ""

#: ../../../library/struct.rst:275
msgid ""
"Identical to the :func:`unpack` function, using the compiled format. "
"(``len(bytes)`` must equal :attr:`self.size`)."
msgstr ""

#: ../../../library/struct.rst:281
msgid ""
"Identical to the :func:`unpack_from` function, using the compiled format. "
"(``len(buffer[offset:])`` must be at least :attr:`self.size`)."
msgstr ""

#: ../../../library/struct.rst:287
msgid "The format string used to construct this Struct object."
msgstr ""

#: ../../../library/struct.rst:291
msgid ""
"The calculated size of the struct (and hence of the bytes) corresponding to :"
"attr:`format`."
msgstr ""

#: ../../../library/struct.rst:8
msgid "C"
msgstr ""

#: ../../../library/struct.rst:8
msgid "structures"
msgstr ""

#: ../../../library/struct.rst:8
msgid "packing"
msgstr ""

#: ../../../library/struct.rst:8
msgid "binary"
msgstr ""

#: ../../../library/struct.rst:8
msgid "data"
msgstr ""

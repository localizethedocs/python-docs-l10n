# SOME DESCRIPTIVE TITLE.
# Copyright (C) 1990-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-10 15:11+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../library/collections.rst:3
msgid ":mod:`collections` --- Container datatypes"
msgstr ""

#: ../../../library/collections.rst:16
msgid ""
"This module implements high-performance container datatypes.  Currently, "
"there are two datatypes, :class:`deque` and :class:`defaultdict`, and one "
"datatype factory function, :func:`namedtuple`. This module also provides "
"the :class:`UserDict` and :class:`UserList` classes which may be useful when "
"inheriting directly from :class:`dict` or :class:`list` isn't convenient."
msgstr ""

#: ../../../library/collections.rst:23
msgid ""
"The specialized containers provided in this module provide alternatives to "
"Python's general purpose built-in containers, :class:`dict`, :class:`list`, :"
"class:`set`, and :class:`tuple`."
msgstr ""

#: ../../../library/collections.rst:27
msgid ""
"In addition to containers, the collections module provides some ABCs "
"(abstract base classes) that can be used to test whether a class provides a "
"particular interface, for example, is it hashable or a mapping, and some of "
"them can also be used as mixin classes."
msgstr ""

#: ../../../library/collections.rst:33
msgid "ABCs - abstract base classes"
msgstr ""

#: ../../../library/collections.rst:35
msgid "The collections module offers the following ABCs:"
msgstr ""

#: ../../../library/collections.rst:38
msgid "ABC"
msgstr ""

#: ../../../library/collections.rst:38
msgid "Inherits"
msgstr ""

#: ../../../library/collections.rst:38
msgid "Abstract Methods"
msgstr ""

#: ../../../library/collections.rst:38
msgid "Mixin Methods"
msgstr ""

#: ../../../library/collections.rst:40
msgid ":class:`Container`"
msgstr ""

#: ../../../library/collections.rst:40
msgid "``__contains__``"
msgstr ""

#: ../../../library/collections.rst:41
msgid ":class:`Hashable`"
msgstr ""

#: ../../../library/collections.rst:41
msgid "``__hash__``"
msgstr ""

#: ../../../library/collections.rst:42 ../../../library/collections.rst:43
msgid ":class:`Iterable`"
msgstr ""

#: ../../../library/collections.rst:42 ../../../library/collections.rst:43
msgid "``__iter__``"
msgstr ""

#: ../../../library/collections.rst:43
msgid ":class:`Iterator`"
msgstr ""

#: ../../../library/collections.rst:43
msgid "``__next__``"
msgstr ""

#: ../../../library/collections.rst:44 ../../../library/collections.rst:72
msgid ":class:`Sized`"
msgstr ""

#: ../../../library/collections.rst:44 ../../../library/collections.rst:72
msgid "``__len__``"
msgstr ""

#: ../../../library/collections.rst:45
msgid ":class:`Callable`"
msgstr ""

#: ../../../library/collections.rst:45
msgid "``__call__``"
msgstr ""

#: ../../../library/collections.rst:47 ../../../library/collections.rst:51
msgid ":class:`Sequence`"
msgstr ""

#: ../../../library/collections.rst:47 ../../../library/collections.rst:55
#: ../../../library/collections.rst:63
msgid ":class:`Sized`, :class:`Iterable`, :class:`Container`"
msgstr ""

#: ../../../library/collections.rst:47 ../../../library/collections.rst:63
msgid "``__getitem__``"
msgstr ""

#: ../../../library/collections.rst:47
msgid ""
"``__contains__``. ``__iter__``, ``__reversed__``. ``index``, and ``count``"
msgstr ""

#: ../../../library/collections.rst:51
msgid ":class:`MutableSequence`"
msgstr ""

#: ../../../library/collections.rst:51
msgid "``__setitem__`` ``__delitem__``, and ``insert``"
msgstr ""

#: ../../../library/collections.rst:51
msgid ""
"Inherited Sequence methods and ``append``, ``reverse``, ``extend``, ``pop``, "
"``remove``, and ``__iadd__``"
msgstr ""

#: ../../../library/collections.rst:55 ../../../library/collections.rst:59
msgid ":class:`Set`"
msgstr ""

#: ../../../library/collections.rst:55
msgid ""
"``__le__``, ``__lt__``, ``__eq__``, ``__ne__``, ``__gt__``, ``__ge__``, "
"``__and__``, ``__or__`` ``__sub__``, ``__xor__``, and ``isdisjoint``"
msgstr ""

#: ../../../library/collections.rst:59
msgid ":class:`MutableSet`"
msgstr ""

#: ../../../library/collections.rst:59
msgid "``add`` and ``discard``"
msgstr ""

#: ../../../library/collections.rst:59
msgid ""
"Inherited Set methods and ``clear``, ``pop``, ``remove``, ``__ior__``, "
"``__iand__``, ``__ixor__``, and ``__isub__``"
msgstr ""

#: ../../../library/collections.rst:63 ../../../library/collections.rst:67
msgid ":class:`Mapping`"
msgstr ""

#: ../../../library/collections.rst:63
msgid ""
"``__contains__``, ``keys``, ``items``, ``values``, ``get``, ``__eq__``, and "
"``__ne__``"
msgstr ""

#: ../../../library/collections.rst:67
msgid ":class:`MutableMapping`"
msgstr ""

#: ../../../library/collections.rst:67
msgid "``__setitem__`` and ``__delitem__``"
msgstr ""

#: ../../../library/collections.rst:67
msgid ""
"Inherited Mapping methods and ``pop``, ``popitem``, ``clear``, ``update``, "
"and ``setdefault``"
msgstr ""

#: ../../../library/collections.rst:72 ../../../library/collections.rst:77
msgid ":class:`MappingView`"
msgstr ""

#: ../../../library/collections.rst:73
msgid ":class:`KeysView`"
msgstr ""

#: ../../../library/collections.rst:73 ../../../library/collections.rst:75
msgid ":class:`MappingView`, :class:`Set`"
msgstr ""

#: ../../../library/collections.rst:73 ../../../library/collections.rst:75
#: ../../../library/collections.rst:77
msgid "``__contains__``, ``__iter__``"
msgstr ""

#: ../../../library/collections.rst:75
msgid ":class:`ItemsView`"
msgstr ""

#: ../../../library/collections.rst:77
msgid ":class:`ValuesView`"
msgstr ""

#: ../../../library/collections.rst:80
msgid ""
"These ABCs allow us to ask classes or instances if they provide particular "
"functionality, for example::"
msgstr ""

#: ../../../library/collections.rst:83
msgid ""
"size = None\n"
"if isinstance(myvar, collections.Sized):\n"
"    size = len(myvar)"
msgstr ""

#: ../../../library/collections.rst:87
msgid ""
"Several of the ABCs are also useful as mixins that make it easier to develop "
"classes supporting container APIs.  For example, to write a class supporting "
"the full :class:`Set` API, it only necessary to supply the three underlying "
"abstract methods: :meth:`__contains__`, :meth:`__iter__`, and :meth:"
"`__len__`. The ABC supplies the remaining methods such as :meth:`__and__` "
"and :meth:`isdisjoint` ::"
msgstr ""

#: ../../../library/collections.rst:94
msgid ""
"class ListBasedSet(collections.Set):\n"
"     ''' Alternate set implementation favoring space over speed\n"
"         and not requiring the set elements to be hashable. '''\n"
"     def __init__(self, iterable):\n"
"         self.elements = lst = []\n"
"         for value in iterable:\n"
"             if value not in lst:\n"
"                 lst.append(value)\n"
"     def __iter__(self):\n"
"         return iter(self.elements)\n"
"     def __contains__(self, value):\n"
"         return value in self.elements\n"
"     def __len__(self):\n"
"         return len(self.elements)\n"
"\n"
"s1 = ListBasedSet('abcdef')\n"
"s2 = ListBasedSet('defghi')\n"
"overlap = s1 & s2            # The __and__() method is supported "
"automatically"
msgstr ""

#: ../../../library/collections.rst:113
msgid "Notes on using :class:`Set` and :class:`MutableSet` as a mixin:"
msgstr ""

#: ../../../library/collections.rst:116
msgid ""
"Since some set operations create new sets, the default mixin methods need a "
"way to create new instances from an iterable. The class constructor is "
"assumed to have a signature in the form ``ClassName(iterable)``. That "
"assumption is factored-out to an internal classmethod called :meth:"
"`_from_iterable` which calls ``cls(iterable)`` to produce a new set. If the :"
"class:`Set` mixin is being used in a class with a different constructor "
"signature, you will need to override :meth:`from_iterable` with a "
"classmethod that can construct new instances from an iterable argument."
msgstr ""

#: ../../../library/collections.rst:127
msgid ""
"To override the comparisons (presumably for speed, as the semantics are "
"fixed), redefine :meth:`__le__` and then the other operations will "
"automatically follow suit."
msgstr ""

#: ../../../library/collections.rst:132
msgid ""
"The :class:`Set` mixin provides a :meth:`_hash` method to compute a hash "
"value for the set; however, :meth:`__hash__` is not defined because not all "
"sets are hashable or immutable.  To add set hashabilty using mixins, inherit "
"from both :meth:`Set` and :meth:`Hashable`, then define ``__hash__ = Set."
"_hash``."
msgstr ""

#: ../../../library/collections.rst:138
msgid "(For more about ABCs, see the :mod:`abc` module and :pep:`3119`.)"
msgstr ""

#: ../../../library/collections.rst:144
msgid ":class:`deque` objects"
msgstr ""

#: ../../../library/collections.rst:149
msgid ""
"Returns a new deque object initialized left-to-right (using :meth:`append`) "
"with data from *iterable*.  If *iterable* is not specified, the new deque is "
"empty."
msgstr ""

#: ../../../library/collections.rst:152
msgid ""
"Deques are a generalization of stacks and queues (the name is pronounced "
"\"deck\" and is short for \"double-ended queue\").  Deques support thread-"
"safe, memory efficient appends and pops from either side of the deque with "
"approximately the same O(1) performance in either direction."
msgstr ""

#: ../../../library/collections.rst:157
msgid ""
"Though :class:`list` objects support similar operations, they are optimized "
"for fast fixed-length operations and incur O(n) memory movement costs for "
"``pop(0)`` and ``insert(0, v)`` operations which change both the size and "
"position of the underlying data representation."
msgstr ""

#: ../../../library/collections.rst:163
msgid ""
"If *maxlen* is not specified or is *None*, deques may grow to an arbitrary "
"length.  Otherwise, the deque is bounded to the specified maximum length.  "
"Once a bounded length deque is full, when new items are added, a "
"corresponding number of items are discarded from the opposite end.  Bounded "
"length deques provide functionality similar to the ``tail`` filter in Unix. "
"They are also useful for tracking transactions and other pools of data where "
"only the most recent activity is of interest."
msgstr ""

#: ../../../library/collections.rst:172
msgid "Deque objects support the following methods:"
msgstr ""

#: ../../../library/collections.rst:176
msgid "Add *x* to the right side of the deque."
msgstr ""

#: ../../../library/collections.rst:181
msgid "Add *x* to the left side of the deque."
msgstr ""

#: ../../../library/collections.rst:186
msgid "Remove all elements from the deque leaving it with length 0."
msgstr ""

#: ../../../library/collections.rst:191
msgid ""
"Extend the right side of the deque by appending elements from the iterable "
"argument."
msgstr ""

#: ../../../library/collections.rst:197
msgid ""
"Extend the left side of the deque by appending elements from *iterable*. "
"Note, the series of left appends results in reversing the order of elements "
"in the iterable argument."
msgstr ""

#: ../../../library/collections.rst:204
msgid ""
"Remove and return an element from the right side of the deque. If no "
"elements are present, raises an :exc:`IndexError`."
msgstr ""

#: ../../../library/collections.rst:210
msgid ""
"Remove and return an element from the left side of the deque. If no elements "
"are present, raises an :exc:`IndexError`."
msgstr ""

#: ../../../library/collections.rst:216
msgid ""
"Removed the first occurrence of *value*.  If not found, raises a :exc:"
"`ValueError`."
msgstr ""

#: ../../../library/collections.rst:222
msgid ""
"Rotate the deque *n* steps to the right.  If *n* is negative, rotate to the "
"left.  Rotating one step to the right is equivalent to: ``d.appendleft(d."
"pop())``."
msgstr ""

#: ../../../library/collections.rst:227
msgid ""
"In addition to the above, deques support iteration, pickling, ``len(d)``, "
"``reversed(d)``, ``copy.copy(d)``, ``copy.deepcopy(d)``, membership testing "
"with the :keyword:`in` operator, and subscript references such as "
"``d[-1]``.  Indexed access is O(1) at both ends but slows to O(n) in the "
"middle.  For fast random access, use lists instead."
msgstr ""

#: ../../../library/collections.rst:233 ../../../library/collections.rst:490
msgid "Example:"
msgstr ""

#: ../../../library/collections.rst:235
msgid ""
">>> from collections import deque\n"
">>> d = deque('ghi')                 # make a new deque with three items\n"
">>> for elem in d:                   # iterate over the deque's elements\n"
"...     print(elem.upper())\n"
"G\n"
"H\n"
"I\n"
"\n"
">>> d.append('j')                    # add a new entry to the right side\n"
">>> d.appendleft('f')                # add a new entry to the left side\n"
">>> d                                # show the representation of the deque\n"
"deque(['f', 'g', 'h', 'i', 'j'])\n"
"\n"
">>> d.pop()                          # return and remove the rightmost item\n"
"'j'\n"
">>> d.popleft()                      # return and remove the leftmost item\n"
"'f'\n"
">>> list(d)                          # list the contents of the deque\n"
"['g', 'h', 'i']\n"
">>> d[0]                             # peek at leftmost item\n"
"'g'\n"
">>> d[-1]                            # peek at rightmost item\n"
"'i'\n"
"\n"
">>> list(reversed(d))                # list the contents of a deque in "
"reverse\n"
"['i', 'h', 'g']\n"
">>> 'h' in d                         # search the deque\n"
"True\n"
">>> d.extend('jkl')                  # add multiple elements at once\n"
">>> d\n"
"deque(['g', 'h', 'i', 'j', 'k', 'l'])\n"
">>> d.rotate(1)                      # right rotation\n"
">>> d\n"
"deque(['l', 'g', 'h', 'i', 'j', 'k'])\n"
">>> d.rotate(-1)                     # left rotation\n"
">>> d\n"
"deque(['g', 'h', 'i', 'j', 'k', 'l'])\n"
"\n"
">>> deque(reversed(d))               # make a new deque in reverse order\n"
"deque(['l', 'k', 'j', 'i', 'h', 'g'])\n"
">>> d.clear()                        # empty the deque\n"
">>> d.pop()                          # cannot pop from an empty deque\n"
"Traceback (most recent call last):\n"
"  File \"<pyshell#6>\", line 1, in -toplevel-\n"
"    d.pop()\n"
"IndexError: pop from an empty deque\n"
"\n"
">>> d.extendleft('abc')              # extendleft() reverses the input "
"order\n"
">>> d\n"
"deque(['c', 'b', 'a'])"
msgstr ""

#: ../../../library/collections.rst:292
msgid ":class:`deque` Recipes"
msgstr ""

#: ../../../library/collections.rst:294
msgid "This section shows various approaches to working with deques."
msgstr ""

#: ../../../library/collections.rst:296
msgid ""
"The :meth:`rotate` method provides a way to implement :class:`deque` slicing "
"and deletion.  For example, a pure python implementation of ``del d[n]`` "
"relies on the :meth:`rotate` method to position elements to be popped::"
msgstr ""

#: ../../../library/collections.rst:300
msgid ""
"def delete_nth(d, n):\n"
"    d.rotate(-n)\n"
"    d.popleft()\n"
"    d.rotate(n)"
msgstr ""

#: ../../../library/collections.rst:305
msgid ""
"To implement :class:`deque` slicing, use a similar approach applying :meth:"
"`rotate` to bring a target element to the left side of the deque. Remove old "
"entries with :meth:`popleft`, add new entries with :meth:`extend`, and then "
"reverse the rotation. With minor variations on that approach, it is easy to "
"implement Forth style stack manipulations such as ``dup``, ``drop``, "
"``swap``, ``over``, ``pick``, ``rot``, and ``roll``."
msgstr ""

#: ../../../library/collections.rst:313
msgid ""
"Multi-pass data reduction algorithms can be succinctly expressed and "
"efficiently coded by extracting elements with multiple calls to :meth:"
"`popleft`, applying a reduction function, and calling :meth:`append` to add "
"the result back to the deque."
msgstr ""

#: ../../../library/collections.rst:318
msgid ""
"For example, building a balanced binary tree of nested lists entails "
"reducing two adjacent nodes into one by grouping them in a list:"
msgstr ""

#: ../../../library/collections.rst:331
msgid ""
"Bounded length deques provide functionality similar to the ``tail`` filter "
"in Unix::"
msgstr ""

#: ../../../library/collections.rst:334
msgid ""
"def tail(filename, n=10):\n"
"    'Return the last n lines of a file'\n"
"    return deque(open(filename), n)"
msgstr ""

#: ../../../library/collections.rst:341
msgid ":class:`defaultdict` objects"
msgstr ""

#: ../../../library/collections.rst:346
msgid ""
"Returns a new dictionary-like object.  :class:`defaultdict` is a subclass of "
"the builtin :class:`dict` class.  It overrides one method and adds one "
"writable instance variable.  The remaining functionality is the same as for "
"the :class:`dict` class and is not documented here."
msgstr ""

#: ../../../library/collections.rst:351
msgid ""
"The first argument provides the initial value for the :attr:"
"`default_factory` attribute; it defaults to ``None``. All remaining "
"arguments are treated the same as if they were passed to the :class:`dict` "
"constructor, including keyword arguments."
msgstr ""

#: ../../../library/collections.rst:357
msgid ""
":class:`defaultdict` objects support the following method in addition to the "
"standard :class:`dict` operations:"
msgstr ""

#: ../../../library/collections.rst:362
msgid ""
"If the :attr:`default_factory` attribute is ``None``, this raises a :exc:"
"`KeyError` exception with the *key* as argument."
msgstr ""

#: ../../../library/collections.rst:365
msgid ""
"If :attr:`default_factory` is not ``None``, it is called without arguments "
"to provide a default value for the given *key*, this value is inserted in "
"the dictionary for the *key*, and returned."
msgstr ""

#: ../../../library/collections.rst:369
msgid ""
"If calling :attr:`default_factory` raises an exception this exception is "
"propagated unchanged."
msgstr ""

#: ../../../library/collections.rst:372
msgid ""
"This method is called by the :meth:`__getitem__` method of the :class:`dict` "
"class when the requested key is not found; whatever it returns or raises is "
"then returned or raised by :meth:`__getitem__`."
msgstr ""

#: ../../../library/collections.rst:377
msgid ":class:`defaultdict` objects support the following instance variable:"
msgstr ""

#: ../../../library/collections.rst:382
msgid ""
"This attribute is used by the :meth:`__missing__` method; it is initialized "
"from the first argument to the constructor, if present, or to ``None``, if "
"absent."
msgstr ""

#: ../../../library/collections.rst:390
msgid ":class:`defaultdict` Examples"
msgstr ""

#: ../../../library/collections.rst:392
msgid ""
"Using :class:`list` as the :attr:`default_factory`, it is easy to group a "
"sequence of key-value pairs into a dictionary of lists:"
msgstr ""

#: ../../../library/collections.rst:403
msgid ""
"When each key is encountered for the first time, it is not already in the "
"mapping; so an entry is automatically created using the :attr:"
"`default_factory` function which returns an empty :class:`list`.  The :meth:"
"`list.append` operation then attaches the value to the new list.  When keys "
"are encountered again, the look-up proceeds normally (returning the list for "
"that key) and the :meth:`list.append` operation adds another value to the "
"list. This technique is simpler and faster than an equivalent technique "
"using :meth:`dict.setdefault`:"
msgstr ""

#: ../../../library/collections.rst:418
msgid ""
"Setting the :attr:`default_factory` to :class:`int` makes the :class:"
"`defaultdict` useful for counting (like a bag or multiset in other "
"languages):"
msgstr ""

#: ../../../library/collections.rst:430
msgid ""
"When a letter is first encountered, it is missing from the mapping, so the :"
"attr:`default_factory` function calls :func:`int` to supply a default count "
"of zero.  The increment operation then builds up the count for each letter."
msgstr ""

#: ../../../library/collections.rst:434
msgid ""
"The function :func:`int` which always returns zero is just a special case of "
"constant functions.  A faster and more flexible way to create constant "
"functions is to use a lambda function which can supply any constant value "
"(not just zero):"
msgstr ""

#: ../../../library/collections.rst:446
msgid ""
"Setting the :attr:`default_factory` to :class:`set` makes the :class:"
"`defaultdict` useful for building a dictionary of sets:"
msgstr ""

#: ../../../library/collections.rst:461
msgid ":func:`namedtuple` Factory Function for Tuples with Named Fields"
msgstr ""

#: ../../../library/collections.rst:463
msgid ""
"Named tuples assign meaning to each position in a tuple and allow for more "
"readable, self-documenting code.  They can be used wherever regular tuples "
"are used, and they add the ability to access fields by name instead of "
"position index."
msgstr ""

#: ../../../library/collections.rst:469
msgid ""
"Returns a new tuple subclass named *typename*.  The new subclass is used to "
"create tuple-like objects that have fields accessible by attribute lookup as "
"well as being indexable and iterable.  Instances of the subclass also have a "
"helpful docstring (with typename and field_names) and a helpful :meth:"
"`__repr__` method which lists the tuple contents in a ``name=value`` format."
msgstr ""

#: ../../../library/collections.rst:475
msgid ""
"The *field_names* are a single string with each fieldname separated by "
"whitespace and/or commas, for example ``'x y'`` or ``'x, y'``.  "
"Alternatively, *field_names* can be a sequence of strings such as ``['x', "
"'y']``."
msgstr ""

#: ../../../library/collections.rst:479
msgid ""
"Any valid Python identifier may be used for a fieldname except for names "
"starting with an underscore.  Valid identifiers consist of letters, digits, "
"and underscores but do not start with a digit or underscore and cannot be a :"
"mod:`keyword` such as *class*, *for*, *return*, *global*, *pass*, or *raise*."
msgstr ""

#: ../../../library/collections.rst:485
msgid ""
"If *verbose* is true, the class definition is printed just before being "
"built."
msgstr ""

#: ../../../library/collections.rst:487
msgid ""
"Named tuple instances do not have per-instance dictionaries, so they are "
"lightweight and require no more memory than regular tuples."
msgstr ""

#: ../../../library/collections.rst:492
msgid ""
">>> Point = namedtuple('Point', 'x y', verbose=True)\n"
"class Point(tuple):\n"
"        'Point(x, y)'\n"
"\n"
"        __slots__ = ()\n"
"\n"
"        _fields = ('x', 'y')\n"
"\n"
"        def __new__(cls, x, y):\n"
"            return tuple.__new__(cls, (x, y))\n"
"\n"
"        @classmethod\n"
"        def _make(cls, iterable, new=tuple.__new__, len=len):\n"
"            'Make a new Point object from a sequence or iterable'\n"
"            result = new(cls, iterable)\n"
"            if len(result) != 2:\n"
"                raise TypeError('Expected 2 arguments, got %d' % "
"len(result))\n"
"            return result\n"
"\n"
"        def __repr__(self):\n"
"            return 'Point(x=%r, y=%r)' % self\n"
"\n"
"        def _asdict(t):\n"
"            'Return a new dict which maps field names to their values'\n"
"            return {'x': t[0], 'y': t[1]}\n"
"\n"
"        def _replace(self, **kwds):\n"
"            'Return a new Point object replacing specified fields with new "
"values'\n"
"            result = self._make(map(kwds.pop, ('x', 'y'), self))\n"
"            if kwds:\n"
"                raise ValueError('Got unexpected field names: %r' % kwds."
"keys())\n"
"            return result\n"
"\n"
"        def __getnewargs__(self):\n"
"            return tuple(self)\n"
"\n"
"        x = property(itemgetter(0))\n"
"        y = property(itemgetter(1))\n"
"\n"
">>> p = Point(11, y=22)     # instantiate with positional or keyword "
"arguments\n"
">>> p[0] + p[1]             # indexable like the plain tuple (11, 22)\n"
"33\n"
">>> x, y = p                # unpack like a regular tuple\n"
">>> x, y\n"
"(11, 22)\n"
">>> p.x + p.y               # fields also accessible by name\n"
"33\n"
">>> p                       # readable __repr__ with a name=value style\n"
"Point(x=11, y=22)"
msgstr ""

#: ../../../library/collections.rst:545
msgid ""
"Named tuples are especially useful for assigning field names to result "
"tuples returned by the :mod:`csv` or :mod:`sqlite3` modules::"
msgstr ""

#: ../../../library/collections.rst:548
msgid ""
"EmployeeRecord = namedtuple('EmployeeRecord', 'name, age, title, department, "
"paygrade')\n"
"\n"
"import csv\n"
"for emp in map(EmployeeRecord._make, csv.reader(open(\"employees.csv\", "
"\"rb\"))):\n"
"    print(emp.name, emp.title)\n"
"\n"
"import sqlite3\n"
"conn = sqlite3.connect('/companydata')\n"
"cursor = conn.cursor()\n"
"cursor.execute('SELECT name, age, title, department, paygrade FROM "
"employees')\n"
"for emp in map(EmployeeRecord._make, cursor.fetchall()):\n"
"    print(emp.name, emp.title)"
msgstr ""

#: ../../../library/collections.rst:561
msgid ""
"In addition to the methods inherited from tuples, named tuples support three "
"additional methods and one attribute.  To prevent conflicts with field "
"names, the method and attribute names start with an underscore."
msgstr ""

#: ../../../library/collections.rst:567
msgid ""
"Class method that makes a new instance from an existing sequence or iterable."
msgstr ""

#: ../../../library/collections.rst:569
msgid ""
">>> t = [11, 22]\n"
">>> Point._make(t)\n"
"Point(x=11, y=22)"
msgstr ""

#: ../../../library/collections.rst:577
msgid ""
"Return a new dict which maps field names to their corresponding values::"
msgstr ""

#: ../../../library/collections.rst:579
msgid ""
">>> p._asdict()\n"
"{'x': 11, 'y': 22}"
msgstr ""

#: ../../../library/collections.rst:584
msgid ""
"Return a new instance of the named tuple replacing specified fields with new "
"values:"
msgstr ""

#: ../../../library/collections.rst:589
msgid ""
">>> p = Point(x=11, y=22)\n"
">>> p._replace(x=33)\n"
"Point(x=33, y=22)\n"
"\n"
">>> for partnum, record in inventory.items():\n"
"...     inventory[partnum] = record._replace(price=newprices[partnum], "
"timestamp=time.now())"
msgstr ""

#: ../../../library/collections.rst:598
msgid ""
"Tuple of strings listing the field names.  Useful for introspection and for "
"creating new named tuple types from existing named tuples."
msgstr ""

#: ../../../library/collections.rst:601
msgid ""
">>> p._fields            # view the field names\n"
"('x', 'y')\n"
"\n"
">>> Color = namedtuple('Color', 'red green blue')\n"
">>> Pixel = namedtuple('Pixel', Point._fields + Color._fields)\n"
">>> Pixel(11, 22, 128, 255, 0)\n"
"Pixel(x=11, y=22, red=128, green=255, blue=0)"
msgstr ""

#: ../../../library/collections.rst:611
msgid ""
"To retrieve a field whose name is stored in a string, use the :func:"
"`getattr` function:"
msgstr ""

#: ../../../library/collections.rst:617
msgid ""
"To convert a dictionary to a named tuple, use the double-star-operator (as "
"described in :ref:`tut-unpacking-arguments`):"
msgstr ""

#: ../../../library/collections.rst:624
msgid ""
"Since a named tuple is a regular Python class, it is easy to add or change "
"functionality with a subclass.  Here is how to add a calculated field and a "
"fixed-width print format:"
msgstr ""

#: ../../../library/collections.rst:641
msgid ""
"The subclass shown above sets ``__slots__`` to an empty tuple.  This keeps "
"keep memory requirements low by preventing the creation of instance "
"dictionaries."
msgstr ""

#: ../../../library/collections.rst:645
msgid ""
"Subclassing is not useful for adding new, stored fields.  Instead, simply "
"create a new named tuple type from the :attr:`_fields` attribute:"
msgstr ""

#: ../../../library/collections.rst:650
msgid ""
"Default values can be implemented by using :meth:`_replace` to customize a "
"prototype instance:"
msgstr ""

#: ../../../library/collections.rst:657
msgid ""
"Enumerated constants can be implemented with named tuples, but it is simpler "
"and more efficient to use a simple class declaration:"
msgstr ""

#: ../../../library/collections.rst:668
msgid ""
"`Named tuple recipe <http://code.activestate.com/recipes/500261/>`_ adapted "
"for Python 2.4."
msgstr ""

#: ../../../library/collections.rst:674
msgid ":class:`UserDict` objects"
msgstr ""

#: ../../../library/collections.rst:676
msgid ""
"The class, :class:`UserDict` acts as a wrapper around dictionary objects. "
"The need for this class has been partially supplanted by the ability to "
"subclass directly from :class:`dict`; however, this class can be easier to "
"work with because the underlying dictionary is accessible as an attribute."
msgstr ""

#: ../../../library/collections.rst:684
msgid ""
"Class that simulates a dictionary.  The instance's contents are kept in a "
"regular dictionary, which is accessible via the :attr:`data` attribute of :"
"class:`UserDict` instances.  If *initialdata* is provided, :attr:`data` is "
"initialized with its contents; note that a reference to *initialdata* will "
"not be kept, allowing it be used for other purposes."
msgstr ""

#: ../../../library/collections.rst:690
msgid ""
"In addition to supporting the methods and operations of mappings, :class:"
"`UserDict` instances provide the following attribute:"
msgstr ""

#: ../../../library/collections.rst:695
msgid ""
"A real dictionary used to store the contents of the :class:`UserDict` class."
msgstr ""

#: ../../../library/collections.rst:700
msgid ":class:`UserList` objects"
msgstr ""

#: ../../../library/collections.rst:702
msgid ""
"This class acts as a wrapper around list objects.  It is a useful base class "
"for your own list-like classes which can inherit from them and override "
"existing methods or add new ones.  In this way, one can add new behaviors to "
"lists."
msgstr ""

#: ../../../library/collections.rst:707
msgid ""
"The need for this class has been partially supplanted by the ability to "
"subclass directly from :class:`list`; however, this class can be easier to "
"work with because the underlying list is accessible as an attribute."
msgstr ""

#: ../../../library/collections.rst:713
msgid ""
"Class that simulates a list.  The instance's contents are kept in a regular "
"list, which is accessible via the :attr:`data` attribute of :class:"
"`UserList` instances.  The instance's contents are initially set to a copy "
"of *list*, defaulting to the empty list ``[]``.  *list* can be any iterable, "
"for example a real Python list or a :class:`UserList` object."
msgstr ""

#: ../../../library/collections.rst:719
msgid ""
"In addition to supporting the methods and operations of mutable sequences, :"
"class:`UserList` instances provide the following attribute:"
msgstr ""

#: ../../../library/collections.rst:724
msgid ""
"A real :class:`list` object used to store the contents of the :class:"
"`UserList` class."
msgstr ""

#: ../../../library/collections.rst:727
msgid ""
"**Subclassing requirements:** Subclasses of :class:`UserList` are expect to "
"offer a constructor which can be called with either no arguments or one "
"argument.  List operations which return a new sequence attempt to create an "
"instance of the actual implementation class.  To do so, it assumes that the "
"constructor can be called with a single parameter, which is a sequence "
"object used as a data source."
msgstr ""

#: ../../../library/collections.rst:734
msgid ""
"If a derived class does not wish to comply with this requirement, all of the "
"special methods supported by this class will need to be overridden; please "
"consult the sources for information about the methods which need to be "
"provided in that case."
msgstr ""

#: ../../../library/collections.rst:740
msgid ":class:`UserString` objects"
msgstr ""

#: ../../../library/collections.rst:742
msgid ""
"The class, :class:`UserString` acts as a wrapper around string objects. The "
"need for this class has been partially supplanted by the ability to subclass "
"directly from :class:`str`; however, this class can be easier to work with "
"because the underlying string is accessible as an attribute."
msgstr ""

#: ../../../library/collections.rst:750
msgid ""
"Class that simulates a string or a Unicode string object.  The instance's "
"content is kept in a regular string object, which is accessible via the :"
"attr:`data` attribute of :class:`UserString` instances.  The instance's "
"contents are initially set to a copy of *sequence*.  The *sequence* can be "
"an instance of :class:`bytes`, :class:`str`, :class:`UserString` (or a "
"subclass) or an arbitrary sequence which can be converted into a string "
"using the built-in :func:`str` function."
msgstr ""

# SOME DESCRIPTIVE TITLE.
# Copyright (C) 1990-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-11 04:42+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../reference/expressions.rst:6
msgid "Expressions"
msgstr ""

#: ../../../reference/expressions.rst:10
msgid ""
"This chapter explains the meaning of the elements of expressions in Python."
msgstr ""

#: ../../../reference/expressions.rst:12
msgid ""
"**Syntax Notes:** In this and the following chapters, extended BNF notation "
"will be used to describe syntax, not lexical analysis.  When (one "
"alternative of) a syntax rule has the form"
msgstr ""

#: ../../../reference/expressions.rst:19
msgid ""
"and no semantics are given, the semantics of this form of ``name`` are the "
"same as for ``othername``."
msgstr ""

#: ../../../reference/expressions.rst:26
msgid "Arithmetic conversions"
msgstr ""

#: ../../../reference/expressions.rst:30
msgid ""
"When a description of an arithmetic operator below uses the phrase \"the "
"numeric arguments are converted to a common type,\" this means that the "
"operator implementation for built-in types works that way:"
msgstr ""

#: ../../../reference/expressions.rst:34
msgid ""
"If either argument is a complex number, the other is converted to complex;"
msgstr ""

#: ../../../reference/expressions.rst:36
msgid ""
"otherwise, if either argument is a floating point number, the other is "
"converted to floating point;"
msgstr ""

#: ../../../reference/expressions.rst:39
msgid "otherwise, both must be integers and no conversion is necessary."
msgstr ""

#: ../../../reference/expressions.rst:41
msgid ""
"Some additional rules apply for certain operators (e.g., a string left "
"argument to the '%' operator).  Extensions must define their own conversion "
"behavior."
msgstr ""

#: ../../../reference/expressions.rst:48
msgid "Atoms"
msgstr ""

#: ../../../reference/expressions.rst:52
msgid ""
"Atoms are the most basic elements of expressions.  The simplest atoms are "
"identifiers or literals.  Forms enclosed in parentheses, brackets or braces "
"are also categorized syntactically as atoms.  The syntax for atoms is:"
msgstr ""

#: ../../../reference/expressions.rst:65
msgid "Identifiers (Names)"
msgstr ""

#: ../../../reference/expressions.rst:69
msgid ""
"An identifier occurring as an atom is a name.  See section :ref:"
"`identifiers` for lexical definition and section :ref:`naming` for "
"documentation of naming and binding."
msgstr ""

#: ../../../reference/expressions.rst:75
msgid ""
"When the name is bound to an object, evaluation of the atom yields that "
"object. When a name is not bound, an attempt to evaluate it raises a :exc:"
"`NameError` exception."
msgstr ""

#: ../../../reference/expressions.rst:83
msgid ""
"**Private name mangling:** When an identifier that textually occurs in a "
"class definition begins with two or more underscore characters and does not "
"end in two or more underscores, it is considered a :dfn:`private name` of "
"that class. Private names are transformed to a longer form before code is "
"generated for them.  The transformation inserts the class name in front of "
"the name, with leading underscores removed, and a single underscore inserted "
"in front of the class name.  For example, the identifier ``__spam`` "
"occurring in a class named ``Ham`` will be transformed to ``_Ham__spam``.  "
"This transformation is independent of the syntactical context in which the "
"identifier is used.  If the transformed name is extremely long (longer than "
"255 characters), implementation defined truncation may happen.  If the class "
"name consists only of underscores, no transformation is done."
msgstr ""

#: ../../../reference/expressions.rst:100
msgid "Literals"
msgstr ""

#: ../../../reference/expressions.rst:104
msgid "Python supports string and bytes literals and various numeric literals:"
msgstr ""

#: ../../../reference/expressions.rst:110
msgid ""
"Evaluation of a literal yields an object of the given type (string, bytes, "
"integer, floating point number, complex number) with the given value.  The "
"value may be approximated in the case of floating point and imaginary "
"(complex) literals.  See section :ref:`literals` for details."
msgstr ""

#: ../../../reference/expressions.rst:119
msgid ""
"With the exception of bytes literals, these all correspond to immutable data "
"types, and hence the object's identity is less important than its value. "
"Multiple evaluations of literals with the same value (either the same "
"occurrence in the program text or a different occurrence) may obtain the "
"same object or a different object with the same value."
msgstr ""

#: ../../../reference/expressions.rst:129
msgid "Parenthesized forms"
msgstr ""

#: ../../../reference/expressions.rst:133
msgid ""
"A parenthesized form is an optional expression list enclosed in parentheses:"
msgstr ""

#: ../../../reference/expressions.rst:138
msgid ""
"A parenthesized expression list yields whatever that expression list yields: "
"if the list contains at least one comma, it yields a tuple; otherwise, it "
"yields the single expression that makes up the expression list."
msgstr ""

#: ../../../reference/expressions.rst:144
msgid ""
"An empty pair of parentheses yields an empty tuple object.  Since tuples are "
"immutable, the rules for literals apply (i.e., two occurrences of the empty "
"tuple may or may not yield the same object)."
msgstr ""

#: ../../../reference/expressions.rst:152
msgid ""
"Note that tuples are not formed by the parentheses, but rather by use of the "
"comma operator.  The exception is the empty tuple, for which parentheses "
"*are* required --- allowing unparenthesized \"nothing\" in expressions would "
"cause ambiguities and allow common typos to pass uncaught."
msgstr ""

#: ../../../reference/expressions.rst:161
msgid "Displays for lists, sets and dictionaries"
msgstr ""

#: ../../../reference/expressions.rst:163
msgid ""
"For constructing a list, a set or a dictionary Python provides special "
"syntax called \"displays\", each of them in two flavors:"
msgstr ""

#: ../../../reference/expressions.rst:166
msgid "either the container contents are listed explicitly, or"
msgstr ""

#: ../../../reference/expressions.rst:168
msgid ""
"they are computed via a set of looping and filtering instructions, called a :"
"dfn:`comprehension`."
msgstr ""

#: ../../../reference/expressions.rst:171
msgid "Common syntax elements for comprehensions are:"
msgstr ""

#: ../../../reference/expressions.rst:179
msgid ""
"The comprehension consists of a single expression followed by at least one :"
"keyword:`for` clause and zero or more :keyword:`for` or :keyword:`if` "
"clauses. In this case, the elements of the new container are those that "
"would be produced by considering each of the :keyword:`for` or :keyword:`if` "
"clauses a block, nesting from left to right, and evaluating the expression "
"to produce an element each time the innermost block is reached."
msgstr ""

#: ../../../reference/expressions.rst:186
msgid ""
"Note that the comprehension is executed in a separate scope, so names "
"assigned to in the target list don't \"leak\" in the enclosing scope."
msgstr ""

#: ../../../reference/expressions.rst:193
msgid "List displays"
msgstr ""

#: ../../../reference/expressions.rst:201
msgid ""
"A list display is a possibly empty series of expressions enclosed in square "
"brackets:"
msgstr ""

#: ../../../reference/expressions.rst:207
msgid ""
"A list display yields a new list object, the contents being specified by "
"either a list of expressions or a comprehension.  When a comma-separated "
"list of expressions is supplied, its elements are evaluated from left to "
"right and placed into the list object in that order.  When a comprehension "
"is supplied, the list is constructed from the elements resulting from the "
"comprehension."
msgstr ""

#: ../../../reference/expressions.rst:217
msgid "Set displays"
msgstr ""

#: ../../../reference/expressions.rst:222
msgid ""
"A set display is denoted by curly braces and distinguishable from dictionary "
"displays by the lack of colons separating keys and values:"
msgstr ""

#: ../../../reference/expressions.rst:228
msgid ""
"A set display yields a new mutable set object, the contents being specified "
"by either a sequence of expressions or a comprehension.  When a comma-"
"separated list of expressions is supplied, its elements are evaluated from "
"left to right and added to the set object.  When a comprehension is "
"supplied, the set is constructed from the elements resulting from the "
"comprehension."
msgstr ""

#: ../../../reference/expressions.rst:234
msgid ""
"An empty set cannot be constructed with ``{}``; this literal constructs an "
"empty dictionary."
msgstr ""

#: ../../../reference/expressions.rst:241
msgid "Dictionary displays"
msgstr ""

#: ../../../reference/expressions.rst:247
msgid ""
"A dictionary display is a possibly empty series of key/datum pairs enclosed "
"in curly braces:"
msgstr ""

#: ../../../reference/expressions.rst:256
msgid "A dictionary display yields a new dictionary object."
msgstr ""

#: ../../../reference/expressions.rst:258
msgid ""
"If a comma-separated sequence of key/datum pairs is given, they are "
"evaluated from left to right to define the entries of the dictionary: each "
"key object is used as a key into the dictionary to store the corresponding "
"datum.  This means that you can specify the same key multiple times in the "
"key/datum list, and the final dictionary's value for that key will be the "
"last one given."
msgstr ""

#: ../../../reference/expressions.rst:264
msgid ""
"A dict comprehension, in contrast to list and set comprehensions, needs two "
"expressions separated with a colon followed by the usual \"for\" and \"if\" "
"clauses. When the comprehension is run, the resulting key and value elements "
"are inserted in the new dictionary in the order they are produced."
msgstr ""

#: ../../../reference/expressions.rst:272
msgid ""
"Restrictions on the types of the key values are listed earlier in section :"
"ref:`types`.  (To summarize, the key type should be :term:`hashable`, which "
"excludes all mutable objects.)  Clashes between duplicate keys are not "
"detected; the last datum (textually rightmost in the display) stored for a "
"given key value prevails."
msgstr ""

#: ../../../reference/expressions.rst:282
msgid "Generator expressions"
msgstr ""

#: ../../../reference/expressions.rst:287
msgid "A generator expression is a compact generator notation in parentheses:"
msgstr ""

#: ../../../reference/expressions.rst:292
msgid ""
"A generator expression yields a new generator object.  Its syntax is the "
"same as for comprehensions, except that it is enclosed in parentheses "
"instead of brackets or curly braces."
msgstr ""

#: ../../../reference/expressions.rst:296
msgid ""
"Variables used in the generator expression are evaluated lazily when the :"
"meth:`__next__` method is called for generator object (in the same fashion "
"as normal generators).  However, the leftmost :keyword:`for` clause is "
"immediately evaluated, so that an error produced by it can be seen before "
"any other possible error in the code that handles the generator expression.  "
"Subsequent :keyword:`for` clauses cannot be evaluated immediately since they "
"may depend on the previous :keyword:`for` loop. For example: ``(x*y for x in "
"range(10) for y in bar(x))``."
msgstr ""

#: ../../../reference/expressions.rst:305
msgid ""
"The parentheses can be omitted on calls with only one argument.  See "
"section :ref:`calls` for the detail."
msgstr ""

#: ../../../reference/expressions.rst:312
msgid "Yield expressions"
msgstr ""

#: ../../../reference/expressions.rst:323
msgid ""
"The :keyword:`yield` expression is only used when defining a generator "
"function, and can only be used in the body of a function definition.  Using "
"a :keyword:`yield` expression in a function definition is sufficient to "
"cause that definition to create a generator function instead of a normal "
"function."
msgstr ""

#: ../../../reference/expressions.rst:328
msgid ""
"When a generator function is called, it returns an iterator known as a "
"generator.  That generator then controls the execution of a generator "
"function. The execution starts when one of the generator's methods is "
"called.  At that time, the execution proceeds to the first :keyword:`yield` "
"expression, where it is suspended again, returning the value of :token:"
"`expression_list` to generator's caller.  By suspended we mean that all "
"local state is retained, including the current bindings of local variables, "
"the instruction pointer, and the internal evaluation stack.  When the "
"execution is resumed by calling one of the generator's methods, the function "
"can proceed exactly as if the :keyword:`yield` expression was just another "
"external call.  The value of the :keyword:`yield` expression after resuming "
"depends on the method which resumed the execution."
msgstr ""

#: ../../../reference/expressions.rst:343
msgid ""
"All of this makes generator functions quite similar to coroutines; they "
"yield multiple times, they have more than one entry point and their "
"execution can be suspended.  The only difference is that a generator "
"function cannot control where should the execution continue after it yields; "
"the control is always transfered to the generator's caller."
msgstr ""

#: ../../../reference/expressions.rst:349
msgid ""
"The :keyword:`yield` statement is allowed in the :keyword:`try` clause of a :"
"keyword:`try` ...  :keyword:`finally` construct.  If the generator is not "
"resumed before it is finalized (by reaching a zero reference count or by "
"being garbage collected), the generator-iterator's :meth:`close` method will "
"be called, allowing any pending :keyword:`finally` clauses to execute."
msgstr ""

#: ../../../reference/expressions.rst:357
msgid ""
"The following generator's methods can be used to control the execution of a "
"generator function:"
msgstr ""

#: ../../../reference/expressions.rst:365
msgid ""
"Starts the execution of a generator function or resumes it at the last "
"executed :keyword:`yield` expression.  When a generator function is resumed "
"with a :meth:`__next__` method, the current :keyword:`yield` expression "
"always evaluates to :const:`None`.  The execution then continues to the "
"next :keyword:`yield` expression, where the generator is suspended again, "
"and the value of the :token:`expression_list` is returned to :meth:`next`'s "
"caller. If the generator exits without yielding another value, a :exc:"
"`StopIteration` exception is raised."
msgstr ""

#: ../../../reference/expressions.rst:374
msgid ""
"This method is normally called implicitly, e.g. by a :keyword:`for` loop, or "
"by the built-in :func:`next` function."
msgstr ""

#: ../../../reference/expressions.rst:380
msgid ""
"Resumes the execution and \"sends\" a value into the generator function.  "
"The ``value`` argument becomes the result of the current :keyword:`yield` "
"expression.  The :meth:`send` method returns the next value yielded by the "
"generator, or raises :exc:`StopIteration` if the generator exits without "
"yielding another value.  When :meth:`send` is called to start the generator, "
"it must be called with :const:`None` as the argument, because there is no :"
"keyword:`yield` expression that could receive the value."
msgstr ""

#: ../../../reference/expressions.rst:391
msgid ""
"Raises an exception of type ``type`` at the point where generator was "
"paused, and returns the next value yielded by the generator function.  If "
"the generator exits without yielding another value, a :exc:`StopIteration` "
"exception is raised.  If the generator function does not catch the passed-in "
"exception, or raises a different exception, then that exception propagates "
"to the caller."
msgstr ""

#: ../../../reference/expressions.rst:402
msgid ""
"Raises a :exc:`GeneratorExit` at the point where the generator function was "
"paused.  If the generator function then raises :exc:`StopIteration` (by "
"exiting normally, or due to already being closed) or :exc:`GeneratorExit` "
"(by not catching the exception), close returns to its caller.  If the "
"generator yields a value, a :exc:`RuntimeError` is raised.  If the generator "
"raises any other exception, it is propagated to the caller.  :meth:`close` "
"does nothing if the generator has already exited due to an exception or "
"normal exit."
msgstr ""

#: ../../../reference/expressions.rst:410
msgid ""
"Here is a simple example that demonstrates the behavior of generators and "
"generator functions::"
msgstr ""

#: ../../../reference/expressions.rst:441
msgid ":pep:`0255` - Simple Generators"
msgstr ""

#: ../../../reference/expressions.rst:441
msgid ""
"The proposal for adding generators and the :keyword:`yield` statement to "
"Python."
msgstr ""

#: ../../../reference/expressions.rst:444
msgid ":pep:`0342` - Coroutines via Enhanced Generators"
msgstr ""

#: ../../../reference/expressions.rst:444
msgid ""
"The proposal to enhance the API and syntax of generators, making them usable "
"as simple coroutines."
msgstr ""

#: ../../../reference/expressions.rst:451
msgid "Primaries"
msgstr ""

#: ../../../reference/expressions.rst:455
msgid ""
"Primaries represent the most tightly bound operations of the language. Their "
"syntax is:"
msgstr ""

#: ../../../reference/expressions.rst:465
msgid "Attribute references"
msgstr ""

#: ../../../reference/expressions.rst:469
msgid "An attribute reference is a primary followed by a period and a name:"
msgstr ""

#: ../../../reference/expressions.rst:479
msgid ""
"The primary must evaluate to an object of a type that supports attribute "
"references, which most objects do.  This object is then asked to produce the "
"attribute whose name is the identifier (which can be customized by "
"overriding the :meth:`__getattr__` method).  If this attribute is not "
"available, the exception :exc:`AttributeError` is raised.  Otherwise, the "
"type and value of the object produced is determined by the object.  Multiple "
"evaluations of the same attribute reference may yield different objects."
msgstr ""

#: ../../../reference/expressions.rst:491
msgid "Subscriptions"
msgstr ""

#: ../../../reference/expressions.rst:504
msgid ""
"A subscription selects an item of a sequence (string, tuple or list) or "
"mapping (dictionary) object:"
msgstr ""

#: ../../../reference/expressions.rst:510
msgid ""
"The primary must evaluate to an object that supports subscription, e.g. a "
"list or dictionary.  User-defined objects can support subscription by "
"defining a :meth:`__getitem__` method."
msgstr ""

#: ../../../reference/expressions.rst:514
msgid ""
"For built-in objects, there are two types of objects that support "
"subscription:"
msgstr ""

#: ../../../reference/expressions.rst:516
msgid ""
"If the primary is a mapping, the expression list must evaluate to an object "
"whose value is one of the keys of the mapping, and the subscription selects "
"the value in the mapping that corresponds to that key.  (The expression list "
"is a tuple except if it has exactly one item.)"
msgstr ""

#: ../../../reference/expressions.rst:521
msgid ""
"If the primary is a sequence, the expression (list) must evaluate to an "
"integer. If this value is negative, the length of the sequence is added to "
"it (so that, e.g., ``x[-1]`` selects the last item of ``x``.)  The resulting "
"value must be a nonnegative integer less than the number of items in the "
"sequence, and the subscription selects the item whose index is that value "
"(counting from zero)."
msgstr ""

#: ../../../reference/expressions.rst:531
msgid ""
"A string's items are characters.  A character is not a separate data type "
"but a string of exactly one character."
msgstr ""

#: ../../../reference/expressions.rst:538
msgid "Slicings"
msgstr ""

#: ../../../reference/expressions.rst:550
msgid ""
"A slicing selects a range of items in a sequence object (e.g., a string, "
"tuple or list).  Slicings may be used as expressions or as targets in "
"assignment or :keyword:`del` statements.  The syntax for a slicing:"
msgstr ""

#: ../../../reference/expressions.rst:563
msgid ""
"There is ambiguity in the formal syntax here: anything that looks like an "
"expression list also looks like a slice list, so any subscription can be "
"interpreted as a slicing.  Rather than further complicating the syntax, this "
"is disambiguated by defining that in this case the interpretation as a "
"subscription takes priority over the interpretation as a slicing (this is "
"the case if the slice list contains no proper slice)."
msgstr ""

#: ../../../reference/expressions.rst:575
msgid ""
"The semantics for a slicing are as follows.  The primary must evaluate to a "
"mapping object, and it is indexed (using the same :meth:`__getitem__` method "
"as normal subscription) with a key that is constructed from the slice list, "
"as follows.  If the slice list contains at least one comma, the key is a "
"tuple containing the conversion of the slice items; otherwise, the "
"conversion of the lone slice item is the key.  The conversion of a slice "
"item that is an expression is that expression.  The conversion of a proper "
"slice is a slice object (see section :ref:`types`) whose :attr:`start`, :"
"attr:`stop` and :attr:`step` attributes are the values of the expressions "
"given as lower bound, upper bound and stride, respectively, substituting "
"``None`` for missing expressions."
msgstr ""

#: ../../../reference/expressions.rst:591
msgid "Calls"
msgstr ""

#: ../../../reference/expressions.rst:597
msgid ""
"A call calls a callable object (e.g., a function) with a possibly empty "
"series of arguments:"
msgstr ""

#: ../../../reference/expressions.rst:613
msgid ""
"A trailing comma may be present after the positional and keyword arguments "
"but does not affect the semantics."
msgstr ""

#: ../../../reference/expressions.rst:616
msgid ""
"The primary must evaluate to a callable object (user-defined functions, "
"built-in functions, methods of built-in objects, class objects, methods of "
"class instances, and all objects having a :meth:`__call__` method are "
"callable).  All argument expressions are evaluated before the call is "
"attempted.  Please refer to section :ref:`function` for the syntax of formal "
"parameter lists."
msgstr ""

#: ../../../reference/expressions.rst:624
msgid ""
"If keyword arguments are present, they are first converted to positional "
"arguments, as follows.  First, a list of unfilled slots is created for the "
"formal parameters.  If there are N positional arguments, they are placed in "
"the first N slots.  Next, for each keyword argument, the identifier is used "
"to determine the corresponding slot (if the identifier is the same as the "
"first formal parameter name, the first slot is used, and so on).  If the "
"slot is already filled, a :exc:`TypeError` exception is raised. Otherwise, "
"the value of the argument is placed in the slot, filling it (even if the "
"expression is ``None``, it fills the slot).  When all arguments have been "
"processed, the slots that are still unfilled are filled with the "
"corresponding default value from the function definition.  (Default values "
"are calculated, once, when the function is defined; thus, a mutable object "
"such as a list or dictionary used as default value will be shared by all "
"calls that don't specify an argument value for the corresponding slot; this "
"should usually be avoided.)  If there are any unfilled slots for which no "
"default value is specified, a :exc:`TypeError` exception is raised.  "
"Otherwise, the list of filled slots is used as the argument list for the "
"call."
msgstr ""

#: ../../../reference/expressions.rst:644
msgid ""
"An implementation may provide builtin functions whose positional parameters "
"do not have names, even if they are 'named' for the purpose of "
"documentation, and which therefore cannot be supplied by keyword.  In "
"CPython, this is the case for functions implemented in C that use :cfunc:"
"`PyArg_ParseTuple` to parse their arguments."
msgstr ""

#: ../../../reference/expressions.rst:650
msgid ""
"If there are more positional arguments than there are formal parameter "
"slots, a :exc:`TypeError` exception is raised, unless a formal parameter "
"using the syntax ``*identifier`` is present; in this case, that formal "
"parameter receives a tuple containing the excess positional arguments (or an "
"empty tuple if there were no excess positional arguments)."
msgstr ""

#: ../../../reference/expressions.rst:656
msgid ""
"If any keyword argument does not correspond to a formal parameter name, a :"
"exc:`TypeError` exception is raised, unless a formal parameter using the "
"syntax ``**identifier`` is present; in this case, that formal parameter "
"receives a dictionary containing the excess keyword arguments (using the "
"keywords as keys and the argument values as corresponding values), or a "
"(new) empty dictionary if there were no excess keyword arguments."
msgstr ""

#: ../../../reference/expressions.rst:663
msgid ""
"If the syntax ``*expression`` appears in the function call, ``expression`` "
"must evaluate to a sequence.  Elements from this sequence are treated as if "
"they were additional positional arguments; if there are positional arguments "
"*x1*,..., *xN*, and ``expression`` evaluates to a sequence *y1*, ..., *yM*, "
"this is equivalent to a call with M+N positional arguments *x1*, ..., *xN*, "
"*y1*, ..., *yM*."
msgstr ""

#: ../../../reference/expressions.rst:670
msgid ""
"A consequence of this is that although the ``*expression`` syntax may appear "
"*after* some keyword arguments, it is processed *before* the keyword "
"arguments (and the ``**expression`` argument, if any -- see below).  So::"
msgstr ""

#: ../../../reference/expressions.rst:686
msgid ""
"It is unusual for both keyword arguments and the ``*expression`` syntax to "
"be used in the same call, so in practice this confusion does not arise."
msgstr ""

#: ../../../reference/expressions.rst:689
msgid ""
"If the syntax ``**expression`` appears in the function call, ``expression`` "
"must evaluate to a mapping, the contents of which are treated as additional "
"keyword arguments.  In the case of a keyword appearing in both "
"``expression`` and as an explicit keyword argument, a :exc:`TypeError` "
"exception is raised."
msgstr ""

#: ../../../reference/expressions.rst:694
msgid ""
"Formal parameters using the syntax ``*identifier`` or ``**identifier`` "
"cannot be used as positional argument slots or as keyword argument names."
msgstr ""

#: ../../../reference/expressions.rst:697
msgid ""
"A call always returns some value, possibly ``None``, unless it raises an "
"exception.  How this value is computed depends on the type of the callable "
"object."
msgstr ""

#: ../../../reference/expressions.rst:701
msgid "If it is---"
msgstr ""

#: ../../../reference/expressions.rst:714
msgid "a user-defined function:"
msgstr ""

#: ../../../reference/expressions.rst:710
msgid ""
"The code block for the function is executed, passing it the argument list.  "
"The first thing the code block will do is bind the formal parameters to the "
"arguments; this is described in section :ref:`function`.  When the code "
"block executes a :keyword:`return` statement, this specifies the return "
"value of the function call."
msgstr ""

#: ../../../reference/expressions.rst:728
msgid "a built-in function or method:"
msgstr ""

#: ../../../reference/expressions.rst:727
msgid ""
"The result is up to the interpreter; see :ref:`built-in-funcs` for the "
"descriptions of built-in functions and methods."
msgstr ""

#: ../../../reference/expressions.rst:735
msgid "a class object:"
msgstr ""

#: ../../../reference/expressions.rst:735
msgid "A new instance of that class is returned."
msgstr ""

#: ../../../reference/expressions.rst:745
msgid "a class instance method:"
msgstr ""

#: ../../../reference/expressions.rst:743
msgid ""
"The corresponding user-defined function is called, with an argument list "
"that is one longer than the argument list of the call: the instance becomes "
"the first argument."
msgstr ""

#: ../../../reference/expressions.rst:754
msgid "a class instance:"
msgstr ""

#: ../../../reference/expressions.rst:752
msgid ""
"The class must define a :meth:`__call__` method; the effect is then the same "
"as if that method was called."
msgstr ""

#: ../../../reference/expressions.rst:759
msgid "The power operator"
msgstr ""

#: ../../../reference/expressions.rst:761
msgid ""
"The power operator binds more tightly than unary operators on its left; it "
"binds less tightly than unary operators on its right.  The syntax is:"
msgstr ""

#: ../../../reference/expressions.rst:767
msgid ""
"Thus, in an unparenthesized sequence of power and unary operators, the "
"operators are evaluated from right to left (this does not constrain the "
"evaluation order for the operands): ``-1**2`` results in ``-1``."
msgstr ""

#: ../../../reference/expressions.rst:771
msgid ""
"The power operator has the same semantics as the built-in :func:`pow` "
"function, when called with two arguments: it yields its left argument raised "
"to the power of its right argument.  The numeric arguments are first "
"converted to a common type, and the result is of that type."
msgstr ""

#: ../../../reference/expressions.rst:776
msgid ""
"For int operands, the result has the same type as the operands unless the "
"second argument is negative; in that case, all arguments are converted to "
"float and a float result is delivered. For example, ``10**2`` returns "
"``100``, but ``10**-2`` returns ``0.01``."
msgstr ""

#: ../../../reference/expressions.rst:781
msgid ""
"Raising ``0.0`` to a negative power results in a :exc:`ZeroDivisionError`. "
"Raising a negative number to a fractional power results in a :class:"
"`complex` number. (In earlier versions it raised a :exc:`ValueError`.)"
msgstr ""

#: ../../../reference/expressions.rst:789
msgid "Unary arithmetic operations"
msgstr ""

#: ../../../reference/expressions.rst:795
msgid "All unary arithmetic (and bitwise) operations have the same priority:"
msgstr ""

#: ../../../reference/expressions.rst:804
msgid ""
"The unary ``-`` (minus) operator yields the negation of its numeric argument."
msgstr ""

#: ../../../reference/expressions.rst:808
msgid "The unary ``+`` (plus) operator yields its numeric argument unchanged."
msgstr ""

#: ../../../reference/expressions.rst:813
msgid ""
"The unary ``~`` (invert) operator yields the bitwise inversion of its "
"integer argument.  The bitwise inversion of ``x`` is defined as ``-(x+1)``.  "
"It only applies to integral numbers."
msgstr ""

#: ../../../reference/expressions.rst:819
msgid ""
"In all three cases, if the argument does not have the proper type, a :exc:"
"`TypeError` exception is raised."
msgstr ""

#: ../../../reference/expressions.rst:826
msgid "Binary arithmetic operations"
msgstr ""

#: ../../../reference/expressions.rst:830
msgid ""
"The binary arithmetic operations have the conventional priority levels.  "
"Note that some of these operations also apply to certain non-numeric types.  "
"Apart from the power operator, there are only two levels, one for "
"multiplicative operators and one for additive operators:"
msgstr ""

#: ../../../reference/expressions.rst:842
msgid ""
"The ``*`` (multiplication) operator yields the product of its arguments.  "
"The arguments must either both be numbers, or one argument must be an "
"integer and the other must be a sequence. In the former case, the numbers "
"are converted to a common type and then multiplied together.  In the latter "
"case, sequence repetition is performed; a negative repetition factor yields "
"an empty sequence."
msgstr ""

#: ../../../reference/expressions.rst:852
msgid ""
"The ``/`` (division) and ``//`` (floor division) operators yield the "
"quotient of their arguments.  The numeric arguments are first converted to a "
"common type. Integer division yields a float, while floor division of "
"integers results in an integer; the result is that of mathematical division "
"with the 'floor' function applied to the result.  Division by zero raises "
"the :exc:`ZeroDivisionError` exception."
msgstr ""

#: ../../../reference/expressions.rst:861
msgid ""
"The ``%`` (modulo) operator yields the remainder from the division of the "
"first argument by the second.  The numeric arguments are first converted to "
"a common type.  A zero right argument raises the :exc:`ZeroDivisionError` "
"exception.  The arguments may be floating point numbers, e.g., ``3.14%0.7`` "
"equals ``0.34`` (since ``3.14`` equals ``4*0.7 + 0.34``.)  The modulo "
"operator always yields a result with the same sign as its second operand (or "
"zero); the absolute value of the result is strictly smaller than the "
"absolute value of the second operand [#]_."
msgstr ""

#: ../../../reference/expressions.rst:870
msgid ""
"The floor division and modulo operators are connected by the following "
"identity: ``x == (x//y)*y + (x%y)``.  Floor division and modulo are also "
"connected with the built-in function :func:`divmod`: ``divmod(x, y) == (x//"
"y, x%y)``. [#]_."
msgstr ""

#: ../../../reference/expressions.rst:875
msgid ""
"In addition to performing the modulo operation on numbers, the ``%`` "
"operator is also overloaded by string objects to perform old-style string "
"formatting (also known as interpolation).  The syntax for string formatting "
"is described in the Python Library Reference, section :ref:`old-string-"
"formatting`."
msgstr ""

#: ../../../reference/expressions.rst:880
msgid ""
"The floor division operator, the modulo operator, and the :func:`divmod` "
"function are not defined for complex numbers.  Instead, convert to a "
"floating point number using the :func:`abs` function if appropriate."
msgstr ""

#: ../../../reference/expressions.rst:886
msgid ""
"The ``+`` (addition) operator yields the sum of its arguments.  The "
"arguments must either both be numbers or both sequences of the same type.  "
"In the former case, the numbers are converted to a common type and then "
"added together.  In the latter case, the sequences are concatenated."
msgstr ""

#: ../../../reference/expressions.rst:893
msgid ""
"The ``-`` (subtraction) operator yields the difference of its arguments.  "
"The numeric arguments are first converted to a common type."
msgstr ""

#: ../../../reference/expressions.rst:900
msgid "Shifting operations"
msgstr ""

#: ../../../reference/expressions.rst:904
msgid ""
"The shifting operations have lower priority than the arithmetic operations:"
msgstr ""

#: ../../../reference/expressions.rst:909
msgid ""
"These operators accept integers as arguments.  They shift the first argument "
"to the left or right by the number of bits given by the second argument."
msgstr ""

#: ../../../reference/expressions.rst:914
msgid ""
"A right shift by *n* bits is defined as division by ``pow(2,n)``.  A left "
"shift by *n* bits is defined as multiplication with ``pow(2,n)``."
msgstr ""

#: ../../../reference/expressions.rst:921
msgid "Binary bitwise operations"
msgstr ""

#: ../../../reference/expressions.rst:925
msgid "Each of the three bitwise operations has a different priority level:"
msgstr ""

#: ../../../reference/expressions.rst:934
msgid ""
"The ``&`` operator yields the bitwise AND of its arguments, which must be "
"integers."
msgstr ""

#: ../../../reference/expressions.rst:941
msgid ""
"The ``^`` operator yields the bitwise XOR (exclusive OR) of its arguments, "
"which must be integers."
msgstr ""

#: ../../../reference/expressions.rst:948
msgid ""
"The ``|`` operator yields the bitwise (inclusive) OR of its arguments, which "
"must be integers."
msgstr ""

#: ../../../reference/expressions.rst:959
#: ../../../reference/expressions.rst:1258
msgid "Comparisons"
msgstr ""

#: ../../../reference/expressions.rst:965
msgid ""
"Unlike C, all comparison operations in Python have the same priority, which "
"is lower than that of any arithmetic, shifting or bitwise operation.  Also "
"unlike C, expressions like ``a < b < c`` have the interpretation that is "
"conventional in mathematics:"
msgstr ""

#: ../../../reference/expressions.rst:975
msgid "Comparisons yield boolean values: ``True`` or ``False``."
msgstr ""

#: ../../../reference/expressions.rst:979
msgid ""
"Comparisons can be chained arbitrarily, e.g., ``x < y <= z`` is equivalent "
"to ``x < y and y <= z``, except that ``y`` is evaluated only once (but in "
"both cases ``z`` is not evaluated at all when ``x < y`` is found to be "
"false)."
msgstr ""

#: ../../../reference/expressions.rst:983
msgid ""
"Formally, if *a*, *b*, *c*, ..., *y*, *z* are expressions and *op1*, "
"*op2*, ..., *opN* are comparison operators, then ``a op1 b op2 c ... y opN "
"z`` is equivalent to ``a op1 b and b op2 c and ... y opN z``, except that "
"each expression is evaluated at most once."
msgstr ""

#: ../../../reference/expressions.rst:988
msgid ""
"Note that ``a op1 b op2 c`` doesn't imply any kind of comparison between *a* "
"and *c*, so that, e.g., ``x < y > z`` is perfectly legal (though perhaps not "
"pretty)."
msgstr ""

#: ../../../reference/expressions.rst:992
msgid ""
"The operators ``<``, ``>``, ``==``, ``>=``, ``<=``, and ``!=`` compare the "
"values of two objects.  The objects need not have the same type. If both are "
"numbers, they are converted to a common type.  Otherwise, the ``==`` and ``!"
"=`` operators *always* consider objects of different types to be unequal, "
"while the ``<``, ``>``, ``>=`` and ``<=`` operators raise a :exc:`TypeError` "
"when comparing objects of different types that do not implement these "
"operators for the given pair of types.  You can control comparison behavior "
"of objects of non-builtin types by defining rich comparison methods like :"
"meth:`__gt__`, described in section :ref:`customization`."
msgstr ""

#: ../../../reference/expressions.rst:1002
msgid "Comparison of objects of the same type depends on the type:"
msgstr ""

#: ../../../reference/expressions.rst:1004
msgid "Numbers are compared arithmetically."
msgstr ""

#: ../../../reference/expressions.rst:1006
msgid ""
"The values :const:`float('NaN')` and :const:`Decimal('NaN')` are special. "
"The are identical to themselves, ``x is x`` but are not equal to themselves, "
"``x != x``.  Additionally, comparing any value to a not-a-number value will "
"return ``False``.  For example, both ``3 < float('NaN')`` and ``float('NaN') "
"< 3`` will return ``False``."
msgstr ""

#: ../../../reference/expressions.rst:1012
msgid ""
"Bytes objects are compared lexicographically using the numeric values of "
"their elements."
msgstr ""

#: ../../../reference/expressions.rst:1015
msgid ""
"Strings are compared lexicographically using the numeric equivalents (the "
"result of the built-in function :func:`ord`) of their characters. [#]_ "
"String and bytes object can't be compared!"
msgstr ""

#: ../../../reference/expressions.rst:1019
msgid ""
"Tuples and lists are compared lexicographically using comparison of "
"corresponding elements.  This means that to compare equal, each element must "
"compare equal and the two sequences must be of the same type and have the "
"same length."
msgstr ""

#: ../../../reference/expressions.rst:1024
msgid ""
"If not equal, the sequences are ordered the same as their first differing "
"elements.  For example, ``[1,2,x] <= [1,2,y]`` has the same value as ``x <= "
"y``.  If the corresponding element does not exist, the shorter sequence is "
"ordered first (for example, ``[1,2] < [1,2,3]``)."
msgstr ""

#: ../../../reference/expressions.rst:1029
msgid ""
"Mappings (dictionaries) compare equal if and only if their sorted ``(key, "
"value)`` lists compare equal. [#]_ Outcomes other than equality are resolved "
"consistently, but are not otherwise defined. [#]_"
msgstr ""

#: ../../../reference/expressions.rst:1033
msgid ""
"Sets and frozensets define comparison operators to mean subset and superset "
"tests.  Those relations do not define total orderings (the two sets ``{1,2}"
"`` and {2,3} are not equal, nor subsets of one another, nor supersets of one "
"another).  Accordingly, sets are not appropriate arguments for functions "
"which depend on total ordering.  For example, :func:`min`, :func:`max`, and :"
"func:`sorted` produce undefined results given a list of sets as inputs."
msgstr ""

#: ../../../reference/expressions.rst:1040
msgid ""
"Most other objects of builtin types compare unequal unless they are the same "
"object; the choice whether one object is considered smaller or larger than "
"another one is made arbitrarily but consistently within one execution of a "
"program."
msgstr ""

#: ../../../reference/expressions.rst:1045
msgid ""
"Comparison of objects of the differing types depends on whether either of "
"the types provide explicit support for the comparison.  Most numeric types "
"can be compared with one another, but comparisons of :class:`float` and :"
"class:`Decimal` are not supported to avoid the inevitable confusion arising "
"from representation issues such as ``float('1.1')`` being inexactly "
"represented and therefore not exactly equal to ``Decimal('1.1')`` which is.  "
"When cross-type comparison is not supported, the comparison method returns "
"``NotImplemented``.  This can create the illusion of non-transitivity "
"between supported cross-type comparisons and unsupported comparisons.  For "
"example, ``Decimal(2) == 2`` and `2 == float(2)`` but ``Decimal(2) != "
"float(2)``."
msgstr ""

#: ../../../reference/expressions.rst:1056
msgid ""
"The operators :keyword:`in` and :keyword:`not in` test for membership.  ``x "
"in s`` evaluates to true if *x* is a member of *s*, and false otherwise.  "
"``x not in s`` returns the negation of ``x in s``.  All built-in sequences "
"and set types support this as well as dictionary, for which :keyword:`in` "
"tests whether a the dictionary has a given key. For container types such as "
"list, tuple, set, frozenset, dict, or collections.deque, the expression ``x "
"in y`` is equivalent to ``any(x is e or x == e for val e in y)``."
msgstr ""

#: ../../../reference/expressions.rst:1064
msgid ""
"For the string and bytes types, ``x in y`` is true if and only if *x* is a "
"substring of *y*.  An equivalent test is ``y.find(x) != -1``.  Empty strings "
"are always considered to be a substring of any other string, so ``\"\" in "
"\"abc\"`` will return ``True``."
msgstr ""

#: ../../../reference/expressions.rst:1069
msgid ""
"For user-defined classes which define the :meth:`__contains__` method, ``x "
"in y`` is true if and only if ``y.__contains__(x)`` is true."
msgstr ""

#: ../../../reference/expressions.rst:1072
msgid ""
"For user-defined classes which do not define :meth:`__contains__` and do "
"define :meth:`__getitem__`, ``x in y`` is true if and only if there is a non-"
"negative integer index *i* such that ``x == y[i]``, and all lower integer "
"indices do not raise :exc:`IndexError` exception.  (If any other exception "
"is raised, it is as if :keyword:`in` raised that exception)."
msgstr ""

#: ../../../reference/expressions.rst:1084
msgid ""
"The operator :keyword:`not in` is defined to have the inverse true value of :"
"keyword:`in`."
msgstr ""

#: ../../../reference/expressions.rst:1092
msgid ""
"The operators :keyword:`is` and :keyword:`is not` test for object identity: "
"``x is y`` is true if and only if *x* and *y* are the same object.  ``x is "
"not y`` yields the inverse truth value. [#]_"
msgstr ""

#: ../../../reference/expressions.rst:1103
msgid "Boolean operations"
msgstr ""

#: ../../../reference/expressions.rst:1109
msgid "Boolean operations have the lowest priority of all Python operations:"
msgstr ""

#: ../../../reference/expressions.rst:1119
msgid ""
"In the context of Boolean operations, and also when expressions are used by "
"control flow statements, the following values are interpreted as false: "
"``False``, ``None``, numeric zero of all types, and empty strings and "
"containers (including strings, tuples, lists, dictionaries, sets and "
"frozensets).  All other values are interpreted as true.  User-defined "
"objects can customize their truth value by providing a :meth:`__bool__` "
"method."
msgstr ""

#: ../../../reference/expressions.rst:1128
msgid ""
"The operator :keyword:`not` yields ``True`` if its argument is false, "
"``False`` otherwise."
msgstr ""

#: ../../../reference/expressions.rst:1131
msgid ""
"The expression ``x if C else y`` first evaluates *C* (*not* *x*); if *C* is "
"true, *x* is evaluated and its value is returned; otherwise, *y* is "
"evaluated and its value is returned."
msgstr ""

#: ../../../reference/expressions.rst:1137
msgid ""
"The expression ``x and y`` first evaluates *x*; if *x* is false, its value "
"is returned; otherwise, *y* is evaluated and the resulting value is returned."
msgstr ""

#: ../../../reference/expressions.rst:1142
msgid ""
"The expression ``x or y`` first evaluates *x*; if *x* is true, its value is "
"returned; otherwise, *y* is evaluated and the resulting value is returned."
msgstr ""

#: ../../../reference/expressions.rst:1145
msgid ""
"(Note that neither :keyword:`and` nor :keyword:`or` restrict the value and "
"type they return to ``False`` and ``True``, but rather return the last "
"evaluated argument.  This is sometimes useful, e.g., if ``s`` is a string "
"that should be replaced by a default value if it is empty, the expression "
"``s or 'foo'`` yields the desired value.  Because :keyword:`not` has to "
"invent a value anyway, it does not bother to return a value of the same type "
"as its argument, so e.g., ``not 'foo'`` yields ``False``, not ``''``.)"
msgstr ""

#: ../../../reference/expressions.rst:1157
msgid "Lambdas"
msgstr ""

#: ../../../reference/expressions.rst:1168
msgid ""
"Lambda forms (lambda expressions) have the same syntactic position as "
"expressions.  They are a shorthand to create anonymous functions; the "
"expression ``lambda arguments: expression`` yields a function object.  The "
"unnamed object behaves like a function object defined with ::"
msgstr ""

#: ../../../reference/expressions.rst:1176
msgid ""
"See section :ref:`function` for the syntax of parameter lists.  Note that "
"functions created with lambda forms cannot contain statements or annotations."
msgstr ""

#: ../../../reference/expressions.rst:1185
msgid "Expression lists"
msgstr ""

#: ../../../reference/expressions.rst:1194
msgid ""
"An expression list containing at least one comma yields a tuple.  The length "
"of the tuple is the number of expressions in the list.  The expressions are "
"evaluated from left to right."
msgstr ""

#: ../../../reference/expressions.rst:1200
msgid ""
"The trailing comma is required only to create a single tuple (a.k.a. a "
"*singleton*); it is optional in all other cases.  A single expression "
"without a trailing comma doesn't create a tuple, but rather yields the value "
"of that expression. (To create an empty tuple, use an empty pair of "
"parentheses: ``()``.)"
msgstr ""

#: ../../../reference/expressions.rst:1210
msgid "Evaluation order"
msgstr ""

#: ../../../reference/expressions.rst:1214
msgid ""
"Python evaluates expressions from left to right.  Notice that while "
"evaluating an assignment, the right-hand side is evaluated before the left-"
"hand side."
msgstr ""

#: ../../../reference/expressions.rst:1217
msgid ""
"In the following lines, expressions will be evaluated in the arithmetic "
"order of their suffixes::"
msgstr ""

#: ../../../reference/expressions.rst:1231
msgid "Summary"
msgstr ""

#: ../../../reference/expressions.rst:1235
msgid ""
"The following table summarizes the operator precedences in Python, from "
"lowest precedence (least binding) to highest precedence (most binding).  "
"Operators in the same box have the same precedence.  Unless the syntax is "
"explicitly given, operators are binary.  Operators in the same box group "
"left to right (except for comparisons, including tests, which all have the "
"same precedence and chain from left to right --- see section :ref:"
"`comparisons` --- and exponentiation, which groups from right to left)."
msgstr ""

#: ../../../reference/expressions.rst:1244
msgid "Operator"
msgstr ""

#: ../../../reference/expressions.rst:1244
msgid "Description"
msgstr ""

#: ../../../reference/expressions.rst:1246
msgid ":keyword:`lambda`"
msgstr ""

#: ../../../reference/expressions.rst:1246
msgid "Lambda expression"
msgstr ""

#: ../../../reference/expressions.rst:1248
msgid ":keyword:`or`"
msgstr ""

#: ../../../reference/expressions.rst:1248
msgid "Boolean OR"
msgstr ""

#: ../../../reference/expressions.rst:1250
msgid ":keyword:`and`"
msgstr ""

#: ../../../reference/expressions.rst:1250
msgid "Boolean AND"
msgstr ""

#: ../../../reference/expressions.rst:1252
msgid ":keyword:`not` *x*"
msgstr ""

#: ../../../reference/expressions.rst:1252
msgid "Boolean NOT"
msgstr ""

#: ../../../reference/expressions.rst:1254
msgid ":keyword:`in`, :keyword:`not` :keyword:`in`"
msgstr ""

#: ../../../reference/expressions.rst:1254
msgid "Membership tests"
msgstr ""

#: ../../../reference/expressions.rst:1256
msgid ":keyword:`is`, :keyword:`is not`"
msgstr ""

#: ../../../reference/expressions.rst:1256
msgid "Identity tests"
msgstr ""

#: ../../../reference/expressions.rst:1258
msgid "``<``, ``<=``, ``>``, ``>=``, ``!=``, ``==``"
msgstr ""

#: ../../../reference/expressions.rst:1260
msgid "``|``"
msgstr ""

#: ../../../reference/expressions.rst:1260
msgid "Bitwise OR"
msgstr ""

#: ../../../reference/expressions.rst:1262
msgid "``^``"
msgstr ""

#: ../../../reference/expressions.rst:1262
msgid "Bitwise XOR"
msgstr ""

#: ../../../reference/expressions.rst:1264
msgid "``&``"
msgstr ""

#: ../../../reference/expressions.rst:1264
msgid "Bitwise AND"
msgstr ""

#: ../../../reference/expressions.rst:1266
msgid "``<<``, ``>>``"
msgstr ""

#: ../../../reference/expressions.rst:1266
msgid "Shifts"
msgstr ""

#: ../../../reference/expressions.rst:1268
msgid "``+``, ``-``"
msgstr ""

#: ../../../reference/expressions.rst:1268
msgid "Addition and subtraction"
msgstr ""

#: ../../../reference/expressions.rst:1270
msgid "``*``, ``/``, ``//``, ``%``"
msgstr ""

#: ../../../reference/expressions.rst:1270
msgid "Multiplication, division, remainder"
msgstr ""

#: ../../../reference/expressions.rst:1272
msgid "``+x``, ``-x``"
msgstr ""

#: ../../../reference/expressions.rst:1272
msgid "Positive, negative"
msgstr ""

#: ../../../reference/expressions.rst:1274
msgid "``~x``"
msgstr ""

#: ../../../reference/expressions.rst:1274
msgid "Bitwise not"
msgstr ""

#: ../../../reference/expressions.rst:1276
msgid "``**``"
msgstr ""

#: ../../../reference/expressions.rst:1276
msgid "Exponentiation"
msgstr ""

#: ../../../reference/expressions.rst:1278
msgid "``x[index]``"
msgstr ""

#: ../../../reference/expressions.rst:1278
msgid "Subscription"
msgstr ""

#: ../../../reference/expressions.rst:1280
msgid "``x[index:index]``"
msgstr ""

#: ../../../reference/expressions.rst:1280
msgid "Slicing"
msgstr ""

#: ../../../reference/expressions.rst:1282
msgid "``x(arguments...)``"
msgstr ""

#: ../../../reference/expressions.rst:1282
msgid "Call"
msgstr ""

#: ../../../reference/expressions.rst:1284
msgid "``x.attribute``"
msgstr ""

#: ../../../reference/expressions.rst:1284
msgid "Attribute reference"
msgstr ""

#: ../../../reference/expressions.rst:1286
msgid "``(expressions...)``"
msgstr ""

#: ../../../reference/expressions.rst:1286
msgid "Binding, tuple display, generator expressions"
msgstr ""

#: ../../../reference/expressions.rst:1289
msgid "``[expressions...]``"
msgstr ""

#: ../../../reference/expressions.rst:1289
msgid "List display"
msgstr ""

#: ../../../reference/expressions.rst:1291
msgid "``{expressions...}``"
msgstr ""

#: ../../../reference/expressions.rst:1291
msgid "Dictionary or set display"
msgstr ""

#: ../../../reference/expressions.rst:1295
msgid "Footnotes"
msgstr ""

#: ../../../reference/expressions.rst:1296
msgid ""
"While ``abs(x%y) < abs(y)`` is true mathematically, for floats it may not be "
"true numerically due to roundoff.  For example, and assuming a platform on "
"which a Python float is an IEEE 754 double-precision number, in order that "
"``-1e-100 % 1e100`` have the same sign as ``1e100``, the computed result is "
"``-1e-100 + 1e100``, which is numerically exactly equal to ``1e100``.  "
"Function :func:`fmod` in the :mod:`math` module returns a result whose sign "
"matches the sign of the first argument instead, and so returns ``-1e-100`` "
"in this case. Which approach is more appropriate depends on the application."
msgstr ""

#: ../../../reference/expressions.rst:1305
msgid ""
"If x is very close to an exact integer multiple of y, it's possible for ``x//"
"y`` to be one larger than ``(x-x%y)//y`` due to rounding.  In such cases, "
"Python returns the latter result, in order to preserve that ``divmod(x,y)[0] "
"* y + x % y`` be very close to ``x``."
msgstr ""

#: ../../../reference/expressions.rst:1310
msgid ""
"While comparisons between strings make sense at the byte level, they may be "
"counter-intuitive to users.  For example, the strings ``\"\\u00C7\"`` and "
"``\"\\u0327\\u0043\"`` compare differently, even though they both represent "
"the same unicode character (LATIN CAPTITAL LETTER C WITH CEDILLA).  To "
"compare strings in a human recognizable way, compare using :func:"
"`unicodedata.normalize`."
msgstr ""

#: ../../../reference/expressions.rst:1317
msgid ""
"The implementation computes this efficiently, without constructing lists or "
"sorting."
msgstr ""

#: ../../../reference/expressions.rst:1320
msgid ""
"Earlier versions of Python used lexicographic comparison of the sorted (key, "
"value) lists, but this was very expensive for the common case of comparing "
"for equality.  An even earlier version of Python compared dictionaries by "
"identity only, but this caused surprises because people expected to be able "
"to test a dictionary for emptiness by comparing it to ``{}``."
msgstr ""

#: ../../../reference/expressions.rst:1326
msgid ""
"Due to automatic garbage-collection, free lists, and the dynamic nature of "
"descriptors, you may notice seemingly unusual behaviour in certain uses of "
"the :keyword:`is` operator, like those involving comparisons between "
"instance methods, or constants.  Check their documentation for more info."
msgstr ""

#: ../../../reference/expressions.rst:8 ../../../reference/expressions.rst:284
#: ../../../reference/expressions.rst:314
#: ../../../reference/expressions.rst:1105
#: ../../../reference/expressions.rst:1159
#: ../../../reference/expressions.rst:1187
msgid "expression"
msgstr ""

#: ../../../reference/expressions.rst:8
msgid "BNF"
msgstr ""

#: ../../../reference/expressions.rst:28 ../../../reference/expressions.rst:791
#: ../../../reference/expressions.rst:828
msgid "arithmetic"
msgstr ""

#: ../../../reference/expressions.rst:28
msgid "conversion"
msgstr ""

#: ../../../reference/expressions.rst:50
msgid "atom"
msgstr ""

#: ../../../reference/expressions.rst:67 ../../../reference/expressions.rst:79
msgid "name"
msgstr ""

#: ../../../reference/expressions.rst:67
msgid "identifier"
msgstr ""

#: ../../../reference/expressions.rst:73
msgid "NameError"
msgstr ""

#: ../../../reference/expressions.rst:79
msgid "mangling"
msgstr ""

#: ../../../reference/expressions.rst:79
msgid "private"
msgstr ""

#: ../../../reference/expressions.rst:79
msgid "names"
msgstr ""

#: ../../../reference/expressions.rst:102
msgid "literal"
msgstr ""

#: ../../../reference/expressions.rst:115
#: ../../../reference/expressions.rst:269
msgid "immutable"
msgstr ""

#: ../../../reference/expressions.rst:115
msgid "data"
msgstr ""

#: ../../../reference/expressions.rst:115
msgid "type"
msgstr ""

#: ../../../reference/expressions.rst:131
msgid "parenthesized form"
msgstr ""

#: ../../../reference/expressions.rst:142
#: ../../../reference/expressions.rst:195
msgid "empty"
msgstr ""

#: ../../../reference/expressions.rst:142
#: ../../../reference/expressions.rst:148
#: ../../../reference/expressions.rst:495
#: ../../../reference/expressions.rst:544
#: ../../../reference/expressions.rst:1192
msgid "tuple"
msgstr ""

#: ../../../reference/expressions.rst:148
#: ../../../reference/expressions.rst:1198
msgid "comma"
msgstr ""

#: ../../../reference/expressions.rst:148
#: ../../../reference/expressions.rst:195
#: ../../../reference/expressions.rst:219
#: ../../../reference/expressions.rst:243
msgid "display"
msgstr ""

#: ../../../reference/expressions.rst:195
#: ../../../reference/expressions.rst:474
#: ../../../reference/expressions.rst:495
#: ../../../reference/expressions.rst:544
#: ../../../reference/expressions.rst:1187
msgid "list"
msgstr ""

#: ../../../reference/expressions.rst:195
msgid "comprehensions"
msgstr ""

#: ../../../reference/expressions.rst:219
msgid "set"
msgstr ""

#: ../../../reference/expressions.rst:243
#: ../../../reference/expressions.rst:495
msgid "dictionary"
msgstr ""

#: ../../../reference/expressions.rst:243
msgid "key"
msgstr ""

#: ../../../reference/expressions.rst:243
msgid "datum"
msgstr ""

#: ../../../reference/expressions.rst:243
msgid "key/datum pair"
msgstr ""

#: ../../../reference/expressions.rst:269
msgid "hashable"
msgstr ""

#: ../../../reference/expressions.rst:284
#: ../../../reference/expressions.rst:314
#: ../../../reference/expressions.rst:355
msgid "generator"
msgstr ""

#: ../../../reference/expressions.rst:314
msgid "yield"
msgstr ""

#: ../../../reference/expressions.rst:314
#: ../../../reference/expressions.rst:704
#: ../../../reference/expressions.rst:717
#: ../../../reference/expressions.rst:1159
msgid "function"
msgstr ""

#: ../../../reference/expressions.rst:341
msgid "coroutine"
msgstr ""

#: ../../../reference/expressions.rst:360
msgid "StopIteration"
msgstr ""

#: ../../../reference/expressions.rst:397
msgid "GeneratorExit"
msgstr ""

#: ../../../reference/expressions.rst:453
msgid "primary"
msgstr ""

#: ../../../reference/expressions.rst:467
msgid "attribute"
msgstr ""

#: ../../../reference/expressions.rst:467
msgid "reference"
msgstr ""

#: ../../../reference/expressions.rst:474
msgid "AttributeError"
msgstr ""

#: ../../../reference/expressions.rst:493
msgid "subscription"
msgstr ""

#: ../../../reference/expressions.rst:495
#: ../../../reference/expressions.rst:544
#: ../../../reference/expressions.rst:1078
msgid "sequence"
msgstr ""

#: ../../../reference/expressions.rst:495
msgid "mapping"
msgstr ""

#: ../../../reference/expressions.rst:495
#: ../../../reference/expressions.rst:527
#: ../../../reference/expressions.rst:544
msgid "string"
msgstr ""

#: ../../../reference/expressions.rst:495
#: ../../../reference/expressions.rst:527
msgid "item"
msgstr ""

#: ../../../reference/expressions.rst:527
msgid "character"
msgstr ""

#: ../../../reference/expressions.rst:540
msgid "slicing"
msgstr ""

#: ../../../reference/expressions.rst:540
msgid "slice"
msgstr ""

#: ../../../reference/expressions.rst:570
msgid "start (slice object attribute)"
msgstr ""

#: ../../../reference/expressions.rst:570
msgid "stop (slice object attribute)"
msgstr ""

#: ../../../reference/expressions.rst:570
msgid "step (slice object attribute)"
msgstr ""

#: ../../../reference/expressions.rst:593
#: ../../../reference/expressions.rst:704
#: ../../../reference/expressions.rst:717
#: ../../../reference/expressions.rst:731
#: ../../../reference/expressions.rst:738
#: ../../../reference/expressions.rst:748
msgid "call"
msgstr ""

#: ../../../reference/expressions.rst:595
msgid "callable"
msgstr ""

#: ../../../reference/expressions.rst:704
msgid "user-defined"
msgstr ""

#: ../../../reference/expressions.rst:704
msgid "user-defined function"
msgstr ""

#: ../../../reference/expressions.rst:717
msgid "method"
msgstr ""

#: ../../../reference/expressions.rst:717
msgid "built-in method"
msgstr ""

#: ../../../reference/expressions.rst:731
msgid "class"
msgstr ""

#: ../../../reference/expressions.rst:731
msgid "class object"
msgstr ""

#: ../../../reference/expressions.rst:738
msgid "class instance"
msgstr ""

#: ../../../reference/expressions.rst:738
#: ../../../reference/expressions.rst:748
msgid "instance"
msgstr ""

#: ../../../reference/expressions.rst:748
msgid "__call__() (object method)"
msgstr ""

#: ../../../reference/expressions.rst:791
msgid "unary"
msgstr ""

#: ../../../reference/expressions.rst:791
#: ../../../reference/expressions.rst:828
#: ../../../reference/expressions.rst:902
#: ../../../reference/expressions.rst:923
#: ../../../reference/expressions.rst:1105
msgid "operation"
msgstr ""

#: ../../../reference/expressions.rst:791
#: ../../../reference/expressions.rst:923
#: ../../../reference/expressions.rst:932
#: ../../../reference/expressions.rst:937
#: ../../../reference/expressions.rst:944
msgid "bitwise"
msgstr ""

#: ../../../reference/expressions.rst:800
msgid "negation"
msgstr ""

#: ../../../reference/expressions.rst:800
msgid "minus"
msgstr ""

#: ../../../reference/expressions.rst:806
msgid "plus"
msgstr ""

#: ../../../reference/expressions.rst:810
msgid "inversion"
msgstr ""

#: ../../../reference/expressions.rst:817
msgid "TypeError"
msgstr ""

#: ../../../reference/expressions.rst:828
#: ../../../reference/expressions.rst:923
msgid "binary"
msgstr ""

#: ../../../reference/expressions.rst:840
msgid "multiplication"
msgstr ""

#: ../../../reference/expressions.rst:848
msgid "ZeroDivisionError"
msgstr ""

#: ../../../reference/expressions.rst:848
msgid "division"
msgstr ""

#: ../../../reference/expressions.rst:859
msgid "modulo"
msgstr ""

#: ../../../reference/expressions.rst:884
msgid "addition"
msgstr ""

#: ../../../reference/expressions.rst:891
msgid "subtraction"
msgstr ""

#: ../../../reference/expressions.rst:902
msgid "shifting"
msgstr ""

#: ../../../reference/expressions.rst:912
msgid "ValueError"
msgstr ""

#: ../../../reference/expressions.rst:932
#: ../../../reference/expressions.rst:1135
msgid "and"
msgstr ""

#: ../../../reference/expressions.rst:937
msgid "xor"
msgstr ""

#: ../../../reference/expressions.rst:937
msgid "exclusive"
msgstr ""

#: ../../../reference/expressions.rst:937
#: ../../../reference/expressions.rst:944
#: ../../../reference/expressions.rst:1140
msgid "or"
msgstr ""

#: ../../../reference/expressions.rst:944
msgid "inclusive"
msgstr ""

#: ../../../reference/expressions.rst:961
msgid "comparison"
msgstr ""

#: ../../../reference/expressions.rst:963
msgid "C"
msgstr ""

#: ../../../reference/expressions.rst:963
msgid "language"
msgstr ""

#: ../../../reference/expressions.rst:977
msgid "chaining"
msgstr ""

#: ../../../reference/expressions.rst:977
msgid "comparisons"
msgstr ""

#: ../../../reference/expressions.rst:1078
msgid "in"
msgstr ""

#: ../../../reference/expressions.rst:1078
msgid "not in"
msgstr ""

#: ../../../reference/expressions.rst:1078
msgid "membership"
msgstr ""

#: ../../../reference/expressions.rst:1078
#: ../../../reference/expressions.rst:1087
msgid "test"
msgstr ""

#: ../../../reference/expressions.rst:1087
msgid "is"
msgstr ""

#: ../../../reference/expressions.rst:1087
msgid "is not"
msgstr ""

#: ../../../reference/expressions.rst:1087
msgid "identity"
msgstr ""

#: ../../../reference/expressions.rst:1105
msgid "Conditional"
msgstr ""

#: ../../../reference/expressions.rst:1105
msgid "Boolean"
msgstr ""

#: ../../../reference/expressions.rst:1126
msgid "not"
msgstr ""

#: ../../../reference/expressions.rst:1159
msgid "lambda"
msgstr ""

#: ../../../reference/expressions.rst:1159
msgid "form"
msgstr ""

#: ../../../reference/expressions.rst:1159
msgid "anonymous"
msgstr ""

#: ../../../reference/expressions.rst:1198
msgid "trailing"
msgstr ""

#: ../../../reference/expressions.rst:1212
msgid "evaluation"
msgstr ""

#: ../../../reference/expressions.rst:1212
msgid "order"
msgstr ""

#: ../../../reference/expressions.rst:1233
msgid "precedence"
msgstr ""

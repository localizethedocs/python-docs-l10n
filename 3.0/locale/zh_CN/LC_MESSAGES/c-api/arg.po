# SOME DESCRIPTIVE TITLE.
# Copyright (C) 1990-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-10 15:11+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../c-api/arg.rst:6
msgid "Parsing arguments and building values"
msgstr ""

#: ../../../c-api/arg.rst:8
msgid ""
"These functions are useful when creating your own extensions functions and "
"methods.  Additional information and examples are available in :ref:"
"`extending-index`."
msgstr ""

#: ../../../c-api/arg.rst:12
msgid ""
"The first three of these functions described, :cfunc:`PyArg_ParseTuple`, :"
"cfunc:`PyArg_ParseTupleAndKeywords`, and :cfunc:`PyArg_Parse`, all use "
"*format strings* which are used to tell the function about the expected "
"arguments.  The format strings use the same syntax for each of these "
"functions."
msgstr ""

#: ../../../c-api/arg.rst:17
msgid ""
"A format string consists of zero or more \"format units.\"  A format unit "
"describes one Python object; it is usually a single character or a "
"parenthesized sequence of format units.  With a few exceptions, a format "
"unit that is not a parenthesized sequence normally corresponds to a single "
"address argument to these functions.  In the following description, the "
"quoted form is the format unit; the entry in (round) parentheses is the "
"Python object type that matches the format unit; and the entry in [square] "
"brackets is the type of the C variable(s) whose address should be passed."
msgstr ""

#: ../../../c-api/arg.rst:38
msgid "``s`` (string or Unicode object) [const char \\*]"
msgstr ""

#: ../../../c-api/arg.rst:27
msgid ""
"Convert a Python string or Unicode object to a C pointer to a character "
"string. You must not provide storage for the string itself; a pointer to an "
"existing string is stored into the character pointer variable whose address "
"you pass. The C string is NUL-terminated.  The Python string must not "
"contain embedded NUL bytes; if it does, a :exc:`TypeError` exception is "
"raised. Unicode objects are converted to C strings using the default "
"encoding.  If this conversion fails, a :exc:`UnicodeError` is raised."
msgstr ""

#: ../../../c-api/arg.rst:35
msgid ""
"Starting with Python 2.5 the type of the length argument can be controlled "
"by defining the macro :cmacro:`PY_SSIZE_T_CLEAN` before including :file:"
"`Python.h`.  If the macro is defined, length is a :ctype:`Py_ssize_t` rather "
"than an int."
msgstr ""

#: ../../../c-api/arg.rst:48
msgid ""
"``s*`` (string, Unicode, or any buffer compatible object) [Py_buffer \\*]"
msgstr ""

#: ../../../c-api/arg.rst:41
msgid ""
"This is similar to ``s``, but the code fills a :ctype:`Py_buffer` structure "
"provided by the caller.  In this case the Python string may contain embedded "
"null bytes.  Unicode objects pass back a pointer to the default encoded "
"string version of the object if such a conversion is possible.  The "
"underlying buffer is locked, so that the caller can subsequently use the "
"buffer even inside a ``Py_BEGIN_ALLOW_THREADS`` block.  **The caller is "
"responsible** for calling ``PyBuffer_Release`` with the structure after it "
"has processed the data."
msgstr ""

#: ../../../c-api/arg.rst:65
msgid ""
"``s#`` (string, Unicode or any read buffer compatible object) [const char "
"\\*, int or :ctype:`Py_ssize_t`]"
msgstr ""

#: ../../../c-api/arg.rst:51
msgid ""
"This variant on ``s`` stores into two C variables, the first one a pointer "
"to a character string, the second one its length.  In this case the Python "
"string may contain embedded null bytes.  Unicode objects pass back a pointer "
"to the default encoded string version of the object if such a conversion is "
"possible.  All other read-buffer compatible objects pass back a reference to "
"the raw internal data representation.  Since this format doesn't allow "
"writable buffer compatible objects like byte arrays, ``s*`` is to be "
"preferred."
msgstr ""

#: ../../../c-api/arg.rst:60
msgid ""
"The type of the length argument (int or :ctype:`Py_ssize_t`) is controlled "
"by defining the macro :cmacro:`PY_SSIZE_T_CLEAN` before including :file:"
"`Python.h`.  If the macro was defined, length is a :ctype:`Py_ssize_t` "
"rather than an int.  This behavior will change in a future Python version to "
"only support :ctype:`Py_ssize_t` and drop int support.  It is best to always "
"define :cmacro:`PY_SSIZE_T_CLEAN`."
msgstr ""

#: ../../../c-api/arg.rst:70
msgid "``y`` (bytes object) [const char \\*]"
msgstr ""

#: ../../../c-api/arg.rst:68
msgid ""
"This variant on ``s`` converts a Python bytes or bytearray object to a C "
"pointer to a character string.  The bytes object must not contain embedded "
"NUL bytes; if it does, a :exc:`TypeError` exception is raised."
msgstr ""

#: ../../../c-api/arg.rst:73
msgid "``y*`` (bytes object) [Py_buffer \\*]"
msgstr ""

#: ../../../c-api/arg.rst:73
msgid "This is to ``s*`` as ``y`` is to ``s``."
msgstr ""

#: ../../../c-api/arg.rst:78
msgid "``y#`` (bytes object) [const char \\*, int]"
msgstr ""

#: ../../../c-api/arg.rst:76
msgid ""
"This variant on ``s#`` stores into two C variables, the first one a pointer "
"to a character string, the second one its length.  This only accepts bytes "
"objects, no byte arrays."
msgstr ""

#: ../../../c-api/arg.rst:82
msgid "``z`` (string or ``None``) [const char \\*]"
msgstr ""

#: ../../../c-api/arg.rst:81 ../../../c-api/arg.rst:103
msgid ""
"Like ``s``, but the Python object may also be ``None``, in which case the C "
"pointer is set to *NULL*."
msgstr ""

#: ../../../c-api/arg.rst:85
msgid ""
"``z*`` (string or ``None`` or any buffer compatible object) [Py_buffer*]"
msgstr ""

#: ../../../c-api/arg.rst:85
msgid "This is to ``s*`` as ``z`` is to ``s``."
msgstr ""

#: ../../../c-api/arg.rst:88
msgid ""
"``z#`` (string or ``None`` or any read buffer compatible object) [const char "
"\\*, int]"
msgstr ""

#: ../../../c-api/arg.rst:88
msgid "This is to ``s#`` as ``z`` is to ``s``."
msgstr ""

#: ../../../c-api/arg.rst:94
msgid "``u`` (Unicode object) [Py_UNICODE \\*]"
msgstr ""

#: ../../../c-api/arg.rst:91
msgid ""
"Convert a Python Unicode object to a C pointer to a NUL-terminated buffer of "
"16-bit Unicode (UTF-16) data.  As with ``s``, there is no need to provide "
"storage for the Unicode data buffer; a pointer to the existing Unicode data "
"is stored into the :ctype:`Py_UNICODE` pointer variable whose address you "
"pass."
msgstr ""

#: ../../../c-api/arg.rst:100
msgid "``u#`` (Unicode object) [Py_UNICODE \\*, int]"
msgstr ""

#: ../../../c-api/arg.rst:97
msgid ""
"This variant on ``u`` stores into two C variables, the first one a pointer "
"to a Unicode data buffer, the second one its length. Non-Unicode objects are "
"handled by interpreting their read-buffer pointer as pointer to a :ctype:"
"`Py_UNICODE` array."
msgstr ""

#: ../../../c-api/arg.rst:104
msgid "``Z`` (Unicode or ``None``) [Py_UNICODE \\*]"
msgstr ""

#: ../../../c-api/arg.rst:107
msgid "``Z#`` (Unicode or ``None``) [Py_UNICODE \\*, int]"
msgstr ""

#: ../../../c-api/arg.rst:107
msgid "This is to ``u#`` as ``Z`` is to ``u``."
msgstr ""

#: ../../../c-api/arg.rst:125
msgid ""
"``es`` (string, Unicode object or character buffer compatible object) [const "
"char \\*encoding, char \\*\\*buffer]"
msgstr ""

#: ../../../c-api/arg.rst:110
msgid ""
"This variant on ``s`` is used for encoding Unicode and objects convertible "
"to Unicode into a character buffer. It only works for encoded data without "
"embedded NUL bytes."
msgstr ""

#: ../../../c-api/arg.rst:114
msgid ""
"This format requires two arguments.  The first is only used as input, and "
"must be a :ctype:`const char\\*` which points to the name of an encoding as "
"a NUL-terminated string, or *NULL*, in which case the default encoding is "
"used. An exception is raised if the named encoding is not known to Python.  "
"The second argument must be a :ctype:`char\\*\\*`; the value of the pointer "
"it references will be set to a buffer with the contents of the argument "
"text. The text will be encoded in the encoding specified by the first "
"argument."
msgstr ""

#: ../../../c-api/arg.rst:122
msgid ""
":cfunc:`PyArg_ParseTuple` will allocate a buffer of the needed size, copy "
"the encoded data into this buffer and adjust *\\*buffer* to reference the "
"newly allocated storage.  The caller is responsible for calling :cfunc:"
"`PyMem_Free` to free the allocated buffer after use."
msgstr ""

#: ../../../c-api/arg.rst:130
msgid ""
"``et`` (string, Unicode object or character buffer compatible object) [const "
"char \\*encoding, char \\*\\*buffer]"
msgstr ""

#: ../../../c-api/arg.rst:128
msgid ""
"Same as ``es`` except that 8-bit string objects are passed through without "
"recoding them.  Instead, the implementation assumes that the string object "
"uses the encoding passed in as parameter."
msgstr ""

#: ../../../c-api/arg.rst:161
msgid ""
"``es#`` (string, Unicode object or character buffer compatible object) "
"[const char \\*encoding, char \\*\\*buffer, int \\*buffer_length]"
msgstr ""

#: ../../../c-api/arg.rst:133
msgid ""
"This variant on ``s#`` is used for encoding Unicode and objects convertible "
"to Unicode into a character buffer.  Unlike the ``es`` format, this variant "
"allows input data which contains NUL characters."
msgstr ""

#: ../../../c-api/arg.rst:137
msgid ""
"It requires three arguments.  The first is only used as input, and must be "
"a :ctype:`const char\\*` which points to the name of an encoding as a NUL-"
"terminated string, or *NULL*, in which case the default encoding is used. An "
"exception is raised if the named encoding is not known to Python.  The "
"second argument must be a :ctype:`char\\*\\*`; the value of the pointer it "
"references will be set to a buffer with the contents of the argument text. "
"The text will be encoded in the encoding specified by the first argument. "
"The third argument must be a pointer to an integer; the referenced integer "
"will be set to the number of bytes in the output buffer."
msgstr ""

#: ../../../c-api/arg.rst:147
msgid "There are two modes of operation:"
msgstr ""

#: ../../../c-api/arg.rst:149
msgid ""
"If *\\*buffer* points a *NULL* pointer, the function will allocate a buffer "
"of the needed size, copy the encoded data into this buffer and set "
"*\\*buffer* to reference the newly allocated storage.  The caller is "
"responsible for calling :cfunc:`PyMem_Free` to free the allocated buffer "
"after usage."
msgstr ""

#: ../../../c-api/arg.rst:154
msgid ""
"If *\\*buffer* points to a non-*NULL* pointer (an already allocated "
"buffer), :cfunc:`PyArg_ParseTuple` will use this location as the buffer and "
"interpret the initial value of *\\*buffer_length* as the buffer size.  It "
"will then copy the encoded data into the buffer and NUL-terminate it.  If "
"the buffer is not large enough, a :exc:`ValueError` will be set."
msgstr ""

#: ../../../c-api/arg.rst:160
msgid ""
"In both cases, *\\*buffer_length* is set to the length of the encoded data "
"without the trailing NUL byte."
msgstr ""

#: ../../../c-api/arg.rst:166
msgid ""
"``et#`` (string, Unicode object or character buffer compatible object) "
"[const char \\*encoding, char \\*\\*buffer]"
msgstr ""

#: ../../../c-api/arg.rst:164
msgid ""
"Same as ``es#`` except that string objects are passed through without "
"recoding them. Instead, the implementation assumes that the string object "
"uses the encoding passed in as parameter."
msgstr ""

#: ../../../c-api/arg.rst:170
msgid "``b`` (integer) [unsigned char]"
msgstr ""

#: ../../../c-api/arg.rst:169
msgid ""
"Convert a nonnegative Python integer to an unsigned tiny int, stored in a C :"
"ctype:`unsigned char`."
msgstr ""

#: ../../../c-api/arg.rst:174
msgid "``B`` (integer) [unsigned char]"
msgstr ""

#: ../../../c-api/arg.rst:173
msgid ""
"Convert a Python integer to a tiny int without overflow checking, stored in "
"a C :ctype:`unsigned char`."
msgstr ""

#: ../../../c-api/arg.rst:177
msgid "``h`` (integer) [short int]"
msgstr ""

#: ../../../c-api/arg.rst:177
msgid "Convert a Python integer to a C :ctype:`short int`."
msgstr ""

#: ../../../c-api/arg.rst:181
msgid "``H`` (integer) [unsigned short int]"
msgstr ""

#: ../../../c-api/arg.rst:180
msgid ""
"Convert a Python integer to a C :ctype:`unsigned short int`, without "
"overflow checking."
msgstr ""

#: ../../../c-api/arg.rst:184
msgid "``i`` (integer) [int]"
msgstr ""

#: ../../../c-api/arg.rst:184
msgid "Convert a Python integer to a plain C :ctype:`int`."
msgstr ""

#: ../../../c-api/arg.rst:188
msgid "``I`` (integer) [unsigned int]"
msgstr ""

#: ../../../c-api/arg.rst:187
msgid ""
"Convert a Python integer to a C :ctype:`unsigned int`, without overflow "
"checking."
msgstr ""

#: ../../../c-api/arg.rst:191
msgid "``l`` (integer) [long int]"
msgstr ""

#: ../../../c-api/arg.rst:191
msgid "Convert a Python integer to a C :ctype:`long int`."
msgstr ""

#: ../../../c-api/arg.rst:195
msgid "``k`` (integer) [unsigned long]"
msgstr ""

#: ../../../c-api/arg.rst:194
msgid ""
"Convert a Python integer to a C :ctype:`unsigned long` without overflow "
"checking."
msgstr ""

#: ../../../c-api/arg.rst:200
msgid "``L`` (integer) [PY_LONG_LONG]"
msgstr ""

#: ../../../c-api/arg.rst:198
msgid ""
"Convert a Python integer to a C :ctype:`long long`.  This format is only "
"available on platforms that support :ctype:`long long` (or :ctype:`_int64` "
"on Windows)."
msgstr ""

#: ../../../c-api/arg.rst:205
msgid "``K`` (integer) [unsigned PY_LONG_LONG]"
msgstr ""

#: ../../../c-api/arg.rst:203
msgid ""
"Convert a Python integer to a C :ctype:`unsigned long long` without overflow "
"checking.  This format is only available on platforms that support :ctype:"
"`unsigned long long` (or :ctype:`unsigned _int64` on Windows)."
msgstr ""

#: ../../../c-api/arg.rst:208
msgid "``n`` (integer) [Py_ssize_t]"
msgstr ""

#: ../../../c-api/arg.rst:208
msgid "Convert a Python integer to a C :ctype:`Py_ssize_t`."
msgstr ""

#: ../../../c-api/arg.rst:212
msgid "``c`` (string of length 1) [char]"
msgstr ""

#: ../../../c-api/arg.rst:211
msgid ""
"Convert a Python character, represented as a string of length 1, to a C :"
"ctype:`char`."
msgstr ""

#: ../../../c-api/arg.rst:215
msgid "``f`` (float) [float]"
msgstr ""

#: ../../../c-api/arg.rst:215
msgid "Convert a Python floating point number to a C :ctype:`float`."
msgstr ""

#: ../../../c-api/arg.rst:218
msgid "``d`` (float) [double]"
msgstr ""

#: ../../../c-api/arg.rst:218
msgid "Convert a Python floating point number to a C :ctype:`double`."
msgstr ""

#: ../../../c-api/arg.rst:221
msgid "``D`` (complex) [Py_complex]"
msgstr ""

#: ../../../c-api/arg.rst:221
msgid "Convert a Python complex number to a C :ctype:`Py_complex` structure."
msgstr ""

#: ../../../c-api/arg.rst:226
msgid "``O`` (object) [PyObject \\*]"
msgstr ""

#: ../../../c-api/arg.rst:224
msgid ""
"Store a Python object (without any conversion) in a C object pointer.  The C "
"program thus receives the actual object that was passed.  The object's "
"reference count is not increased.  The pointer stored is not *NULL*."
msgstr ""

#: ../../../c-api/arg.rst:233
msgid "``O!`` (object) [*typeobject*, PyObject \\*]"
msgstr ""

#: ../../../c-api/arg.rst:229
msgid ""
"Store a Python object in a C object pointer.  This is similar to ``O``, but "
"takes two C arguments: the first is the address of a Python type object, the "
"second is the address of the C variable (of type :ctype:`PyObject\\*`) into "
"which the object pointer is stored.  If the Python object does not have the "
"required type, :exc:`TypeError` is raised."
msgstr ""

#: ../../../c-api/arg.rst:247
msgid "``O&`` (object) [*converter*, *anything*]"
msgstr ""

#: ../../../c-api/arg.rst:236
msgid ""
"Convert a Python object to a C variable through a *converter* function.  "
"This takes two arguments: the first is a function, the second is the address "
"of a C variable (of arbitrary type), converted to :ctype:`void \\*`.  The "
"*converter* function in turn is called as follows::"
msgstr ""

#: ../../../c-api/arg.rst:241
msgid "status = converter(object, address);"
msgstr ""

#: ../../../c-api/arg.rst:243
msgid ""
"where *object* is the Python object to be converted and *address* is the :"
"ctype:`void\\*` argument that was passed to the :cfunc:`PyArg_Parse\\*` "
"function. The returned *status* should be ``1`` for a successful conversion "
"and ``0`` if the conversion has failed.  When the conversion fails, the "
"*converter* function should raise an exception and leave the content of "
"*address* unmodified."
msgstr ""

#: ../../../c-api/arg.rst:252
msgid "``S`` (string) [PyStringObject \\*]"
msgstr ""

#: ../../../c-api/arg.rst:250
msgid ""
"Like ``O`` but requires that the Python object is a string object.  Raises :"
"exc:`TypeError` if the object is not a string object.  The C variable may "
"also be declared as :ctype:`PyObject\\*`."
msgstr ""

#: ../../../c-api/arg.rst:257
msgid "``U`` (Unicode string) [PyUnicodeObject \\*]"
msgstr ""

#: ../../../c-api/arg.rst:255
msgid ""
"Like ``O`` but requires that the Python object is a Unicode object.  Raises :"
"exc:`TypeError` if the object is not a Unicode object.  The C variable may "
"also be declared as :ctype:`PyObject\\*`."
msgstr ""

#: ../../../c-api/arg.rst:264
msgid "``t#`` (read-only character buffer) [char \\*, int]"
msgstr ""

#: ../../../c-api/arg.rst:260
msgid ""
"Like ``s#``, but accepts any object which implements the read-only buffer "
"interface.  The :ctype:`char\\*` variable is set to point to the first byte "
"of the buffer, and the :ctype:`int` is set to the length of the buffer.  "
"Only single-segment buffer objects are accepted; :exc:`TypeError` is raised "
"for all others."
msgstr ""

#: ../../../c-api/arg.rst:270
msgid "``w`` (read-write character buffer) [char \\*]"
msgstr ""

#: ../../../c-api/arg.rst:267
msgid ""
"Similar to ``s``, but accepts any object which implements the read-write "
"buffer interface.  The caller must determine the length of the buffer by "
"other means, or use ``w#`` instead.  Only single-segment buffer objects are "
"accepted; :exc:`TypeError` is raised for all others."
msgstr ""

#: ../../../c-api/arg.rst:273
msgid "``w*`` (read-write byte-oriented buffer) [Py_buffer \\*]"
msgstr ""

#: ../../../c-api/arg.rst:273
msgid "This is to ``w`` what ``s*`` is to ``s``."
msgstr ""

#: ../../../c-api/arg.rst:280
msgid "``w#`` (read-write character buffer) [char \\*, int]"
msgstr ""

#: ../../../c-api/arg.rst:276
msgid ""
"Like ``s#``, but accepts any object which implements the read-write buffer "
"interface.  The :ctype:`char \\*` variable is set to point to the first byte "
"of the buffer, and the :ctype:`int` is set to the length of the buffer.  "
"Only single-segment buffer objects are accepted; :exc:`TypeError` is raised "
"for all others."
msgstr ""

#: ../../../c-api/arg.rst:285
msgid "``(items)`` (tuple) [*matching-items*]"
msgstr ""

#: ../../../c-api/arg.rst:283
msgid ""
"The object must be a Python sequence whose length is the number of format "
"units in *items*.  The C arguments must correspond to the individual format "
"units in *items*.  Format units for sequences may be nested."
msgstr ""

#: ../../../c-api/arg.rst:287
msgid ""
"It is possible to pass \"long\" integers (integers whose value exceeds the "
"platform's :const:`LONG_MAX`) however no proper range checking is done --- "
"the most significant bits are silently truncated when the receiving field is "
"too small to receive the value (actually, the semantics are inherited from "
"downcasts in C --- your mileage may vary)."
msgstr ""

#: ../../../c-api/arg.rst:293
msgid ""
"A few other characters have a meaning in a format string.  These may not "
"occur inside nested parentheses.  They are:"
msgstr ""

#: ../../../c-api/arg.rst:301
msgid "``|``"
msgstr ""

#: ../../../c-api/arg.rst:297
msgid ""
"Indicates that the remaining arguments in the Python argument list are "
"optional. The C variables corresponding to optional arguments should be "
"initialized to their default value --- when an optional argument is not "
"specified, :cfunc:`PyArg_ParseTuple` does not touch the contents of the "
"corresponding C variable(s)."
msgstr ""

#: ../../../c-api/arg.rst:306
msgid "``:``"
msgstr ""

#: ../../../c-api/arg.rst:304
msgid ""
"The list of format units ends here; the string after the colon is used as "
"the function name in error messages (the \"associated value\" of the "
"exception that :cfunc:`PyArg_ParseTuple` raises)."
msgstr ""

#: ../../../c-api/arg.rst:311
msgid "``;``"
msgstr ""

#: ../../../c-api/arg.rst:309
msgid ""
"The list of format units ends here; the string after the semicolon is used "
"as the error message *instead* of the default error message.  ``:`` and ``;"
"`` mutually exclude each other."
msgstr ""

#: ../../../c-api/arg.rst:313
msgid ""
"Note that any Python object references which are provided to the caller are "
"*borrowed* references; do not decrement their reference count!"
msgstr ""

#: ../../../c-api/arg.rst:316
msgid ""
"Additional arguments passed to these functions must be addresses of "
"variables whose type is determined by the format string; these are used to "
"store values from the input tuple.  There are a few cases, as described in "
"the list of format units above, where these parameters are used as input "
"values; they should match what is specified for the corresponding format "
"unit in that case."
msgstr ""

#: ../../../c-api/arg.rst:322
msgid ""
"For the conversion to succeed, the *arg* object must match the format and "
"the format must be exhausted.  On success, the :cfunc:`PyArg_Parse\\*` "
"functions return true, otherwise they return false and raise an appropriate "
"exception. When the :cfunc:`PyArg_Parse\\*` functions fail due to conversion "
"failure in one of the format units, the variables at the addresses "
"corresponding to that and the following format units are left untouched."
msgstr ""

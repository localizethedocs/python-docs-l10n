# SOME DESCRIPTIVE TITLE.
# Copyright (C) 1990-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-10 15:11+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../library/ssl.rst:3
msgid ":mod:`ssl` --- SSL wrapper for socket objects"
msgstr ""

#: ../../../library/ssl.rst:16
msgid ""
"This module provides access to Transport Layer Security (often known as "
"\"Secure Sockets Layer\") encryption and peer authentication facilities for "
"network sockets, both client-side and server-side. This module uses the "
"OpenSSL library. It is available on all modern Unix systems, Windows, Mac OS "
"X, and probably additional platforms, as long as OpenSSL is installed on "
"that platform."
msgstr ""

#: ../../../library/ssl.rst:25
msgid ""
"Some behavior may be platform dependent, since calls are made to the "
"operating system socket APIs.  The installed version of OpenSSL may also "
"cause variations in behavior."
msgstr ""

#: ../../../library/ssl.rst:29
msgid ""
"This section documents the objects and functions in the ``ssl`` module; for "
"more general information about TLS, SSL, and certificates, the reader is "
"referred to the documents in the \"See Also\" section at the bottom."
msgstr ""

#: ../../../library/ssl.rst:34
msgid ""
"This module provides a class, :class:`ssl.SSLSocket`, which is derived from "
"the :class:`socket.socket` type, and provides a socket-like wrapper that "
"also encrypts and decrypts the data going over the socket with SSL.  It "
"supports additional :meth:`read` and :meth:`write` methods, along with a "
"method, :meth:`getpeercert`, to retrieve the certificate of the other side "
"of the connection, and a method, :meth:`cipher`, to retrieve the cipher "
"being used for the secure connection."
msgstr ""

#: ../../../library/ssl.rst:44
msgid "Functions, Constants, and Exceptions"
msgstr ""

#: ../../../library/ssl.rst:48
msgid ""
"Raised to signal an error from the underlying SSL implementation.  This "
"signifies some problem in the higher-level encryption and authentication "
"layer that's superimposed on the underlying network connection.  This error "
"is a subtype of :exc:`socket.error`, which in turn is a subtype of :exc:"
"`IOError`."
msgstr ""

#: ../../../library/ssl.rst:56
msgid ""
"Takes an instance ``sock`` of :class:`socket.socket`, and returns an "
"instance of :class:`ssl.SSLSocket`, a subtype of :class:`socket.socket`, "
"which wraps the underlying socket in an SSL context. For client-side "
"sockets, the context construction is lazy; if the underlying socket isn't "
"connected yet, the context construction will be performed after :meth:"
"`connect` is called on the socket.  For server-side sockets, if the socket "
"has no remote peer, it is assumed to be a listening socket, and the server-"
"side SSL wrapping is automatically performed on client connections accepted "
"via the :meth:`accept` method.  :func:`wrap_socket` may raise :exc:"
"`SSLError`."
msgstr ""

#: ../../../library/ssl.rst:65
msgid ""
"The ``keyfile`` and ``certfile`` parameters specify optional files which "
"contain a certificate to be used to identify the local side of the "
"connection.  See the discussion of :ref:`ssl-certificates` for more "
"information on how the certificate is stored in the ``certfile``."
msgstr ""

#: ../../../library/ssl.rst:69
msgid ""
"Often the private key is stored in the same file as the certificate; in this "
"case, only the ``certfile`` parameter need be passed.  If the private key is "
"stored in a separate file, both parameters must be used. If the private key "
"is stored in the ``certfile``, it should come before the first certificate "
"in the certificate chain::"
msgstr ""

#: ../../../library/ssl.rst:75
msgid ""
"-----BEGIN RSA PRIVATE KEY-----\n"
"... (private key in base64 encoding) ...\n"
"-----END RSA PRIVATE KEY-----\n"
"-----BEGIN CERTIFICATE-----\n"
"... (certificate in base64 PEM encoding) ...\n"
"-----END CERTIFICATE-----"
msgstr ""

#: ../../../library/ssl.rst:82
msgid ""
"The parameter ``server_side`` is a boolean which identifies whether server-"
"side or client-side behavior is desired from this socket."
msgstr ""

#: ../../../library/ssl.rst:85
msgid ""
"The parameter ``cert_reqs`` specifies whether a certificate is required from "
"the other side of the connection, and whether it will be validated if "
"provided.  It must be one of the three values :const:`CERT_NONE` "
"(certificates ignored), :const:`CERT_OPTIONAL` (not required, but validated "
"if provided), or :const:`CERT_REQUIRED` (required and validated).  If the "
"value of this parameter is not :const:`CERT_NONE`, then the ``ca_certs`` "
"parameter must point to a file of CA certificates."
msgstr ""

#: ../../../library/ssl.rst:93
msgid ""
"The ``ca_certs`` file contains a set of concatenated \"certification "
"authority\" certificates, which are used to validate certificates passed "
"from the other end of the connection. See the discussion of :ref:`ssl-"
"certificates` for more information about how to arrange the certificates in "
"this file."
msgstr ""

#: ../../../library/ssl.rst:98
msgid ""
"The parameter ``ssl_version`` specifies which version of the SSL protocol to "
"use. Typically, the server chooses a particular protocol version, and the "
"client must adapt to the server's choice.  Most of the versions are not "
"interoperable with the other versions.  If not specified, for client-side "
"operation, the default SSL version is SSLv3; for server-side operation, "
"SSLv23.  These version selections provide the most compatibility with other "
"versions."
msgstr ""

#: ../../../library/ssl.rst:105
msgid ""
"Here's a table showing which versions in a client (down the side) can "
"connect to which versions in a server (along the top):"
msgstr ""

#: ../../../library/ssl.rst:111
msgid "*client* / **server**"
msgstr ""

#: ../../../library/ssl.rst:111
msgid "**SSLv2**"
msgstr ""

#: ../../../library/ssl.rst:111
msgid "**SSLv3**"
msgstr ""

#: ../../../library/ssl.rst:111
msgid "**SSLv23**"
msgstr ""

#: ../../../library/ssl.rst:111
msgid "**TLSv1**"
msgstr ""

#: ../../../library/ssl.rst:113
msgid "*SSLv2*"
msgstr ""

#: ../../../library/ssl.rst:113 ../../../library/ssl.rst:114
#: ../../../library/ssl.rst:115 ../../../library/ssl.rst:116
msgid "yes"
msgstr ""

#: ../../../library/ssl.rst:113 ../../../library/ssl.rst:114
#: ../../../library/ssl.rst:115 ../../../library/ssl.rst:116
msgid "no"
msgstr ""

#: ../../../library/ssl.rst:113
msgid "yes*"
msgstr ""

#: ../../../library/ssl.rst:114
msgid "*SSLv3*"
msgstr ""

#: ../../../library/ssl.rst:115
msgid "*SSLv23*"
msgstr ""

#: ../../../library/ssl.rst:116
msgid "*TLSv1*"
msgstr ""

#: ../../../library/ssl.rst:119
msgid ""
"In some older versions of OpenSSL (for instance, 0.9.7l on OS X 10.4), an "
"SSLv2 client could not connect to an SSLv23 server."
msgstr ""

#: ../../../library/ssl.rst:122
msgid ""
"The parameter ``do_handshake_on_connect`` specifies whether to do the SSL "
"handshake automatically after doing a :meth:`socket.connect`, or whether the "
"application program will call it explicitly, by invoking the :meth:"
"`SSLSocket.do_handshake` method.  Calling :meth:`SSLSocket.do_handshake` "
"explicitly gives the program control over the blocking behavior of the "
"socket I/O involved in the handshake."
msgstr ""

#: ../../../library/ssl.rst:128
msgid ""
"The parameter ``suppress_ragged_eofs`` specifies how the :meth:`SSLSocket."
"read` method should signal unexpected EOF from the other end of the "
"connection.  If specified as :const:`True` (the default), it returns a "
"normal EOF in response to unexpected EOF errors raised from the underlying "
"socket; if :const:`False`, it will raise the exceptions back to the caller."
msgstr ""

#: ../../../library/ssl.rst:136
msgid ""
"Returns True if the SSL pseudo-random number generator has been seeded with "
"'enough' randomness, and False otherwise.  You can use :func:`ssl.RAND_egd` "
"and :func:`ssl.RAND_add` to increase the randomness of the pseudo-random "
"number generator."
msgstr ""

#: ../../../library/ssl.rst:143
msgid ""
"If you are running an entropy-gathering daemon (EGD) somewhere, and ``path`` "
"is the pathname of a socket connection open to it, this will read 256 bytes "
"of randomness from the socket, and add it to the SSL pseudo-random number "
"generator to increase the security of generated secret keys.  This is "
"typically only necessary on systems without better sources of randomness."
msgstr ""

#: ../../../library/ssl.rst:149
msgid ""
"See http://egd.sourceforge.net/ or http://prngd.sourceforge.net/ for sources "
"of entropy-gathering daemons."
msgstr ""

#: ../../../library/ssl.rst:154
msgid ""
"Mixes the given ``bytes`` into the SSL pseudo-random number generator. The "
"parameter ``entropy`` (a float) is a lower bound on the entropy contained in "
"string (so you can always use :const:`0.0`). See :rfc:`1750` for more "
"information on sources of entropy."
msgstr ""

#: ../../../library/ssl.rst:161
msgid ""
"Returns a floating-point value containing a normal seconds-after-the-epoch "
"time value, given the time-string representing the \"notBefore\" or "
"\"notAfter\" date from a certificate."
msgstr ""

#: ../../../library/ssl.rst:165
msgid "Here's an example::"
msgstr ""

#: ../../../library/ssl.rst:167
msgid ""
">>> import ssl\n"
">>> ssl.cert_time_to_seconds(\"May  9 00:00:00 2007 GMT\")\n"
"1178694000.0\n"
">>> import time\n"
">>> time.ctime(ssl.cert_time_to_seconds(\"May  9 00:00:00 2007 GMT\"))\n"
"'Wed May  9 00:00:00 2007'\n"
">>>"
msgstr ""

#: ../../../library/ssl.rst:177
msgid ""
"Given the address ``addr`` of an SSL-protected server, as a (*hostname*, "
"*port-number*) pair, fetches the server's certificate, and returns it as a "
"PEM-encoded string.  If ``ssl_version`` is specified, uses that version of "
"the SSL protocol to attempt to connect to the server.  If ``ca_certs`` is "
"specified, it should be a file containing a list of root certificates, the "
"same format as used for the same parameter in :func:`wrap_socket`.  The call "
"will attempt to validate the server certificate against that set of root "
"certificates, and will fail if the validation attempt fails."
msgstr ""

#: ../../../library/ssl.rst:189
msgid ""
"Given a certificate as a DER-encoded blob of bytes, returns a PEM-encoded "
"string version of the same certificate."
msgstr ""

#: ../../../library/ssl.rst:194
msgid ""
"Given a certificate as an ASCII PEM string, returns a DER-encoded sequence "
"of bytes for that same certificate."
msgstr ""

#: ../../../library/ssl.rst:199
msgid ""
"Value to pass to the ``cert_reqs`` parameter to :func:`sslobject` when no "
"certificates will be required or validated from the other side of the socket "
"connection."
msgstr ""

#: ../../../library/ssl.rst:205
msgid ""
"Value to pass to the ``cert_reqs`` parameter to :func:`sslobject` when no "
"certificates will be required from the other side of the socket connection, "
"but if they are provided, will be validated. Note that use of this setting "
"requires a valid certificate validation file also be passed as a value of "
"the ``ca_certs`` parameter."
msgstr ""

#: ../../../library/ssl.rst:214
msgid ""
"Value to pass to the ``cert_reqs`` parameter to :func:`sslobject` when "
"certificates will be required from the other side of the socket connection.  "
"Note that use of this setting requires a valid certificate validation file "
"also be passed as a value of the ``ca_certs`` parameter."
msgstr ""

#: ../../../library/ssl.rst:222
msgid "Selects SSL version 2 as the channel encryption protocol."
msgstr ""

#: ../../../library/ssl.rst:226
msgid ""
"Selects SSL version 2 or 3 as the channel encryption protocol. This is a "
"setting to use with servers for maximum compatibility with the other end of "
"an SSL connection, but it may cause the specific ciphers chosen for the "
"encryption to be of fairly low quality."
msgstr ""

#: ../../../library/ssl.rst:234
msgid ""
"Selects SSL version 3 as the channel encryption protocol. For clients, this "
"is the maximally compatible SSL variant."
msgstr ""

#: ../../../library/ssl.rst:239
msgid ""
"Selects TLS version 1 as the channel encryption protocol.  This is the most "
"modern version, and probably the best choice for maximum protection, if both "
"sides can speak it."
msgstr ""

#: ../../../library/ssl.rst:245
msgid "SSLSocket Objects"
msgstr ""

#: ../../../library/ssl.rst:249
msgid ""
"Reads up to ``nbytes`` bytes from the SSL-encrypted channel and returns "
"them. If the ``buffer`` is specified, it will attempt to read into the "
"buffer the minimum of the size of the buffer and ``nbytes``, if that is "
"specified. If no buffer is specified, an immutable buffer is allocated and "
"returned with the data read from the socket."
msgstr ""

#: ../../../library/ssl.rst:257
msgid ""
"Writes the ``data`` to the other side of the connection, using the SSL "
"channel to encrypt.  Returns the number of bytes written."
msgstr ""

#: ../../../library/ssl.rst:262
msgid ""
"Performs the SSL setup handshake.  If the socket is non-blocking, this "
"method may raise :exc:`SSLError` with the value of the exception instance's "
"``args[0]`` being either :const:`SSL_ERROR_WANT_READ` or :const:"
"`SSL_ERROR_WANT_WRITE`, and should be called again until it stops raising "
"those exceptions.  Here's an example of how to do that::"
msgstr ""

#: ../../../library/ssl.rst:270
msgid ""
"while True:\n"
"    try:\n"
"        sock.do_handshake()\n"
"        break\n"
"    except ssl.SSLError as err:\n"
"        if err.args[0] == ssl.SSL_ERROR_WANT_READ:\n"
"            select.select([sock], [], [])\n"
"        elif err.args[0] == ssl.SSL_ERROR_WANT_WRITE:\n"
"            select.select([], [sock], [])\n"
"        else:\n"
"            raise"
msgstr ""

#: ../../../library/ssl.rst:284 ../../../library/ssl.rst:340
msgid ""
"Performs the SSL shutdown handshake, which removes the TLS layer from the "
"underlying socket, and returns the underlying socket object.  This can be "
"used to go from encrypted operation over a connection to unencrypted.  The "
"returned socket should always be used for further communication with the "
"other side of the connection, rather than the original socket"
msgstr ""

#: ../../../library/ssl.rst:293
msgid ""
"If there is no certificate for the peer on the other end of the connection, "
"returns ``None``."
msgstr ""

#: ../../../library/ssl.rst:296
msgid ""
"If the the parameter ``binary_form`` is :const:`False`, and a certificate "
"was received from the peer, this method returns a :class:`dict` instance.  "
"If the certificate was not validated, the dict is empty.  If the certificate "
"was validated, it returns a dict with the keys ``subject`` (the principal "
"for which the certificate was issued), and ``notAfter`` (the time after "
"which the certificate should not be trusted).  The certificate was already "
"validated, so the ``notBefore`` and ``issuer`` fields are not returned.  If "
"a certificate contains an instance of the *Subject Alternative Name* "
"extension (see :rfc:`3280`), there will also be a ``subjectAltName`` key in "
"the dictionary."
msgstr ""

#: ../../../library/ssl.rst:308
msgid ""
"The \"subject\" field is a tuple containing the sequence of relative "
"distinguished names (RDNs) given in the certificate's data structure for the "
"principal, and each RDN is a sequence of name-value pairs::"
msgstr ""

#: ../../../library/ssl.rst:313
msgid ""
"{'notAfter': 'Feb 16 16:54:50 2013 GMT',\n"
" 'subject': ((('countryName', u'US'),),\n"
"             (('stateOrProvinceName', u'Delaware'),),\n"
"             (('localityName', u'Wilmington'),),\n"
"             (('organizationName', u'Python Software Foundation'),),\n"
"             (('organizationalUnitName', u'SSL'),),\n"
"             (('commonName', u'somemachine.python.org'),))}"
msgstr ""

#: ../../../library/ssl.rst:321
msgid ""
"If the ``binary_form`` parameter is :const:`True`, and a certificate was "
"provided, this method returns the DER-encoded form of the entire certificate "
"as a sequence of bytes, or :const:`None` if the peer did not provide a "
"certificate.  This return value is independent of validation; if validation "
"was required (:const:`CERT_OPTIONAL` or :const:`CERT_REQUIRED`), it will "
"have been validated, but if :const:`CERT_NONE` was used to establish the "
"connection, the certificate, if present, will not have been validated."
msgstr ""

#: ../../../library/ssl.rst:332
msgid ""
"Returns a three-value tuple containing the name of the cipher being used, "
"the version of the SSL protocol that defines its use, and the number of "
"secret bits being used.  If no connection has been established, returns "
"``None``."
msgstr ""

#: ../../../library/ssl.rst:354
msgid "Certificates"
msgstr ""

#: ../../../library/ssl.rst:356
msgid ""
"Certificates in general are part of a public-key / private-key system.  In "
"this system, each *principal*, (which may be a machine, or a person, or an "
"organization) is assigned a unique two-part encryption key. One part of the "
"key is public, and is called the *public key*; the other part is kept "
"secret, and is called the *private key*.  The two parts are related, in that "
"if you encrypt a message with one of the parts, you can decrypt it with the "
"other part, and **only** with the other part."
msgstr ""

#: ../../../library/ssl.rst:362
msgid ""
"A certificate contains information about two principals.  It contains the "
"name of a *subject*, and the subject's public key.  It also contains a "
"statement by a second principal, the *issuer*, that the subject is who he "
"claims to be, and that this is indeed the subject's public key.  The "
"issuer's statement is signed with the issuer's private key, which only the "
"issuer knows.  However, anyone can verify the issuer's statement by finding "
"the issuer's public key, decrypting the statement with it, and comparing it "
"to the other information in the certificate.  The certificate also contains "
"information about the time period over which it is valid.  This is expressed "
"as two fields, called \"notBefore\" and \"notAfter\"."
msgstr ""

#: ../../../library/ssl.rst:374
msgid ""
"In the Python use of certificates, a client or server can use a certificate "
"to prove who they are.  The other side of a network connection can also be "
"required to produce a certificate, and that certificate can be validated to "
"the satisfaction of the client or server that requires such validation. The "
"connection attempt can be set to raise an exception if the validation "
"fails.  Validation is done automatically, by the underlying OpenSSL "
"framework; the application need not concern itself with its mechanics. But "
"the application does usually need to provide sets of certificates to allow "
"this process to take place."
msgstr ""

#: ../../../library/ssl.rst:386
msgid ""
"Python uses files to contain certificates.  They should be formatted as "
"\"PEM\" (see :rfc:`1422`), which is a base-64 encoded form wrapped with a "
"header line and a footer line::"
msgstr ""

#: ../../../library/ssl.rst:390
msgid ""
"-----BEGIN CERTIFICATE-----\n"
"... (certificate in base64 PEM encoding) ...\n"
"-----END CERTIFICATE-----"
msgstr ""

#: ../../../library/ssl.rst:394
msgid ""
"The Python files which contain certificates can contain a sequence of "
"certificates, sometimes called a *certificate chain*.  This chain should "
"start with the specific certificate for the principal who \"is\" the client "
"or server, and then the certificate for the issuer of that certificate, and "
"then the certificate for the issuer of *that* certificate, and so on up the "
"chain till you get to a certificate which is *self-signed*, that is, a "
"certificate which has the same subject and issuer, sometimes called a *root "
"certificate*.  The certificates should just be concatenated together in the "
"certificate file.  For example, suppose we had a three certificate chain, "
"from our server certificate to the certificate of the certification "
"authority that signed our server certificate, to the root certificate of the "
"agency which issued the certification authority's certificate::"
msgstr ""

#: ../../../library/ssl.rst:408
msgid ""
"-----BEGIN CERTIFICATE-----\n"
"... (certificate for your server)...\n"
"-----END CERTIFICATE-----\n"
"-----BEGIN CERTIFICATE-----\n"
"... (the certificate for the CA)...\n"
"-----END CERTIFICATE-----\n"
"-----BEGIN CERTIFICATE-----\n"
"... (the root certificate for the CA's issuer)...\n"
"-----END CERTIFICATE-----"
msgstr ""

#: ../../../library/ssl.rst:418
msgid ""
"If you are going to require validation of the other side of the connection's "
"certificate, you need to provide a \"CA certs\" file, filled with the "
"certificate chains for each issuer you are willing to trust.  Again, this "
"file just contains these chains concatenated together.  For validation, "
"Python will use the first chain it finds in the file which matches. Some "
"\"standard\" root certificates are available from various certification "
"authorities: `CACert.org <http://www.cacert.org/index.php?id=3>`_, `Thawte "
"<http://www.thawte.com/roots/>`_, `Verisign <http://www.verisign.com/support/"
"roots.html>`_, `Positive SSL <http://www.PositiveSSL.com/ssl-certificate-"
"support/cert_installation/UTN-USERFirst-Hardware.crt>`_ (used by python."
"org), `Equifax and GeoTrust <http://www.geotrust.com/resources/"
"root_certificates/index.asp>`_."
msgstr ""

#: ../../../library/ssl.rst:431
msgid ""
"In general, if you are using SSL3 or TLS1, you don't need to put the full "
"chain in your \"CA certs\" file; you only need the root certificates, and "
"the remote peer is supposed to furnish the other certificates necessary to "
"chain from its certificate to a root certificate. See :rfc:`4158` for more "
"discussion of the way in which certification chains can be built."
msgstr ""

#: ../../../library/ssl.rst:439
msgid ""
"If you are going to create a server that provides SSL-encrypted connection "
"services, you will need to acquire a certificate for that service.  There "
"are many ways of acquiring appropriate certificates, such as buying one from "
"a certification authority.  Another common practice is to generate a self-"
"signed certificate.  The simplest way to do this is with the OpenSSL "
"package, using something like the following::"
msgstr ""

#: ../../../library/ssl.rst:447
msgid ""
"% openssl req -new -x509 -days 365 -nodes -out cert.pem -keyout cert.pem\n"
"Generating a 1024 bit RSA private key\n"
".......++++++\n"
".............................++++++\n"
"writing new private key to 'cert.pem'\n"
"-----\n"
"You are about to be asked to enter information that will be incorporated\n"
"into your certificate request.\n"
"What you are about to enter is what is called a Distinguished Name or a DN.\n"
"There are quite a few fields but you can leave some blank\n"
"For some fields there will be a default value,\n"
"If you enter '.', the field will be left blank.\n"
"-----\n"
"Country Name (2 letter code) [AU]:US\n"
"State or Province Name (full name) [Some-State]:MyState\n"
"Locality Name (eg, city) []:Some City\n"
"Organization Name (eg, company) [Internet Widgits Pty Ltd]:My Organization, "
"Inc.\n"
"Organizational Unit Name (eg, section) []:My Group\n"
"Common Name (eg, YOUR name) []:myserver.mygroup.myorganization.com\n"
"Email Address []:ops@myserver.mygroup.myorganization.com\n"
"%"
msgstr ""

#: ../../../library/ssl.rst:469
msgid ""
"The disadvantage of a self-signed certificate is that it is its own root "
"certificate, and no one else will have it in their cache of known (and "
"trusted) root certificates."
msgstr ""

#: ../../../library/ssl.rst:475
msgid "Examples"
msgstr ""

#: ../../../library/ssl.rst:478
msgid "Testing for SSL support"
msgstr ""

#: ../../../library/ssl.rst:480
msgid ""
"To test for the presence of SSL support in a Python installation, user code "
"should use the following idiom::"
msgstr ""

#: ../../../library/ssl.rst:482
msgid ""
"try:\n"
"   import ssl\n"
"except ImportError:\n"
"   pass\n"
"else:\n"
"   [ do something that requires SSL support ]"
msgstr ""

#: ../../../library/ssl.rst:490
msgid "Client-side operation"
msgstr ""

#: ../../../library/ssl.rst:492
msgid ""
"This example connects to an SSL server, prints the server's address and "
"certificate, sends some bytes, and reads part of the response::"
msgstr ""

#: ../../../library/ssl.rst:495
msgid ""
"import socket, ssl, pprint\n"
"\n"
"s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n"
"\n"
"# require a certificate from the server\n"
"ssl_sock = ssl.wrap_socket(s,\n"
"                           ca_certs=\"/etc/ca_certs_file\",\n"
"                           cert_reqs=ssl.CERT_REQUIRED)\n"
"\n"
"ssl_sock.connect(('www.verisign.com', 443))\n"
"\n"
"print(repr(ssl_sock.getpeername()))\n"
"pprint.pprint(ssl_sock.getpeercert())\n"
"print(pprint.pformat(ssl_sock.getpeercert()))\n"
"\n"
"# Set a simple HTTP request -- use http.client in actual code.\n"
"ssl_sock.write(\"\"\"GET / HTTP/1.0\\r\n"
"Host: www.verisign.com\\r\\n\\r\\n\"\"\")\n"
"\n"
"# Read a chunk of data.  Will not necessarily\n"
"# read all the data returned by the server.\n"
"data = ssl_sock.read()\n"
"\n"
"# note that closing the SSLSocket will also close the underlying socket\n"
"ssl_sock.close()"
msgstr ""

#: ../../../library/ssl.rst:521
msgid ""
"As of September 6, 2007, the certificate printed by this program looked like "
"this::"
msgstr ""

#: ../../../library/ssl.rst:524
msgid ""
"{'notAfter': 'May  8 23:59:59 2009 GMT',\n"
" 'subject': ((('serialNumber', u'2497886'),),\n"
"             (('1.3.6.1.4.1.311.60.2.1.3', u'US'),),\n"
"             (('1.3.6.1.4.1.311.60.2.1.2', u'Delaware'),),\n"
"             (('countryName', u'US'),),\n"
"             (('postalCode', u'94043'),),\n"
"             (('stateOrProvinceName', u'California'),),\n"
"             (('localityName', u'Mountain View'),),\n"
"             (('streetAddress', u'487 East Middlefield Road'),),\n"
"             (('organizationName', u'VeriSign, Inc.'),),\n"
"             (('organizationalUnitName',\n"
"               u'Production Security Services'),),\n"
"             (('organizationalUnitName',\n"
"               u'Terms of use at www.verisign.com/rpa (c)06'),),\n"
"             (('commonName', u'www.verisign.com'),))}"
msgstr ""

#: ../../../library/ssl.rst:540
msgid "which is a fairly poorly-formed ``subject`` field."
msgstr ""

#: ../../../library/ssl.rst:543
msgid "Server-side operation"
msgstr ""

#: ../../../library/ssl.rst:545
msgid ""
"For server operation, typically you'd need to have a server certificate, and "
"private key, each in a file. You'd open a socket, bind it to a port, call :"
"meth:`listen` on it, then start waiting for clients to connect::"
msgstr ""

#: ../../../library/ssl.rst:549
msgid ""
"import socket, ssl\n"
"\n"
"bindsocket = socket.socket()\n"
"bindsocket.bind(('myaddr.mydomain.com', 10023))\n"
"bindsocket.listen(5)"
msgstr ""

#: ../../../library/ssl.rst:555
msgid ""
"When one did, you'd call :meth:`accept` on the socket to get the new socket "
"from the other end, and use :func:`wrap_socket` to create a server-side SSL "
"context for it::"
msgstr ""

#: ../../../library/ssl.rst:558
msgid ""
"while True:\n"
"   newsocket, fromaddr = bindsocket.accept()\n"
"   connstream = ssl.wrap_socket(newsocket,\n"
"                                server_side=True,\n"
"                                certfile=\"mycertfile\",\n"
"                                keyfile=\"mykeyfile\",\n"
"                                ssl_version=ssl.PROTOCOL_TLSv1)\n"
"   deal_with_client(connstream)"
msgstr ""

#: ../../../library/ssl.rst:567
msgid ""
"Then you'd read data from the ``connstream`` and do something with it till "
"you are finished with the client (or the client is finished with you)::"
msgstr ""

#: ../../../library/ssl.rst:569
msgid ""
"def deal_with_client(connstream):\n"
"\n"
"   data = connstream.read()\n"
"   # null data means the client is finished with us\n"
"   while data:\n"
"      if not do_something(connstream, data):\n"
"         # we'll assume do_something returns False\n"
"         # when we're finished with client\n"
"         break\n"
"      data = connstream.read()\n"
"   # finished with client\n"
"   connstream.close()"
msgstr ""

#: ../../../library/ssl.rst:582
msgid "And go back to listening for new client connections."
msgstr ""

#: ../../../library/ssl.rst:588
msgid "Class :class:`socket.socket`"
msgstr ""

#: ../../../library/ssl.rst:588
msgid "Documentation of underlying :mod:`socket` class"
msgstr ""

#: ../../../library/ssl.rst:591
msgid ""
"`Introducing SSL and Certificates using OpenSSL <http://old.pseudonym.org/"
"ssl/wwwj-index.html>`_"
msgstr ""

#: ../../../library/ssl.rst:591
msgid "Frederick J. Hirsch"
msgstr ""

#: ../../../library/ssl.rst:594
msgid ""
"`RFC 1422: Privacy Enhancement for Internet Electronic Mail: Part II: "
"Certificate-Based Key Management <http://www.ietf.org/rfc/rfc1422>`_"
msgstr ""

#: ../../../library/ssl.rst:594
msgid "Steve Kent"
msgstr ""

#: ../../../library/ssl.rst:597
msgid ""
"`RFC 1750: Randomness Recommendations for Security <http://www.ietf.org/rfc/"
"rfc1750>`_"
msgstr ""

#: ../../../library/ssl.rst:597
msgid "D. Eastlake et. al."
msgstr ""

#: ../../../library/ssl.rst:599
msgid ""
"`RFC 3280: Internet X.509 Public Key Infrastructure Certificate and CRL "
"Profile <http://www.ietf.org/rfc/rfc3280>`_"
msgstr ""

#: ../../../library/ssl.rst:600
msgid "Housley et. al."
msgstr ""

#: ../../../library/ssl.rst:12
msgid "OpenSSL"
msgstr ""

#: ../../../library/ssl.rst:12
msgid "(use in module ssl)"
msgstr ""

#: ../../../library/ssl.rst:14
msgid "TLS"
msgstr ""

#: ../../../library/ssl.rst:14
msgid "SSL"
msgstr ""

#: ../../../library/ssl.rst:14
msgid "Transport Layer Security"
msgstr ""

#: ../../../library/ssl.rst:14
msgid "Secure Sockets Layer"
msgstr ""

#: ../../../library/ssl.rst:347
msgid "certificates"
msgstr ""

#: ../../../library/ssl.rst:349
msgid "X509 certificate"
msgstr ""

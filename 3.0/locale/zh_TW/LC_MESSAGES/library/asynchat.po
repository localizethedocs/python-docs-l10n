# SOME DESCRIPTIVE TITLE.
# Copyright (C) 1990-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-11 04:42+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../library/asynchat.rst:3
msgid ":mod:`asynchat` --- Asynchronous socket command/response handler"
msgstr ""

#: ../../../library/asynchat.rst:11
msgid ""
"This module builds on the :mod:`asyncore` infrastructure, simplifying "
"asynchronous clients and servers and making it easier to handle protocols "
"whose elements are terminated by arbitrary strings, or are of variable "
"length. :mod:`asynchat` defines the abstract class :class:`async_chat` that "
"you subclass, providing implementations of the :meth:`collect_incoming_data` "
"and :meth:`found_terminator` methods. It uses the same asynchronous loop as :"
"mod:`asyncore`, and the two types of channel, :class:`asyncore.dispatcher` "
"and :class:`asynchat.async_chat`, can freely be mixed in the channel map. "
"Typically an :class:`asyncore.dispatcher` server channel generates new :"
"class:`asynchat.async_chat` channel objects as it receives incoming "
"connection requests."
msgstr ""

#: ../../../library/asynchat.rst:26
msgid ""
"This class is an abstract subclass of :class:`asyncore.dispatcher`. To make "
"practical use of the code you must subclass :class:`async_chat`, providing "
"meaningful :meth:`collect_incoming_data` and :meth:`found_terminator` "
"methods. The :class:`asyncore.dispatcher` methods can be used, although not "
"all make sense in a message/response context."
msgstr ""

#: ../../../library/asynchat.rst:33
msgid ""
"Like :class:`asyncore.dispatcher`, :class:`async_chat` defines a set of "
"events that are generated by an analysis of socket conditions after a :cfunc:"
"`select` call. Once the polling loop has been started the :class:"
"`async_chat` object's methods are called by the event-processing framework "
"with no action on the part of the programmer."
msgstr ""

#: ../../../library/asynchat.rst:39
msgid ""
"Two class attributes can be modified, to improve performance, or possibly "
"even to conserve memory."
msgstr ""

#: ../../../library/asynchat.rst:45
msgid "The asynchronous input buffer size (default ``4096``)."
msgstr ""

#: ../../../library/asynchat.rst:50
msgid "The asynchronous output buffer size (default ``4096``)."
msgstr ""

#: ../../../library/asynchat.rst:52
msgid ""
"Unlike :class:`asyncore.dispatcher`, :class:`async_chat` allows you to "
"define a first-in-first-out queue (fifo) of *producers*. A producer need "
"have only one method, :meth:`more`, which should return data to be "
"transmitted on the channel. The producer indicates exhaustion (*i.e.* that "
"it contains no more data) by having its :meth:`more` method return the empty "
"string. At this point the :class:`async_chat` object removes the producer "
"from the fifo and starts using the next producer, if any. When the producer "
"fifo is empty the :meth:`handle_write` method does nothing. You use the "
"channel object's :meth:`set_terminator` method to describe how to recognize "
"the end of, or an important breakpoint in, an incoming transmission from the "
"remote endpoint."
msgstr ""

#: ../../../library/asynchat.rst:65
msgid ""
"To build a functioning :class:`async_chat` subclass your  input methods :"
"meth:`collect_incoming_data` and :meth:`found_terminator` must handle the "
"data that the channel receives asynchronously. The methods are described "
"below."
msgstr ""

#: ../../../library/asynchat.rst:73
msgid ""
"Pushes a ``None`` on to the producer fifo. When this producer is popped off "
"the fifo it causes the channel to be closed."
msgstr ""

#: ../../../library/asynchat.rst:79
msgid ""
"Called with *data* holding an arbitrary amount of received data.  The "
"default method, which must be overridden, raises a :exc:"
"`NotImplementedError` exception."
msgstr ""

#: ../../../library/asynchat.rst:86
msgid ""
"Sample implementation of a data collection rutine to be used in conjunction "
"with :meth:`_get_data` in a user-specified :meth:`found_terminator`."
msgstr ""

#: ../../../library/asynchat.rst:92
msgid ""
"In emergencies this method will discard any data held in the input and/or "
"output buffers and the producer fifo."
msgstr ""

#: ../../../library/asynchat.rst:98
msgid ""
"Called when the incoming data stream  matches the termination condition set "
"by :meth:`set_terminator`. The default method, which must be overridden, "
"raises a :exc:`NotImplementedError` exception. The buffered input data "
"should be available via an instance attribute."
msgstr ""

#: ../../../library/asynchat.rst:106
msgid ""
"Will return and clear the data received with the sample :meth:"
"`_collect_incoming_data` implementation."
msgstr ""

#: ../../../library/asynchat.rst:112
msgid "Returns the current terminator for the channel."
msgstr ""

#: ../../../library/asynchat.rst:117
msgid ""
"Called when the channel is closed. The default method silently closes the "
"channel's socket."
msgstr ""

#: ../../../library/asynchat.rst:123
msgid ""
"Called when a read event fires on the channel's socket in the asynchronous "
"loop.  The default method checks for the termination condition established "
"by :meth:`set_terminator`, which can be either the appearance of a "
"particular string in the input stream or the receipt of a particular number "
"of characters.  When the terminator is found, :meth:`handle_read` calls the :"
"meth:`found_terminator` method after calling :meth:`collect_incoming_data` "
"with any data preceding the terminating condition."
msgstr ""

#: ../../../library/asynchat.rst:134
msgid ""
"Called when the application may write data to the channel.   The default "
"method calls the :meth:`initiate_send` method, which in turn will call :meth:"
"`refill_buffer` to collect data from the producer fifo associated with the "
"channel."
msgstr ""

#: ../../../library/asynchat.rst:142
msgid ""
"Creates a :class:`simple_producer` object (*see below*) containing the data "
"and pushes it on to the channel's ``producer_fifo`` to ensure its "
"transmission.  This is all you need to do to have the channel write the data "
"out to the network, although it is possible to use your own producers in "
"more complex schemes to implement encryption and chunking, for example."
msgstr ""

#: ../../../library/asynchat.rst:151
msgid ""
"Takes a producer object and adds it to the producer fifo associated with the "
"channel.  When all currently-pushed producers have been exhausted the "
"channel will consume this producer's data by calling its :meth:`more` method "
"and send the data to the remote endpoint."
msgstr ""

#: ../../../library/asynchat.rst:159
msgid ""
"Should return ``True`` for the channel to be included in the set of channels "
"tested by the :cfunc:`select` loop for readability."
msgstr ""

#: ../../../library/asynchat.rst:165
msgid ""
"Refills the output buffer by calling the :meth:`more` method of the producer "
"at the head of the fifo.  If it is exhausted then the producer is popped off "
"the fifo and the next producer is activated.  If the current producer is, or "
"becomes, ``None`` then the channel is closed."
msgstr ""

#: ../../../library/asynchat.rst:173
msgid ""
"Sets the terminating condition to be recognized on the channel.  ``term`` "
"may be any of three types of value, corresponding to three different ways to "
"handle incoming protocol data."
msgstr ""

#: ../../../library/asynchat.rst:178
msgid "term"
msgstr ""

#: ../../../library/asynchat.rst:178
msgid "Description"
msgstr ""

#: ../../../library/asynchat.rst:180
msgid "*string*"
msgstr ""

#: ../../../library/asynchat.rst:180
msgid ""
"Will call :meth:`found_terminator` when the string is found in the input "
"stream"
msgstr ""

#: ../../../library/asynchat.rst:183
msgid "*integer*"
msgstr ""

#: ../../../library/asynchat.rst:183
msgid ""
"Will call :meth:`found_terminator` when the indicated number of characters "
"have been received"
msgstr ""

#: ../../../library/asynchat.rst:187
msgid "``None``"
msgstr ""

#: ../../../library/asynchat.rst:187
msgid "The channel continues to collect data forever"
msgstr ""

#: ../../../library/asynchat.rst:191
msgid ""
"Note that any data following the terminator will be available for reading by "
"the channel after :meth:`found_terminator` is called."
msgstr ""

#: ../../../library/asynchat.rst:197
msgid ""
"Should return ``True`` as long as items remain on the producer fifo, or the "
"channel is connected and the channel's output buffer is non-empty."
msgstr ""

#: ../../../library/asynchat.rst:202
msgid "asynchat - Auxiliary Classes and Functions"
msgstr ""

#: ../../../library/asynchat.rst:207
msgid ""
"A :class:`simple_producer` takes a chunk of data and an optional buffer "
"size.  Repeated calls to its :meth:`more` method yield successive chunks of "
"the data no larger than *buffer_size*."
msgstr ""

#: ../../../library/asynchat.rst:214
msgid ""
"Produces the next chunk of information from the producer, or returns the "
"empty string."
msgstr ""

#: ../../../library/asynchat.rst:220
msgid ""
"Each channel maintains a :class:`fifo` holding data which has been pushed by "
"the application but not yet popped for writing to the channel.  A :class:"
"`fifo` is a list used to hold data and/or producers until they are "
"required.  If the *list* argument is provided then it should contain "
"producers or data items to be written to the channel."
msgstr ""

#: ../../../library/asynchat.rst:229
msgid "Returns ``True`` if and only if the fifo is empty."
msgstr ""

#: ../../../library/asynchat.rst:234
msgid "Returns the least-recently :meth:`push`\\ ed item from the fifo."
msgstr ""

#: ../../../library/asynchat.rst:239
msgid ""
"Adds the given data (which may be a string or a producer object) to the "
"producer fifo."
msgstr ""

#: ../../../library/asynchat.rst:245
msgid ""
"If the fifo is not empty, returns ``True, first()``, deleting the popped "
"item.  Returns ``False, None`` for an empty fifo."
msgstr ""

#: ../../../library/asynchat.rst:248
msgid ""
"The :mod:`asynchat` module also defines one utility function, which may be "
"of use in network and textual analysis operations."
msgstr ""

#: ../../../library/asynchat.rst:254
msgid ""
"Returns ``True`` if string *haystack* ends with any non-empty prefix of "
"string *needle*."
msgstr ""

#: ../../../library/asynchat.rst:261
msgid "asynchat Example"
msgstr ""

#: ../../../library/asynchat.rst:263
msgid ""
"The following partial example shows how HTTP requests can be read with :"
"class:`async_chat`.  A web server might create an :class:"
"`http_request_handler` object for each incoming client connection. Notice "
"that initially the channel terminator is set to match the blank line at the "
"end of the HTTP headers, and a flag indicates that the headers are being "
"read."
msgstr ""

#: ../../../library/asynchat.rst:270
msgid ""
"Once the headers have been read, if the request is of type POST (indicating "
"that further data are present in the input stream) then the ``Content-Length:"
"`` header is used to set a numeric terminator to read the right amount of "
"data from the channel."
msgstr ""

#: ../../../library/asynchat.rst:275
msgid ""
"The :meth:`handle_request` method is called once all relevant input has been "
"marshalled, after setting the channel terminator to ``None`` to ensure that "
"any extraneous data sent by the web client are ignored. ::"
msgstr ""

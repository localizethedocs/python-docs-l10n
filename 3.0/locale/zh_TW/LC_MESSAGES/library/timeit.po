# SOME DESCRIPTIVE TITLE.
# Copyright (C) 1990-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-10 15:11+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../library/timeit.rst:3
msgid ":mod:`timeit` --- Measure execution time of small code snippets"
msgstr ""

#: ../../../library/timeit.rst:13
msgid ""
"This module provides a simple way to time small bits of Python code. It has "
"both command line as well as callable interfaces.  It avoids a number of "
"common traps for measuring execution times.  See also Tim Peters' "
"introduction to the \"Algorithms\" chapter in the Python Cookbook, published "
"by O'Reilly."
msgstr ""

#: ../../../library/timeit.rst:18
msgid "The module defines the following public class:"
msgstr ""

#: ../../../library/timeit.rst:23
msgid "Class for timing execution speed of small code snippets."
msgstr ""

#: ../../../library/timeit.rst:25
msgid ""
"The constructor takes a statement to be timed, an additional statement used "
"for setup, and a timer function.  Both statements default to ``'pass'``; the "
"timer function is platform-dependent (see the module doc string).  The "
"statements may contain newlines, as long as they don't contain multi-line "
"string literals."
msgstr ""

#: ../../../library/timeit.rst:30
msgid ""
"To measure the execution time of the first statement, use the :meth:`timeit` "
"method.  The :meth:`repeat` method is a convenience to call :meth:`timeit` "
"multiple times and return a list of results."
msgstr ""

#: ../../../library/timeit.rst:34
msgid ""
"The *stmt* and *setup* parameters can also take objects that are callable "
"without arguments. This will embed calls to them in a timer function that "
"will then be executed by :meth:`timeit`.  Note that the timing overhead is a "
"little larger in this case because of the extra function calls."
msgstr ""

#: ../../../library/timeit.rst:42
msgid "Helper to print a traceback from the timed code."
msgstr ""

#: ../../../library/timeit.rst:44
msgid "Typical use::"
msgstr ""

#: ../../../library/timeit.rst:46
msgid ""
"t = Timer(...)       # outside the try/except\n"
"try:\n"
"    t.timeit(...)    # or t.repeat(...)\n"
"except:\n"
"    t.print_exc()"
msgstr ""

#: ../../../library/timeit.rst:52
msgid ""
"The advantage over the standard traceback is that source lines in the "
"compiled template will be displayed. The optional *file* argument directs "
"where the traceback is sent; it defaults to ``sys.stderr``."
msgstr ""

#: ../../../library/timeit.rst:59
msgid "Call :meth:`timeit` a few times."
msgstr ""

#: ../../../library/timeit.rst:61
msgid ""
"This is a convenience function that calls the :meth:`timeit` repeatedly, "
"returning a list of results.  The first argument specifies how many times to "
"call :meth:`timeit`.  The second argument specifies the *number* argument "
"for :func:`timeit`."
msgstr ""

#: ../../../library/timeit.rst:68
msgid ""
"It's tempting to calculate mean and standard deviation from the result "
"vector and report these.  However, this is not very useful.  In a typical "
"case, the lowest value gives a lower bound for how fast your machine can run "
"the given code snippet; higher values in the result vector are typically not "
"caused by variability in Python's speed, but by other processes interfering "
"with your timing accuracy.  So the :func:`min` of the result is probably the "
"only number you should be interested in.  After that, you should look at the "
"entire vector and apply common sense rather than statistics."
msgstr ""

#: ../../../library/timeit.rst:80
msgid ""
"Time *number* executions of the main statement. This executes the setup "
"statement once, and then returns the time it takes to execute the main "
"statement a number of times, measured in seconds as a float.  The argument "
"is the number of times through the loop, defaulting to one million.  The "
"main statement, the setup statement and the timer function to be used are "
"passed to the constructor."
msgstr ""

#: ../../../library/timeit.rst:88
msgid ""
"By default, :meth:`timeit` temporarily turns off :term:`garbage collection` "
"during the timing.  The advantage of this approach is that it makes "
"independent timings more comparable.  This disadvantage is that GC may be an "
"important component of the performance of the function being measured. If "
"so, GC can be re-enabled as the first statement in the *setup* string. For "
"example::"
msgstr ""

#: ../../../library/timeit.rst:95
msgid "timeit.Timer('for i in range(10): oct(i)', 'gc.enable()').timeit()"
msgstr ""

#: ../../../library/timeit.rst:98
msgid "The module also defines two convenience functions:"
msgstr ""

#: ../../../library/timeit.rst:102
msgid ""
"Create a :class:`Timer` instance with the given statement, setup code and "
"timer function and run its :meth:`repeat` method with the given repeat count "
"and *number* executions."
msgstr ""

#: ../../../library/timeit.rst:109
msgid ""
"Create a :class:`Timer` instance with the given statement, setup code and "
"timer function and run its :meth:`timeit` method with *number* executions."
msgstr ""

#: ../../../library/timeit.rst:114
msgid "Command Line Interface"
msgstr ""

#: ../../../library/timeit.rst:116
msgid ""
"When called as a program from the command line, the following form is used::"
msgstr ""

#: ../../../library/timeit.rst:118
msgid "python -m timeit [-n N] [-r N] [-s S] [-t] [-c] [-h] [statement ...]"
msgstr ""

#: ../../../library/timeit.rst:120
msgid "where the following options are understood:"
msgstr ""

#: ../../../library/timeit.rst:123
msgid "-n N/:option:`--number=N`"
msgstr ""

#: ../../../library/timeit.rst:123
msgid "how many times to execute 'statement'"
msgstr ""

#: ../../../library/timeit.rst:126
msgid "-r N/:option:`--repeat=N`"
msgstr ""

#: ../../../library/timeit.rst:126
msgid "how many times to repeat the timer (default 3)"
msgstr ""

#: ../../../library/timeit.rst:129
msgid "-s S/:option:`--setup=S`"
msgstr ""

#: ../../../library/timeit.rst:129
msgid "statement to be executed once initially (default ``'pass'``)"
msgstr ""

#: ../../../library/timeit.rst:132
msgid "-t/:option:`--time`"
msgstr ""

#: ../../../library/timeit.rst:132
msgid "use :func:`time.time` (default on all platforms but Windows)"
msgstr ""

#: ../../../library/timeit.rst:135
msgid "-c/:option:`--clock`"
msgstr ""

#: ../../../library/timeit.rst:135
msgid "use :func:`time.clock` (default on Windows)"
msgstr ""

#: ../../../library/timeit.rst:138
msgid "-v/:option:`--verbose`"
msgstr ""

#: ../../../library/timeit.rst:138
msgid "print raw timing results; repeat for more digits precision"
msgstr ""

#: ../../../library/timeit.rst:141
msgid "-h/:option:`--help`"
msgstr ""

#: ../../../library/timeit.rst:141
msgid "print a short usage message and exit"
msgstr ""

#: ../../../library/timeit.rst:143
msgid ""
"A multi-line statement may be given by specifying each line as a separate "
"statement argument; indented lines are possible by enclosing an argument in "
"quotes and using leading spaces.  Multiple :option:`-s` options are treated "
"similarly."
msgstr ""

#: ../../../library/timeit.rst:148
msgid ""
"If :option:`-n` is not given, a suitable number of loops is calculated by "
"trying successive powers of 10 until the total time is at least 0.2 seconds."
msgstr ""

#: ../../../library/timeit.rst:151
msgid ""
"The default timer function is platform dependent.  On Windows, :func:`time."
"clock` has microsecond granularity but :func:`time.time`'s granularity is "
"1/60th of a second; on Unix, :func:`time.clock` has 1/100th of a second "
"granularity and :func:`time.time` is much more precise.  On either platform, "
"the default timer functions measure wall clock time, not the CPU time. This "
"means that other processes running on the same computer may interfere with "
"the timing.  The best thing to do when accurate timing is necessary is to "
"repeat the timing a few times and use the best time.  The :option:`-r` "
"option is good for this; the default of 3 repetitions is probably enough in "
"most cases.  On Unix, you can use :func:`time.clock` to measure CPU time."
msgstr ""

#: ../../../library/timeit.rst:164
msgid ""
"There is a certain baseline overhead associated with executing a pass "
"statement. The code here doesn't try to hide it, but you should be aware of "
"it.  The baseline overhead can be measured by invoking the program without "
"arguments."
msgstr ""

#: ../../../library/timeit.rst:168
msgid ""
"The baseline overhead differs between Python versions!  Also, to fairly "
"compare older Python versions to Python 2.3, you may want to use Python's :"
"option:`-O` option for the older versions to avoid timing ``SET_LINENO`` "
"instructions."
msgstr ""

#: ../../../library/timeit.rst:174
msgid "Examples"
msgstr ""

#: ../../../library/timeit.rst:176
msgid ""
"Here are two example sessions (one using the command line, one using the "
"module interface) that compare the cost of using :func:`hasattr` vs. :"
"keyword:`try`/:keyword:`except` to test for missing and present object "
"attributes. ::"
msgstr ""

#: ../../../library/timeit.rst:181
msgid ""
"% timeit.py 'try:' '  str.__bool__' 'except AttributeError:' '  pass'\n"
"100000 loops, best of 3: 15.7 usec per loop\n"
"% timeit.py 'if hasattr(str, \"__bool__\"): pass'\n"
"100000 loops, best of 3: 4.26 usec per loop\n"
"% timeit.py 'try:' '  int.__bool__' 'except AttributeError:' '  pass'\n"
"1000000 loops, best of 3: 1.43 usec per loop\n"
"% timeit.py 'if hasattr(int, \"__bool__\"): pass'\n"
"100000 loops, best of 3: 2.23 usec per loop"
msgstr ""

#: ../../../library/timeit.rst:192
msgid ""
">>> import timeit\n"
">>> s = \"\"\"\\\n"
"... try:\n"
"...     str.__bool__\n"
"... except AttributeError:\n"
"...     pass\n"
"... \"\"\"\n"
">>> t = timeit.Timer(stmt=s)\n"
">>> print(\"%.2f usec/pass\" % (1000000 * t.timeit(number=100000)/100000))\n"
"17.09 usec/pass\n"
">>> s = \"\"\"\\\n"
"... if hasattr(str, '__bool__'): pass\n"
"... \"\"\"\n"
">>> t = timeit.Timer(stmt=s)\n"
">>> print(\"%.2f usec/pass\" % (1000000 * t.timeit(number=100000)/100000))\n"
"4.85 usec/pass\n"
">>> s = \"\"\"\\\n"
"... try:\n"
"...     int.__bool__\n"
"... except AttributeError:\n"
"...     pass\n"
"... \"\"\"\n"
">>> t = timeit.Timer(stmt=s)\n"
">>> print(\"%.2f usec/pass\" % (1000000 * t.timeit(number=100000)/100000))\n"
"1.97 usec/pass\n"
">>> s = \"\"\"\\\n"
"... if hasattr(int, '__bool__'): pass\n"
"... \"\"\"\n"
">>> t = timeit.Timer(stmt=s)\n"
">>> print(\"%.2f usec/pass\" % (1000000 * t.timeit(number=100000)/100000))\n"
"3.15 usec/pass"
msgstr ""

#: ../../../library/timeit.rst:224
msgid ""
"To give the :mod:`timeit` module access to functions you define, you can "
"pass a ``setup`` parameter which contains an import statement::"
msgstr ""

#: ../../../library/timeit.rst:227
msgid ""
"def test():\n"
"    \"Stupid test function\"\n"
"    L = [i for i in range(100)]\n"
"\n"
"if __name__=='__main__':\n"
"    from timeit import Timer\n"
"    t = Timer(\"test()\", \"from __main__ import test\")\n"
"    print(t.timeit())"
msgstr ""

#: ../../../library/timeit.rst:9
msgid "Benchmarking"
msgstr ""

#: ../../../library/timeit.rst:9
msgid "Performance"
msgstr ""

# SOME DESCRIPTIVE TITLE.
# Copyright (C) 1990-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-10 15:11+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../library/tokenize.rst:2
msgid ":mod:`tokenize` --- Tokenizer for Python source"
msgstr ""

#: ../../../library/tokenize.rst:10
msgid ""
"The :mod:`tokenize` module provides a lexical scanner for Python source "
"code, implemented in Python.  The scanner in this module returns comments as "
"tokens as well, making it useful for implementing \"pretty-printers,\" "
"including colorizers for on-screen displays."
msgstr ""

#: ../../../library/tokenize.rst:15
msgid "The primary entry point is a :term:`generator`:"
msgstr ""

#: ../../../library/tokenize.rst:19
msgid ""
"The :func:`tokenize` generator requires one argument, *readline*, which must "
"be a callable object which provides the same interface as the :meth:"
"`readline` method of built-in file objects (see section :ref:`bltin-file-"
"objects`).  Each call to the function should return one line of input as "
"bytes."
msgstr ""

#: ../../../library/tokenize.rst:25
msgid ""
"The generator produces 5-tuples with these members: the token type; the "
"token string; a 2-tuple ``(srow, scol)`` of ints specifying the row and "
"column where the token begins in the source; a 2-tuple ``(erow, ecol)`` of "
"ints specifying the row and column where the token ends in the source; and "
"the line on which the token was found. The line passed (the last tuple item) "
"is the *logical* line; continuation lines are included."
msgstr ""

#: ../../../library/tokenize.rst:32
msgid ""
":func:`tokenize` determines the source encoding of the file by looking for a "
"UTF-8 BOM or encoding cookie, according to :pep:`263`."
msgstr ""

#: ../../../library/tokenize.rst:36
msgid ""
"All constants from the :mod:`token` module are also exported from :mod:"
"`tokenize`, as are three additional token type values:"
msgstr ""

#: ../../../library/tokenize.rst:41
msgid "Token value used to indicate a comment."
msgstr ""

#: ../../../library/tokenize.rst:46
msgid ""
"Token value used to indicate a non-terminating newline.  The NEWLINE token "
"indicates the end of a logical line of Python code; NL tokens are generated "
"when a logical line of code is continued over multiple physical lines."
msgstr ""

#: ../../../library/tokenize.rst:53
msgid ""
"Token value that indicates the encoding used to decode the source bytes into "
"text. The first token returned by :func:`tokenize` will always be an "
"ENCODING token."
msgstr ""

#: ../../../library/tokenize.rst:58
msgid ""
"Another function is provided to reverse the tokenization process. This is "
"useful for creating tools that tokenize a script, modify the token stream, "
"and write back the modified script."
msgstr ""

#: ../../../library/tokenize.rst:65
msgid ""
"Converts tokens back into Python source code.  The *iterable* must return "
"sequences with at least two elements, the token type and the token string. "
"Any additional sequence elements are ignored."
msgstr ""

#: ../../../library/tokenize.rst:69
msgid ""
"The reconstructed script is returned as a single string.  The result is "
"guaranteed to tokenize back to match the input so that the conversion is "
"lossless and round-trips are assured.  The guarantee applies only to the "
"token type and token string as the spacing between tokens (column positions) "
"may change."
msgstr ""

#: ../../../library/tokenize.rst:75
msgid ""
"It returns bytes, encoded using the ENCODING token, which is the first token "
"sequence output by :func:`tokenize`."
msgstr ""

#: ../../../library/tokenize.rst:79
msgid ""
":func:`tokenize` needs to detect the encoding of source files it tokenizes. "
"The function it uses to do this is available:"
msgstr ""

#: ../../../library/tokenize.rst:84
msgid ""
"The :func:`detect_encoding` function is used to detect the encoding that "
"should be used to decode a Python source file. It requires one argment, "
"readline, in the same way as the :func:`tokenize` generator."
msgstr ""

#: ../../../library/tokenize.rst:88
msgid ""
"It will call readline a maximum of twice, and return the encoding used (as a "
"string) and a list of any lines (not decoded from bytes) it has read in."
msgstr ""

#: ../../../library/tokenize.rst:92
msgid ""
"It detects the encoding from the presence of a utf-8 bom or an encoding "
"cookie as specified in pep-0263. If both a bom and a cookie are present, but "
"disagree, a SyntaxError will be raised."
msgstr ""

#: ../../../library/tokenize.rst:96
msgid ""
"If no encoding is specified, then the default of 'utf-8' will be returned."
msgstr ""

#: ../../../library/tokenize.rst:99
msgid ""
"Example of a script re-writer that transforms float literals into Decimal "
"objects::"
msgstr ""

#: ../../../library/tokenize.rst:102
msgid ""
"def decistmt(s):\n"
"    \"\"\"Substitute Decimals for floats in a string of statements.\n"
"\n"
"    >>> from decimal import Decimal\n"
"    >>> s = 'print(+21.3e-5*-.1234/81.7)'\n"
"    >>> decistmt(s)\n"
"    \"print (+Decimal ('21.3e-5')*-Decimal ('.1234')/Decimal ('81.7'))\"\n"
"\n"
"    The format of the exponent is inherited from the platform C library.\n"
"    Known cases are \"e-007\" (Windows) and \"e-07\" (not Windows).  Since\n"
"    we're only showing 12 digits, and the 13th isn't close to 5, the\n"
"    rest of the output should be platform-independent.\n"
"\n"
"    >>> exec(s) #doctest: +ELLIPSIS\n"
"    -3.21716034272e-0...7\n"
"\n"
"    Output from calculations with Decimal should be identical across all\n"
"    platforms.\n"
"\n"
"    >>> exec(decistmt(s))\n"
"    -3.217160342717258261933904529E-7\n"
"    \"\"\"\n"
"    result = []\n"
"    g = tokenize(BytesIO(s.encode('utf-8')).readline) # tokenize the string\n"
"    for toknum, tokval, _, _, _  in g:\n"
"        if toknum == NUMBER and '.' in tokval:  # replace NUMBER tokens\n"
"            result.extend([\n"
"                (NAME, 'Decimal'),\n"
"                (OP, '('),\n"
"                (STRING, repr(tokval)),\n"
"                (OP, ')')\n"
"            ])\n"
"        else:\n"
"            result.append((toknum, tokval))\n"
"    return untokenize(result).decode('utf-8')"
msgstr ""

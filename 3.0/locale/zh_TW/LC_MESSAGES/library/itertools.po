# SOME DESCRIPTIVE TITLE.
# Copyright (C) 1990-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-10 15:11+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../library/itertools.rst:3
msgid ":mod:`itertools` --- Functions creating iterators for efficient looping"
msgstr ""

#: ../../../library/itertools.rst:16
msgid ""
"This module implements a number of :term:`iterator` building blocks inspired "
"by constructs from the Haskell and SML programming languages.  Each has been "
"recast in a form suitable for Python."
msgstr ""

#: ../../../library/itertools.rst:20
msgid ""
"The module standardizes a core set of fast, memory efficient tools that are "
"useful by themselves or in combination.  Standardization helps avoid the "
"readability and reliability problems which arise when many different "
"individuals create their own slightly varying implementations, each with "
"their own quirks and naming conventions."
msgstr ""

#: ../../../library/itertools.rst:26
msgid ""
"The tools are designed to combine readily with one another.  This makes it "
"easy to construct more specialized tools succinctly and efficiently in pure "
"Python."
msgstr ""

#: ../../../library/itertools.rst:29
msgid ""
"For instance, SML provides a tabulation tool: ``tabulate(f)`` which produces "
"a sequence ``f(0), f(1), ...``.  But, this effect can be achieved in Python "
"by combining :func:`map` and :func:`count` to form ``map(f, count())``."
msgstr ""

#: ../../../library/itertools.rst:33
msgid ""
"Likewise, the functional tools are designed to work well with the high-speed "
"functions provided by the :mod:`operator` module."
msgstr ""

#: ../../../library/itertools.rst:36
msgid ""
"Whether cast in pure python form or compiled code, tools that use iterators "
"are more memory efficient (and often faster) than their list based "
"counterparts. Adopting the principles of just-in-time manufacturing, they "
"create data when and where needed instead of consuming memory with the "
"computer equivalent of \"inventory\"."
msgstr ""

#: ../../../library/itertools.rst:44
msgid ""
"The Standard ML Basis Library, `The Standard ML Basis Library <http://www."
"standardml.org/Basis/>`_."
msgstr ""

#: ../../../library/itertools.rst:47
msgid ""
"Haskell, A Purely Functional Language, `Definition of Haskell and the "
"Standard Libraries <http://www.haskell.org/definition/>`_."
msgstr ""

#: ../../../library/itertools.rst:54
msgid "Itertool functions"
msgstr ""

#: ../../../library/itertools.rst:56
msgid ""
"The following module functions all construct and return iterators. Some "
"provide streams of infinite length, so they should only be accessed by "
"functions or loops that truncate the stream."
msgstr ""

#: ../../../library/itertools.rst:63
msgid ""
"Make an iterator that returns elements from the first iterable until it is "
"exhausted, then proceeds to the next iterable, until all of the iterables "
"are exhausted.  Used for treating consecutive sequences as a single "
"sequence. Equivalent to::"
msgstr ""

#: ../../../library/itertools.rst:68
msgid ""
"def chain(*iterables):\n"
"    # chain('ABC', 'DEF') --> A B C D E F\n"
"    for it in iterables:\n"
"        for element in it:\n"
"            yield element"
msgstr ""

#: ../../../library/itertools.rst:77
msgid ""
"Alternate constructor for :func:`chain`.  Gets chained inputs from a single "
"iterable argument that is evaluated lazily.  Equivalent to::"
msgstr ""

#: ../../../library/itertools.rst:80
msgid ""
"@classmethod\n"
"def from_iterable(iterables):\n"
"    # chain.from_iterable(['ABC', 'DEF']) --> A B C D E F\n"
"    for it in iterables:\n"
"        for element in it:\n"
"            yield element"
msgstr ""

#: ../../../library/itertools.rst:90
msgid "Return *r* length subsequences of elements from the input *iterable*."
msgstr ""

#: ../../../library/itertools.rst:92
msgid ""
"Combinations are emitted in lexicographic sort order.  So, if the input "
"*iterable* is sorted, the combination tuples will be produced in sorted "
"order."
msgstr ""

#: ../../../library/itertools.rst:96
msgid ""
"Elements are treated as unique based on their position, not on their value.  "
"So if the input elements are unique, there will be no repeat values in each "
"combination."
msgstr ""

#: ../../../library/itertools.rst:100 ../../../library/itertools.rst:299
msgid "Equivalent to::"
msgstr ""

#: ../../../library/itertools.rst:102
msgid ""
"def combinations(iterable, r):\n"
"    # combinations('ABCD', 2) --> AB AC AD BC BD CD\n"
"    # combinations(range(4), 3) --> 012 013 023 123\n"
"    pool = tuple(iterable)\n"
"    n = len(pool)\n"
"    if r > n:\n"
"        return\n"
"    indices = list(range(r))\n"
"    yield tuple(pool[i] for i in indices)\n"
"    while 1:\n"
"        for i in reversed(range(r)):\n"
"            if indices[i] != i + n - r:\n"
"                break\n"
"        else:\n"
"            return\n"
"        indices[i] += 1\n"
"        for j in range(i+1, r):\n"
"            indices[j] = indices[j-1] + 1\n"
"        yield tuple(pool[i] for i in indices)"
msgstr ""

#: ../../../library/itertools.rst:122
msgid ""
"The code for :func:`combinations` can be also expressed as a subsequence of :"
"func:`permutations` after filtering entries where the elements are not in "
"sorted order (according to their position in the input pool)::"
msgstr ""

#: ../../../library/itertools.rst:126
msgid ""
"def combinations(iterable, r):\n"
"    pool = tuple(iterable)\n"
"    n = len(pool)\n"
"    for indices in permutations(range(n), r):\n"
"        if sorted(indices) == list(indices):\n"
"            yield tuple(pool[i] for i in indices)"
msgstr ""

#: ../../../library/itertools.rst:133
msgid ""
"The number of items returned is ``n! / r! / (n-r)!`` when ``0 <= r <= n`` or "
"zero when ``r > n``."
msgstr ""

#: ../../../library/itertools.rst:138
msgid ""
"Make an iterator that returns consecutive integers starting with *n*. If not "
"specified *n* defaults to zero.   Often used as an argument to :func:`map` "
"to generate consecutive data points. Also, used with :func:`zip` to add "
"sequence numbers.  Equivalent to::"
msgstr ""

#: ../../../library/itertools.rst:143
msgid ""
"def count(n=0):\n"
"    # count(10) --> 10 11 12 13 14 ...\n"
"    while True:\n"
"        yield n\n"
"        n += 1"
msgstr ""

#: ../../../library/itertools.rst:152
msgid ""
"Make an iterator returning elements from the iterable and saving a copy of "
"each. When the iterable is exhausted, return elements from the saved copy.  "
"Repeats indefinitely.  Equivalent to::"
msgstr ""

#: ../../../library/itertools.rst:156
msgid ""
"def cycle(iterable):\n"
"    # cycle('ABCD') --> A B C D A B C D A B C D ...\n"
"    saved = []\n"
"    for element in iterable:\n"
"        yield element\n"
"        saved.append(element)\n"
"    while saved:\n"
"        for element in saved:\n"
"              yield element"
msgstr ""

#: ../../../library/itertools.rst:166
msgid ""
"Note, this member of the toolkit may require significant auxiliary storage "
"(depending on the length of the iterable)."
msgstr ""

#: ../../../library/itertools.rst:172
msgid ""
"Make an iterator that drops elements from the iterable as long as the "
"predicate is true; afterwards, returns every element.  Note, the iterator "
"does not produce *any* output until the predicate first becomes false, so it "
"may have a lengthy start-up time.  Equivalent to::"
msgstr ""

#: ../../../library/itertools.rst:177
msgid ""
"def dropwhile(predicate, iterable):\n"
"    # dropwhile(lambda x: x<5, [1,4,6,4,1]) --> 6 4 1\n"
"    iterable = iter(iterable)\n"
"    for x in iterable:\n"
"        if not predicate(x):\n"
"            yield x\n"
"            break\n"
"    for x in iterable:\n"
"        yield x"
msgstr ""

#: ../../../library/itertools.rst:189
msgid ""
"Make an iterator that filters elements from iterable returning only those "
"for which the predicate is ``False``. If *predicate* is ``None``, return the "
"items that are false. Equivalent to::"
msgstr ""

#: ../../../library/itertools.rst:193
msgid ""
"def filterfalse(predicate, iterable):\n"
"    # filterfalse(lambda x: x%2, range(10)) --> 0 2 4 6 8\n"
"    if predicate is None:\n"
"        predicate = bool\n"
"    for x in iterable:\n"
"        if not predicate(x):\n"
"            yield x"
msgstr ""

#: ../../../library/itertools.rst:204
msgid ""
"Make an iterator that returns consecutive keys and groups from the "
"*iterable*. The *key* is a function computing a key value for each element.  "
"If not specified or is ``None``, *key* defaults to an identity function and "
"returns the element unchanged.  Generally, the iterable needs to already be "
"sorted on the same key function."
msgstr ""

#: ../../../library/itertools.rst:210
msgid ""
"The operation of :func:`groupby` is similar to the ``uniq`` filter in Unix.  "
"It generates a break or new group every time the value of the key function "
"changes (which is why it is usually necessary to have sorted the data using "
"the same key function).  That behavior differs from SQL's GROUP BY which "
"aggregates common elements regardless of their input order."
msgstr ""

#: ../../../library/itertools.rst:216
msgid ""
"The returned group is itself an iterator that shares the underlying iterable "
"with :func:`groupby`.  Because the source is shared, when the :func:"
"`groupby` object is advanced, the previous group is no longer visible.  So, "
"if that data is needed later, it should be stored as a list::"
msgstr ""

#: ../../../library/itertools.rst:221
msgid ""
"groups = []\n"
"uniquekeys = []\n"
"data = sorted(data, key=keyfunc)\n"
"for k, g in groupby(data, keyfunc):\n"
"    groups.append(list(g))      # Store group iterator as a list\n"
"    uniquekeys.append(k)"
msgstr ""

#: ../../../library/itertools.rst:228
msgid ":func:`groupby` is equivalent to::"
msgstr ""

#: ../../../library/itertools.rst:230
msgid ""
"class groupby(object):\n"
"    # [k for k, g in groupby('AAAABBBCCDAABBB')] --> A B C D A B\n"
"    # [list(g) for k, g in groupby('AAAABBBCCD')] --> AAAA BBB CC D\n"
"    def __init__(self, iterable, key=None):\n"
"        if key is None:\n"
"            key = lambda x: x\n"
"        self.keyfunc = key\n"
"        self.it = iter(iterable)\n"
"        self.tgtkey = self.currkey = self.currvalue = object()\n"
"    def __iter__(self):\n"
"        return self\n"
"    def __next__(self):\n"
"        while self.currkey == self.tgtkey:\n"
"            self.currvalue = next(self.it) # Exit on StopIteration\n"
"            self.currkey = self.keyfunc(self.currvalue)\n"
"        self.tgtkey = self.currkey\n"
"        return (self.currkey, self._grouper(self.tgtkey))\n"
"    def _grouper(self, tgtkey):\n"
"        while self.currkey == tgtkey:\n"
"            yield self.currvalue\n"
"            self.currvalue = next(self.it) # Exit on StopIteration\n"
"            self.currkey = self.keyfunc(self.currvalue)"
msgstr ""

#: ../../../library/itertools.rst:256
msgid ""
"Make an iterator that returns selected elements from the iterable. If "
"*start* is non-zero, then elements from the iterable are skipped until start "
"is reached. Afterward, elements are returned consecutively unless *step* is "
"set higher than one which results in items being skipped.  If *stop* is "
"``None``, then iteration continues until the iterator is exhausted, if at "
"all; otherwise, it stops at the specified position.  Unlike regular "
"slicing, :func:`islice` does not support negative values for *start*, "
"*stop*, or *step*.  Can be used to extract related fields from data where "
"the internal structure has been flattened (for example, a multi-line report "
"may list a name field on every third line).  Equivalent to::"
msgstr ""

#: ../../../library/itertools.rst:266
msgid ""
"def islice(iterable, *args):\n"
"    # islice('ABCDEFG', 2) --> A B\n"
"    # islice('ABCDEFG', 2, 4) --> C D\n"
"    # islice('ABCDEFG', 2, None) --> C D E F G\n"
"    # islice('ABCDEFG', 0, None, 2) --> A C E G\n"
"    s = slice(*args)\n"
"    it = range(s.start or 0, s.stop or sys.maxsize, s.step or 1)\n"
"    nexti = next(it)\n"
"    for i, element in enumerate(iterable):\n"
"        if i == nexti:\n"
"            yield element\n"
"            nexti = next(it)"
msgstr ""

#: ../../../library/itertools.rst:279
msgid ""
"If *start* is ``None``, then iteration starts at zero. If *step* is "
"``None``, then the step defaults to one."
msgstr ""

#: ../../../library/itertools.rst:285
msgid ""
"Return successive *r* length permutations of elements in the *iterable*."
msgstr ""

#: ../../../library/itertools.rst:287
msgid ""
"If *r* is not specified or is ``None``, then *r* defaults to the length of "
"the *iterable* and all possible full-length permutations are generated."
msgstr ""

#: ../../../library/itertools.rst:291
msgid ""
"Permutations are emitted in lexicographic sort order.  So, if the input "
"*iterable* is sorted, the permutation tuples will be produced in sorted "
"order."
msgstr ""

#: ../../../library/itertools.rst:295
msgid ""
"Elements are treated as unique based on their position, not on their value.  "
"So if the input elements are unique, there will be no repeat values in each "
"permutation."
msgstr ""

#: ../../../library/itertools.rst:301
msgid ""
"def permutations(iterable, r=None):\n"
"    # permutations('ABCD', 2) --> AB AC AD BA BC BD CA CB CD DA DB DC\n"
"    # permutations(range(3)) --> 012 021 102 120 201 210\n"
"    pool = tuple(iterable)\n"
"    n = len(pool)\n"
"    r = n if r is None else r\n"
"    if r > n:\n"
"        return\n"
"    indices = list(range(n))\n"
"    cycles = range(n, n-r, -1)\n"
"    yield tuple(pool[i] for i in indices[:r])\n"
"    while n:\n"
"        for i in reversed(range(r)):\n"
"            cycles[i] -= 1\n"
"            if cycles[i] == 0:\n"
"                indices[i:] = indices[i+1:] + indices[i:i+1]\n"
"                cycles[i] = n - i\n"
"            else:\n"
"                j = cycles[i]\n"
"                indices[i], indices[-j] = indices[-j], indices[i]\n"
"                yield tuple(pool[i] for i in indices[:r])\n"
"                break\n"
"        else:\n"
"            return"
msgstr ""

#: ../../../library/itertools.rst:326
msgid ""
"The code for :func:`permutations` can be also expressed as a subsequence of :"
"func:`product`, filtered to exclude entries with repeated elements (those "
"from the same position in the input pool)::"
msgstr ""

#: ../../../library/itertools.rst:330
msgid ""
"def permutations(iterable, r=None):\n"
"    pool = tuple(iterable)\n"
"    n = len(pool)\n"
"    r = n if r is None else r\n"
"    for indices in product(range(n), repeat=r):\n"
"        if len(set(indices)) == r:\n"
"            yield tuple(pool[i] for i in indices)"
msgstr ""

#: ../../../library/itertools.rst:338
msgid ""
"The number of items returned is ``n! / (n-r)!`` when ``0 <= r <= n`` or zero "
"when ``r > n``."
msgstr ""

#: ../../../library/itertools.rst:343
msgid "Cartesian product of input iterables."
msgstr ""

#: ../../../library/itertools.rst:345
msgid ""
"Equivalent to nested for-loops in a generator expression. For example, "
"``product(A, B)`` returns the same as ``((x,y) for x in A for y in B)``."
msgstr ""

#: ../../../library/itertools.rst:348
msgid ""
"The nested loops cycle like an odometer with the rightmost element advancing "
"on every iteration.  This pattern creates a lexicographic ordering so that "
"if the input's iterables are sorted, the product tuples are emitted in "
"sorted order."
msgstr ""

#: ../../../library/itertools.rst:353
msgid ""
"To compute the product of an iterable with itself, specify the number of "
"repetitions with the optional *repeat* keyword argument.  For example, "
"``product(A, repeat=4)`` means the same as ``product(A, A, A, A)``."
msgstr ""

#: ../../../library/itertools.rst:357
msgid ""
"This function is equivalent to the following code, except that the actual "
"implementation does not build up intermediate results in memory::"
msgstr ""

#: ../../../library/itertools.rst:360
msgid ""
"def product(*args, repeat=1):\n"
"    # product('ABCD', 'xy') --> Ax Ay Bx By Cx Cy Dx Dy\n"
"    # product(range(2), repeat=3) --> 000 001 010 011 100 101 110 111\n"
"    pools = map(tuple, args) * repeat\n"
"    result = [[]]\n"
"    for pool in pools:\n"
"        result = [x+[y] for x in result for y in pool]\n"
"    for prod in result:\n"
"        yield tuple(prod)"
msgstr ""

#: ../../../library/itertools.rst:373
msgid ""
"Make an iterator that returns *object* over and over again. Runs "
"indefinitely unless the *times* argument is specified. Used as argument to :"
"func:`map` for invariant parameters to the called function.  Also used with :"
"func:`zip` to create an invariant part of a tuple record.  Equivalent to::"
msgstr ""

#: ../../../library/itertools.rst:378
msgid ""
"def repeat(object, times=None):\n"
"    # repeat(10, 3) --> 10 10 10\n"
"    if times is None:\n"
"        while True:\n"
"            yield object\n"
"    else:\n"
"        for i in range(times):\n"
"            yield object"
msgstr ""

#: ../../../library/itertools.rst:390
msgid ""
"Make an iterator that computes the function using arguments obtained from "
"the iterable.  Used instead of :func:`map` when argument parameters are "
"already grouped in tuples from a single iterable (the data has been \"pre-"
"zipped\").  The difference between :func:`map` and :func:`starmap` parallels "
"the distinction between ``function(a,b)`` and ``function(*c)``. Equivalent "
"to::"
msgstr ""

#: ../../../library/itertools.rst:396
msgid ""
"def starmap(function, iterable):\n"
"    # starmap(pow, [(2,5), (3,2), (10,3)]) --> 32 9 1000\n"
"    for args in iterable:\n"
"        yield function(*args)"
msgstr ""

#: ../../../library/itertools.rst:404
msgid ""
"Make an iterator that returns elements from the iterable as long as the "
"predicate is true.  Equivalent to::"
msgstr ""

#: ../../../library/itertools.rst:407
msgid ""
"def takewhile(predicate, iterable):\n"
"    # takewhile(lambda x: x<5, [1,4,6,4,1]) --> 1 4\n"
"    for x in iterable:\n"
"        if predicate(x):\n"
"            yield x\n"
"        else:\n"
"            break"
msgstr ""

#: ../../../library/itertools.rst:418
msgid ""
"Return *n* independent iterators from a single iterable. The case where "
"``n==2`` is equivalent to::"
msgstr ""

#: ../../../library/itertools.rst:421
msgid ""
"def tee(iterable):\n"
"    def gen(next, data={}):\n"
"        for i in count():\n"
"            if i in data:\n"
"                yield data.pop(i)\n"
"            else:\n"
"                data[i] = next()\n"
"                yield data[i]\n"
"    it = iter(iterable)\n"
"    return (gen(it.__next__), gen(it.__next__))"
msgstr ""

#: ../../../library/itertools.rst:432
msgid ""
"Note, once :func:`tee` has made a split, the original *iterable* should not "
"be used anywhere else; otherwise, the *iterable* could get advanced without "
"the tee objects being informed."
msgstr ""

#: ../../../library/itertools.rst:436
msgid ""
"Note, this member of the toolkit may require significant auxiliary storage "
"(depending on how much temporary data needs to be stored). In general, if "
"one iterator is going to use most or all of the data before the other "
"iterator, it is faster to use :func:`list` instead of :func:`tee`."
msgstr ""

#: ../../../library/itertools.rst:444
msgid ""
"Make an iterator that aggregates elements from each of the iterables. If the "
"iterables are of uneven length, missing values are filled-in with "
"*fillvalue*. Iteration continues until the longest iterable is exhausted.  "
"Equivalent to::"
msgstr ""

#: ../../../library/itertools.rst:448
msgid ""
"def zip_longest(*args, fillvalue=None):\n"
"    # zip_longest('ABCD', 'xy', fillvalue='-') --> Ax By C- D-\n"
"    def sentinel(counter = ([fillvalue]*(len(args)-1)).pop):\n"
"        yield counter()         # yields the fillvalue, or raises "
"IndexError\n"
"    fillers = repeat(fillvalue)\n"
"    iters = [chain(it, sentinel(), fillers) for it in args]\n"
"    try:\n"
"        for tup in zip(*iters):\n"
"            yield tup\n"
"    except IndexError:\n"
"        pass"
msgstr ""

#: ../../../library/itertools.rst:460
msgid ""
"If one of the iterables is potentially infinite, then the :func:"
"`zip_longest` function should be wrapped with something that limits the "
"number of calls (for example :func:`islice` or :func:`takewhile`).  If not "
"specified, *fillvalue* defaults to ``None``."
msgstr ""

#: ../../../library/itertools.rst:469
msgid "Examples"
msgstr ""

#: ../../../library/itertools.rst:471
msgid ""
"The following examples show common uses for each tool and demonstrate ways "
"they can be combined."
msgstr ""

#: ../../../library/itertools.rst:474
msgid ""
">>> # Show a dictionary sorted and grouped by value\n"
">>> from operator import itemgetter\n"
">>> d = dict(a=1, b=2, c=1, d=2, e=1, f=2, g=3)\n"
">>> di = sorted(d.items(), key=itemgetter(1))\n"
">>> for k, g in groupby(di, key=itemgetter(1)):\n"
"...     print(k, map(itemgetter(0), g))\n"
"...\n"
"1 ['a', 'c', 'e']\n"
"2 ['b', 'd', 'f']\n"
"3 ['g']\n"
"\n"
">>> # Find runs of consecutive numbers using groupby.  The key to the "
"solution\n"
">>> # is differencing with a range so that consecutive numbers all appear "
"in\n"
">>> # same group.\n"
">>> data = [ 1,  4,5,6, 10, 15,16,17,18, 22, 25,26,27,28]\n"
">>> for k, g in groupby(enumerate(data), lambda t:t[0]-t[1]):\n"
"...     print(map(operator.itemgetter(1), g))\n"
"...\n"
"[1]\n"
"[4, 5, 6]\n"
"[10]\n"
"[15, 16, 17, 18]\n"
"[22]\n"
"[25, 26, 27, 28]"
msgstr ""

#: ../../../library/itertools.rst:506
msgid "Recipes"
msgstr ""

#: ../../../library/itertools.rst:508
msgid ""
"This section shows recipes for creating an extended toolset using the "
"existing itertools as building blocks."
msgstr ""

#: ../../../library/itertools.rst:511
msgid ""
"The extended tools offer the same high performance as the underlying "
"toolset. The superior memory performance is kept by processing elements one "
"at a time rather than bringing the whole iterable into memory all at once. "
"Code volume is kept small by linking the tools together in a functional "
"style which helps eliminate temporary variables.  High speed is retained by "
"preferring \"vectorized\" building blocks over the use of for-loops and :"
"term:`generator`\\s which incur interpreter overhead."
msgstr ""

#: ../../../library/itertools.rst:519
msgid ""
"def take(n, iterable):\n"
"    \"Return first n items of the iterable as a list\"\n"
"    return list(islice(iterable, n))\n"
"\n"
"def enumerate(iterable, start=0):\n"
"    return zip(count(start), iterable)\n"
"\n"
"def tabulate(function, start=0):\n"
"    \"Return function(0), function(1), ...\"\n"
"    return map(function, count(start))\n"
"\n"
"def nth(iterable, n):\n"
"    \"Returns the nth item or None\"\n"
"    return next(islice(iterable, n, None), None)\n"
"\n"
"def quantify(iterable, pred=bool):\n"
"    \"Count how many times the predicate is true\"\n"
"    return sum(map(pred, iterable))\n"
"\n"
"def padnone(iterable):\n"
"    \"\"\"Returns the sequence elements and then returns None indefinitely.\n"
"\n"
"    Useful for emulating the behavior of the built-in map() function.\n"
"    \"\"\"\n"
"    return chain(iterable, repeat(None))\n"
"\n"
"def ncycles(iterable, n):\n"
"    \"Returns the sequence elements n times\"\n"
"    return chain.from_iterable(repeat(iterable, n))\n"
"\n"
"def dotproduct(vec1, vec2):\n"
"    return sum(map(operator.mul, vec1, vec2))\n"
"\n"
"def flatten(listOfLists):\n"
"    return list(chain.from_iterable(listOfLists))\n"
"\n"
"def repeatfunc(func, times=None, *args):\n"
"    \"\"\"Repeat calls to func with specified arguments.\n"
"\n"
"    Example:  repeatfunc(random.random)\n"
"    \"\"\"\n"
"    if times is None:\n"
"        return starmap(func, repeat(args))\n"
"    return starmap(func, repeat(args, times))\n"
"\n"
"def pairwise(iterable):\n"
"    \"s -> (s0,s1), (s1,s2), (s2, s3), ...\"\n"
"    a, b = tee(iterable)\n"
"    for elem in b:\n"
"        break\n"
"    return zip(a, b)\n"
"\n"
"def grouper(n, iterable, fillvalue=None):\n"
"    \"grouper(3, 'ABCDEFG', 'x') --> ABC DEF Gxx\"\n"
"    args = [iter(iterable)] * n\n"
"    return zip_longest(*args, fillvalue=fillvalue)\n"
"\n"
"def roundrobin(*iterables):\n"
"    \"roundrobin('ABC', 'D', 'EF') --> A D E B F C\"\n"
"    # Recipe credited to George Sakkis\n"
"    pending = len(iterables)\n"
"    nexts = cycle(iter(it).__next__ for it in iterables)\n"
"    while pending:\n"
"        try:\n"
"            for next in nexts:\n"
"                yield next()\n"
"        except StopIteration:\n"
"            pending -= 1\n"
"            nexts = cycle(islice(nexts, pending))\n"
"\n"
"def powerset(iterable):\n"
"    \"powerset([1,2,3]) --> () (1,) (2,) (3,) (1,2) (1,3) (2,3) (1,2,3)\"\n"
"    s = list(iterable)\n"
"    return chain.from_iterable(combinations(s, r) for r in range(len(s)+1))\n"
"\n"
"def compress(data, selectors):\n"
"    \"compress('ABCDEF', [1,0,1,0,1,1]) --> A C E F\"\n"
"    return (d for d, s in zip(data, selectors) if s)\n"
"\n"
"def combinations_with_replacement(iterable, r):\n"
"    \"combinations_with_replacement('ABC', 2) --> AA AB AC BB BC CC\"\n"
"    # number items returned:  (n+r-1)! / r! / (n-1)!\n"
"    pool = tuple(iterable)\n"
"    n = len(pool)\n"
"    indices = [0] * r\n"
"    yield tuple(pool[i] for i in indices)\n"
"    while True:\n"
"        for i in reversed(range(r)):\n"
"            if indices[i] != n - 1:\n"
"                break\n"
"        else:\n"
"            return\n"
"        indices[i:] = [indices[i] + 1] * (r - i)\n"
"        yield tuple(pool[i] for i in indices)\n"
"\n"
" def unique_everseen(iterable, key=None):\n"
"     \"List unique elements, preserving order. Remember all elements ever "
"seen.\"\n"
"     # unique_everseen('AAAABBBCCDAABBB') --> A B C D\n"
"     # unique_everseen('ABBCcAD', str.lower) --> A B C D\n"
"     seen = set()\n"
"     seen_add = seen.add\n"
"     if key is None:\n"
"         for element in iterable:\n"
"             if element not in seen:\n"
"                 seen_add(element)\n"
"                 yield element\n"
"     else:\n"
"         for element in iterable:\n"
"             k = key(element)\n"
"             if k not in seen:\n"
"                 seen_add(k)\n"
"                 yield element\n"
"\n"
" def unique_justseen(iterable, key=None):\n"
"     \"List unique elements, preserving order. Remember only the element "
"just seen.\"\n"
"     # unique_justseen('AAAABBBCCDAABBB') --> A B C D A B\n"
"     # unique_justseen('ABBCcAD', str.lower) --> A B C A D\n"
"     return map(next, map(itemgetter(1), groupby(iterable, key)))"
msgstr ""

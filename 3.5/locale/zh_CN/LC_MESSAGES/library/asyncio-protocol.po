# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.5\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-10 15:09+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: /home/runner/work/python-docs-l10n/python-docs-l10n/out/repo/Doc/library/asyncio-protocol.rst:5
msgid "Transports  and protocols (callback based API)"
msgstr ""

#: /home/runner/work/python-docs-l10n/python-docs-l10n/out/repo/Doc/library/asyncio-protocol.rst:10
msgid "Transports"
msgstr ""

#: /home/runner/work/python-docs-l10n/python-docs-l10n/out/repo/Doc/library/asyncio-protocol.rst:12
msgid ""
"Transports are classes provided by :mod:`asyncio` in order to abstract "
"various kinds of communication channels.  You generally won't instantiate a "
"transport yourself; instead, you will call an :class:`AbstractEventLoop` "
"method which will create the transport and try to initiate the underlying "
"communication channel, calling you back when it succeeds."
msgstr ""

#: /home/runner/work/python-docs-l10n/python-docs-l10n/out/repo/Doc/library/asyncio-protocol.rst:18
msgid ""
"Once the communication channel is established, a transport is always paired "
"with a :ref:`protocol <asyncio-protocol>` instance.  The protocol can then "
"call the transport's methods for various purposes."
msgstr ""

#: /home/runner/work/python-docs-l10n/python-docs-l10n/out/repo/Doc/library/asyncio-protocol.rst:22
msgid ""
":mod:`asyncio` currently implements transports for TCP, UDP, SSL, and "
"subprocess pipes.  The methods available on a transport depend on the "
"transport's kind."
msgstr ""

#: /home/runner/work/python-docs-l10n/python-docs-l10n/out/repo/Doc/library/asyncio-protocol.rst:26
msgid ""
"The transport classes are :ref:`not thread safe <asyncio-multithreading>`."
msgstr ""

#: /home/runner/work/python-docs-l10n/python-docs-l10n/out/repo/Doc/library/asyncio-protocol.rst:30
msgid "BaseTransport"
msgstr ""

#: /home/runner/work/python-docs-l10n/python-docs-l10n/out/repo/Doc/library/asyncio-protocol.rst:34
msgid "Base class for transports."
msgstr ""

#: /home/runner/work/python-docs-l10n/python-docs-l10n/out/repo/Doc/library/asyncio-protocol.rst:38
msgid ""
"Close the transport.  If the transport has a buffer for outgoing data, "
"buffered data will be flushed asynchronously.  No more data will be "
"received.  After all buffered data is flushed, the protocol's :meth:"
"`connection_lost` method will be called with :const:`None` as its argument."
msgstr ""

#: /home/runner/work/python-docs-l10n/python-docs-l10n/out/repo/Doc/library/asyncio-protocol.rst:46
msgid "Return ``True`` if the transport is closing or is closed."
msgstr ""

#: /home/runner/work/python-docs-l10n/python-docs-l10n/out/repo/Doc/library/asyncio-protocol.rst:52
msgid ""
"Return optional transport information.  *name* is a string representing the "
"piece of transport-specific information to get, *default* is the value to "
"return if the information doesn't exist."
msgstr ""

#: /home/runner/work/python-docs-l10n/python-docs-l10n/out/repo/Doc/library/asyncio-protocol.rst:56
msgid ""
"This method allows transport implementations to easily expose channel-"
"specific information."
msgstr ""

#: /home/runner/work/python-docs-l10n/python-docs-l10n/out/repo/Doc/library/asyncio-protocol.rst:59
msgid "socket:"
msgstr ""

#: /home/runner/work/python-docs-l10n/python-docs-l10n/out/repo/Doc/library/asyncio-protocol.rst:61
msgid ""
"``'peername'``: the remote address to which the socket is connected, result "
"of :meth:`socket.socket.getpeername` (``None`` on error)"
msgstr ""

#: /home/runner/work/python-docs-l10n/python-docs-l10n/out/repo/Doc/library/asyncio-protocol.rst:63
msgid "``'socket'``: :class:`socket.socket` instance"
msgstr ""

#: /home/runner/work/python-docs-l10n/python-docs-l10n/out/repo/Doc/library/asyncio-protocol.rst:64
msgid ""
"``'sockname'``: the socket's own address, result of :meth:`socket.socket."
"getsockname`"
msgstr ""

#: /home/runner/work/python-docs-l10n/python-docs-l10n/out/repo/Doc/library/asyncio-protocol.rst:67
msgid "SSL socket:"
msgstr ""

#: /home/runner/work/python-docs-l10n/python-docs-l10n/out/repo/Doc/library/asyncio-protocol.rst:69
msgid ""
"``'compression'``: the compression algorithm being used as a string, or "
"``None`` if the connection isn't compressed; result of :meth:`ssl.SSLSocket."
"compression`"
msgstr ""

#: /home/runner/work/python-docs-l10n/python-docs-l10n/out/repo/Doc/library/asyncio-protocol.rst:72
msgid ""
"``'cipher'``: a three-value tuple containing the name of the cipher being "
"used, the version of the SSL protocol that defines its use, and the number "
"of secret bits being used; result of :meth:`ssl.SSLSocket.cipher`"
msgstr ""

#: /home/runner/work/python-docs-l10n/python-docs-l10n/out/repo/Doc/library/asyncio-protocol.rst:76
msgid ""
"``'peercert'``: peer certificate; result of :meth:`ssl.SSLSocket.getpeercert`"
msgstr ""

#: /home/runner/work/python-docs-l10n/python-docs-l10n/out/repo/Doc/library/asyncio-protocol.rst:78
msgid "``'sslcontext'``: :class:`ssl.SSLContext` instance"
msgstr ""

#: /home/runner/work/python-docs-l10n/python-docs-l10n/out/repo/Doc/library/asyncio-protocol.rst:79
msgid ""
"``'ssl_object'``: :class:`ssl.SSLObject` or :class:`ssl.SSLSocket` instance"
msgstr ""

#: /home/runner/work/python-docs-l10n/python-docs-l10n/out/repo/Doc/library/asyncio-protocol.rst:82
msgid "pipe:"
msgstr ""

#: /home/runner/work/python-docs-l10n/python-docs-l10n/out/repo/Doc/library/asyncio-protocol.rst:84
msgid "``'pipe'``: pipe object"
msgstr ""

#: /home/runner/work/python-docs-l10n/python-docs-l10n/out/repo/Doc/library/asyncio-protocol.rst:86
msgid "subprocess:"
msgstr ""

#: /home/runner/work/python-docs-l10n/python-docs-l10n/out/repo/Doc/library/asyncio-protocol.rst:88
msgid "``'subprocess'``: :class:`subprocess.Popen` instance"
msgstr ""

#: /home/runner/work/python-docs-l10n/python-docs-l10n/out/repo/Doc/library/asyncio-protocol.rst:92
msgid ""
"Set a new protocol.  Switching protocol should only be done when both "
"protocols are documented to support the switch."
msgstr ""

#: /home/runner/work/python-docs-l10n/python-docs-l10n/out/repo/Doc/library/asyncio-protocol.rst:99
msgid "Return the current protocol."
msgstr ""

#: /home/runner/work/python-docs-l10n/python-docs-l10n/out/repo/Doc/library/asyncio-protocol.rst:103
msgid "``'ssl_object'`` info was added to SSL sockets."
msgstr ""

#: /home/runner/work/python-docs-l10n/python-docs-l10n/out/repo/Doc/library/asyncio-protocol.rst:108
msgid "ReadTransport"
msgstr ""

#: /home/runner/work/python-docs-l10n/python-docs-l10n/out/repo/Doc/library/asyncio-protocol.rst:112
msgid "Interface for read-only transports."
msgstr ""

#: /home/runner/work/python-docs-l10n/python-docs-l10n/out/repo/Doc/library/asyncio-protocol.rst:116
msgid ""
"Pause the receiving end of the transport.  No data will be passed to the "
"protocol's :meth:`data_received` method until :meth:`resume_reading` is "
"called."
msgstr ""

#: /home/runner/work/python-docs-l10n/python-docs-l10n/out/repo/Doc/library/asyncio-protocol.rst:122
msgid ""
"Resume the receiving end.  The protocol's :meth:`data_received` method will "
"be called once again if some data is available for reading."
msgstr ""

#: /home/runner/work/python-docs-l10n/python-docs-l10n/out/repo/Doc/library/asyncio-protocol.rst:127
msgid "WriteTransport"
msgstr ""

#: /home/runner/work/python-docs-l10n/python-docs-l10n/out/repo/Doc/library/asyncio-protocol.rst:131
msgid "Interface for write-only transports."
msgstr ""

#: /home/runner/work/python-docs-l10n/python-docs-l10n/out/repo/Doc/library/asyncio-protocol.rst:135
#: /home/runner/work/python-docs-l10n/python-docs-l10n/out/repo/Doc/library/asyncio-protocol.rst:223
msgid ""
"Close the transport immediately, without waiting for pending operations to "
"complete.  Buffered data will be lost.  No more data will be received. The "
"protocol's :meth:`connection_lost` method will eventually be called with :"
"const:`None` as its argument."
msgstr ""

#: /home/runner/work/python-docs-l10n/python-docs-l10n/out/repo/Doc/library/asyncio-protocol.rst:142
msgid ""
"Return :const:`True` if the transport supports :meth:`write_eof`, :const:"
"`False` if not."
msgstr ""

#: /home/runner/work/python-docs-l10n/python-docs-l10n/out/repo/Doc/library/asyncio-protocol.rst:147
msgid "Return the current size of the output buffer used by the transport."
msgstr ""

#: /home/runner/work/python-docs-l10n/python-docs-l10n/out/repo/Doc/library/asyncio-protocol.rst:151
msgid ""
"Get the *high*- and *low*-water limits for write flow control. Return a "
"tuple ``(low, high)`` where *low* and *high* are positive number of bytes."
msgstr ""

#: /home/runner/work/python-docs-l10n/python-docs-l10n/out/repo/Doc/library/asyncio-protocol.rst:155
msgid "Use :meth:`set_write_buffer_limits` to set the limits."
msgstr ""

#: /home/runner/work/python-docs-l10n/python-docs-l10n/out/repo/Doc/library/asyncio-protocol.rst:161
msgid "Set the *high*- and *low*-water limits for write flow control."
msgstr ""

#: /home/runner/work/python-docs-l10n/python-docs-l10n/out/repo/Doc/library/asyncio-protocol.rst:163
msgid ""
"These two values (measured in number of bytes) control when the protocol's :"
"meth:`pause_writing` and :meth:`resume_writing` methods are called. If "
"specified, the low-water limit must be less than or equal to the high-water "
"limit.  Neither *high* nor *low* can be negative."
msgstr ""

#: /home/runner/work/python-docs-l10n/python-docs-l10n/out/repo/Doc/library/asyncio-protocol.rst:169
msgid ""
":meth:`pause_writing` is called when the buffer size becomes greater than or "
"equal to the *high* value. If writing has been paused, :meth:"
"`resume_writing` is called when the buffer size becomes less than or equal "
"to the *low* value."
msgstr ""

#: /home/runner/work/python-docs-l10n/python-docs-l10n/out/repo/Doc/library/asyncio-protocol.rst:174
msgid ""
"The defaults are implementation-specific.  If only the high-water limit is "
"given, the low-water limit defaults to an implementation-specific value less "
"than or equal to the high-water limit.  Setting *high* to zero forces *low* "
"to zero as well, and causes :meth:`pause_writing` to be called whenever the "
"buffer becomes non-empty.  Setting *low* to zero causes :meth:"
"`resume_writing` to be called only once the buffer is empty. Use of zero for "
"either limit is generally sub-optimal as it reduces opportunities for doing "
"I/O and computation concurrently."
msgstr ""

#: /home/runner/work/python-docs-l10n/python-docs-l10n/out/repo/Doc/library/asyncio-protocol.rst:185
msgid "Use :meth:`get_write_buffer_limits` to get the limits."
msgstr ""

#: /home/runner/work/python-docs-l10n/python-docs-l10n/out/repo/Doc/library/asyncio-protocol.rst:189
msgid "Write some *data* bytes to the transport."
msgstr ""

#: /home/runner/work/python-docs-l10n/python-docs-l10n/out/repo/Doc/library/asyncio-protocol.rst:191
#: /home/runner/work/python-docs-l10n/python-docs-l10n/out/repo/Doc/library/asyncio-protocol.rst:218
msgid ""
"This method does not block; it buffers the data and arranges for it to be "
"sent out asynchronously."
msgstr ""

#: /home/runner/work/python-docs-l10n/python-docs-l10n/out/repo/Doc/library/asyncio-protocol.rst:196
msgid ""
"Write a list (or any iterable) of data bytes to the transport. This is "
"functionally equivalent to calling :meth:`write` on each element yielded by "
"the iterable, but may be implemented more efficiently."
msgstr ""

#: /home/runner/work/python-docs-l10n/python-docs-l10n/out/repo/Doc/library/asyncio-protocol.rst:202
msgid ""
"Close the write end of the transport after flushing buffered data. Data may "
"still be received."
msgstr ""

#: /home/runner/work/python-docs-l10n/python-docs-l10n/out/repo/Doc/library/asyncio-protocol.rst:205
msgid ""
"This method can raise :exc:`NotImplementedError` if the transport (e.g. SSL) "
"doesn't support half-closes."
msgstr ""

#: /home/runner/work/python-docs-l10n/python-docs-l10n/out/repo/Doc/library/asyncio-protocol.rst:210
msgid "DatagramTransport"
msgstr ""

#: /home/runner/work/python-docs-l10n/python-docs-l10n/out/repo/Doc/library/asyncio-protocol.rst:214
msgid ""
"Send the *data* bytes to the remote peer given by *addr* (a transport-"
"dependent target address).  If *addr* is :const:`None`, the data is sent to "
"the target address given on transport creation."
msgstr ""

#: /home/runner/work/python-docs-l10n/python-docs-l10n/out/repo/Doc/library/asyncio-protocol.rst:230
msgid "BaseSubprocessTransport"
msgstr ""

#: /home/runner/work/python-docs-l10n/python-docs-l10n/out/repo/Doc/library/asyncio-protocol.rst:236
msgid "Return the subprocess process id as an integer."
msgstr ""

#: /home/runner/work/python-docs-l10n/python-docs-l10n/out/repo/Doc/library/asyncio-protocol.rst:240
msgid ""
"Return the transport for the communication pipe corresponding to the integer "
"file descriptor *fd*:"
msgstr ""

#: /home/runner/work/python-docs-l10n/python-docs-l10n/out/repo/Doc/library/asyncio-protocol.rst:243
msgid ""
"``0``: readable streaming transport of the standard input (*stdin*), or :"
"const:`None` if the subprocess was not created with ``stdin=PIPE``"
msgstr ""

#: /home/runner/work/python-docs-l10n/python-docs-l10n/out/repo/Doc/library/asyncio-protocol.rst:245
msgid ""
"``1``: writable streaming transport of the standard output (*stdout*), or :"
"const:`None` if the subprocess was not created with ``stdout=PIPE``"
msgstr ""

#: /home/runner/work/python-docs-l10n/python-docs-l10n/out/repo/Doc/library/asyncio-protocol.rst:247
msgid ""
"``2``: writable streaming transport of the standard error (*stderr*), or :"
"const:`None` if the subprocess was not created with ``stderr=PIPE``"
msgstr ""

#: /home/runner/work/python-docs-l10n/python-docs-l10n/out/repo/Doc/library/asyncio-protocol.rst:249
msgid "other *fd*: :const:`None`"
msgstr ""

#: /home/runner/work/python-docs-l10n/python-docs-l10n/out/repo/Doc/library/asyncio-protocol.rst:253
msgid ""
"Return the subprocess returncode as an integer or :const:`None` if it hasn't "
"returned, similarly to the :attr:`subprocess.Popen.returncode` attribute."
msgstr ""

#: /home/runner/work/python-docs-l10n/python-docs-l10n/out/repo/Doc/library/asyncio-protocol.rst:259
msgid "Kill the subprocess, as in :meth:`subprocess.Popen.kill`."
msgstr ""

#: /home/runner/work/python-docs-l10n/python-docs-l10n/out/repo/Doc/library/asyncio-protocol.rst:261
msgid ""
"On POSIX systems, the function sends SIGKILL to the subprocess. On Windows, "
"this method is an alias for :meth:`terminate`."
msgstr ""

#: /home/runner/work/python-docs-l10n/python-docs-l10n/out/repo/Doc/library/asyncio-protocol.rst:266
msgid ""
"Send the *signal* number to the subprocess, as in :meth:`subprocess.Popen."
"send_signal`."
msgstr ""

#: /home/runner/work/python-docs-l10n/python-docs-l10n/out/repo/Doc/library/asyncio-protocol.rst:271
msgid ""
"Ask the subprocess to stop, as in :meth:`subprocess.Popen.terminate`. This "
"method is an alias for the :meth:`close` method."
msgstr ""

#: /home/runner/work/python-docs-l10n/python-docs-l10n/out/repo/Doc/library/asyncio-protocol.rst:274
msgid ""
"On POSIX systems, this method sends SIGTERM to the subprocess. On Windows, "
"the Windows API function TerminateProcess() is called to stop the subprocess."
msgstr ""

#: /home/runner/work/python-docs-l10n/python-docs-l10n/out/repo/Doc/library/asyncio-protocol.rst:280
msgid ""
"Ask the subprocess to stop by calling the :meth:`terminate` method if the "
"subprocess hasn't returned yet, and close transports of all pipes (*stdin*, "
"*stdout* and *stderr*)."
msgstr ""

#: /home/runner/work/python-docs-l10n/python-docs-l10n/out/repo/Doc/library/asyncio-protocol.rst:288
msgid "Protocols"
msgstr ""

#: /home/runner/work/python-docs-l10n/python-docs-l10n/out/repo/Doc/library/asyncio-protocol.rst:290
msgid ""
":mod:`asyncio` provides base classes that you can subclass to implement your "
"network protocols.  Those classes are used in conjunction with :ref:"
"`transports <asyncio-transport>` (see below): the protocol parses incoming "
"data and asks for the writing of outgoing data, while the transport is "
"responsible for the actual I/O and buffering."
msgstr ""

#: /home/runner/work/python-docs-l10n/python-docs-l10n/out/repo/Doc/library/asyncio-protocol.rst:296
msgid ""
"When subclassing a protocol class, it is recommended you override certain "
"methods.  Those methods are callbacks: they will be called by the transport "
"on certain events (for example when some data is received); you shouldn't "
"call them yourself, unless you are implementing a transport."
msgstr ""

#: /home/runner/work/python-docs-l10n/python-docs-l10n/out/repo/Doc/library/asyncio-protocol.rst:302
msgid ""
"All callbacks have default implementations, which are empty.  Therefore, you "
"only need to implement the callbacks for the events in which you are "
"interested."
msgstr ""

#: /home/runner/work/python-docs-l10n/python-docs-l10n/out/repo/Doc/library/asyncio-protocol.rst:308
msgid "Protocol classes"
msgstr ""

#: /home/runner/work/python-docs-l10n/python-docs-l10n/out/repo/Doc/library/asyncio-protocol.rst:312
msgid ""
"The base class for implementing streaming protocols (for use with e.g. TCP "
"and SSL transports)."
msgstr ""

#: /home/runner/work/python-docs-l10n/python-docs-l10n/out/repo/Doc/library/asyncio-protocol.rst:317
msgid ""
"The base class for implementing datagram protocols (for use with e.g. UDP "
"transports)."
msgstr ""

#: /home/runner/work/python-docs-l10n/python-docs-l10n/out/repo/Doc/library/asyncio-protocol.rst:322
msgid ""
"The base class for implementing protocols communicating with child processes "
"(through a set of unidirectional pipes)."
msgstr ""

#: /home/runner/work/python-docs-l10n/python-docs-l10n/out/repo/Doc/library/asyncio-protocol.rst:327
msgid "Connection callbacks"
msgstr ""

#: /home/runner/work/python-docs-l10n/python-docs-l10n/out/repo/Doc/library/asyncio-protocol.rst:329
#: /home/runner/work/python-docs-l10n/python-docs-l10n/out/repo/Doc/library/asyncio-protocol.rst:441
msgid ""
"These callbacks may be called on :class:`Protocol`, :class:"
"`DatagramProtocol` and :class:`SubprocessProtocol` instances:"
msgstr ""

#: /home/runner/work/python-docs-l10n/python-docs-l10n/out/repo/Doc/library/asyncio-protocol.rst:334
msgid "Called when a connection is made."
msgstr ""

#: /home/runner/work/python-docs-l10n/python-docs-l10n/out/repo/Doc/library/asyncio-protocol.rst:336
msgid ""
"The *transport* argument is the transport representing the connection.  You "
"are responsible for storing it somewhere (e.g. as an attribute) if you need "
"to."
msgstr ""

#: /home/runner/work/python-docs-l10n/python-docs-l10n/out/repo/Doc/library/asyncio-protocol.rst:342
msgid "Called when the connection is lost or closed."
msgstr ""

#: /home/runner/work/python-docs-l10n/python-docs-l10n/out/repo/Doc/library/asyncio-protocol.rst:344
msgid ""
"The argument is either an exception object or :const:`None`. The latter "
"means a regular EOF is received, or the connection was aborted or closed by "
"this side of the connection."
msgstr ""

#: /home/runner/work/python-docs-l10n/python-docs-l10n/out/repo/Doc/library/asyncio-protocol.rst:348
msgid ""
":meth:`~BaseProtocol.connection_made` and :meth:`~BaseProtocol."
"connection_lost` are called exactly once per successful connection.  All "
"other callbacks will be called between those two methods, which allows for "
"easier resource management in your protocol implementation."
msgstr ""

#: /home/runner/work/python-docs-l10n/python-docs-l10n/out/repo/Doc/library/asyncio-protocol.rst:353
msgid ""
"The following callbacks may be called only on :class:`SubprocessProtocol` "
"instances:"
msgstr ""

#: /home/runner/work/python-docs-l10n/python-docs-l10n/out/repo/Doc/library/asyncio-protocol.rst:358
msgid ""
"Called when the child process writes data into its stdout or stderr pipe. "
"*fd* is the integer file descriptor of the pipe.  *data* is a non-empty "
"bytes object containing the data."
msgstr ""

#: /home/runner/work/python-docs-l10n/python-docs-l10n/out/repo/Doc/library/asyncio-protocol.rst:364
msgid ""
"Called when one of the pipes communicating with the child process is "
"closed.  *fd* is the integer file descriptor that was closed."
msgstr ""

#: /home/runner/work/python-docs-l10n/python-docs-l10n/out/repo/Doc/library/asyncio-protocol.rst:369
msgid "Called when the child process has exited."
msgstr ""

#: /home/runner/work/python-docs-l10n/python-docs-l10n/out/repo/Doc/library/asyncio-protocol.rst:373
msgid "Streaming protocols"
msgstr ""

#: /home/runner/work/python-docs-l10n/python-docs-l10n/out/repo/Doc/library/asyncio-protocol.rst:375
msgid "The following callbacks are called on :class:`Protocol` instances:"
msgstr ""

#: /home/runner/work/python-docs-l10n/python-docs-l10n/out/repo/Doc/library/asyncio-protocol.rst:379
msgid ""
"Called when some data is received.  *data* is a non-empty bytes object "
"containing the incoming data."
msgstr ""

#: /home/runner/work/python-docs-l10n/python-docs-l10n/out/repo/Doc/library/asyncio-protocol.rst:383
msgid ""
"Whether the data is buffered, chunked or reassembled depends on the "
"transport.  In general, you shouldn't rely on specific semantics and instead "
"make your parsing generic and flexible enough.  However, data is always "
"received in the correct order."
msgstr ""

#: /home/runner/work/python-docs-l10n/python-docs-l10n/out/repo/Doc/library/asyncio-protocol.rst:390
msgid ""
"Called when the other end signals it won't send any more data (for example "
"by calling :meth:`write_eof`, if the other end also uses asyncio)."
msgstr ""

#: /home/runner/work/python-docs-l10n/python-docs-l10n/out/repo/Doc/library/asyncio-protocol.rst:394
msgid ""
"This method may return a false value (including ``None``), in which case the "
"transport will close itself.  Conversely, if this method returns a true "
"value, closing the transport is up to the protocol.  Since the default "
"implementation returns ``None``, it implicitly closes the connection."
msgstr ""

#: /home/runner/work/python-docs-l10n/python-docs-l10n/out/repo/Doc/library/asyncio-protocol.rst:400
msgid ""
"Some transports such as SSL don't support half-closed connections, in which "
"case returning true from this method will not prevent closing the connection."
msgstr ""

#: /home/runner/work/python-docs-l10n/python-docs-l10n/out/repo/Doc/library/asyncio-protocol.rst:404
msgid ""
":meth:`data_received` can be called an arbitrary number of times during a "
"connection.  However, :meth:`eof_received` is called at most once and, if "
"called, :meth:`data_received` won't be called after it."
msgstr ""

#: /home/runner/work/python-docs-l10n/python-docs-l10n/out/repo/Doc/library/asyncio-protocol.rst:408
msgid "State machine:"
msgstr ""

#: /home/runner/work/python-docs-l10n/python-docs-l10n/out/repo/Doc/library/asyncio-protocol.rst:410
msgid ""
"start -> :meth:`~BaseProtocol.connection_made` [-> :meth:`~Protocol."
"data_received` \\*] [-> :meth:`~Protocol.eof_received` ?] -> :meth:"
"`~BaseProtocol.connection_lost` -> end"
msgstr ""

#: /home/runner/work/python-docs-l10n/python-docs-l10n/out/repo/Doc/library/asyncio-protocol.rst:417
msgid "Datagram protocols"
msgstr ""

#: /home/runner/work/python-docs-l10n/python-docs-l10n/out/repo/Doc/library/asyncio-protocol.rst:419
msgid ""
"The following callbacks are called on :class:`DatagramProtocol` instances."
msgstr ""

#: /home/runner/work/python-docs-l10n/python-docs-l10n/out/repo/Doc/library/asyncio-protocol.rst:423
msgid ""
"Called when a datagram is received.  *data* is a bytes object containing the "
"incoming data.  *addr* is the address of the peer sending the data; the "
"exact format depends on the transport."
msgstr ""

#: /home/runner/work/python-docs-l10n/python-docs-l10n/out/repo/Doc/library/asyncio-protocol.rst:429
msgid ""
"Called when a previous send or receive operation raises an :class:"
"`OSError`.  *exc* is the :class:`OSError` instance."
msgstr ""

#: /home/runner/work/python-docs-l10n/python-docs-l10n/out/repo/Doc/library/asyncio-protocol.rst:432
msgid ""
"This method is called in rare conditions, when the transport (e.g. UDP) "
"detects that a datagram couldn't be delivered to its recipient. In many "
"conditions though, undeliverable datagrams will be silently dropped."
msgstr ""

#: /home/runner/work/python-docs-l10n/python-docs-l10n/out/repo/Doc/library/asyncio-protocol.rst:439
msgid "Flow control callbacks"
msgstr ""

#: /home/runner/work/python-docs-l10n/python-docs-l10n/out/repo/Doc/library/asyncio-protocol.rst:446
msgid "Called when the transport's buffer goes over the high-water mark."
msgstr ""

#: /home/runner/work/python-docs-l10n/python-docs-l10n/out/repo/Doc/library/asyncio-protocol.rst:450
msgid "Called when the transport's buffer drains below the low-water mark."
msgstr ""

#: /home/runner/work/python-docs-l10n/python-docs-l10n/out/repo/Doc/library/asyncio-protocol.rst:453
msgid ""
":meth:`pause_writing` and :meth:`resume_writing` calls are paired -- :meth:"
"`pause_writing` is called once when the buffer goes strictly over the high-"
"water mark (even if subsequent writes increases the buffer size even more), "
"and eventually :meth:`resume_writing` is called once when the buffer size "
"reaches the low-water mark."
msgstr ""

#: /home/runner/work/python-docs-l10n/python-docs-l10n/out/repo/Doc/library/asyncio-protocol.rst:460
msgid ""
"If the buffer size equals the high-water mark, :meth:`pause_writing` is not "
"called -- it must go strictly over. Conversely, :meth:`resume_writing` is "
"called when the buffer size is equal or lower than the low-water mark.  "
"These end conditions are important to ensure that things go as expected when "
"either mark is zero."
msgstr ""

#: /home/runner/work/python-docs-l10n/python-docs-l10n/out/repo/Doc/library/asyncio-protocol.rst:468
msgid ""
"On BSD systems (OS X, FreeBSD, etc.) flow control is not supported for :"
"class:`DatagramProtocol`, because send failures caused by writing too many "
"packets cannot be detected easily.  The socket always appears 'ready' and "
"excess packets are dropped; an :class:`OSError` with errno set to :const:"
"`errno.ENOBUFS` may or may not be raised; if it is raised, it will be "
"reported to :meth:`DatagramProtocol.error_received` but otherwise ignored."
msgstr ""

#: /home/runner/work/python-docs-l10n/python-docs-l10n/out/repo/Doc/library/asyncio-protocol.rst:478
msgid "Coroutines and protocols"
msgstr ""

#: /home/runner/work/python-docs-l10n/python-docs-l10n/out/repo/Doc/library/asyncio-protocol.rst:480
msgid ""
"Coroutines can be scheduled in a protocol method using :func:"
"`ensure_future`, but there is no guarantee made about the execution order.  "
"Protocols are not aware of coroutines created in protocol methods and so "
"will not wait for them."
msgstr ""

#: /home/runner/work/python-docs-l10n/python-docs-l10n/out/repo/Doc/library/asyncio-protocol.rst:484
msgid ""
"To have a reliable execution order, use :ref:`stream objects <asyncio-"
"streams>` in a coroutine with ``yield from``. For example, the :meth:"
"`StreamWriter.drain` coroutine can be used to wait until the write buffer is "
"flushed."
msgstr ""

#: /home/runner/work/python-docs-l10n/python-docs-l10n/out/repo/Doc/library/asyncio-protocol.rst:490
msgid "Protocol examples"
msgstr ""

#: /home/runner/work/python-docs-l10n/python-docs-l10n/out/repo/Doc/library/asyncio-protocol.rst:495
msgid "TCP echo client protocol"
msgstr ""

#: /home/runner/work/python-docs-l10n/python-docs-l10n/out/repo/Doc/library/asyncio-protocol.rst:497
msgid ""
"TCP echo client  using the :meth:`AbstractEventLoop.create_connection` "
"method, send data and wait until the connection is closed::"
msgstr ""

#: /home/runner/work/python-docs-l10n/python-docs-l10n/out/repo/Doc/library/asyncio-protocol.rst:500
msgid ""
"import asyncio\n"
"\n"
"class EchoClientProtocol(asyncio.Protocol):\n"
"    def __init__(self, message, loop):\n"
"        self.message = message\n"
"        self.loop = loop\n"
"\n"
"    def connection_made(self, transport):\n"
"        transport.write(self.message.encode())\n"
"        print('Data sent: {!r}'.format(self.message))\n"
"\n"
"    def data_received(self, data):\n"
"        print('Data received: {!r}'.format(data.decode()))\n"
"\n"
"    def connection_lost(self, exc):\n"
"        print('The server closed the connection')\n"
"        print('Stop the event loop')\n"
"        self.loop.stop()\n"
"\n"
"loop = asyncio.get_event_loop()\n"
"message = 'Hello World!'\n"
"coro = loop.create_connection(lambda: EchoClientProtocol(message, loop),\n"
"                              '127.0.0.1', 8888)\n"
"loop.run_until_complete(coro)\n"
"loop.run_forever()\n"
"loop.close()"
msgstr ""

#: /home/runner/work/python-docs-l10n/python-docs-l10n/out/repo/Doc/library/asyncio-protocol.rst:527
msgid ""
"The event loop is running twice. The :meth:`~AbstractEventLoop."
"run_until_complete` method is preferred in this short example to raise an "
"exception if the server is not listening, instead of having to write a short "
"coroutine to handle the exception and stop the running loop. At :meth:"
"`~AbstractEventLoop.run_until_complete` exit, the loop is no longer running, "
"so there is no need to stop the loop in case of an error."
msgstr ""

#: /home/runner/work/python-docs-l10n/python-docs-l10n/out/repo/Doc/library/asyncio-protocol.rst:536
msgid ""
"The :ref:`TCP echo client using streams <asyncio-tcp-echo-client-streams>` "
"example uses the :func:`asyncio.open_connection` function."
msgstr ""

#: /home/runner/work/python-docs-l10n/python-docs-l10n/out/repo/Doc/library/asyncio-protocol.rst:543
msgid "TCP echo server protocol"
msgstr ""

#: /home/runner/work/python-docs-l10n/python-docs-l10n/out/repo/Doc/library/asyncio-protocol.rst:545
msgid ""
"TCP echo server using the :meth:`AbstractEventLoop.create_server` method, "
"send back received data and close the connection::"
msgstr ""

#: /home/runner/work/python-docs-l10n/python-docs-l10n/out/repo/Doc/library/asyncio-protocol.rst:548
msgid ""
"import asyncio\n"
"\n"
"class EchoServerClientProtocol(asyncio.Protocol):\n"
"    def connection_made(self, transport):\n"
"        peername = transport.get_extra_info('peername')\n"
"        print('Connection from {}'.format(peername))\n"
"        self.transport = transport\n"
"\n"
"    def data_received(self, data):\n"
"        message = data.decode()\n"
"        print('Data received: {!r}'.format(message))\n"
"\n"
"        print('Send: {!r}'.format(message))\n"
"        self.transport.write(data)\n"
"\n"
"        print('Close the client socket')\n"
"        self.transport.close()\n"
"\n"
"loop = asyncio.get_event_loop()\n"
"# Each client connection will create a new protocol instance\n"
"coro = loop.create_server(EchoServerClientProtocol, '127.0.0.1', 8888)\n"
"server = loop.run_until_complete(coro)\n"
"\n"
"# Serve requests until Ctrl+C is pressed\n"
"print('Serving on {}'.format(server.sockets[0].getsockname()))\n"
"try:\n"
"    loop.run_forever()\n"
"except KeyboardInterrupt:\n"
"    pass\n"
"\n"
"# Close the server\n"
"server.close()\n"
"loop.run_until_complete(server.wait_closed())\n"
"loop.close()"
msgstr ""

#: /home/runner/work/python-docs-l10n/python-docs-l10n/out/repo/Doc/library/asyncio-protocol.rst:583
msgid ""
":meth:`Transport.close` can be called immediately after :meth:"
"`WriteTransport.write` even if data are not sent yet on the socket: both "
"methods are asynchronous. ``yield from`` is not needed because these "
"transport methods are not coroutines."
msgstr ""

#: /home/runner/work/python-docs-l10n/python-docs-l10n/out/repo/Doc/library/asyncio-protocol.rst:590
msgid ""
"The :ref:`TCP echo server using streams <asyncio-tcp-echo-server-streams>` "
"example uses the :func:`asyncio.start_server` function."
msgstr ""

#: /home/runner/work/python-docs-l10n/python-docs-l10n/out/repo/Doc/library/asyncio-protocol.rst:597
msgid "UDP echo client protocol"
msgstr ""

#: /home/runner/work/python-docs-l10n/python-docs-l10n/out/repo/Doc/library/asyncio-protocol.rst:599
msgid ""
"UDP echo client using the :meth:`AbstractEventLoop.create_datagram_endpoint` "
"method, send data and close the transport when we received the answer::"
msgstr ""

#: /home/runner/work/python-docs-l10n/python-docs-l10n/out/repo/Doc/library/asyncio-protocol.rst:602
msgid ""
"import asyncio\n"
"\n"
"class EchoClientProtocol:\n"
"    def __init__(self, message, loop):\n"
"        self.message = message\n"
"        self.loop = loop\n"
"        self.transport = None\n"
"\n"
"    def connection_made(self, transport):\n"
"        self.transport = transport\n"
"        print('Send:', self.message)\n"
"        self.transport.sendto(self.message.encode())\n"
"\n"
"    def datagram_received(self, data, addr):\n"
"        print(\"Received:\", data.decode())\n"
"\n"
"        print(\"Close the socket\")\n"
"        self.transport.close()\n"
"\n"
"    def error_received(self, exc):\n"
"        print('Error received:', exc)\n"
"\n"
"    def connection_lost(self, exc):\n"
"        print(\"Socket closed, stop the event loop\")\n"
"        loop = asyncio.get_event_loop()\n"
"        loop.stop()\n"
"\n"
"loop = asyncio.get_event_loop()\n"
"message = \"Hello World!\"\n"
"connect = loop.create_datagram_endpoint(\n"
"    lambda: EchoClientProtocol(message, loop),\n"
"    remote_addr=('127.0.0.1', 9999))\n"
"transport, protocol = loop.run_until_complete(connect)\n"
"loop.run_forever()\n"
"transport.close()\n"
"loop.close()"
msgstr ""

#: /home/runner/work/python-docs-l10n/python-docs-l10n/out/repo/Doc/library/asyncio-protocol.rst:643
msgid "UDP echo server protocol"
msgstr ""

#: /home/runner/work/python-docs-l10n/python-docs-l10n/out/repo/Doc/library/asyncio-protocol.rst:645
msgid ""
"UDP echo server using the :meth:`AbstractEventLoop.create_datagram_endpoint` "
"method, send back received data::"
msgstr ""

#: /home/runner/work/python-docs-l10n/python-docs-l10n/out/repo/Doc/library/asyncio-protocol.rst:648
msgid ""
"import asyncio\n"
"\n"
"class EchoServerProtocol:\n"
"    def connection_made(self, transport):\n"
"        self.transport = transport\n"
"\n"
"    def datagram_received(self, data, addr):\n"
"        message = data.decode()\n"
"        print('Received %r from %s' % (message, addr))\n"
"        print('Send %r to %s' % (message, addr))\n"
"        self.transport.sendto(data, addr)\n"
"\n"
"loop = asyncio.get_event_loop()\n"
"print(\"Starting UDP server\")\n"
"# One protocol instance will be created to serve all client requests\n"
"listen = loop.create_datagram_endpoint(\n"
"    EchoServerProtocol, local_addr=('127.0.0.1', 9999))\n"
"transport, protocol = loop.run_until_complete(listen)\n"
"\n"
"try:\n"
"    loop.run_forever()\n"
"except KeyboardInterrupt:\n"
"    pass\n"
"\n"
"transport.close()\n"
"loop.close()"
msgstr ""

#: /home/runner/work/python-docs-l10n/python-docs-l10n/out/repo/Doc/library/asyncio-protocol.rst:679
msgid "Register an open socket to wait for data using a protocol"
msgstr ""

#: /home/runner/work/python-docs-l10n/python-docs-l10n/out/repo/Doc/library/asyncio-protocol.rst:681
msgid ""
"Wait until a socket receives data using the :meth:`AbstractEventLoop."
"create_connection` method with a protocol, and then close the event loop ::"
msgstr ""

#: /home/runner/work/python-docs-l10n/python-docs-l10n/out/repo/Doc/library/asyncio-protocol.rst:685
msgid ""
"import asyncio\n"
"try:\n"
"    from socket import socketpair\n"
"except ImportError:\n"
"    from asyncio.windows_utils import socketpair\n"
"\n"
"# Create a pair of connected sockets\n"
"rsock, wsock = socketpair()\n"
"loop = asyncio.get_event_loop()\n"
"\n"
"class MyProtocol(asyncio.Protocol):\n"
"    transport = None\n"
"\n"
"    def connection_made(self, transport):\n"
"        self.transport = transport\n"
"\n"
"    def data_received(self, data):\n"
"        print(\"Received:\", data.decode())\n"
"\n"
"        # We are done: close the transport (it will call connection_lost())\n"
"        self.transport.close()\n"
"\n"
"    def connection_lost(self, exc):\n"
"        # The socket has been closed, stop the event loop\n"
"        loop.stop()\n"
"\n"
"# Register the socket to wait for data\n"
"connect_coro = loop.create_connection(MyProtocol, sock=rsock)\n"
"transport, protocol = loop.run_until_complete(connect_coro)\n"
"\n"
"# Simulate the reception of data from the network\n"
"loop.call_soon(wsock.send, 'abc'.encode())\n"
"\n"
"# Run the event loop\n"
"loop.run_forever()\n"
"\n"
"# We are done, close sockets and the event loop\n"
"rsock.close()\n"
"wsock.close()\n"
"loop.close()"
msgstr ""

#: /home/runner/work/python-docs-l10n/python-docs-l10n/out/repo/Doc/library/asyncio-protocol.rst:728
msgid ""
"The :ref:`watch a file descriptor for read events <asyncio-watch-read-"
"event>` example uses the low-level :meth:`AbstractEventLoop.add_reader` "
"method to register the file descriptor of a socket."
msgstr ""

#: /home/runner/work/python-docs-l10n/python-docs-l10n/out/repo/Doc/library/asyncio-protocol.rst:733
msgid ""
"The :ref:`register an open socket to wait for data using streams <asyncio-"
"register-socket-streams>` example uses high-level streams created by the :"
"func:`open_connection` function in a coroutine."
msgstr ""

# SOME DESCRIPTIVE TITLE.
# Copyright (C) 1990-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-10 15:08+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../library/sqlite3.rst:2
msgid ":mod:`sqlite3` --- DB-API 2.0 interface for SQLite databases"
msgstr ""

#: ../../../library/sqlite3.rst:9
msgid ""
"SQLite is a C library that provides a lightweight disk-based database that "
"doesn't require a separate server process and allows accessing the database "
"using a nonstandard variant of the SQL query language. Some applications can "
"use SQLite for internal data storage.  It's also possible to prototype an "
"application using SQLite and then port the code to a larger database such as "
"PostgreSQL or Oracle."
msgstr ""

#: ../../../library/sqlite3.rst:16
msgid ""
"sqlite3 was written by Gerhard Häring and provides a SQL interface compliant "
"with the DB-API 2.0 specification described by :pep:`249`."
msgstr ""

#: ../../../library/sqlite3.rst:19
msgid ""
"To use the module, you must first create a :class:`Connection` object that "
"represents the database.  Here the data will be stored in the :file:`example."
"db` file::"
msgstr ""

#: ../../../library/sqlite3.rst:23
msgid ""
"import sqlite3\n"
"conn = sqlite3.connect('example.db')"
msgstr ""

#: ../../../library/sqlite3.rst:26
msgid ""
"You can also supply the special name ``:memory:`` to create a database in "
"RAM."
msgstr ""

#: ../../../library/sqlite3.rst:28
msgid ""
"Once you have a :class:`Connection`, you can create a :class:`Cursor`  "
"object and call its :meth:`~Cursor.execute` method to perform SQL commands::"
msgstr ""

#: ../../../library/sqlite3.rst:31
msgid ""
"c = conn.cursor()\n"
"\n"
"# Create table\n"
"c.execute('''create table stocks\n"
"(date text, trans text, symbol text,\n"
" qty real, price real)''')\n"
"\n"
"# Insert a row of data\n"
"c.execute(\"\"\"insert into stocks\n"
"          values ('2006-01-05','BUY','RHAT',100,35.14)\"\"\")\n"
"\n"
"# Save (commit) the changes\n"
"conn.commit()\n"
"\n"
"# We can also close the cursor if we are done with it\n"
"c.close()"
msgstr ""

#: ../../../library/sqlite3.rst:48
msgid ""
"Usually your SQL operations will need to use values from Python variables.  "
"You shouldn't assemble your query using Python's string operations because "
"doing so is insecure; it makes your program vulnerable to an SQL injection "
"attack."
msgstr ""

#: ../../../library/sqlite3.rst:52
msgid ""
"Instead, use the DB-API's parameter substitution.  Put ``?`` as a "
"placeholder wherever you want to use a value, and then provide a tuple of "
"values as the second argument to the cursor's :meth:`~Cursor.execute` "
"method.  (Other database modules may use a different placeholder, such as "
"``%s`` or ``:1``.) For example::"
msgstr ""

#: ../../../library/sqlite3.rst:58
msgid ""
"# Never do this -- insecure!\n"
"symbol = 'IBM'\n"
"c.execute(\"select * from stocks where symbol = '%s'\" % symbol)\n"
"\n"
"# Do this instead\n"
"t = ('IBM',)\n"
"c.execute('select * from stocks where symbol=?', t)\n"
"\n"
"# Larger example\n"
"for t in [('2006-03-28', 'BUY', 'IBM', 1000, 45.00),\n"
"          ('2006-04-05', 'BUY', 'MSFT', 1000, 72.00),\n"
"          ('2006-04-06', 'SELL', 'IBM', 500, 53.00),\n"
"         ]:\n"
"    c.execute('insert into stocks values (?,?,?,?,?)', t)"
msgstr ""

#: ../../../library/sqlite3.rst:73
msgid ""
"To retrieve data after executing a SELECT statement, you can either treat "
"the cursor as an :term:`iterator`, call the cursor's :meth:`~Cursor."
"fetchone` method to retrieve a single matching row, or call :meth:`~Cursor."
"fetchall` to get a list of the matching rows."
msgstr ""

#: ../../../library/sqlite3.rst:78
msgid "This example uses the iterator form::"
msgstr ""

#: ../../../library/sqlite3.rst:80
msgid ""
">>> c = conn.cursor()\n"
">>> c.execute('select * from stocks order by price')\n"
">>> for row in c:\n"
"...     print(row)\n"
"...\n"
"('2006-01-05', 'BUY', 'RHAT', 100, 35.14)\n"
"('2006-03-28', 'BUY', 'IBM', 1000, 45.0)\n"
"('2006-04-06', 'SELL', 'IBM', 500, 53.0)\n"
"('2006-04-05', 'BUY', 'MSOFT', 1000, 72.0)\n"
">>>"
msgstr ""

#: ../../../library/sqlite3.rst:96
msgid "http://code.google.com/p/pysqlite/"
msgstr ""

#: ../../../library/sqlite3.rst:95
msgid ""
"The pysqlite web page -- sqlite3 is developed externally under the name "
"\"pysqlite\"."
msgstr ""

#: ../../../library/sqlite3.rst:100
msgid "http://www.sqlite.org"
msgstr ""

#: ../../../library/sqlite3.rst:99
msgid ""
"The SQLite web page; the documentation describes the syntax and the "
"available data types for the supported SQL dialect."
msgstr ""

#: ../../../library/sqlite3.rst:102
msgid ":pep:`249` - Database API Specification 2.0"
msgstr ""

#: ../../../library/sqlite3.rst:103
msgid "PEP written by Marc-André Lemburg."
msgstr ""

#: ../../../library/sqlite3.rst:109
msgid "Module functions and constants"
msgstr ""

#: ../../../library/sqlite3.rst:114
msgid ""
"The version number of this module, as a string. This is not the version of "
"the SQLite library."
msgstr ""

#: ../../../library/sqlite3.rst:120
msgid ""
"The version number of this module, as a tuple of integers. This is not the "
"version of the SQLite library."
msgstr ""

#: ../../../library/sqlite3.rst:126
msgid "The version number of the run-time SQLite library, as a string."
msgstr ""

#: ../../../library/sqlite3.rst:131
msgid ""
"The version number of the run-time SQLite library, as a tuple of integers."
msgstr ""

#: ../../../library/sqlite3.rst:136 ../../../library/sqlite3.rst:149
msgid ""
"This constant is meant to be used with the *detect_types* parameter of the :"
"func:`connect` function."
msgstr ""

#: ../../../library/sqlite3.rst:139
msgid ""
"Setting it makes the :mod:`sqlite3` module parse the declared type for each "
"column it returns.  It will parse out the first word of the declared type, "
"i. e.  for \"integer primary key\", it will parse out \"integer\", or for "
"\"number(10)\" it will parse out \"number\". Then for that column, it will "
"look into the converters dictionary and use the converter function "
"registered for that type there."
msgstr ""

#: ../../../library/sqlite3.rst:152
msgid ""
"Setting this makes the SQLite interface parse the column name for each "
"column it returns.  It will look for a string formed [mytype] in there, and "
"then decide that 'mytype' is the type of the column. It will try to find an "
"entry of 'mytype' in the converters dictionary and then use the converter "
"function found there to return the value. The column name found in :attr:"
"`Cursor.description` is only the first word of the column name, i.  e. if "
"you use something like ``'as \"x [datetime]\"'`` in your SQL, then we will "
"parse out everything until the first blank for the column name: the column "
"name would simply be \"x\"."
msgstr ""

#: ../../../library/sqlite3.rst:164
msgid ""
"Opens a connection to the SQLite database file *database*. You can use ``\":"
"memory:\"`` to open a database connection to a database that resides in RAM "
"instead of on disk."
msgstr ""

#: ../../../library/sqlite3.rst:168
msgid ""
"When a database is accessed by multiple connections, and one of the "
"processes modifies the database, the SQLite database is locked until that "
"transaction is committed. The *timeout* parameter specifies how long the "
"connection should wait for the lock to go away until raising an exception. "
"The default for the timeout parameter is 5.0 (five seconds)."
msgstr ""

#: ../../../library/sqlite3.rst:174
msgid ""
"For the *isolation_level* parameter, please see the :attr:`Connection."
"isolation_level` property of :class:`Connection` objects."
msgstr ""

#: ../../../library/sqlite3.rst:177
msgid ""
"SQLite natively supports only the types TEXT, INTEGER, FLOAT, BLOB and NULL. "
"If you want to use other types you must add support for them yourself. The "
"*detect_types* parameter and the using custom **converters** registered with "
"the module-level :func:`register_converter` function allow you to easily do "
"that."
msgstr ""

#: ../../../library/sqlite3.rst:182
msgid ""
"*detect_types* defaults to 0 (i. e. off, no type detection), you can set it "
"to any combination of :const:`PARSE_DECLTYPES` and :const:`PARSE_COLNAMES` "
"to turn type detection on."
msgstr ""

#: ../../../library/sqlite3.rst:186
msgid ""
"By default, the :mod:`sqlite3` module uses its :class:`Connection` class for "
"the connect call.  You can, however, subclass the :class:`Connection` class "
"and make :func:`connect` use your class instead by providing your class for "
"the *factory* parameter."
msgstr ""

#: ../../../library/sqlite3.rst:191
msgid "Consult the section :ref:`sqlite3-types` of this manual for details."
msgstr ""

#: ../../../library/sqlite3.rst:193
msgid ""
"The :mod:`sqlite3` module internally uses a statement cache to avoid SQL "
"parsing overhead. If you want to explicitly set the number of statements "
"that are cached for the connection, you can set the *cached_statements* "
"parameter. The currently implemented default is to cache 100 statements."
msgstr ""

#: ../../../library/sqlite3.rst:201
msgid ""
"Registers a callable to convert a bytestring from the database into a custom "
"Python type. The callable will be invoked for all database values that are "
"of the type *typename*. Confer the parameter *detect_types* of the :func:"
"`connect` function for how the type detection works. Note that the case of "
"*typename* and the name of the type in your query must match!"
msgstr ""

#: ../../../library/sqlite3.rst:210
msgid ""
"Registers a callable to convert the custom Python type *type* into one of "
"SQLite's supported types. The callable *callable* accepts as single "
"parameter the Python value, and must return a value of the following types: "
"int, float, str or bytes."
msgstr ""

#: ../../../library/sqlite3.rst:218
msgid ""
"Returns :const:`True` if the string *sql* contains one or more complete SQL "
"statements terminated by semicolons. It does not verify that the SQL is "
"syntactically correct, only that there are no unclosed string literals and "
"the statement is terminated by a semicolon."
msgstr ""

#: ../../../library/sqlite3.rst:223
msgid ""
"This can be used to build a shell for SQLite, as in the following example:"
msgstr ""

#: ../../../library/sqlite3.rst:226
msgid ""
"# A minimal SQLite shell for experiments\n"
"\n"
"import sqlite3\n"
"\n"
"con = sqlite3.connect(\":memory:\")\n"
"con.isolation_level = None\n"
"cur = con.cursor()\n"
"\n"
"buffer = \"\"\n"
"\n"
"print(\"Enter your SQL commands to execute in sqlite3.\")\n"
"print(\"Enter a blank line to exit.\")\n"
"\n"
"while True:\n"
"    line = input()\n"
"    if line == \"\":\n"
"        break\n"
"    buffer += line\n"
"    if sqlite3.complete_statement(buffer):\n"
"        try:\n"
"            buffer = buffer.strip()\n"
"            cur.execute(buffer)\n"
"\n"
"            if buffer.lstrip().upper().startswith(\"SELECT\"):\n"
"                print(cur.fetchall())\n"
"        except sqlite3.Error as e:\n"
"            print(\"An error occurred:\", e.args[0])\n"
"        buffer = \"\"\n"
"\n"
"con.close()\n"
msgstr ""

#: ../../../library/sqlite3.rst:231
msgid ""
"By default you will not get any tracebacks in user-defined functions, "
"aggregates, converters, authorizer callbacks etc. If you want to debug them, "
"you can call this function with *flag* as True. Afterwards, you will get "
"tracebacks from callbacks on ``sys.stderr``. Use :const:`False` to disable "
"the feature again."
msgstr ""

#: ../../../library/sqlite3.rst:241
msgid "Connection Objects"
msgstr ""

#: ../../../library/sqlite3.rst:245
msgid "A SQLite database connection has the following attributes and methods:"
msgstr ""

#: ../../../library/sqlite3.rst:249
msgid ""
"Get or set the current isolation level. :const:`None` for autocommit mode or "
"one of \"DEFERRED\", \"IMMEDIATE\" or \"EXCLUSIVE\". See section :ref:"
"`sqlite3-controlling-transactions` for a more detailed explanation."
msgstr ""

#: ../../../library/sqlite3.rst:255
msgid ""
":const:`True` if a transaction is active (there are uncommitted changes), :"
"const:`False` otherwise.  Read-only attribute."
msgstr ""

#: ../../../library/sqlite3.rst:262
msgid ""
"The cursor method accepts a single optional parameter *cursorClass*. If "
"supplied, this must be a custom cursor class that extends :class:`sqlite3."
"Cursor`."
msgstr ""

#: ../../../library/sqlite3.rst:268
msgid ""
"This method commits the current transaction. If you don't call this method, "
"anything you did since the last call to ``commit()`` is not visible from "
"other database connections. If you wonder why you don't see the data you've "
"written to the database, please check you didn't forget to call this method."
msgstr ""

#: ../../../library/sqlite3.rst:275
msgid ""
"This method rolls back any changes to the database since the last call to :"
"meth:`commit`."
msgstr ""

#: ../../../library/sqlite3.rst:280
msgid ""
"This closes the database connection. Note that this does not automatically "
"call :meth:`commit`. If you just close your database connection without "
"calling :meth:`commit` first, your changes will be lost!"
msgstr ""

#: ../../../library/sqlite3.rst:286
msgid ""
"This is a nonstandard shortcut that creates an intermediate cursor object by "
"calling the cursor method, then calls the cursor's :meth:`execute <Cursor."
"execute>` method with the parameters given."
msgstr ""

#: ../../../library/sqlite3.rst:293
msgid ""
"This is a nonstandard shortcut that creates an intermediate cursor object by "
"calling the cursor method, then calls the cursor's :meth:`executemany "
"<Cursor.executemany>` method with the parameters given."
msgstr ""

#: ../../../library/sqlite3.rst:299
msgid ""
"This is a nonstandard shortcut that creates an intermediate cursor object by "
"calling the cursor method, then calls the cursor's :meth:`executescript "
"<Cursor.executescript>` method with the parameters given."
msgstr ""

#: ../../../library/sqlite3.rst:306
msgid ""
"Creates a user-defined function that you can later use from within SQL "
"statements under the function name *name*. *num_params* is the number of "
"parameters the function accepts, and *func* is a Python callable that is "
"called as the SQL function."
msgstr ""

#: ../../../library/sqlite3.rst:311
msgid ""
"The function can return any of the types supported by SQLite: bytes, str, "
"int, float and None."
msgstr ""

#: ../../../library/sqlite3.rst:314 ../../../library/sqlite3.rst:330
#: ../../../library/sqlite3.rst:424 ../../../library/sqlite3.rst:528
msgid "Example:"
msgstr ""

#: ../../../library/sqlite3.rst:316
msgid ""
"import sqlite3\n"
"import hashlib\n"
"\n"
"def md5sum(t):\n"
"    return hashlib.md5(t).hexdigest()\n"
"\n"
"con = sqlite3.connect(\":memory:\")\n"
"con.create_function(\"md5\", 1, md5sum)\n"
"cur = con.cursor()\n"
"cur.execute(\"select md5(?)\", (b\"foo\",))\n"
"print(cur.fetchone()[0])\n"
msgstr ""

#: ../../../library/sqlite3.rst:321
msgid "Creates a user-defined aggregate function."
msgstr ""

#: ../../../library/sqlite3.rst:323
msgid ""
"The aggregate class must implement a ``step`` method, which accepts the "
"number of parameters *num_params*, and a ``finalize`` method which will "
"return the final result of the aggregate."
msgstr ""

#: ../../../library/sqlite3.rst:327
msgid ""
"The ``finalize`` method can return any of the types supported by SQLite: "
"bytes, str, int, float and None."
msgstr ""

#: ../../../library/sqlite3.rst:332
msgid ""
"import sqlite3\n"
"\n"
"class MySum:\n"
"    def __init__(self):\n"
"        self.count = 0\n"
"\n"
"    def step(self, value):\n"
"        self.count += value\n"
"\n"
"    def finalize(self):\n"
"        return self.count\n"
"\n"
"con = sqlite3.connect(\":memory:\")\n"
"con.create_aggregate(\"mysum\", 1, MySum)\n"
"cur = con.cursor()\n"
"cur.execute(\"create table test(i)\")\n"
"cur.execute(\"insert into test(i) values (1)\")\n"
"cur.execute(\"insert into test(i) values (2)\")\n"
"cur.execute(\"select mysum(i) from test\")\n"
"print(cur.fetchone()[0])\n"
msgstr ""

#: ../../../library/sqlite3.rst:337
msgid ""
"Creates a collation with the specified *name* and *callable*. The callable "
"will be passed two string arguments. It should return -1 if the first is "
"ordered lower than the second, 0 if they are ordered equal and 1 if the "
"first is ordered higher than the second.  Note that this controls sorting "
"(ORDER BY in SQL) so your comparisons don't affect other SQL operations."
msgstr ""

#: ../../../library/sqlite3.rst:343
msgid ""
"Note that the callable will get its parameters as Python bytestrings, which "
"will normally be encoded in UTF-8."
msgstr ""

#: ../../../library/sqlite3.rst:346
msgid ""
"The following example shows a custom collation that sorts \"the wrong way\":"
msgstr ""

#: ../../../library/sqlite3.rst:348
msgid ""
"import sqlite3\n"
"\n"
"def collate_reverse(string1, string2):\n"
"    if string1 == string2:\n"
"        return 0\n"
"    elif string1 < string2:\n"
"        return 1\n"
"    else:\n"
"        return -1\n"
"\n"
"con = sqlite3.connect(\":memory:\")\n"
"con.create_collation(\"reverse\", collate_reverse)\n"
"\n"
"cur = con.cursor()\n"
"cur.execute(\"create table test(x)\")\n"
"cur.executemany(\"insert into test(x) values (?)\", [(\"a\",), (\"b\",)])\n"
"cur.execute(\"select x from test order by x collate reverse\")\n"
"for row in cur:\n"
"    print(row)\n"
"con.close()\n"
msgstr ""

#: ../../../library/sqlite3.rst:350
msgid ""
"To remove a collation, call ``create_collation`` with None as callable::"
msgstr ""

#: ../../../library/sqlite3.rst:352
msgid "con.create_collation(\"reverse\", None)"
msgstr ""

#: ../../../library/sqlite3.rst:357
msgid ""
"You can call this method from a different thread to abort any queries that "
"might be executing on the connection. The query will then abort and the "
"caller will get an exception."
msgstr ""

#: ../../../library/sqlite3.rst:364
msgid ""
"This routine registers a callback. The callback is invoked for each attempt "
"to access a column of a table in the database. The callback should return :"
"const:`SQLITE_OK` if access is allowed, :const:`SQLITE_DENY` if the entire "
"SQL statement should be aborted with an error and :const:`SQLITE_IGNORE` if "
"the column should be treated as a NULL value. These constants are available "
"in the :mod:`sqlite3` module."
msgstr ""

#: ../../../library/sqlite3.rst:371
msgid ""
"The first argument to the callback signifies what kind of operation is to be "
"authorized. The second and third argument will be arguments or :const:`None` "
"depending on the first argument. The 4th argument is the name of the "
"database (\"main\", \"temp\", etc.) if applicable. The 5th argument is the "
"name of the inner-most trigger or view that is responsible for the access "
"attempt or :const:`None` if this access attempt is directly from input SQL "
"code."
msgstr ""

#: ../../../library/sqlite3.rst:378
msgid ""
"Please consult the SQLite documentation about the possible values for the "
"first argument and the meaning of the second and third argument depending on "
"the first one. All necessary constants are available in the :mod:`sqlite3` "
"module."
msgstr ""

#: ../../../library/sqlite3.rst:385
msgid ""
"This routine registers a callback. The callback is invoked for every *n* "
"instructions of the SQLite virtual machine. This is useful if you want to "
"get called from SQLite during long-running operations, for example to update "
"a GUI."
msgstr ""

#: ../../../library/sqlite3.rst:390
msgid ""
"If you want to clear any previously installed progress handler, call the "
"method with :const:`None` for *handler*."
msgstr ""

#: ../../../library/sqlite3.rst:396
msgid ""
"This routine allows/disallows the SQLite engine to load SQLite extensions "
"from shared libraries.  SQLite extensions can define new functions, "
"aggregates or whole new virtual table implementations.  One well-known "
"extension is the fulltext-search extension distributed with SQLite."
msgstr ""

#: ../../../library/sqlite3.rst:401 ../../../library/sqlite3.rst:413
msgid "Loadable extensions are disabled by default. See [#f1]_."
msgstr ""

#: ../../../library/sqlite3.rst:405
msgid ""
"import sqlite3\n"
"\n"
"con = sqlite3.connect(\":memory:\")\n"
"\n"
"# enable extension loading\n"
"con.enable_load_extension(True)\n"
"\n"
"# Load the fulltext search extension\n"
"con.execute(\"select load_extension('./fts3.so')\")\n"
"\n"
"# alternatively you can load the extension using an API call:\n"
"# con.load_extension(\"./fts3.so\")\n"
"\n"
"# disable extension laoding again\n"
"con.enable_load_extension(False)\n"
"\n"
"# example from SQLite wiki\n"
"con.execute(\"create virtual table recipe using fts3(name, ingredients)\")\n"
"con.executescript(\"\"\"\n"
"    insert into recipe (name, ingredients) values ('broccoli stew', "
"'broccoli peppers cheese tomatoes');\n"
"    insert into recipe (name, ingredients) values ('pumpkin stew', 'pumpkin "
"onions garlic celery');\n"
"    insert into recipe (name, ingredients) values ('broccoli pie', 'broccoli "
"cheese onions flour');\n"
"    insert into recipe (name, ingredients) values ('pumpkin pie', 'pumpkin "
"sugar flour butter');\n"
"    \"\"\")\n"
"for row in con.execute(\"select rowid, name, ingredients from recipe where "
"name match 'pie'\"):\n"
"    print(row)\n"
msgstr ""

#: ../../../library/sqlite3.rst:409
msgid ""
"This routine loads a SQLite extension from a shared library.  You have to "
"enable extension loading with :meth:`enable_load_extension` before you can "
"use this routine."
msgstr ""

#: ../../../library/sqlite3.rst:419
msgid ""
"You can change this attribute to a callable that accepts the cursor and the "
"original row as a tuple and will return the real result row.  This way, you "
"can implement more advanced ways of returning results, such  as returning an "
"object that can also access columns by name."
msgstr ""

#: ../../../library/sqlite3.rst:426
msgid ""
"import sqlite3\n"
"\n"
"def dict_factory(cursor, row):\n"
"    d = {}\n"
"    for idx, col in enumerate(cursor.description):\n"
"        d[col[0]] = row[idx]\n"
"    return d\n"
"\n"
"con = sqlite3.connect(\":memory:\")\n"
"con.row_factory = dict_factory\n"
"cur = con.cursor()\n"
"cur.execute(\"select 1 as a\")\n"
"print(cur.fetchone()[\"a\"])\n"
msgstr ""

#: ../../../library/sqlite3.rst:428
msgid ""
"If returning a tuple doesn't suffice and you want name-based access to "
"columns, you should consider setting :attr:`row_factory` to the highly-"
"optimized :class:`sqlite3.Row` type. :class:`Row` provides both index-based "
"and case-insensitive name-based access to columns with almost no memory "
"overhead. It will probably be better than your own custom dictionary-based "
"approach or even a db_row based solution."
msgstr ""

#: ../../../library/sqlite3.rst:440
msgid ""
"Using this attribute you can control what objects are returned for the "
"``TEXT`` data type. By default, this attribute is set to :class:`str` and "
"the :mod:`sqlite3` module will return Unicode objects for ``TEXT``. If you "
"want to return bytestrings instead, you can set it to :class:`bytes`."
msgstr ""

#: ../../../library/sqlite3.rst:445
msgid ""
"For efficiency reasons, there's also a way to return :class:`str` objects "
"only for non-ASCII data, and :class:`bytes` otherwise. To activate it, set "
"this attribute to :const:`sqlite3.OptimizedUnicode`."
msgstr ""

#: ../../../library/sqlite3.rst:449
msgid ""
"You can also set it to any other callable that accepts a single bytestring "
"parameter and returns the resulting object."
msgstr ""

#: ../../../library/sqlite3.rst:452
msgid "See the following example code for illustration:"
msgstr ""

#: ../../../library/sqlite3.rst:454
msgid ""
"import sqlite3\n"
"\n"
"con = sqlite3.connect(\":memory:\")\n"
"cur = con.cursor()\n"
"\n"
"AUSTRIA = \"\\xd6sterreich\"\n"
"\n"
"# by default, rows are returned as Unicode\n"
"cur.execute(\"select ?\", (AUSTRIA,))\n"
"row = cur.fetchone()\n"
"assert row[0] == AUSTRIA\n"
"\n"
"# but we can make sqlite3 always return bytestrings ...\n"
"con.text_factory = bytes\n"
"cur.execute(\"select ?\", (AUSTRIA,))\n"
"row = cur.fetchone()\n"
"assert type(row[0]) is bytes\n"
"# the bytestrings will be encoded in UTF-8, unless you stored garbage in "
"the\n"
"# database ...\n"
"assert row[0] == AUSTRIA.encode(\"utf-8\")\n"
"\n"
"# we can also implement a custom text_factory ...\n"
"# here we implement one that appends \"foo\" to all strings\n"
"con.text_factory = lambda x: x.decode(\"utf-8\") + \"foo\"\n"
"cur.execute(\"select ?\", (\"bar\",))\n"
"row = cur.fetchone()\n"
"assert row[0] == \"barfoo\"\n"
msgstr ""

#: ../../../library/sqlite3.rst:459
msgid ""
"Returns the total number of database rows that have been modified, inserted, "
"or deleted since the database connection was opened."
msgstr ""

#: ../../../library/sqlite3.rst:465
msgid ""
"Returns an iterator to dump the database in an SQL text format.  Useful when "
"saving an in-memory database for later restoration.  This function provides "
"the same capabilities as the :kbd:`.dump` command in the :program:`sqlite3` "
"shell."
msgstr ""

#: ../../../library/sqlite3.rst:470
msgid "Example::"
msgstr ""

#: ../../../library/sqlite3.rst:472
msgid ""
"# Convert file existing_db.db to SQL dump file dump.sql\n"
"import sqlite3, os\n"
"\n"
"con = sqlite3.connect('existing_db.db')\n"
"with open('dump.sql', 'w') as f:\n"
"    for line in con.iterdump():\n"
"        f.write('%s\\n' % line)"
msgstr ""

#: ../../../library/sqlite3.rst:484
msgid "Cursor Objects"
msgstr ""

#: ../../../library/sqlite3.rst:488
msgid "A :class:`Cursor` instance has the following attributes and methods."
msgstr ""

#: ../../../library/sqlite3.rst:492
msgid ""
"Executes an SQL statement. The SQL statement may be parametrized (i. e. "
"placeholders instead of SQL literals). The :mod:`sqlite3` module supports "
"two kinds of placeholders: question marks (qmark style) and named "
"placeholders (named style)."
msgstr ""

#: ../../../library/sqlite3.rst:497
msgid "Here's an example of both styles:"
msgstr ""

#: ../../../library/sqlite3.rst:499
msgid ""
"import sqlite3\n"
"\n"
"con = sqlite3.connect(\":memory:\")\n"
"cur = con.cursor()\n"
"cur.execute(\"create table people (name_last, age)\")\n"
"\n"
"who = \"Yeltsin\"\n"
"age = 72\n"
"\n"
"# This is the qmark style:\n"
"cur.execute(\"insert into people values (?, ?)\", (who, age))\n"
"\n"
"# And this is the named style:\n"
"cur.execute(\"select * from people where name_last=:who and age=:age\", "
"{\"who\": who, \"age\": age})\n"
"\n"
"print(cur.fetchone())\n"
msgstr ""

#: ../../../library/sqlite3.rst:501
msgid ""
":meth:`execute` will only execute a single SQL statement. If you try to "
"execute more than one statement with it, it will raise a Warning. Use :meth:"
"`executescript` if you want to execute multiple SQL statements with one call."
msgstr ""

#: ../../../library/sqlite3.rst:509
msgid ""
"Executes an SQL command against all parameter sequences or mappings found in "
"the sequence *sql*.  The :mod:`sqlite3` module also allows using an :term:"
"`iterator` yielding parameters instead of a sequence."
msgstr ""

#: ../../../library/sqlite3.rst:513
msgid ""
"import sqlite3\n"
"\n"
"class IterChars:\n"
"    def __init__(self):\n"
"        self.count = ord('a')\n"
"\n"
"    def __iter__(self):\n"
"        return self\n"
"\n"
"    def __next__(self):\n"
"        if self.count > ord('z'):\n"
"            raise StopIteration\n"
"        self.count += 1\n"
"        return (chr(self.count - 1),) # this is a 1-tuple\n"
"\n"
"con = sqlite3.connect(\":memory:\")\n"
"cur = con.cursor()\n"
"cur.execute(\"create table characters(c)\")\n"
"\n"
"theIter = IterChars()\n"
"cur.executemany(\"insert into characters(c) values (?)\", theIter)\n"
"\n"
"cur.execute(\"select c from characters\")\n"
"print(cur.fetchall())\n"
msgstr ""

#: ../../../library/sqlite3.rst:515
msgid "Here's a shorter example using a :term:`generator`:"
msgstr ""

#: ../../../library/sqlite3.rst:517
msgid ""
"import sqlite3\n"
"import string\n"
"\n"
"def char_generator():\n"
"    for c in string.ascii_lowercase:\n"
"        yield (c,)\n"
"\n"
"con = sqlite3.connect(\":memory:\")\n"
"cur = con.cursor()\n"
"cur.execute(\"create table characters(c)\")\n"
"\n"
"cur.executemany(\"insert into characters(c) values (?)\", char_generator())\n"
"\n"
"cur.execute(\"select c from characters\")\n"
"print(cur.fetchall())\n"
msgstr ""

#: ../../../library/sqlite3.rst:522
msgid ""
"This is a nonstandard convenience method for executing multiple SQL "
"statements at once. It issues a ``COMMIT`` statement first, then executes "
"the SQL script it gets as a parameter."
msgstr ""

#: ../../../library/sqlite3.rst:526
msgid "*sql_script* can be an instance of :class:`str` or :class:`bytes`."
msgstr ""

#: ../../../library/sqlite3.rst:530
msgid ""
"import sqlite3\n"
"\n"
"con = sqlite3.connect(\":memory:\")\n"
"cur = con.cursor()\n"
"cur.executescript(\"\"\"\n"
"    create table person(\n"
"        firstname,\n"
"        lastname,\n"
"        age\n"
"    );\n"
"\n"
"    create table book(\n"
"        title,\n"
"        author,\n"
"        published\n"
"    );\n"
"\n"
"    insert into book(title, author, published)\n"
"    values (\n"
"        'Dirk Gently''s Holistic Detective Agency',\n"
"        'Douglas Adams',\n"
"        1987\n"
"    );\n"
"    \"\"\")\n"
msgstr ""

#: ../../../library/sqlite3.rst:535
msgid ""
"Fetches the next row of a query result set, returning a single sequence, or :"
"const:`None` when no more data is available."
msgstr ""

#: ../../../library/sqlite3.rst:541
msgid ""
"Fetches the next set of rows of a query result, returning a list.  An empty "
"list is returned when no more rows are available."
msgstr ""

#: ../../../library/sqlite3.rst:544
msgid ""
"The number of rows to fetch per call is specified by the *size* parameter. "
"If it is not given, the cursor's arraysize determines the number of rows to "
"be fetched. The method should try to fetch as many rows as indicated by the "
"size parameter. If this is not possible due to the specified number of rows "
"not being available, fewer rows may be returned."
msgstr ""

#: ../../../library/sqlite3.rst:550
msgid ""
"Note there are performance considerations involved with the *size* "
"parameter. For optimal performance, it is usually best to use the arraysize "
"attribute. If the *size* parameter is used, then it is best for it to retain "
"the same value from one :meth:`fetchmany` call to the next."
msgstr ""

#: ../../../library/sqlite3.rst:557
msgid ""
"Fetches all (remaining) rows of a query result, returning a list.  Note that "
"the cursor's arraysize attribute can affect the performance of this "
"operation. An empty list is returned when no rows are available."
msgstr ""

#: ../../../library/sqlite3.rst:564
msgid ""
"Although the :class:`Cursor` class of the :mod:`sqlite3` module implements "
"this attribute, the database engine's own support for the determination of "
"\"rows affected\"/\"rows selected\" is quirky."
msgstr ""

#: ../../../library/sqlite3.rst:568
msgid ""
"For :meth:`executemany` statements, the number of modifications are summed "
"up into :attr:`rowcount`."
msgstr ""

#: ../../../library/sqlite3.rst:571
msgid ""
"As required by the Python DB API Spec, the :attr:`rowcount` attribute \"is "
"-1 in case no ``executeXX()`` has been performed on the cursor or the "
"rowcount of the last operation is not determinable by the interface\". This "
"includes ``SELECT`` statements because we cannot determine the number of "
"rows a query produced until all rows were fetched."
msgstr ""

#: ../../../library/sqlite3.rst:577
msgid ""
"With SQLite versions before 3.6.5, :attr:`rowcount` is set to 0 if you make "
"a ``DELETE FROM table`` without any condition."
msgstr ""

#: ../../../library/sqlite3.rst:582
msgid ""
"This read-only attribute provides the rowid of the last modified row. It is "
"only set if you issued a ``INSERT`` statement using the :meth:`execute` "
"method. For operations other than ``INSERT`` or when :meth:`executemany` is "
"called, :attr:`lastrowid` is set to :const:`None`."
msgstr ""

#: ../../../library/sqlite3.rst:589
msgid ""
"This read-only attribute provides the column names of the last query. To "
"remain compatible with the Python DB API, it returns a 7-tuple for each "
"column where the last six items of each tuple are :const:`None`."
msgstr ""

#: ../../../library/sqlite3.rst:593
msgid "It is set for ``SELECT`` statements without any matching rows as well."
msgstr ""

#: ../../../library/sqlite3.rst:598
msgid "Row Objects"
msgstr ""

#: ../../../library/sqlite3.rst:602
msgid ""
"A :class:`Row` instance serves as a highly optimized :attr:`~Connection."
"row_factory` for :class:`Connection` objects. It tries to mimic a tuple in "
"most of its features."
msgstr ""

#: ../../../library/sqlite3.rst:606
msgid ""
"It supports mapping access by column name and index, iteration, "
"representation, equality testing and :func:`len`."
msgstr ""

#: ../../../library/sqlite3.rst:609
msgid ""
"If two :class:`Row` objects have exactly the same columns and their members "
"are equal, they compare equal."
msgstr ""

#: ../../../library/sqlite3.rst:614
msgid ""
"This method returns a tuple of column names. Immediately after a query, it "
"is the first member of each tuple in :attr:`Cursor.description`."
msgstr ""

#: ../../../library/sqlite3.rst:617
msgid "Let's assume we initialize a table as in the example given above::"
msgstr ""

#: ../../../library/sqlite3.rst:619
msgid ""
"conn = sqlite3.connect(\":memory:\")\n"
"c = conn.cursor()\n"
"c.execute('''create table stocks\n"
"(date text, trans text, symbol text,\n"
" qty real, price real)''')\n"
"c.execute(\"\"\"insert into stocks\n"
"          values ('2006-01-05','BUY','RHAT',100,35.14)\"\"\")\n"
"conn.commit()\n"
"c.close()"
msgstr ""

#: ../../../library/sqlite3.rst:629
msgid "Now we plug :class:`Row` in::"
msgstr ""

#: ../../../library/sqlite3.rst:631
msgid ""
">>> conn.row_factory = sqlite3.Row\n"
">>> c = conn.cursor()\n"
">>> c.execute('select * from stocks')\n"
"<sqlite3.Cursor object at 0x7f4e7dd8fa80>\n"
">>> r = c.fetchone()\n"
">>> type(r)\n"
"<class 'sqlite3.Row'>\n"
">>> tuple(r)\n"
"('2006-01-05', 'BUY', 'RHAT', 100.0, 35.14)\n"
">>> len(r)\n"
"5\n"
">>> r[2]\n"
"'RHAT'\n"
">>> r.keys()\n"
"['date', 'trans', 'symbol', 'qty', 'price']\n"
">>> r['qty']\n"
"100.0\n"
">>> for member in r:\n"
"...     print(member)\n"
"...\n"
"2006-01-05\n"
"BUY\n"
"RHAT\n"
"100.0\n"
"35.14"
msgstr ""

#: ../../../library/sqlite3.rst:661
msgid "SQLite and Python types"
msgstr ""

#: ../../../library/sqlite3.rst:665
msgid "Introduction"
msgstr ""

#: ../../../library/sqlite3.rst:667
msgid ""
"SQLite natively supports the following types: ``NULL``, ``INTEGER``, "
"``REAL``, ``TEXT``, ``BLOB``."
msgstr ""

#: ../../../library/sqlite3.rst:670
msgid ""
"The following Python types can thus be sent to SQLite without any problem:"
msgstr ""

#: ../../../library/sqlite3.rst:673 ../../../library/sqlite3.rst:690
msgid "Python type"
msgstr ""

#: ../../../library/sqlite3.rst:673 ../../../library/sqlite3.rst:690
msgid "SQLite type"
msgstr ""

#: ../../../library/sqlite3.rst:675 ../../../library/sqlite3.rst:692
msgid ":const:`None`"
msgstr ""

#: ../../../library/sqlite3.rst:675 ../../../library/sqlite3.rst:692
msgid "``NULL``"
msgstr ""

#: ../../../library/sqlite3.rst:677 ../../../library/sqlite3.rst:694
msgid ":class:`int`"
msgstr ""

#: ../../../library/sqlite3.rst:677 ../../../library/sqlite3.rst:694
msgid "``INTEGER``"
msgstr ""

#: ../../../library/sqlite3.rst:679 ../../../library/sqlite3.rst:696
msgid ":class:`float`"
msgstr ""

#: ../../../library/sqlite3.rst:679 ../../../library/sqlite3.rst:696
msgid "``REAL``"
msgstr ""

#: ../../../library/sqlite3.rst:681
msgid ":class:`str`"
msgstr ""

#: ../../../library/sqlite3.rst:681 ../../../library/sqlite3.rst:698
msgid "``TEXT``"
msgstr ""

#: ../../../library/sqlite3.rst:683 ../../../library/sqlite3.rst:700
msgid ":class:`bytes`"
msgstr ""

#: ../../../library/sqlite3.rst:683 ../../../library/sqlite3.rst:700
msgid "``BLOB``"
msgstr ""

#: ../../../library/sqlite3.rst:687
msgid "This is how SQLite types are converted to Python types by default:"
msgstr ""

#: ../../../library/sqlite3.rst:698
msgid "depends on text_factory, str by default"
msgstr ""

#: ../../../library/sqlite3.rst:703
msgid ""
"The type system of the :mod:`sqlite3` module is extensible in two ways: you "
"can store additional Python types in a SQLite database via object "
"adaptation, and you can let the :mod:`sqlite3` module convert SQLite types "
"to different Python types via converters."
msgstr ""

#: ../../../library/sqlite3.rst:710
msgid "Using adapters to store additional Python types in SQLite databases"
msgstr ""

#: ../../../library/sqlite3.rst:712
msgid ""
"As described before, SQLite supports only a limited set of types natively. "
"To use other Python types with SQLite, you must **adapt** them to one of the "
"sqlite3 module's supported types for SQLite: one of NoneType, int, float, "
"str, bytes."
msgstr ""

#: ../../../library/sqlite3.rst:717
msgid ""
"The :mod:`sqlite3` module uses Python object adaptation, as described in :"
"pep:`246` for this.  The protocol to use is :class:`PrepareProtocol`."
msgstr ""

#: ../../../library/sqlite3.rst:720
msgid ""
"There are two ways to enable the :mod:`sqlite3` module to adapt a custom "
"Python type to one of the supported ones."
msgstr ""

#: ../../../library/sqlite3.rst:725
msgid "Letting your object adapt itself"
msgstr ""

#: ../../../library/sqlite3.rst:727
msgid ""
"This is a good approach if you write the class yourself. Let's suppose you "
"have a class like this::"
msgstr ""

#: ../../../library/sqlite3.rst:730
msgid ""
"class Point:\n"
"    def __init__(self, x, y):\n"
"        self.x, self.y = x, y"
msgstr ""

#: ../../../library/sqlite3.rst:734
msgid ""
"Now you want to store the point in a single SQLite column.  First you'll "
"have to choose one of the supported types first to be used for representing "
"the point. Let's just use str and separate the coordinates using a "
"semicolon. Then you need to give your class a method ``__conform__(self, "
"protocol)`` which must return the converted value. The parameter *protocol* "
"will be :class:`PrepareProtocol`."
msgstr ""

#: ../../../library/sqlite3.rst:740
msgid ""
"import sqlite3\n"
"\n"
"class Point:\n"
"    def __init__(self, x, y):\n"
"        self.x, self.y = x, y\n"
"\n"
"    def __conform__(self, protocol):\n"
"        if protocol is sqlite3.PrepareProtocol:\n"
"            return \"%f;%f\" % (self.x, self.y)\n"
"\n"
"con = sqlite3.connect(\":memory:\")\n"
"cur = con.cursor()\n"
"\n"
"p = Point(4.0, -3.2)\n"
"cur.execute(\"select ?\", (p,))\n"
"print(cur.fetchone()[0])\n"
msgstr ""

#: ../../../library/sqlite3.rst:744
msgid "Registering an adapter callable"
msgstr ""

#: ../../../library/sqlite3.rst:746
msgid ""
"The other possibility is to create a function that converts the type to the "
"string representation and register the function with :meth:"
"`register_adapter`."
msgstr ""

#: ../../../library/sqlite3.rst:749
msgid ""
"import sqlite3\n"
"\n"
"class Point:\n"
"    def __init__(self, x, y):\n"
"        self.x, self.y = x, y\n"
"\n"
"def adapt_point(point):\n"
"    return \"%f;%f\" % (point.x, point.y)\n"
"\n"
"sqlite3.register_adapter(Point, adapt_point)\n"
"\n"
"con = sqlite3.connect(\":memory:\")\n"
"cur = con.cursor()\n"
"\n"
"p = Point(4.0, -3.2)\n"
"cur.execute(\"select ?\", (p,))\n"
"print(cur.fetchone()[0])\n"
msgstr ""

#: ../../../library/sqlite3.rst:751
msgid ""
"The :mod:`sqlite3` module has two default adapters for Python's built-in :"
"class:`datetime.date` and :class:`datetime.datetime` types.  Now let's "
"suppose we want to store :class:`datetime.datetime` objects not in ISO "
"representation, but as a Unix timestamp."
msgstr ""

#: ../../../library/sqlite3.rst:756
msgid ""
"import sqlite3\n"
"import datetime\n"
"import time\n"
"\n"
"def adapt_datetime(ts):\n"
"    return time.mktime(ts.timetuple())\n"
"\n"
"sqlite3.register_adapter(datetime.datetime, adapt_datetime)\n"
"\n"
"con = sqlite3.connect(\":memory:\")\n"
"cur = con.cursor()\n"
"\n"
"now = datetime.datetime.now()\n"
"cur.execute(\"select ?\", (now,))\n"
"print(cur.fetchone()[0])\n"
msgstr ""

#: ../../../library/sqlite3.rst:760
msgid "Converting SQLite values to custom Python types"
msgstr ""

#: ../../../library/sqlite3.rst:762
msgid ""
"Writing an adapter lets you send custom Python types to SQLite. But to make "
"it really useful we need to make the Python to SQLite to Python roundtrip "
"work."
msgstr ""

#: ../../../library/sqlite3.rst:765
msgid "Enter converters."
msgstr ""

#: ../../../library/sqlite3.rst:767
msgid ""
"Let's go back to the :class:`Point` class. We stored the x and y coordinates "
"separated via semicolons as strings in SQLite."
msgstr ""

#: ../../../library/sqlite3.rst:770
msgid ""
"First, we'll define a converter function that accepts the string as a "
"parameter and constructs a :class:`Point` object from it."
msgstr ""

#: ../../../library/sqlite3.rst:775
msgid ""
"Converter functions **always** get called with a string, no matter under "
"which data type you sent the value to SQLite."
msgstr ""

#: ../../../library/sqlite3.rst:780
msgid ""
"def convert_point(s):\n"
"    x, y = map(float, s.split(b\";\"))\n"
"    return Point(x, y)"
msgstr ""

#: ../../../library/sqlite3.rst:784
msgid ""
"Now you need to make the :mod:`sqlite3` module know that what you select "
"from the database is actually a point. There are two ways of doing this:"
msgstr ""

#: ../../../library/sqlite3.rst:787
msgid "Implicitly via the declared type"
msgstr ""

#: ../../../library/sqlite3.rst:789
msgid "Explicitly via the column name"
msgstr ""

#: ../../../library/sqlite3.rst:791
msgid ""
"Both ways are described in section :ref:`sqlite3-module-contents`, in the "
"entries for the constants :const:`PARSE_DECLTYPES` and :const:"
"`PARSE_COLNAMES`."
msgstr ""

#: ../../../library/sqlite3.rst:794
msgid "The following example illustrates both approaches."
msgstr ""

#: ../../../library/sqlite3.rst:796
msgid ""
"import sqlite3\n"
"\n"
"class Point:\n"
"    def __init__(self, x, y):\n"
"        self.x, self.y = x, y\n"
"\n"
"    def __repr__(self):\n"
"        return \"(%f;%f)\" % (self.x, self.y)\n"
"\n"
"def adapt_point(point):\n"
"    return (\"%f;%f\" % (point.x, point.y)).encode('ascii')\n"
"\n"
"def convert_point(s):\n"
"    x, y = list(map(float, s.split(b\";\")))\n"
"    return Point(x, y)\n"
"\n"
"# Register the adapter\n"
"sqlite3.register_adapter(Point, adapt_point)\n"
"\n"
"# Register the converter\n"
"sqlite3.register_converter(\"point\", convert_point)\n"
"\n"
"p = Point(4.0, -3.2)\n"
"\n"
"#########################\n"
"# 1) Using declared types\n"
"con = sqlite3.connect(\":memory:\", detect_types=sqlite3.PARSE_DECLTYPES)\n"
"cur = con.cursor()\n"
"cur.execute(\"create table test(p point)\")\n"
"\n"
"cur.execute(\"insert into test(p) values (?)\", (p,))\n"
"cur.execute(\"select p from test\")\n"
"print(\"with declared types:\", cur.fetchone()[0])\n"
"cur.close()\n"
"con.close()\n"
"\n"
"#######################\n"
"# 1) Using column names\n"
"con = sqlite3.connect(\":memory:\", detect_types=sqlite3.PARSE_COLNAMES)\n"
"cur = con.cursor()\n"
"cur.execute(\"create table test(p)\")\n"
"\n"
"cur.execute(\"insert into test(p) values (?)\", (p,))\n"
"cur.execute('select p as \"p [point]\" from test')\n"
"print(\"with column names:\", cur.fetchone()[0])\n"
"cur.close()\n"
"con.close()\n"
msgstr ""

#: ../../../library/sqlite3.rst:800
msgid "Default adapters and converters"
msgstr ""

#: ../../../library/sqlite3.rst:802
msgid ""
"There are default adapters for the date and datetime types in the datetime "
"module. They will be sent as ISO dates/ISO timestamps to SQLite."
msgstr ""

#: ../../../library/sqlite3.rst:805
msgid ""
"The default converters are registered under the name \"date\" for :class:"
"`datetime.date` and under the name \"timestamp\" for :class:`datetime."
"datetime`."
msgstr ""

#: ../../../library/sqlite3.rst:809
msgid ""
"This way, you can use date/timestamps from Python without any additional "
"fiddling in most cases. The format of the adapters is also compatible with "
"the experimental SQLite date/time functions."
msgstr ""

#: ../../../library/sqlite3.rst:813
msgid "The following example demonstrates this."
msgstr ""

#: ../../../library/sqlite3.rst:815
msgid ""
"import sqlite3\n"
"import datetime\n"
"\n"
"con = sqlite3.connect(\":memory:\", detect_types=sqlite3.PARSE_DECLTYPES|"
"sqlite3.PARSE_COLNAMES)\n"
"cur = con.cursor()\n"
"cur.execute(\"create table test(d date, ts timestamp)\")\n"
"\n"
"today = datetime.date.today()\n"
"now = datetime.datetime.now()\n"
"\n"
"cur.execute(\"insert into test(d, ts) values (?, ?)\", (today, now))\n"
"cur.execute(\"select d, ts from test\")\n"
"row = cur.fetchone()\n"
"print(today, \"=>\", row[0], type(row[0]))\n"
"print(now, \"=>\", row[1], type(row[1]))\n"
"\n"
"cur.execute('select current_date as \"d [date]\", current_timestamp as \"ts "
"[timestamp]\"')\n"
"row = cur.fetchone()\n"
"print(\"current_date\", row[0], type(row[0]))\n"
"print(\"current_timestamp\", row[1], type(row[1]))\n"
msgstr ""

#: ../../../library/sqlite3.rst:817
msgid ""
"If a timestamp stored in SQLite has a fractional part longer than 6 numbers, "
"its value will be truncated to microsecond precision by the timestamp "
"converter."
msgstr ""

#: ../../../library/sqlite3.rst:825
msgid "Controlling Transactions"
msgstr ""

#: ../../../library/sqlite3.rst:827
msgid ""
"By default, the :mod:`sqlite3` module opens transactions implicitly before a "
"Data Modification Language (DML)  statement (i.e. ``INSERT``/``UPDATE``/"
"``DELETE``/``REPLACE``), and commits transactions implicitly before a non-"
"DML, non-query statement (i. e. anything other than ``SELECT`` or the "
"aforementioned)."
msgstr ""

#: ../../../library/sqlite3.rst:833
msgid ""
"So if you are within a transaction and issue a command like ``CREATE "
"TABLE ...``, ``VACUUM``, ``PRAGMA``, the :mod:`sqlite3` module will commit "
"implicitly before executing that command. There are two reasons for doing "
"that. The first is that some of these commands don't work within "
"transactions. The other reason is that sqlite3 needs to keep track of the "
"transaction state (if a transaction is active or not).  The current "
"transaction state is exposed through the :attr:`Connection.in_transaction` "
"attribute of the connection object."
msgstr ""

#: ../../../library/sqlite3.rst:841
msgid ""
"You can control which kind of ``BEGIN`` statements sqlite3 implicitly "
"executes (or none at all) via the *isolation_level* parameter to the :func:"
"`connect` call, or via the :attr:`isolation_level` property of connections."
msgstr ""

#: ../../../library/sqlite3.rst:845
msgid ""
"If you want **autocommit mode**, then set :attr:`isolation_level` to None."
msgstr ""

#: ../../../library/sqlite3.rst:847
msgid ""
"Otherwise leave it at its default, which will result in a plain \"BEGIN\" "
"statement, or set it to one of SQLite's supported isolation levels: "
"\"DEFERRED\", \"IMMEDIATE\" or \"EXCLUSIVE\"."
msgstr ""

#: ../../../library/sqlite3.rst:854
msgid "Using :mod:`sqlite3` efficiently"
msgstr ""

#: ../../../library/sqlite3.rst:858
msgid "Using shortcut methods"
msgstr ""

#: ../../../library/sqlite3.rst:860
msgid ""
"Using the nonstandard :meth:`execute`, :meth:`executemany` and :meth:"
"`executescript` methods of the :class:`Connection` object, your code can be "
"written more concisely because you don't have to create the (often "
"superfluous) :class:`Cursor` objects explicitly. Instead, the :class:"
"`Cursor` objects are created implicitly and these shortcut methods return "
"the cursor objects. This way, you can execute a ``SELECT`` statement and "
"iterate over it directly using only a single call on the :class:`Connection` "
"object."
msgstr ""

#: ../../../library/sqlite3.rst:868
msgid ""
"import sqlite3\n"
"\n"
"persons = [\n"
"    (\"Hugo\", \"Boss\"),\n"
"    (\"Calvin\", \"Klein\")\n"
"    ]\n"
"\n"
"con = sqlite3.connect(\":memory:\")\n"
"\n"
"# Create the table\n"
"con.execute(\"create table person(firstname, lastname)\")\n"
"\n"
"# Fill the table\n"
"con.executemany(\"insert into person(firstname, lastname) values (?, ?)\", "
"persons)\n"
"\n"
"# Print the table contents\n"
"for row in con.execute(\"select firstname, lastname from person\"):\n"
"    print(row)\n"
"\n"
"print(\"I just deleted\", con.execute(\"delete from person\").rowcount, "
"\"rows\")\n"
msgstr ""

#: ../../../library/sqlite3.rst:872
msgid "Accessing columns by name instead of by index"
msgstr ""

#: ../../../library/sqlite3.rst:874
msgid ""
"One useful feature of the :mod:`sqlite3` module is the built-in :class:"
"`sqlite3.Row` class designed to be used as a row factory."
msgstr ""

#: ../../../library/sqlite3.rst:877
msgid ""
"Rows wrapped with this class can be accessed both by index (like tuples) and "
"case-insensitively by name:"
msgstr ""

#: ../../../library/sqlite3.rst:880
msgid ""
"import sqlite3\n"
"\n"
"con = sqlite3.connect(\":memory:\")\n"
"con.row_factory = sqlite3.Row\n"
"\n"
"cur = con.cursor()\n"
"cur.execute(\"select 'John' as name, 42 as age\")\n"
"for row in cur:\n"
"    assert row[0] == row[\"name\"]\n"
"    assert row[\"name\"] == row[\"nAmE\"]\n"
"    assert row[1] == row[\"age\"]\n"
"    assert row[1] == row[\"AgE\"]\n"
msgstr ""

#: ../../../library/sqlite3.rst:884
msgid "Using the connection as a context manager"
msgstr ""

#: ../../../library/sqlite3.rst:886
msgid ""
"Connection objects can be used as context managers that automatically commit "
"or rollback transactions.  In the event of an exception, the transaction is "
"rolled back; otherwise, the transaction is committed:"
msgstr ""

#: ../../../library/sqlite3.rst:891
msgid ""
"import sqlite3\n"
"\n"
"con = sqlite3.connect(\":memory:\")\n"
"con.execute(\"create table person (id integer primary key, firstname varchar "
"unique)\")\n"
"\n"
"# Successful, con.commit() is called automatically afterwards\n"
"with con:\n"
"    con.execute(\"insert into person(firstname) values (?)\", (\"Joe\",))\n"
"\n"
"# con.rollback() is called after the with block finishes with an exception, "
"the\n"
"# exception is still raised and must be caught\n"
"try:\n"
"    with con:\n"
"        con.execute(\"insert into person(firstname) values (?)\", "
"(\"Joe\",))\n"
"except sqlite3.IntegrityError:\n"
"    print(\"couldn't add Joe twice\")\n"
msgstr ""

#: ../../../library/sqlite3.rst:895
msgid "Common issues"
msgstr ""

#: ../../../library/sqlite3.rst:898
msgid "Multithreading"
msgstr ""

#: ../../../library/sqlite3.rst:900
msgid ""
"Older SQLite versions had issues with sharing connections between threads. "
"That's why the Python module disallows sharing connections and cursors "
"between threads. If you still try to do so, you will get an exception at "
"runtime."
msgstr ""

#: ../../../library/sqlite3.rst:904
msgid ""
"The only exception is calling the :meth:`~Connection.interrupt` method, "
"which only makes sense to call from a different thread."
msgstr ""

#: ../../../library/sqlite3.rst:908
msgid "Footnotes"
msgstr ""

#: ../../../library/sqlite3.rst:909
msgid ""
"The sqlite3 module is not built with loadable extension support by default, "
"because some platforms (notably Mac OS X) have SQLite libraries which are "
"compiled without this feature. To get loadable extension support, you must "
"pass --enable-loadable-sqlite-extensions to configure."
msgstr ""

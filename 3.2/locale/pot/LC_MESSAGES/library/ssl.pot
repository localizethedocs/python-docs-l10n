# SOME DESCRIPTIVE TITLE.
# Copyright (C) 1990-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-10 15:08+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../library/ssl.rst:2
msgid ":mod:`ssl` --- TLS/SSL wrapper for socket objects"
msgstr ""

#: ../../../library/ssl.rst:15
msgid "**Source code:** :source:`Lib/ssl.py`"
msgstr ""

#: ../../../library/ssl.rst:19
msgid ""
"This module provides access to Transport Layer Security (often known as "
"\"Secure Sockets Layer\") encryption and peer authentication facilities for "
"network sockets, both client-side and server-side.  This module uses the "
"OpenSSL library. It is available on all modern Unix systems, Windows, Mac OS "
"X, and probably additional platforms, as long as OpenSSL is installed on "
"that platform."
msgstr ""

#: ../../../library/ssl.rst:27
msgid ""
"Some behavior may be platform dependent, since calls are made to the "
"operating system socket APIs.  The installed version of OpenSSL may also "
"cause variations in behavior."
msgstr ""

#: ../../../library/ssl.rst:33
msgid ""
"OpenSSL's internal random number generator does not properly handle fork. "
"Applications must change the PRNG state of the parent process if they use "
"any SSL feature with with :func:`os.fork`. Any successful call of :func:"
"`~ssl.RAND_add`, :func:`~ssl.RAND_bytes` or :func:`~ssl.RAND_pseudo_bytes` "
"is sufficient."
msgstr ""

#: ../../../library/ssl.rst:39
msgid ""
"This section documents the objects and functions in the ``ssl`` module; for "
"more general information about TLS, SSL, and certificates, the reader is "
"referred to the documents in the \"See Also\" section at the bottom."
msgstr ""

#: ../../../library/ssl.rst:43
msgid ""
"This module provides a class, :class:`ssl.SSLSocket`, which is derived from "
"the :class:`socket.socket` type, and provides a socket-like wrapper that "
"also encrypts and decrypts the data going over the socket with SSL.  It "
"supports additional methods such as :meth:`getpeercert`, which retrieves the "
"certificate of the other side of the connection, and :meth:`cipher`,which "
"retrieves the cipher being used for the secure connection."
msgstr ""

#: ../../../library/ssl.rst:50
msgid ""
"For more sophisticated applications, the :class:`ssl.SSLContext` class helps "
"manage settings and certificates, which can then be inherited by SSL sockets "
"created through the :meth:`SSLContext.wrap_socket` method."
msgstr ""

#: ../../../library/ssl.rst:56
msgid "Functions, Constants, and Exceptions"
msgstr ""

#: ../../../library/ssl.rst:60
msgid ""
"Raised to signal an error from the underlying SSL implementation (currently "
"provided by the OpenSSL library).  This signifies some problem in the higher-"
"level encryption and authentication layer that's superimposed on the "
"underlying network connection.  This error is a subtype of :exc:`socket."
"error`, which in turn is a subtype of :exc:`IOError`.  The error code and "
"message of :exc:`SSLError` instances are provided by the OpenSSL library."
msgstr ""

#: ../../../library/ssl.rst:70
msgid ""
"Raised to signal an error with a certificate (such as mismatching "
"hostname).  Certificate errors detected by OpenSSL, though, raise an :exc:"
"`SSLError`."
msgstr ""

#: ../../../library/ssl.rst:76
msgid "Socket creation"
msgstr ""

#: ../../../library/ssl.rst:78
msgid ""
"The following function allows for standalone socket creation.  Starting from "
"Python 3.2, it can be more flexible to use :meth:`SSLContext.wrap_socket` "
"instead."
msgstr ""

#: ../../../library/ssl.rst:84
msgid ""
"Takes an instance ``sock`` of :class:`socket.socket`, and returns an "
"instance of :class:`ssl.SSLSocket`, a subtype of :class:`socket.socket`, "
"which wraps the underlying socket in an SSL context.  For client-side "
"sockets, the context construction is lazy; if the underlying socket isn't "
"connected yet, the context construction will be performed after :meth:"
"`connect` is called on the socket.  For server-side sockets, if the socket "
"has no remote peer, it is assumed to be a listening socket, and the server-"
"side SSL wrapping is automatically performed on client connections accepted "
"via the :meth:`accept` method.  :func:`wrap_socket` may raise :exc:"
"`SSLError`."
msgstr ""

#: ../../../library/ssl.rst:94
msgid ""
"The ``keyfile`` and ``certfile`` parameters specify optional files which "
"contain a certificate to be used to identify the local side of the "
"connection.  See the discussion of :ref:`ssl-certificates` for more "
"information on how the certificate is stored in the ``certfile``."
msgstr ""

#: ../../../library/ssl.rst:99
msgid ""
"The parameter ``server_side`` is a boolean which identifies whether server-"
"side or client-side behavior is desired from this socket."
msgstr ""

#: ../../../library/ssl.rst:102
msgid ""
"The parameter ``cert_reqs`` specifies whether a certificate is required from "
"the other side of the connection, and whether it will be validated if "
"provided.  It must be one of the three values :const:`CERT_NONE` "
"(certificates ignored), :const:`CERT_OPTIONAL` (not required, but validated "
"if provided), or :const:`CERT_REQUIRED` (required and validated).  If the "
"value of this parameter is not :const:`CERT_NONE`, then the ``ca_certs`` "
"parameter must point to a file of CA certificates."
msgstr ""

#: ../../../library/ssl.rst:110
msgid ""
"The ``ca_certs`` file contains a set of concatenated \"certification "
"authority\" certificates, which are used to validate certificates passed "
"from the other end of the connection.  See the discussion of :ref:`ssl-"
"certificates` for more information about how to arrange the certificates in "
"this file."
msgstr ""

#: ../../../library/ssl.rst:116
msgid ""
"The parameter ``ssl_version`` specifies which version of the SSL protocol to "
"use.  Typically, the server chooses a particular protocol version, and the "
"client must adapt to the server's choice.  Most of the versions are not "
"interoperable with the other versions.  If not specified, the default is :"
"data:`PROTOCOL_SSLv23`; it provides the most compatibility with other "
"versions."
msgstr ""

#: ../../../library/ssl.rst:123
msgid ""
"Here's a table showing which versions in a client (down the side) can "
"connect to which versions in a server (along the top):"
msgstr ""

#: ../../../library/ssl.rst:129
msgid "*client* / **server**"
msgstr ""

#: ../../../library/ssl.rst:129
msgid "**SSLv2**"
msgstr ""

#: ../../../library/ssl.rst:129
msgid "**SSLv3**"
msgstr ""

#: ../../../library/ssl.rst:129
msgid "**SSLv23**"
msgstr ""

#: ../../../library/ssl.rst:129
msgid "**TLSv1**"
msgstr ""

#: ../../../library/ssl.rst:131
msgid "*SSLv2*"
msgstr ""

#: ../../../library/ssl.rst:131 ../../../library/ssl.rst:132
#: ../../../library/ssl.rst:133 ../../../library/ssl.rst:134
msgid "yes"
msgstr ""

#: ../../../library/ssl.rst:131 ../../../library/ssl.rst:132
#: ../../../library/ssl.rst:133 ../../../library/ssl.rst:134
msgid "no"
msgstr ""

#: ../../../library/ssl.rst:132
msgid "*SSLv3*"
msgstr ""

#: ../../../library/ssl.rst:133
msgid "*SSLv23*"
msgstr ""

#: ../../../library/ssl.rst:134
msgid "*TLSv1*"
msgstr ""

#: ../../../library/ssl.rst:139
msgid ""
"Which connections succeed will vary depending on the version of OpenSSL.  "
"For instance, in some older versions of OpenSSL (such as 0.9.7l on OS X "
"10.4), an SSLv2 client could not connect to an SSLv23 server.  Another "
"example: beginning with OpenSSL 1.0.0, an SSLv23 client will not actually "
"attempt SSLv2 connections unless you explicitly enable SSLv2 ciphers; for "
"example, you might specify ``\"ALL\"`` or ``\"SSLv2\"`` as the *ciphers* "
"parameter to enable them."
msgstr ""

#: ../../../library/ssl.rst:148
msgid ""
"The *ciphers* parameter sets the available ciphers for this SSL object. It "
"should be a string in the `OpenSSL cipher list format <http://www.openssl."
"org/docs/apps/ciphers.html#CIPHER_LIST_FORMAT>`_."
msgstr ""

#: ../../../library/ssl.rst:152
msgid ""
"The parameter ``do_handshake_on_connect`` specifies whether to do the SSL "
"handshake automatically after doing a :meth:`socket.connect`, or whether the "
"application program will call it explicitly, by invoking the :meth:"
"`SSLSocket.do_handshake` method.  Calling :meth:`SSLSocket.do_handshake` "
"explicitly gives the program control over the blocking behavior of the "
"socket I/O involved in the handshake."
msgstr ""

#: ../../../library/ssl.rst:159
msgid ""
"The parameter ``suppress_ragged_eofs`` specifies how the :meth:`SSLSocket."
"recv` method should signal unexpected EOF from the other end of the "
"connection.  If specified as :const:`True` (the default), it returns a "
"normal EOF (an empty bytes object) in response to unexpected EOF errors "
"raised from the underlying socket; if :const:`False`, it will raise the "
"exceptions back to the caller."
msgstr ""

#: ../../../library/ssl.rst:166
msgid "New optional argument *ciphers*."
msgstr ""

#: ../../../library/ssl.rst:170
msgid "Random generation"
msgstr ""

#: ../../../library/ssl.rst:174
msgid ""
"Returns True if the SSL pseudo-random number generator has been seeded with "
"'enough' randomness, and False otherwise.  You can use :func:`ssl.RAND_egd` "
"and :func:`ssl.RAND_add` to increase the randomness of the pseudo-random "
"number generator."
msgstr ""

#: ../../../library/ssl.rst:181
msgid ""
"If you are running an entropy-gathering daemon (EGD) somewhere, and ``path`` "
"is the pathname of a socket connection open to it, this will read 256 bytes "
"of randomness from the socket, and add it to the SSL pseudo-random number "
"generator to increase the security of generated secret keys.  This is "
"typically only necessary on systems without better sources of randomness."
msgstr ""

#: ../../../library/ssl.rst:187
msgid ""
"See http://egd.sourceforge.net/ or http://prngd.sourceforge.net/ for sources "
"of entropy-gathering daemons."
msgstr ""

#: ../../../library/ssl.rst:192
msgid ""
"Mixes the given ``bytes`` into the SSL pseudo-random number generator.  The "
"parameter ``entropy`` (a float) is a lower bound on the entropy contained in "
"string (so you can always use :const:`0.0`).  See :rfc:`1750` for more "
"information on sources of entropy."
msgstr ""

#: ../../../library/ssl.rst:198
msgid "Certificate handling"
msgstr ""

#: ../../../library/ssl.rst:202
msgid ""
"Verify that *cert* (in decoded format as returned by :meth:`SSLSocket."
"getpeercert`) matches the given *hostname*.  The rules applied are those for "
"checking the identity of HTTPS servers as outlined in :rfc:`2818`, except "
"that IP addresses are not currently supported. In addition to HTTPS, this "
"function should be suitable for checking the identity of servers in various "
"SSL-based protocols such as FTPS, IMAPS, POPS and others."
msgstr ""

#: ../../../library/ssl.rst:210
msgid ""
":exc:`CertificateError` is raised on failure. On success, the function "
"returns nothing::"
msgstr ""

#: ../../../library/ssl.rst:213
msgid ""
">>> cert = {'subject': ((('commonName', 'example.com'),),)}\n"
">>> ssl.match_hostname(cert, \"example.com\")\n"
">>> ssl.match_hostname(cert, \"example.org\")\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"  File \"/home/py3k/Lib/ssl.py\", line 130, in match_hostname\n"
"ssl.CertificateError: hostname 'example.org' doesn't match 'example.com'"
msgstr ""

#: ../../../library/ssl.rst:225
msgid ""
"Returns a floating-point value containing a normal seconds-after-the-epoch "
"time value, given the time-string representing the \"notBefore\" or "
"\"notAfter\" date from a certificate."
msgstr ""

#: ../../../library/ssl.rst:229
msgid "Here's an example::"
msgstr ""

#: ../../../library/ssl.rst:231
msgid ""
">>> import ssl\n"
">>> ssl.cert_time_to_seconds(\"May  9 00:00:00 2007 GMT\")\n"
"1178694000.0\n"
">>> import time\n"
">>> time.ctime(ssl.cert_time_to_seconds(\"May  9 00:00:00 2007 GMT\"))\n"
"'Wed May  9 00:00:00 2007'"
msgstr ""

#: ../../../library/ssl.rst:240
msgid ""
"Given the address ``addr`` of an SSL-protected server, as a (*hostname*, "
"*port-number*) pair, fetches the server's certificate, and returns it as a "
"PEM-encoded string.  If ``ssl_version`` is specified, uses that version of "
"the SSL protocol to attempt to connect to the server.  If ``ca_certs`` is "
"specified, it should be a file containing a list of root certificates, the "
"same format as used for the same parameter in :func:`wrap_socket`.  The call "
"will attempt to validate the server certificate against that set of root "
"certificates, and will fail if the validation attempt fails."
msgstr ""

#: ../../../library/ssl.rst:251
msgid ""
"Given a certificate as a DER-encoded blob of bytes, returns a PEM-encoded "
"string version of the same certificate."
msgstr ""

#: ../../../library/ssl.rst:256
msgid ""
"Given a certificate as an ASCII PEM string, returns a DER-encoded sequence "
"of bytes for that same certificate."
msgstr ""

#: ../../../library/ssl.rst:260
msgid "Constants"
msgstr ""

#: ../../../library/ssl.rst:264
msgid ""
"Possible value for :attr:`SSLContext.verify_mode`, or the ``cert_reqs`` "
"parameter to :func:`wrap_socket`.  In this mode (the default), no "
"certificates will be required from the other side of the socket connection. "
"If a certificate is received from the other end, no attempt to validate it "
"is made."
msgstr ""

#: ../../../library/ssl.rst:270 ../../../library/ssl.rst:915
msgid "See the discussion of :ref:`ssl-security` below."
msgstr ""

#: ../../../library/ssl.rst:274
msgid ""
"Possible value for :attr:`SSLContext.verify_mode`, or the ``cert_reqs`` "
"parameter to :func:`wrap_socket`.  In this mode no certificates will be "
"required from the other side of the socket connection; but if they are "
"provided, validation will be attempted and an :class:`SSLError` will be "
"raised on failure."
msgstr ""

#: ../../../library/ssl.rst:280 ../../../library/ssl.rst:291
msgid ""
"Use of this setting requires a valid set of CA certificates to be passed, "
"either to :meth:`SSLContext.load_verify_locations` or as a value of the "
"``ca_certs`` parameter to :func:`wrap_socket`."
msgstr ""

#: ../../../library/ssl.rst:286
msgid ""
"Possible value for :attr:`SSLContext.verify_mode`, or the ``cert_reqs`` "
"parameter to :func:`wrap_socket`.  In this mode, certificates are required "
"from the other side of the socket connection; an :class:`SSLError` will be "
"raised if no certificate is provided, or if its validation fails."
msgstr ""

#: ../../../library/ssl.rst:297
msgid "Selects SSL version 2 as the channel encryption protocol."
msgstr ""

#: ../../../library/ssl.rst:299
msgid ""
"This protocol is not available if OpenSSL is compiled with OPENSSL_NO_SSL2 "
"flag."
msgstr ""

#: ../../../library/ssl.rst:304
msgid "SSL version 2 is insecure.  Its use is highly discouraged."
msgstr ""

#: ../../../library/ssl.rst:308
msgid ""
"Selects SSL version 2 or 3 as the channel encryption protocol.  This is a "
"setting to use with servers for maximum compatibility with the other end of "
"an SSL connection, but it may cause the specific ciphers chosen for the "
"encryption to be of fairly low quality."
msgstr ""

#: ../../../library/ssl.rst:315
msgid ""
"Selects SSL version 3 as the channel encryption protocol.  For clients, this "
"is the maximally compatible SSL variant."
msgstr ""

#: ../../../library/ssl.rst:320
msgid ""
"Selects TLS version 1 as the channel encryption protocol.  This is the most "
"modern version, and probably the best choice for maximum protection, if both "
"sides can speak it."
msgstr ""

#: ../../../library/ssl.rst:326
msgid ""
"Enables workarounds for various bugs present in other SSL implementations. "
"This option is set by default.  It does not necessarily set the same flags "
"as OpenSSL's ``SSL_OP_ALL`` constant."
msgstr ""

#: ../../../library/ssl.rst:334
msgid ""
"Prevents an SSLv2 connection.  This option is only applicable in conjunction "
"with :const:`PROTOCOL_SSLv23`.  It prevents the peers from choosing SSLv2 as "
"the protocol version."
msgstr ""

#: ../../../library/ssl.rst:342
msgid ""
"Prevents an SSLv3 connection.  This option is only applicable in conjunction "
"with :const:`PROTOCOL_SSLv23`.  It prevents the peers from choosing SSLv3 as "
"the protocol version."
msgstr ""

#: ../../../library/ssl.rst:350
msgid ""
"Prevents a TLSv1 connection.  This option is only applicable in conjunction "
"with :const:`PROTOCOL_SSLv23`.  It prevents the peers from choosing TLSv1 as "
"the protocol version."
msgstr ""

#: ../../../library/ssl.rst:358
msgid ""
"Whether the OpenSSL library has built-in support for the *Server Name "
"Indication* extension to the SSLv3 and TLSv1 protocols (as defined in :rfc:"
"`4366`).  When true, you can use the *server_hostname* argument to :meth:"
"`SSLContext.wrap_socket`."
msgstr ""

#: ../../../library/ssl.rst:367
msgid "The version string of the OpenSSL library loaded by the interpreter::"
msgstr ""

#: ../../../library/ssl.rst:369
msgid ""
">>> ssl.OPENSSL_VERSION\n"
"'OpenSSL 0.9.8k 25 Mar 2009'"
msgstr ""

#: ../../../library/ssl.rst:376
msgid ""
"A tuple of five integers representing version information about the OpenSSL "
"library::"
msgstr ""

#: ../../../library/ssl.rst:379
msgid ""
">>> ssl.OPENSSL_VERSION_INFO\n"
"(0, 9, 8, 11, 15)"
msgstr ""

#: ../../../library/ssl.rst:386
msgid "The raw version number of the OpenSSL library, as a single integer::"
msgstr ""

#: ../../../library/ssl.rst:388
msgid ""
">>> ssl.OPENSSL_VERSION_NUMBER\n"
"9470143\n"
">>> hex(ssl.OPENSSL_VERSION_NUMBER)\n"
"'0x9080bf'"
msgstr ""

#: ../../../library/ssl.rst:397
msgid "SSL Sockets"
msgstr ""

#: ../../../library/ssl.rst:399
msgid "SSL sockets provide the following methods of :ref:`socket-objects`:"
msgstr ""

#: ../../../library/ssl.rst:401
msgid ":meth:`~socket.socket.accept()`"
msgstr ""

#: ../../../library/ssl.rst:402
msgid ":meth:`~socket.socket.bind()`"
msgstr ""

#: ../../../library/ssl.rst:403
msgid ":meth:`~socket.socket.close()`"
msgstr ""

#: ../../../library/ssl.rst:404
msgid ":meth:`~socket.socket.connect()`"
msgstr ""

#: ../../../library/ssl.rst:405
msgid ":meth:`~socket.socket.detach()`"
msgstr ""

#: ../../../library/ssl.rst:406
msgid ":meth:`~socket.socket.fileno()`"
msgstr ""

#: ../../../library/ssl.rst:407
msgid ""
":meth:`~socket.socket.getpeername()`, :meth:`~socket.socket.getsockname()`"
msgstr ""

#: ../../../library/ssl.rst:408
msgid ""
":meth:`~socket.socket.getsockopt()`, :meth:`~socket.socket.setsockopt()`"
msgstr ""

#: ../../../library/ssl.rst:409
msgid ""
":meth:`~socket.socket.gettimeout()`, :meth:`~socket.socket.settimeout()`, :"
"meth:`~socket.socket.setblocking()`"
msgstr ""

#: ../../../library/ssl.rst:411
msgid ":meth:`~socket.socket.listen()`"
msgstr ""

#: ../../../library/ssl.rst:412
msgid ":meth:`~socket.socket.makefile()`"
msgstr ""

#: ../../../library/ssl.rst:413
msgid ""
":meth:`~socket.socket.recv()`, :meth:`~socket.socket.recv_into()` (but "
"passing a non-zero ``flags`` argument is not allowed)"
msgstr ""

#: ../../../library/ssl.rst:415
msgid ""
":meth:`~socket.socket.send()`, :meth:`~socket.socket.sendall()` (with the "
"same limitation)"
msgstr ""

#: ../../../library/ssl.rst:417
msgid ":meth:`~socket.socket.shutdown()`"
msgstr ""

#: ../../../library/ssl.rst:419
msgid ""
"However, since the SSL (and TLS) protocol has its own framing atop of TCP, "
"the SSL sockets abstraction can, in certain respects, diverge from the "
"specification of normal, OS-level sockets.  See especially the :ref:`notes "
"on non-blocking sockets <ssl-nonblocking>`."
msgstr ""

#: ../../../library/ssl.rst:424
msgid "SSL sockets also have the following additional methods and attributes:"
msgstr ""

#: ../../../library/ssl.rst:428
msgid "Perform the SSL setup handshake."
msgstr ""

#: ../../../library/ssl.rst:432
msgid ""
"If there is no certificate for the peer on the other end of the connection, "
"returns ``None``."
msgstr ""

#: ../../../library/ssl.rst:435
msgid ""
"If the parameter ``binary_form`` is :const:`False`, and a certificate was "
"received from the peer, this method returns a :class:`dict` instance.  If "
"the certificate was not validated, the dict is empty.  If the certificate "
"was validated, it returns a dict with several keys, amongst them ``subject`` "
"(the principal for which the certificate was issued) and ``issuer`` (the "
"principal issuing the certificate).  If a certificate contains an instance "
"of the *Subject Alternative Name* extension (see :rfc:`3280`), there will "
"also be a ``subjectAltName`` key in the dictionary."
msgstr ""

#: ../../../library/ssl.rst:444
msgid ""
"The ``subject`` and ``issuer`` fields are tuples containing the sequence of "
"relative distinguished names (RDNs) given in the certificate's data "
"structure for the respective fields, and each RDN is a sequence of name-"
"value pairs.  Here is a real-world example::"
msgstr ""

#: ../../../library/ssl.rst:449
msgid ""
"{'issuer': ((('countryName', 'IL'),),\n"
"            (('organizationName', 'StartCom Ltd.'),),\n"
"            (('organizationalUnitName',\n"
"              'Secure Digital Certificate Signing'),),\n"
"            (('commonName',\n"
"              'StartCom Class 2 Primary Intermediate Server CA'),)),\n"
" 'notAfter': 'Nov 22 08:15:19 2013 GMT',\n"
" 'notBefore': 'Nov 21 03:09:52 2011 GMT',\n"
" 'serialNumber': '95F0',\n"
" 'subject': ((('description', '571208-SLe257oHY9fVQ07Z'),),\n"
"             (('countryName', 'US'),),\n"
"             (('stateOrProvinceName', 'California'),),\n"
"             (('localityName', 'San Francisco'),),\n"
"             (('organizationName', 'Electronic Frontier Foundation, "
"Inc.'),),\n"
"             (('commonName', '*.eff.org'),),\n"
"             (('emailAddress', 'hostmaster@eff.org'),)),\n"
" 'subjectAltName': (('DNS', '*.eff.org'), ('DNS', 'eff.org')),\n"
" 'version': 3}"
msgstr ""

#: ../../../library/ssl.rst:469
msgid ""
"To validate a certificate for a particular service, you can use the :func:"
"`match_hostname` function."
msgstr ""

#: ../../../library/ssl.rst:472
msgid ""
"If the ``binary_form`` parameter is :const:`True`, and a certificate was "
"provided, this method returns the DER-encoded form of the entire certificate "
"as a sequence of bytes, or :const:`None` if the peer did not provide a "
"certificate.  This return value is independent of validation; if validation "
"was required (:const:`CERT_OPTIONAL` or :const:`CERT_REQUIRED`), it will "
"have been validated, but if :const:`CERT_NONE` was used to establish the "
"connection, the certificate, if present, will not have been validated."
msgstr ""

#: ../../../library/ssl.rst:480
msgid ""
"The returned dictionary includes additional items such as ``issuer`` and "
"``notBefore``."
msgstr ""

#: ../../../library/ssl.rst:486
msgid ""
"Returns a three-value tuple containing the name of the cipher being used, "
"the version of the SSL protocol that defines its use, and the number of "
"secret bits being used.  If no connection has been established, returns "
"``None``."
msgstr ""

#: ../../../library/ssl.rst:493
msgid ""
"Performs the SSL shutdown handshake, which removes the TLS layer from the "
"underlying socket, and returns the underlying socket object.  This can be "
"used to go from encrypted operation over a connection to unencrypted.  The "
"returned socket should always be used for further communication with the "
"other side of the connection, rather than the original socket."
msgstr ""

#: ../../../library/ssl.rst:502
msgid ""
"The :class:`SSLContext` object this SSL socket is tied to.  If the SSL "
"socket was created using the top-level :func:`wrap_socket` function (rather "
"than :meth:`SSLContext.wrap_socket`), this is a custom context object "
"created for this SSL socket."
msgstr ""

#: ../../../library/ssl.rst:511
msgid "SSL Contexts"
msgstr ""

#: ../../../library/ssl.rst:515
msgid ""
"An SSL context holds various data longer-lived than single SSL connections, "
"such as SSL configuration options, certificate(s) and private key(s). It "
"also manages a cache of SSL sessions for server-side sockets, in order to "
"speed up repeated connections from the same clients."
msgstr ""

#: ../../../library/ssl.rst:522
msgid ""
"Create a new SSL context.  You must pass *protocol* which must be one of the "
"``PROTOCOL_*`` constants defined in this module. :data:`PROTOCOL_SSLv23` is "
"recommended for maximum interoperability."
msgstr ""

#: ../../../library/ssl.rst:527
msgid ":class:`SSLContext` objects have the following methods and attributes:"
msgstr ""

#: ../../../library/ssl.rst:531
msgid ""
"Load a private key and the corresponding certificate.  The *certfile* string "
"must be the path to a single file in PEM format containing the certificate "
"as well as any number of CA certificates needed to establish the "
"certificate's authenticity.  The *keyfile* string, if present, must point to "
"a file containing the private key in.  Otherwise the private key will be "
"taken from *certfile* as well.  See the discussion of :ref:`ssl-"
"certificates` for more information on how the certificate is stored in the "
"*certfile*."
msgstr ""

#: ../../../library/ssl.rst:540
msgid ""
"An :class:`SSLError` is raised if the private key doesn't match with the "
"certificate."
msgstr ""

#: ../../../library/ssl.rst:545
msgid ""
"Load a set of \"certification authority\" (CA) certificates used to validate "
"other peers' certificates when :data:`verify_mode` is other than :data:"
"`CERT_NONE`.  At least one of *cafile* or *capath* must be specified."
msgstr ""

#: ../../../library/ssl.rst:549
msgid ""
"The *cafile* string, if present, is the path to a file of concatenated CA "
"certificates in PEM format. See the discussion of :ref:`ssl-certificates` "
"for more information about how to arrange the certificates in this file."
msgstr ""

#: ../../../library/ssl.rst:554
msgid ""
"The *capath* string, if present, is the path to a directory containing "
"several CA certificates in PEM format, following an `OpenSSL specific layout "
"<http://www.openssl.org/docs/ssl/SSL_CTX_load_verify_locations.html>`_."
msgstr ""

#: ../../../library/ssl.rst:561
msgid ""
"Load a set of default \"certification authority\" (CA) certificates from a "
"filesystem path defined when building the OpenSSL library.  Unfortunately, "
"there's no easy way to know whether this method succeeds: no error is "
"returned if no certificates are to be found.  When the OpenSSL library is "
"provided as part of the operating system, though, it is likely to be "
"configured properly."
msgstr ""

#: ../../../library/ssl.rst:570
msgid ""
"Set the available ciphers for sockets created with this context. It should "
"be a string in the `OpenSSL cipher list format <http://www.openssl.org/docs/"
"apps/ciphers.html#CIPHER_LIST_FORMAT>`_. If no cipher can be selected "
"(because compile-time options or other configuration forbids use of all the "
"specified ciphers), an :class:`SSLError` will be raised."
msgstr ""

#: ../../../library/ssl.rst:578
msgid ""
"when connected, the :meth:`SSLSocket.cipher` method of SSL sockets will give "
"the currently selected cipher."
msgstr ""

#: ../../../library/ssl.rst:585
msgid ""
"Wrap an existing Python socket *sock* and return an :class:`SSLSocket` "
"object.  The SSL socket is tied to the context, its settings and "
"certificates.  The parameters *server_side*, *do_handshake_on_connect* and "
"*suppress_ragged_eofs* have the same meaning as in the top-level :func:"
"`wrap_socket` function."
msgstr ""

#: ../../../library/ssl.rst:591
msgid ""
"On client connections, the optional parameter *server_hostname* specifies "
"the hostname of the service which we are connecting to.  This allows a "
"single server to host multiple SSL-based services with distinct "
"certificates, quite similarly to HTTP virtual hosts.  Specifying "
"*server_hostname* will raise a :exc:`ValueError` if the OpenSSL library "
"doesn't have support for it (that is, if :data:`HAS_SNI` is :const:"
"`False`).  Specifying *server_hostname* will also raise a :exc:`ValueError` "
"if *server_side* is true."
msgstr ""

#: ../../../library/ssl.rst:602
msgid ""
"Get statistics about the SSL sessions created or managed by this context. A "
"dictionary is returned which maps the names of each `piece of information "
"<http://www.openssl.org/docs/ssl/SSL_CTX_sess_number.html>`_ to their "
"numeric values.  For example, here is the total number of hits and misses in "
"the session cache since the context was created::"
msgstr ""

#: ../../../library/ssl.rst:608
msgid ""
">>> stats = context.session_stats()\n"
">>> stats['hits'], stats['misses']\n"
"(0, 0)"
msgstr ""

#: ../../../library/ssl.rst:614
msgid ""
"An integer representing the set of SSL options enabled on this context. The "
"default value is :data:`OP_ALL`, but you can specify other options such as :"
"data:`OP_NO_SSLv2` by ORing them together."
msgstr ""

#: ../../../library/ssl.rst:619
msgid ""
"With versions of OpenSSL older than 0.9.8m, it is only possible to set "
"options, not to clear them.  Attempting to clear an option (by resetting the "
"corresponding bits) will raise a ``ValueError``."
msgstr ""

#: ../../../library/ssl.rst:625
msgid ""
"The protocol version chosen when constructing the context.  This attribute "
"is read-only."
msgstr ""

#: ../../../library/ssl.rst:630
msgid ""
"Whether to try to verify other peers' certificates and how to behave if "
"verification fails.  This attribute must be one of :data:`CERT_NONE`, :data:"
"`CERT_OPTIONAL` or :data:`CERT_REQUIRED`."
msgstr ""

#: ../../../library/ssl.rst:642
msgid "Certificates"
msgstr ""

#: ../../../library/ssl.rst:644
msgid ""
"Certificates in general are part of a public-key / private-key system.  In "
"this system, each *principal*, (which may be a machine, or a person, or an "
"organization) is assigned a unique two-part encryption key.  One part of the "
"key is public, and is called the *public key*; the other part is kept "
"secret, and is called the *private key*.  The two parts are related, in that "
"if you encrypt a message with one of the parts, you can decrypt it with the "
"other part, and **only** with the other part."
msgstr ""

#: ../../../library/ssl.rst:652
msgid ""
"A certificate contains information about two principals.  It contains the "
"name of a *subject*, and the subject's public key.  It also contains a "
"statement by a second principal, the *issuer*, that the subject is who he "
"claims to be, and that this is indeed the subject's public key.  The "
"issuer's statement is signed with the issuer's private key, which only the "
"issuer knows.  However, anyone can verify the issuer's statement by finding "
"the issuer's public key, decrypting the statement with it, and comparing it "
"to the other information in the certificate. The certificate also contains "
"information about the time period over which it is valid.  This is expressed "
"as two fields, called \"notBefore\" and \"notAfter\"."
msgstr ""

#: ../../../library/ssl.rst:662
msgid ""
"In the Python use of certificates, a client or server can use a certificate "
"to prove who they are.  The other side of a network connection can also be "
"required to produce a certificate, and that certificate can be validated to "
"the satisfaction of the client or server that requires such validation.  The "
"connection attempt can be set to raise an exception if the validation fails. "
"Validation is done automatically, by the underlying OpenSSL framework; the "
"application need not concern itself with its mechanics.  But the application "
"does usually need to provide sets of certificates to allow this process to "
"take place."
msgstr ""

#: ../../../library/ssl.rst:672
msgid ""
"Python uses files to contain certificates.  They should be formatted as "
"\"PEM\" (see :rfc:`1422`), which is a base-64 encoded form wrapped with a "
"header line and a footer line::"
msgstr ""

#: ../../../library/ssl.rst:676
msgid ""
"-----BEGIN CERTIFICATE-----\n"
"... (certificate in base64 PEM encoding) ...\n"
"-----END CERTIFICATE-----"
msgstr ""

#: ../../../library/ssl.rst:681
msgid "Certificate chains"
msgstr ""

#: ../../../library/ssl.rst:683
msgid ""
"The Python files which contain certificates can contain a sequence of "
"certificates, sometimes called a *certificate chain*.  This chain should "
"start with the specific certificate for the principal who \"is\" the client "
"or server, and then the certificate for the issuer of that certificate, and "
"then the certificate for the issuer of *that* certificate, and so on up the "
"chain till you get to a certificate which is *self-signed*, that is, a "
"certificate which has the same subject and issuer, sometimes called a *root "
"certificate*.  The certificates should just be concatenated together in the "
"certificate file.  For example, suppose we had a three certificate chain, "
"from our server certificate to the certificate of the certification "
"authority that signed our server certificate, to the root certificate of the "
"agency which issued the certification authority's certificate::"
msgstr ""

#: ../../../library/ssl.rst:696
msgid ""
"-----BEGIN CERTIFICATE-----\n"
"... (certificate for your server)...\n"
"-----END CERTIFICATE-----\n"
"-----BEGIN CERTIFICATE-----\n"
"... (the certificate for the CA)...\n"
"-----END CERTIFICATE-----\n"
"-----BEGIN CERTIFICATE-----\n"
"... (the root certificate for the CA's issuer)...\n"
"-----END CERTIFICATE-----"
msgstr ""

#: ../../../library/ssl.rst:707
msgid "CA certificates"
msgstr ""

#: ../../../library/ssl.rst:709
msgid ""
"If you are going to require validation of the other side of the connection's "
"certificate, you need to provide a \"CA certs\" file, filled with the "
"certificate chains for each issuer you are willing to trust.  Again, this "
"file just contains these chains concatenated together.  For validation, "
"Python will use the first chain it finds in the file which matches.  Some "
"\"standard\" root certificates are available from various certification "
"authorities: `CACert.org <http://www.cacert.org/index.php?id=3>`_, `Thawte "
"<http://www.thawte.com/roots/>`_, `Verisign <http://www.verisign.com/support/"
"roots.html>`_, `Positive SSL <http://www.PositiveSSL.com/ssl-certificate-"
"support/cert_installation/UTN-USERFirst-Hardware.crt>`_ (used by python."
"org), `Equifax and GeoTrust <http://www.geotrust.com/resources/"
"root_certificates/index.asp>`_."
msgstr ""

#: ../../../library/ssl.rst:722
msgid ""
"In general, if you are using SSL3 or TLS1, you don't need to put the full "
"chain in your \"CA certs\" file; you only need the root certificates, and "
"the remote peer is supposed to furnish the other certificates necessary to "
"chain from its certificate to a root certificate.  See :rfc:`4158` for more "
"discussion of the way in which certification chains can be built."
msgstr ""

#: ../../../library/ssl.rst:729
msgid "Combined key and certificate"
msgstr ""

#: ../../../library/ssl.rst:731
msgid ""
"Often the private key is stored in the same file as the certificate; in this "
"case, only the ``certfile`` parameter to :meth:`SSLContext.load_cert_chain` "
"and :func:`wrap_socket` needs to be passed.  If the private key is stored "
"with the certificate, it should come before the first certificate in the "
"certificate chain::"
msgstr ""

#: ../../../library/ssl.rst:737
msgid ""
"-----BEGIN RSA PRIVATE KEY-----\n"
"... (private key in base64 encoding) ...\n"
"-----END RSA PRIVATE KEY-----\n"
"-----BEGIN CERTIFICATE-----\n"
"... (certificate in base64 PEM encoding) ...\n"
"-----END CERTIFICATE-----"
msgstr ""

#: ../../../library/ssl.rst:745
msgid "Self-signed certificates"
msgstr ""

#: ../../../library/ssl.rst:747
msgid ""
"If you are going to create a server that provides SSL-encrypted connection "
"services, you will need to acquire a certificate for that service.  There "
"are many ways of acquiring appropriate certificates, such as buying one from "
"a certification authority.  Another common practice is to generate a self-"
"signed certificate.  The simplest way to do this is with the OpenSSL "
"package, using something like the following::"
msgstr ""

#: ../../../library/ssl.rst:754
msgid ""
"% openssl req -new -x509 -days 365 -nodes -out cert.pem -keyout cert.pem\n"
"Generating a 1024 bit RSA private key\n"
".......++++++\n"
".............................++++++\n"
"writing new private key to 'cert.pem'\n"
"-----\n"
"You are about to be asked to enter information that will be incorporated\n"
"into your certificate request.\n"
"What you are about to enter is what is called a Distinguished Name or a DN.\n"
"There are quite a few fields but you can leave some blank\n"
"For some fields there will be a default value,\n"
"If you enter '.', the field will be left blank.\n"
"-----\n"
"Country Name (2 letter code) [AU]:US\n"
"State or Province Name (full name) [Some-State]:MyState\n"
"Locality Name (eg, city) []:Some City\n"
"Organization Name (eg, company) [Internet Widgits Pty Ltd]:My Organization, "
"Inc.\n"
"Organizational Unit Name (eg, section) []:My Group\n"
"Common Name (eg, YOUR name) []:myserver.mygroup.myorganization.com\n"
"Email Address []:ops@myserver.mygroup.myorganization.com\n"
"%"
msgstr ""

#: ../../../library/ssl.rst:776
msgid ""
"The disadvantage of a self-signed certificate is that it is its own root "
"certificate, and no one else will have it in their cache of known (and "
"trusted) root certificates."
msgstr ""

#: ../../../library/ssl.rst:782
msgid "Examples"
msgstr ""

#: ../../../library/ssl.rst:785
msgid "Testing for SSL support"
msgstr ""

#: ../../../library/ssl.rst:787
msgid ""
"To test for the presence of SSL support in a Python installation, user code "
"should use the following idiom::"
msgstr ""

#: ../../../library/ssl.rst:790
msgid ""
"try:\n"
"    import ssl\n"
"except ImportError:\n"
"    pass\n"
"else:\n"
"    ... # do something that requires SSL support"
msgstr ""

#: ../../../library/ssl.rst:798
msgid "Client-side operation"
msgstr ""

#: ../../../library/ssl.rst:800
msgid ""
"This example connects to an SSL server and prints the server's certificate::"
msgstr ""

#: ../../../library/ssl.rst:802
msgid ""
"import socket, ssl, pprint\n"
"\n"
"s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n"
"# require a certificate from the server\n"
"ssl_sock = ssl.wrap_socket(s,\n"
"                           ca_certs=\"/etc/ca_certs_file\",\n"
"                           cert_reqs=ssl.CERT_REQUIRED)\n"
"ssl_sock.connect(('www.verisign.com', 443))\n"
"\n"
"pprint.pprint(ssl_sock.getpeercert())\n"
"# note that closing the SSLSocket will also close the underlying socket\n"
"ssl_sock.close()"
msgstr ""

#: ../../../library/ssl.rst:815
msgid ""
"As of January 6, 2012, the certificate printed by this program looks like "
"this::"
msgstr ""

#: ../../../library/ssl.rst:818
msgid ""
"{'issuer': ((('countryName', 'US'),),\n"
"            (('organizationName', 'VeriSign, Inc.'),),\n"
"            (('organizationalUnitName', 'VeriSign Trust Network'),),\n"
"            (('organizationalUnitName',\n"
"              'Terms of use at https://www.verisign.com/rpa (c)06'),),\n"
"            (('commonName',\n"
"              'VeriSign Class 3 Extended Validation SSL SGC CA'),)),\n"
" 'notAfter': 'May 25 23:59:59 2012 GMT',\n"
" 'notBefore': 'May 26 00:00:00 2010 GMT',\n"
" 'serialNumber': '53D2BEF924A7245E83CA01E46CAA2477',\n"
" 'subject': ((('1.3.6.1.4.1.311.60.2.1.3', 'US'),),\n"
"             (('1.3.6.1.4.1.311.60.2.1.2', 'Delaware'),),\n"
"             (('businessCategory', 'V1.0, Clause 5.(b)'),),\n"
"             (('serialNumber', '2497886'),),\n"
"             (('countryName', 'US'),),\n"
"             (('postalCode', '94043'),),\n"
"             (('stateOrProvinceName', 'California'),),\n"
"             (('localityName', 'Mountain View'),),\n"
"             (('streetAddress', '487 East Middlefield Road'),),\n"
"             (('organizationName', 'VeriSign, Inc.'),),\n"
"             (('organizationalUnitName', ' Production Security "
"Services'),),\n"
"             (('commonName', 'www.verisign.com'),)),\n"
" 'subjectAltName': (('DNS', 'www.verisign.com'),\n"
"                    ('DNS', 'verisign.com'),\n"
"                    ('DNS', 'www.verisign.net'),\n"
"                    ('DNS', 'verisign.net'),\n"
"                    ('DNS', 'www.verisign.mobi'),\n"
"                    ('DNS', 'verisign.mobi'),\n"
"                    ('DNS', 'www.verisign.eu'),\n"
"                    ('DNS', 'verisign.eu')),\n"
" 'version': 3}"
msgstr ""

#: ../../../library/ssl.rst:850
msgid ""
"This other example first creates an SSL context, instructs it to verify "
"certificates sent by peers, and feeds it a set of recognized certificate "
"authorities (CA)::"
msgstr ""

#: ../../../library/ssl.rst:854
msgid ""
">>> context = ssl.SSLContext(ssl.PROTOCOL_SSLv23)\n"
">>> context.verify_mode = ssl.CERT_REQUIRED\n"
">>> context.load_verify_locations(\"/etc/ssl/certs/ca-bundle.crt\")"
msgstr ""

#: ../../../library/ssl.rst:858
msgid ""
"(it is assumed your operating system places a bundle of all CA certificates "
"in ``/etc/ssl/certs/ca-bundle.crt``; if not, you'll get an error and have to "
"adjust the location)"
msgstr ""

#: ../../../library/ssl.rst:862
msgid ""
"When you use the context to connect to a server, :const:`CERT_REQUIRED` "
"validates the server certificate: it ensures that the server certificate was "
"signed with one of the CA certificates, and checks the signature for "
"correctness::"
msgstr ""

#: ../../../library/ssl.rst:867
msgid ""
">>> conn = context.wrap_socket(socket.socket(socket.AF_INET))\n"
">>> conn.connect((\"linuxfr.org\", 443))"
msgstr ""

#: ../../../library/ssl.rst:870
msgid ""
"You should then fetch the certificate and check its fields for conformity::"
msgstr ""

#: ../../../library/ssl.rst:872
msgid ""
">>> cert = conn.getpeercert()\n"
">>> ssl.match_hostname(cert, \"linuxfr.org\")"
msgstr ""

#: ../../../library/ssl.rst:875
msgid ""
"Visual inspection shows that the certificate does identify the desired "
"service (that is, the HTTPS host ``linuxfr.org``)::"
msgstr ""

#: ../../../library/ssl.rst:878
msgid ""
">>> pprint.pprint(cert)\n"
"{'issuer': ((('organizationName', 'CAcert Inc.'),),\n"
"            (('organizationalUnitName', 'http://www.CAcert.org'),),\n"
"            (('commonName', 'CAcert Class 3 Root'),)),\n"
" 'notAfter': 'Jun  7 21:02:24 2013 GMT',\n"
" 'notBefore': 'Jun  8 21:02:24 2011 GMT',\n"
" 'serialNumber': 'D3E9',\n"
" 'subject': ((('commonName', 'linuxfr.org'),),),\n"
" 'subjectAltName': (('DNS', 'linuxfr.org'),\n"
"                    ('othername', '<unsupported>'),\n"
"                    ('DNS', 'linuxfr.org'),\n"
"                    ('othername', '<unsupported>'),\n"
"                    ('DNS', 'dev.linuxfr.org'),\n"
"                    ('othername', '<unsupported>'),\n"
"                    ('DNS', 'prod.linuxfr.org'),\n"
"                    ('othername', '<unsupported>'),\n"
"                    ('DNS', 'alpha.linuxfr.org'),\n"
"                    ('othername', '<unsupported>'),\n"
"                    ('DNS', '*.linuxfr.org'),\n"
"                    ('othername', '<unsupported>')),\n"
" 'version': 3}"
msgstr ""

#: ../../../library/ssl.rst:900
msgid ""
"Now that you are assured of its authenticity, you can proceed to talk with "
"the server::"
msgstr ""

#: ../../../library/ssl.rst:903
msgid ""
">>> conn.sendall(b\"HEAD / HTTP/1.0\\r\\nHost: linuxfr.org\\r\\n\\r\\n\")\n"
">>> pprint.pprint(conn.recv(1024).split(b\"\\r\\n\"))\n"
"[b'HTTP/1.1 302 Found',\n"
" b'Date: Sun, 16 May 2010 13:43:28 GMT',\n"
" b'Server: Apache/2.2',\n"
" b'Location: https://linuxfr.org/pub/',\n"
" b'Vary: Accept-Encoding',\n"
" b'Connection: close',\n"
" b'Content-Type: text/html; charset=iso-8859-1',\n"
" b'',\n"
" b'']"
msgstr ""

#: ../../../library/ssl.rst:919
msgid "Server-side operation"
msgstr ""

#: ../../../library/ssl.rst:921
msgid ""
"For server operation, typically you'll need to have a server certificate, "
"and private key, each in a file.  You'll first create a context holding the "
"key and the certificate, so that clients can check your authenticity.  Then "
"you'll open a socket, bind it to a port, call :meth:`listen` on it, and "
"start waiting for clients to connect::"
msgstr ""

#: ../../../library/ssl.rst:927
msgid ""
"import socket, ssl\n"
"\n"
"context = ssl.SSLContext(ssl.PROTOCOL_TLSv1)\n"
"context.load_cert_chain(certfile=\"mycertfile\", keyfile=\"mykeyfile\")\n"
"\n"
"bindsocket = socket.socket()\n"
"bindsocket.bind(('myaddr.mydomain.com', 10023))\n"
"bindsocket.listen(5)"
msgstr ""

#: ../../../library/ssl.rst:936
msgid ""
"When a client connects, you'll call :meth:`accept` on the socket to get the "
"new socket from the other end, and use the context's :meth:`SSLContext."
"wrap_socket` method to create a server-side SSL socket for the connection::"
msgstr ""

#: ../../../library/ssl.rst:940
msgid ""
"while True:\n"
"    newsocket, fromaddr = bindsocket.accept()\n"
"    connstream = context.wrap_socket(newsocket, server_side=True)\n"
"    try:\n"
"        deal_with_client(connstream)\n"
"    finally:\n"
"        connstream.shutdown(socket.SHUT_RDWR)\n"
"        connstream.close()"
msgstr ""

#: ../../../library/ssl.rst:949
msgid ""
"Then you'll read data from the ``connstream`` and do something with it till "
"you are finished with the client (or the client is finished with you)::"
msgstr ""

#: ../../../library/ssl.rst:952
msgid ""
"def deal_with_client(connstream):\n"
"    data = connstream.recv(1024)\n"
"    # empty data means the client is finished with us\n"
"    while data:\n"
"        if not do_something(connstream, data):\n"
"            # we'll assume do_something returns False\n"
"            # when we're finished with client\n"
"            break\n"
"        data = connstream.recv(1024)\n"
"    # finished with client"
msgstr ""

#: ../../../library/ssl.rst:963
msgid ""
"And go back to listening for new client connections (of course, a real "
"server would probably handle each client connection in a separate thread, or "
"put the sockets in non-blocking mode and use an event loop)."
msgstr ""

#: ../../../library/ssl.rst:971
msgid "Notes on non-blocking sockets"
msgstr ""

#: ../../../library/ssl.rst:973
msgid ""
"When working with non-blocking sockets, there are several things you need to "
"be aware of:"
msgstr ""

#: ../../../library/ssl.rst:976
msgid ""
"Calling :func:`~select.select` tells you that the OS-level socket can be "
"read from (or written to), but it does not imply that there is sufficient "
"data at the upper SSL layer.  For example, only part of an SSL frame might "
"have arrived.  Therefore, you must be ready to handle :meth:`SSLSocket.recv` "
"and :meth:`SSLSocket.send` failures, and retry after another call to :func:"
"`~select.select`."
msgstr ""

#: ../../../library/ssl.rst:983
msgid ""
"(of course, similar provisions apply when using other primitives such as :"
"func:`~select.poll`)"
msgstr ""

#: ../../../library/ssl.rst:986
msgid ""
"The SSL handshake itself will be non-blocking: the :meth:`SSLSocket."
"do_handshake` method has to be retried until it returns successfully.  Here "
"is a synopsis using :func:`~select.select` to wait for the socket's "
"readiness::"
msgstr ""

#: ../../../library/ssl.rst:991
msgid ""
"while True:\n"
"    try:\n"
"        sock.do_handshake()\n"
"        break\n"
"    except ssl.SSLError as err:\n"
"        if err.args[0] == ssl.SSL_ERROR_WANT_READ:\n"
"            select.select([sock], [], [])\n"
"        elif err.args[0] == ssl.SSL_ERROR_WANT_WRITE:\n"
"            select.select([], [sock], [])\n"
"        else:\n"
"            raise"
msgstr ""

#: ../../../library/ssl.rst:1007
msgid "Security considerations"
msgstr ""

#: ../../../library/ssl.rst:1010
msgid "Verifying certificates"
msgstr ""

#: ../../../library/ssl.rst:1012
msgid ""
":const:`CERT_NONE` is the default.  Since it does not authenticate the other "
"peer, it can be insecure, especially in client mode where most of time you "
"would like to ensure the authenticity of the server you're talking to. "
"Therefore, when in client mode, it is highly recommended to use :const:"
"`CERT_REQUIRED`.  However, it is in itself not sufficient; you also have to "
"check that the server certificate, which can be obtained by calling :meth:"
"`SSLSocket.getpeercert`, matches the desired service.  For many protocols "
"and applications, the service can be identified by the hostname; in this "
"case, the :func:`match_hostname` function can be used."
msgstr ""

#: ../../../library/ssl.rst:1022
msgid ""
"In server mode, if you want to authenticate your clients using the SSL layer "
"(rather than using a higher-level authentication mechanism), you'll also "
"have to specify :const:`CERT_REQUIRED` and similarly check the client "
"certificate."
msgstr ""

#: ../../../library/ssl.rst:1028
msgid ""
"In client mode, :const:`CERT_OPTIONAL` and :const:`CERT_REQUIRED` are "
"equivalent unless anonymous ciphers are enabled (they are disabled by "
"default)."
msgstr ""

#: ../../../library/ssl.rst:1033
msgid "Protocol versions"
msgstr ""

#: ../../../library/ssl.rst:1035
msgid ""
"SSL version 2 is considered insecure and is therefore dangerous to use.  If "
"you want maximum compatibility between clients and servers, it is "
"recommended to use :const:`PROTOCOL_SSLv23` as the protocol version and then "
"disable SSLv2 explicitly using the :data:`SSLContext.options` attribute::"
msgstr ""

#: ../../../library/ssl.rst:1040
msgid ""
"context = ssl.SSLContext(ssl.PROTOCOL_SSLv23)\n"
"context.options |= ssl.OP_NO_SSLv2"
msgstr ""

#: ../../../library/ssl.rst:1043
msgid ""
"The SSL context created above will allow SSLv3 and TLSv1 connections, but "
"not SSLv2."
msgstr ""

#: ../../../library/ssl.rst:1047
msgid "Cipher selection"
msgstr ""

#: ../../../library/ssl.rst:1049
msgid ""
"If you have advanced security requirements, fine-tuning of the ciphers "
"enabled when negotiating a SSL session is possible through the :meth:"
"`SSLContext.set_ciphers` method.  Starting from Python 3.2.3, the ssl module "
"disables certain weak ciphers by default, but you may want to further "
"restrict the cipher choice.  For example::"
msgstr ""

#: ../../../library/ssl.rst:1055
msgid ""
"context = ssl.SSLContext(ssl.PROTOCOL_TLSv1)\n"
"context.set_ciphers('HIGH:!aNULL:!eNULL')"
msgstr ""

#: ../../../library/ssl.rst:1058
msgid ""
"The ``!aNULL:!eNULL`` part of the cipher spec is necessary to disable "
"ciphers which don't provide both encryption and authentication.  Be sure to "
"read OpenSSL's documentation about the `cipher list format <http://www."
"openssl.org/docs/apps/ciphers.html#CIPHER_LIST_FORMAT>`_. If you want to "
"check which ciphers are enabled by a given cipher list, use the ``openssl "
"ciphers`` command on your system."
msgstr ""

#: ../../../library/ssl.rst:1069
msgid "Class :class:`socket.socket`"
msgstr ""

#: ../../../library/ssl.rst:1069
msgid "Documentation of underlying :mod:`socket` class"
msgstr ""

#: ../../../library/ssl.rst:1072
msgid ""
"`TLS (Transport Layer Security) and SSL (Secure Socket Layer) <http://www3."
"rad.com/networks/applications/secure/tls.htm>`_"
msgstr ""

#: ../../../library/ssl.rst:1072
msgid "Debby Koren"
msgstr ""

#: ../../../library/ssl.rst:1075
msgid ""
"`RFC 1422: Privacy Enhancement for Internet Electronic Mail: Part II: "
"Certificate-Based Key Management <http://www.ietf.org/rfc/rfc1422>`_"
msgstr ""

#: ../../../library/ssl.rst:1075
msgid "Steve Kent"
msgstr ""

#: ../../../library/ssl.rst:1078
msgid ""
"`RFC 1750: Randomness Recommendations for Security <http://www.ietf.org/rfc/"
"rfc1750>`_"
msgstr ""

#: ../../../library/ssl.rst:1078
msgid "D. Eastlake et. al."
msgstr ""

#: ../../../library/ssl.rst:1081
msgid ""
"`RFC 3280: Internet X.509 Public Key Infrastructure Certificate and CRL "
"Profile <http://www.ietf.org/rfc/rfc3280>`_"
msgstr ""

#: ../../../library/ssl.rst:1081
msgid "Housley et. al."
msgstr ""

#: ../../../library/ssl.rst:1083
msgid ""
"`RFC 4366: Transport Layer Security (TLS) Extensions <http://www.ietf.org/"
"rfc/rfc4366>`_"
msgstr ""

#: ../../../library/ssl.rst:1084
msgid "Blake-Wilson et. al."
msgstr ""

#: ../../../library/ssl.rst:11
msgid "OpenSSL"
msgstr ""

#: ../../../library/ssl.rst:11
msgid "(use in module ssl)"
msgstr ""

#: ../../../library/ssl.rst:13
msgid "TLS"
msgstr ""

#: ../../../library/ssl.rst:13
msgid "SSL"
msgstr ""

#: ../../../library/ssl.rst:13
msgid "Transport Layer Security"
msgstr ""

#: ../../../library/ssl.rst:13
msgid "Secure Sockets Layer"
msgstr ""

#: ../../../library/ssl.rst:635
msgid "certificates"
msgstr ""

#: ../../../library/ssl.rst:637
msgid "X509 certificate"
msgstr ""

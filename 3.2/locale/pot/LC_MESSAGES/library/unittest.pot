# SOME DESCRIPTIVE TITLE.
# Copyright (C) 1990-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-10 15:08+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../library/unittest.rst:2
msgid ":mod:`unittest` --- Unit testing framework"
msgstr ""

#: ../../../library/unittest.rst:11
msgid ""
"(If you are already familiar with the basic concepts of testing, you might "
"want to skip to :ref:`the list of assert methods <assert-methods>`.)"
msgstr ""

#: ../../../library/unittest.rst:14
msgid ""
"The Python unit testing framework, sometimes referred to as \"PyUnit,\" is a "
"Python language version of JUnit, by Kent Beck and Erich Gamma. JUnit is, in "
"turn, a Java version of Kent's Smalltalk testing framework.  Each is the de "
"facto standard unit testing framework for its respective language."
msgstr ""

#: ../../../library/unittest.rst:19
msgid ""
":mod:`unittest` supports test automation, sharing of setup and shutdown code "
"for tests, aggregation of tests into collections, and independence of the "
"tests from the reporting framework.  The :mod:`unittest` module provides "
"classes that make it easy to support these qualities for a set of tests."
msgstr ""

#: ../../../library/unittest.rst:24
msgid "To achieve this, :mod:`unittest` supports some important concepts:"
msgstr ""

#: ../../../library/unittest.rst:30
msgid "test fixture"
msgstr ""

#: ../../../library/unittest.rst:27
msgid ""
"A :dfn:`test fixture` represents the preparation needed to perform one or "
"more tests, and any associate cleanup actions.  This may involve, for "
"example, creating temporary or proxy databases, directories, or starting a "
"server process."
msgstr ""

#: ../../../library/unittest.rst:35
msgid "test case"
msgstr ""

#: ../../../library/unittest.rst:33
msgid ""
"A :dfn:`test case` is the smallest unit of testing.  It checks for a "
"specific response to a particular set of inputs.  :mod:`unittest` provides a "
"base class, :class:`TestCase`, which may be used to create new test cases."
msgstr ""

#: ../../../library/unittest.rst:39
msgid "test suite"
msgstr ""

#: ../../../library/unittest.rst:38
msgid ""
"A :dfn:`test suite` is a collection of test cases, test suites, or both.  It "
"is used to aggregate tests that should be executed together."
msgstr ""

#: ../../../library/unittest.rst:45
msgid "test runner"
msgstr ""

#: ../../../library/unittest.rst:42
msgid ""
"A :dfn:`test runner` is a component which orchestrates the execution of "
"tests and provides the outcome to the user.  The runner may use a graphical "
"interface, a textual interface, or return a special value to indicate the "
"results of executing the tests."
msgstr ""

#: ../../../library/unittest.rst:47
msgid ""
"The test case and test fixture concepts are supported through the :class:"
"`TestCase` and :class:`FunctionTestCase` classes; the former should be used "
"when creating new tests, and the latter can be used when integrating "
"existing test code with a :mod:`unittest`\\ -driven framework. When building "
"test fixtures using :class:`TestCase`, the :meth:`~TestCase.setUp` and :meth:"
"`~TestCase.tearDown` methods can be overridden to provide initialization and "
"cleanup for the fixture.  With :class:`FunctionTestCase`, existing functions "
"can be passed to the constructor for these purposes.  When the test is run, "
"the fixture initialization is run first; if it succeeds, the cleanup method "
"is run after the test has been executed, regardless of the outcome of the "
"test.  Each instance of the :class:`TestCase` will only be used to run a "
"single test method, so a new fixture is created for each test."
msgstr ""

#: ../../../library/unittest.rst:60
msgid ""
"Test suites are implemented by the :class:`TestSuite` class.  This class "
"allows individual tests and test suites to be aggregated; when the suite is "
"executed, all tests added directly to the suite and in \"child\" test suites "
"are run."
msgstr ""

#: ../../../library/unittest.rst:64
msgid ""
"A test runner is an object that provides a single method, :meth:`~TestRunner."
"run`, which accepts a :class:`TestCase` or :class:`TestSuite` object as a "
"parameter, and returns a result object.  The class :class:`TestResult` is "
"provided for use as the result object. :mod:`unittest` provides the :class:"
"`TextTestRunner` as an example test runner which reports test results on the "
"standard error stream by default.  Alternate runners can be implemented for "
"other environments (such as graphical environments) without any need to "
"derive from a specific class."
msgstr ""

#: ../../../library/unittest.rst:77
msgid "Module :mod:`doctest`"
msgstr ""

#: ../../../library/unittest.rst:77
msgid "Another test-support module with a very different flavor."
msgstr ""

#: ../../../library/unittest.rst:82
msgid ""
"`unittest2: A backport of new unittest features for Python 2.4-2.6 <http://"
"pypi.python.org/pypi/unittest2>`_"
msgstr ""

#: ../../../library/unittest.rst:80
msgid ""
"Many new features were added to unittest in Python 2.7, including test "
"discovery. unittest2 allows you to use these features with earlier versions "
"of Python."
msgstr ""

#: ../../../library/unittest.rst:86
msgid ""
"`Simple Smalltalk Testing: With Patterns <http://www.XProgramming.com/"
"testfram.htm>`_"
msgstr ""

#: ../../../library/unittest.rst:85
msgid ""
"Kent Beck's original paper on testing frameworks using the pattern shared "
"by :mod:`unittest`."
msgstr ""

#: ../../../library/unittest.rst:90
msgid ""
"`Nose <http://code.google.com/p/python-nose/>`_ and `py.test <http://pytest."
"org>`_"
msgstr ""

#: ../../../library/unittest.rst:89
msgid ""
"Third-party unittest frameworks with a lighter-weight syntax for writing "
"tests.  For example, ``assert func(10) == 42``."
msgstr ""

#: ../../../library/unittest.rst:94
msgid ""
"`The Python Testing Tools Taxonomy <http://pycheesecake.org/wiki/"
"PythonTestingToolsTaxonomy>`_"
msgstr ""

#: ../../../library/unittest.rst:93
msgid ""
"An extensive list of Python testing tools including functional testing "
"frameworks and mock object libraries."
msgstr ""

#: ../../../library/unittest.rst:98
msgid ""
"`Testing in Python Mailing List <http://lists.idyll.org/listinfo/testing-in-"
"python>`_"
msgstr ""

#: ../../../library/unittest.rst:97
msgid ""
"A special-interest-group for discussion of testing, and testing tools, in "
"Python."
msgstr ""

#: ../../../library/unittest.rst:100
msgid ""
"The script :file:`Tools/unittestgui/unittestgui.py` in the Python source "
"distribution is a GUI tool for test discovery and execution.  This is "
"intended largely for ease of use for those new to unit testing.  For "
"production environments it is recommended that tests be driven by a "
"continuous integration system such as `Buildbot <http://buildbot.net/"
"trac>`_, `Jenkins <http://jenkins-ci.org>`_ or  `Hudson <http://hudson-ci."
"org/>`_."
msgstr ""

#: ../../../library/unittest.rst:111
msgid "Basic example"
msgstr ""

#: ../../../library/unittest.rst:113
msgid ""
"The :mod:`unittest` module provides a rich set of tools for constructing and "
"running tests.  This section demonstrates that a small subset of the tools "
"suffice to meet the needs of most users."
msgstr ""

#: ../../../library/unittest.rst:117
msgid ""
"Here is a short script to test three functions from the :mod:`random` "
"module::"
msgstr ""

#: ../../../library/unittest.rst:119
msgid ""
"import random\n"
"import unittest\n"
"\n"
"class TestSequenceFunctions(unittest.TestCase):\n"
"\n"
"    def setUp(self):\n"
"        self.seq = list(range(10))\n"
"\n"
"    def test_shuffle(self):\n"
"        # make sure the shuffled sequence does not lose any elements\n"
"        random.shuffle(self.seq)\n"
"        self.seq.sort()\n"
"        self.assertEqual(self.seq, list(range(10)))\n"
"\n"
"        # should raise an exception for an immutable sequence\n"
"        self.assertRaises(TypeError, random.shuffle, (1,2,3))\n"
"\n"
"    def test_choice(self):\n"
"        element = random.choice(self.seq)\n"
"        self.assertTrue(element in self.seq)\n"
"\n"
"    def test_sample(self):\n"
"        with self.assertRaises(ValueError):\n"
"            random.sample(self.seq, 20)\n"
"        for element in random.sample(self.seq, 5):\n"
"            self.assertTrue(element in self.seq)\n"
"\n"
"if __name__ == '__main__':\n"
"    unittest.main()"
msgstr ""

#: ../../../library/unittest.rst:149
msgid ""
"A testcase is created by subclassing :class:`unittest.TestCase`.  The three "
"individual tests are defined with methods whose names start with the letters "
"``test``.  This naming convention informs the test runner about which "
"methods represent tests."
msgstr ""

#: ../../../library/unittest.rst:154
msgid ""
"The crux of each test is a call to :meth:`~TestCase.assertEqual` to check "
"for an expected result; :meth:`~TestCase.assertTrue` to verify a condition; "
"or :meth:`~TestCase.assertRaises` to verify that an expected exception gets "
"raised. These methods are used instead of the :keyword:`assert` statement so "
"the test runner can accumulate all test results and produce a report."
msgstr ""

#: ../../../library/unittest.rst:160
msgid ""
"When a :meth:`~TestCase.setUp` method is defined, the test runner will run "
"that method prior to each test.  Likewise, if a :meth:`~TestCase.tearDown` "
"method is defined, the test runner will invoke that method after each test.  "
"In the example, :meth:`~TestCase.setUp` was used to create a fresh sequence "
"for each test."
msgstr ""

#: ../../../library/unittest.rst:166
msgid ""
"The final block shows a simple way to run the tests. :func:`unittest.main` "
"provides a command-line interface to the test script.  When run from the "
"command line, the above script produces an output that looks like this::"
msgstr ""

#: ../../../library/unittest.rst:170
msgid ""
"...\n"
"----------------------------------------------------------------------\n"
"Ran 3 tests in 0.000s\n"
"\n"
"OK"
msgstr ""

#: ../../../library/unittest.rst:176
msgid ""
"Instead of :func:`unittest.main`, there are other ways to run the tests with "
"a finer level of control, less terse output, and no requirement to be run "
"from the command line.  For example, the last two lines may be replaced "
"with::"
msgstr ""

#: ../../../library/unittest.rst:180
msgid ""
"suite = unittest.TestLoader().loadTestsFromTestCase(TestSequenceFunctions)\n"
"unittest.TextTestRunner(verbosity=2).run(suite)"
msgstr ""

#: ../../../library/unittest.rst:183
msgid ""
"Running the revised script from the interpreter or another script produces "
"the following output::"
msgstr ""

#: ../../../library/unittest.rst:186
msgid ""
"test_choice (__main__.TestSequenceFunctions) ... ok\n"
"test_sample (__main__.TestSequenceFunctions) ... ok\n"
"test_shuffle (__main__.TestSequenceFunctions) ... ok\n"
"\n"
"----------------------------------------------------------------------\n"
"Ran 3 tests in 0.110s\n"
"\n"
"OK"
msgstr ""

#: ../../../library/unittest.rst:195
msgid ""
"The above examples show the most commonly used :mod:`unittest` features "
"which are sufficient to meet many everyday testing needs.  The remainder of "
"the documentation explores the full feature set from first principles."
msgstr ""

#: ../../../library/unittest.rst:203
msgid "Command-Line Interface"
msgstr ""

#: ../../../library/unittest.rst:205
msgid ""
"The unittest module can be used from the command line to run tests from "
"modules, classes or even individual test methods::"
msgstr ""

#: ../../../library/unittest.rst:208
msgid ""
"python -m unittest test_module1 test_module2\n"
"python -m unittest test_module.TestClass\n"
"python -m unittest test_module.TestClass.test_method"
msgstr ""

#: ../../../library/unittest.rst:212
msgid ""
"You can pass in a list with any combination of module names, and fully "
"qualified class or method names."
msgstr ""

#: ../../../library/unittest.rst:215
msgid "Test modules can be specified by file path as well::"
msgstr ""

#: ../../../library/unittest.rst:217
msgid "python -m unittest tests/test_something.py"
msgstr ""

#: ../../../library/unittest.rst:219
msgid ""
"This allows you to use the shell filename completion to specify the test "
"module. The file specified must still be importable as a module. The path is "
"converted to a module name by removing the '.py' and converting path "
"separators into '.'. If you want to execute a test file that isn't "
"importable as a module you should execute the file directly instead."
msgstr ""

#: ../../../library/unittest.rst:225
msgid ""
"You can run tests with more detail (higher verbosity) by passing in the -v "
"flag::"
msgstr ""

#: ../../../library/unittest.rst:227
msgid "python -m unittest -v test_module"
msgstr ""

#: ../../../library/unittest.rst:229
msgid ""
"When executed without arguments :ref:`unittest-test-discovery` is started::"
msgstr ""

#: ../../../library/unittest.rst:231
msgid "python -m unittest"
msgstr ""

#: ../../../library/unittest.rst:233
msgid "For a list of all the command-line options::"
msgstr ""

#: ../../../library/unittest.rst:235
msgid "python -m unittest -h"
msgstr ""

#: ../../../library/unittest.rst:237
msgid ""
"In earlier versions it was only possible to run individual test methods and "
"not modules or classes."
msgstr ""

#: ../../../library/unittest.rst:243
msgid "Command-line options"
msgstr ""

#: ../../../library/unittest.rst:245
msgid ":program:`unittest` supports these command-line options:"
msgstr ""

#: ../../../library/unittest.rst:251
msgid ""
"The standard output and standard error streams are buffered during the test "
"run. Output during a passing test is discarded. Output is echoed normally on "
"test fail or error and is added to the failure messages."
msgstr ""

#: ../../../library/unittest.rst:257
msgid ""
"Control-C during the test run waits for the current test to end and then "
"reports all the results so far. A second control-C raises the normal :exc:"
"`KeyboardInterrupt` exception."
msgstr ""

#: ../../../library/unittest.rst:261
msgid ""
"See `Signal Handling`_ for the functions that provide this functionality."
msgstr ""

#: ../../../library/unittest.rst:265
msgid "Stop the test run on the first error or failure."
msgstr ""

#: ../../../library/unittest.rst:267
msgid "The command-line options ``-b``, ``-c`` and ``-f`` were added."
msgstr ""

#: ../../../library/unittest.rst:270
msgid ""
"The command line can also be used for test discovery, for running all of the "
"tests in a project or just a subset."
msgstr ""

#: ../../../library/unittest.rst:277
msgid "Test Discovery"
msgstr ""

#: ../../../library/unittest.rst:281
msgid ""
"Unittest supports simple test discovery. In order to be compatible with test "
"discovery, all of the test files must be :ref:`modules <tut-modules>` or :"
"ref:`packages <tut-packages>` importable from the top-level directory of the "
"project (this means that their filenames must be valid :ref:`identifiers "
"<identifiers>`)."
msgstr ""

#: ../../../library/unittest.rst:287
msgid ""
"Test discovery is implemented in :meth:`TestLoader.discover`, but can also "
"be used from the command line. The basic command-line usage is::"
msgstr ""

#: ../../../library/unittest.rst:290
msgid ""
"cd project_directory\n"
"python -m unittest discover"
msgstr ""

#: ../../../library/unittest.rst:295
msgid ""
"As a shortcut, ``python -m unittest`` is the equivalent of ``python -m "
"unittest discover``. If you want to pass arguments to test discovery the "
"``discover`` sub-command must be used explicitly."
msgstr ""

#: ../../../library/unittest.rst:299
msgid "The ``discover`` sub-command has the following options:"
msgstr ""

#: ../../../library/unittest.rst:305
msgid "Verbose output"
msgstr ""

#: ../../../library/unittest.rst:309
msgid "Directory to start discovery (``.`` default)"
msgstr ""

#: ../../../library/unittest.rst:313
msgid "Pattern to match test files (``test*.py`` default)"
msgstr ""

#: ../../../library/unittest.rst:317
msgid "Top level directory of project (defaults to start directory)"
msgstr ""

#: ../../../library/unittest.rst:319
msgid ""
"The :option:`-s`, :option:`-p`, and :option:`-t` options can be passed in as "
"positional arguments in that order. The following two command lines are "
"equivalent::"
msgstr ""

#: ../../../library/unittest.rst:323
msgid ""
"python -m unittest discover -s project_directory -p '*_test.py'\n"
"python -m unittest discover project_directory '*_test.py'"
msgstr ""

#: ../../../library/unittest.rst:326
msgid ""
"As well as being a path it is possible to pass a package name, for example "
"``myproject.subpackage.test``, as the start directory. The package name you "
"supply will then be imported and its location on the filesystem will be used "
"as the start directory."
msgstr ""

#: ../../../library/unittest.rst:333
msgid ""
"Test discovery loads tests by importing them. Once test discovery has found "
"all the test files from the start directory you specify it turns the paths "
"into package names to import. For example :file:`foo/bar/baz.py` will be "
"imported as ``foo.bar.baz``."
msgstr ""

#: ../../../library/unittest.rst:338
msgid ""
"If you have a package installed globally and attempt test discovery on a "
"different copy of the package then the import *could* happen from the wrong "
"place. If this happens test discovery will warn you and exit."
msgstr ""

#: ../../../library/unittest.rst:342
msgid ""
"If you supply the start directory as a package name rather than a path to a "
"directory then discover assumes that whichever location it imports from is "
"the location you intended, so you will not get the warning."
msgstr ""

#: ../../../library/unittest.rst:347
msgid ""
"Test modules and packages can customize test loading and discovery by "
"through the `load_tests protocol`_."
msgstr ""

#: ../../../library/unittest.rst:354
msgid "Organizing test code"
msgstr ""

#: ../../../library/unittest.rst:356
msgid ""
"The basic building blocks of unit testing are :dfn:`test cases` --- single "
"scenarios that must be set up and checked for correctness.  In :mod:"
"`unittest`, test cases are represented by :class:`unittest.TestCase` "
"instances. To make your own test cases you must write subclasses of :class:"
"`TestCase` or use :class:`FunctionTestCase`."
msgstr ""

#: ../../../library/unittest.rst:362
msgid ""
"An instance of a :class:`TestCase`\\ -derived class is an object that can "
"completely run a single test method, together with optional set-up and tidy-"
"up code."
msgstr ""

#: ../../../library/unittest.rst:366
msgid ""
"The testing code of a :class:`TestCase` instance should be entirely self "
"contained, such that it can be run either in isolation or in arbitrary "
"combination with any number of other test cases."
msgstr ""

#: ../../../library/unittest.rst:370
msgid ""
"The simplest :class:`TestCase` subclass will simply override the :meth:"
"`~TestCase.runTest` method in order to perform specific testing code::"
msgstr ""

#: ../../../library/unittest.rst:373
msgid ""
"import unittest\n"
"\n"
"class DefaultWidgetSizeTestCase(unittest.TestCase):\n"
"    def runTest(self):\n"
"        widget = Widget('The widget')\n"
"        self.assertEqual(widget.size(), (50, 50), 'incorrect default size')"
msgstr ""

#: ../../../library/unittest.rst:380
msgid ""
"Note that in order to test something, we use one of the :meth:`assert\\*` "
"methods provided by the :class:`TestCase` base class.  If the test fails, an "
"exception will be raised, and :mod:`unittest` will identify the test case as "
"a :dfn:`failure`.  Any other exceptions will be treated as :dfn:`errors`. "
"This helps you identify where the problem is: :dfn:`failures` are caused by "
"incorrect results - a 5 where you expected a 6. :dfn:`Errors` are caused by "
"incorrect code - e.g., a :exc:`TypeError` caused by an incorrect function "
"call."
msgstr ""

#: ../../../library/unittest.rst:388
msgid ""
"The way to run a test case will be described later.  For now, note that to "
"construct an instance of such a test case, we call its constructor without "
"arguments::"
msgstr ""

#: ../../../library/unittest.rst:392
msgid "testCase = DefaultWidgetSizeTestCase()"
msgstr ""

#: ../../../library/unittest.rst:394
msgid ""
"Now, such test cases can be numerous, and their set-up can be repetitive.  "
"In the above case, constructing a :class:`Widget` in each of 100 Widget test "
"case subclasses would mean unsightly duplication."
msgstr ""

#: ../../../library/unittest.rst:398
msgid ""
"Luckily, we can factor out such set-up code by implementing a method called :"
"meth:`~TestCase.setUp`, which the testing framework will automatically call "
"for us when we run the test::"
msgstr ""

#: ../../../library/unittest.rst:402
msgid ""
"import unittest\n"
"\n"
"class SimpleWidgetTestCase(unittest.TestCase):\n"
"    def setUp(self):\n"
"        self.widget = Widget('The widget')\n"
"\n"
"class DefaultWidgetSizeTestCase(SimpleWidgetTestCase):\n"
"    def runTest(self):\n"
"        self.assertEqual(self.widget.size(), (50,50),\n"
"                         'incorrect default size')\n"
"\n"
"class WidgetResizeTestCase(SimpleWidgetTestCase):\n"
"    def runTest(self):\n"
"        self.widget.resize(100,150)\n"
"        self.assertEqual(self.widget.size(), (100,150),\n"
"                         'wrong size after resize')"
msgstr ""

#: ../../../library/unittest.rst:419
msgid ""
"If the :meth:`~TestCase.setUp` method raises an exception while the test is "
"running, the framework will consider the test to have suffered an error, and "
"the :meth:`~TestCase.runTest` method will not be executed."
msgstr ""

#: ../../../library/unittest.rst:423
msgid ""
"Similarly, we can provide a :meth:`~TestCase.tearDown` method that tidies up "
"after the :meth:`~TestCase.runTest` method has been run::"
msgstr ""

#: ../../../library/unittest.rst:426
msgid ""
"import unittest\n"
"\n"
"class SimpleWidgetTestCase(unittest.TestCase):\n"
"    def setUp(self):\n"
"        self.widget = Widget('The widget')\n"
"\n"
"    def tearDown(self):\n"
"        self.widget.dispose()\n"
"        self.widget = None"
msgstr ""

#: ../../../library/unittest.rst:436
msgid ""
"If :meth:`~TestCase.setUp` succeeded, the :meth:`~TestCase.tearDown` method "
"will be run whether :meth:`~TestCase.runTest` succeeded or not."
msgstr ""

#: ../../../library/unittest.rst:439
msgid ""
"Such a working environment for the testing code is called a :dfn:`fixture`."
msgstr ""

#: ../../../library/unittest.rst:441
msgid ""
"Often, many small test cases will use the same fixture.  In this case, we "
"would end up subclassing :class:`SimpleWidgetTestCase` into many small one-"
"method classes such as :class:`DefaultWidgetSizeTestCase`.  This is time-"
"consuming and discouraging, so in the same vein as JUnit, :mod:`unittest` "
"provides a simpler mechanism::"
msgstr ""

#: ../../../library/unittest.rst:447
msgid ""
"import unittest\n"
"\n"
"class WidgetTestCase(unittest.TestCase):\n"
"    def setUp(self):\n"
"        self.widget = Widget('The widget')\n"
"\n"
"    def tearDown(self):\n"
"        self.widget.dispose()\n"
"        self.widget = None\n"
"\n"
"    def test_default_size(self):\n"
"        self.assertEqual(self.widget.size(), (50,50),\n"
"                         'incorrect default size')\n"
"\n"
"    def test_resize(self):\n"
"        self.widget.resize(100,150)\n"
"        self.assertEqual(self.widget.size(), (100,150),\n"
"                         'wrong size after resize')"
msgstr ""

#: ../../../library/unittest.rst:466
msgid ""
"Here we have not provided a :meth:`~TestCase.runTest` method, but have "
"instead provided two different test methods.  Class instances will now each "
"run one of the :meth:`test_\\*` methods, with ``self.widget`` created and "
"destroyed separately for each instance.  When creating an instance we must "
"specify the test method it is to run.  We do this by passing the method name "
"in the constructor::"
msgstr ""

#: ../../../library/unittest.rst:473
msgid ""
"defaultSizeTestCase = WidgetTestCase('test_default_size')\n"
"resizeTestCase = WidgetTestCase('test_resize')"
msgstr ""

#: ../../../library/unittest.rst:476
msgid ""
"Test case instances are grouped together according to the features they "
"test. :mod:`unittest` provides a mechanism for this: the :dfn:`test suite`, "
"represented by :mod:`unittest`'s :class:`TestSuite` class::"
msgstr ""

#: ../../../library/unittest.rst:480
msgid ""
"widgetTestSuite = unittest.TestSuite()\n"
"widgetTestSuite.addTest(WidgetTestCase('test_default_size'))\n"
"widgetTestSuite.addTest(WidgetTestCase('test_resize'))"
msgstr ""

#: ../../../library/unittest.rst:484
msgid ""
"For the ease of running tests, as we will see later, it is a good idea to "
"provide in each test module a callable object that returns a pre-built test "
"suite::"
msgstr ""

#: ../../../library/unittest.rst:488 ../../../library/unittest.rst:725
msgid ""
"def suite():\n"
"    suite = unittest.TestSuite()\n"
"    suite.addTest(WidgetTestCase('test_default_size'))\n"
"    suite.addTest(WidgetTestCase('test_resize'))\n"
"    return suite"
msgstr ""

#: ../../../library/unittest.rst:494
msgid "or even::"
msgstr ""

#: ../../../library/unittest.rst:496
msgid ""
"def suite():\n"
"    tests = ['test_default_size', 'test_resize']\n"
"\n"
"    return unittest.TestSuite(map(WidgetTestCase, tests))"
msgstr ""

#: ../../../library/unittest.rst:501
msgid ""
"Since it is a common pattern to create a :class:`TestCase` subclass with "
"many similarly named test functions, :mod:`unittest` provides a :class:"
"`TestLoader` class that can be used to automate the process of creating a "
"test suite and populating it with individual tests. For example, ::"
msgstr ""

#: ../../../library/unittest.rst:506
msgid "suite = unittest.TestLoader().loadTestsFromTestCase(WidgetTestCase)"
msgstr ""

#: ../../../library/unittest.rst:508
msgid ""
"will create a test suite that will run ``WidgetTestCase."
"test_default_size()`` and ``WidgetTestCase.test_resize``. :class:"
"`TestLoader` uses the ``'test'`` method name prefix to identify test methods "
"automatically."
msgstr ""

#: ../../../library/unittest.rst:512
msgid ""
"Note that the order in which the various test cases will be run is "
"determined by sorting the test function names with respect to the built-in "
"ordering for strings."
msgstr ""

#: ../../../library/unittest.rst:516
msgid ""
"Often it is desirable to group suites of test cases together, so as to run "
"tests for the whole system at once.  This is easy, since :class:`TestSuite` "
"instances can be added to a :class:`TestSuite` just as :class:`TestCase` "
"instances can be added to a :class:`TestSuite`::"
msgstr ""

#: ../../../library/unittest.rst:521
msgid ""
"suite1 = module1.TheTestSuite()\n"
"suite2 = module2.TheTestSuite()\n"
"alltests = unittest.TestSuite([suite1, suite2])"
msgstr ""

#: ../../../library/unittest.rst:525
msgid ""
"You can place the definitions of test cases and test suites in the same "
"modules as the code they are to test (such as :file:`widget.py`), but there "
"are several advantages to placing the test code in a separate module, such "
"as :file:`test_widget.py`:"
msgstr ""

#: ../../../library/unittest.rst:530
msgid "The test module can be run standalone from the command line."
msgstr ""

#: ../../../library/unittest.rst:532
msgid "The test code can more easily be separated from shipped code."
msgstr ""

#: ../../../library/unittest.rst:534
msgid ""
"There is less temptation to change test code to fit the code it tests "
"without a good reason."
msgstr ""

#: ../../../library/unittest.rst:537
msgid ""
"Test code should be modified much less frequently than the code it tests."
msgstr ""

#: ../../../library/unittest.rst:539
msgid "Tested code can be refactored more easily."
msgstr ""

#: ../../../library/unittest.rst:541
msgid ""
"Tests for modules written in C must be in separate modules anyway, so why "
"not be consistent?"
msgstr ""

#: ../../../library/unittest.rst:544
msgid ""
"If the testing strategy changes, there is no need to change the source code."
msgstr ""

#: ../../../library/unittest.rst:550
msgid "Re-using old test code"
msgstr ""

#: ../../../library/unittest.rst:552
msgid ""
"Some users will find that they have existing test code that they would like "
"to run from :mod:`unittest`, without converting every old test function to "
"a :class:`TestCase` subclass."
msgstr ""

#: ../../../library/unittest.rst:556
msgid ""
"For this reason, :mod:`unittest` provides a :class:`FunctionTestCase` class. "
"This subclass of :class:`TestCase` can be used to wrap an existing test "
"function.  Set-up and tear-down functions can also be provided."
msgstr ""

#: ../../../library/unittest.rst:560
msgid "Given the following test function::"
msgstr ""

#: ../../../library/unittest.rst:562
msgid ""
"def testSomething():\n"
"    something = makeSomething()\n"
"    assert something.name is not None\n"
"    # ..."
msgstr ""

#: ../../../library/unittest.rst:567
msgid "one can create an equivalent test case instance as follows::"
msgstr ""

#: ../../../library/unittest.rst:569
msgid "testcase = unittest.FunctionTestCase(testSomething)"
msgstr ""

#: ../../../library/unittest.rst:571
msgid ""
"If there are additional set-up and tear-down methods that should be called "
"as part of the test case's operation, they can also be provided like so::"
msgstr ""

#: ../../../library/unittest.rst:574
msgid ""
"testcase = unittest.FunctionTestCase(testSomething,\n"
"                                     setUp=makeSomethingDB,\n"
"                                     tearDown=deleteSomethingDB)"
msgstr ""

#: ../../../library/unittest.rst:578
msgid ""
"To make migrating existing test suites easier, :mod:`unittest` supports "
"tests raising :exc:`AssertionError` to indicate test failure. However, it is "
"recommended that you use the explicit :meth:`TestCase.fail\\*` and :meth:"
"`TestCase.assert\\*` methods instead, as future versions of :mod:`unittest` "
"may treat :exc:`AssertionError` differently."
msgstr ""

#: ../../../library/unittest.rst:586
msgid ""
"Even though :class:`FunctionTestCase` can be used to quickly convert an "
"existing test base over to a :mod:`unittest`\\ -based system, this approach "
"is not recommended.  Taking the time to set up proper :class:`TestCase` "
"subclasses will make future test refactorings infinitely easier."
msgstr ""

#: ../../../library/unittest.rst:591
msgid ""
"In some cases, the existing tests may have been written using the :mod:"
"`doctest` module.  If so, :mod:`doctest` provides a :class:`DocTestSuite` "
"class that can automatically build :class:`unittest.TestSuite` instances "
"from the existing :mod:`doctest`\\ -based tests."
msgstr ""

#: ../../../library/unittest.rst:600
msgid "Skipping tests and expected failures"
msgstr ""

#: ../../../library/unittest.rst:604
msgid ""
"Unittest supports skipping individual test methods and even whole classes of "
"tests.  In addition, it supports marking a test as a \"expected failure,\" a "
"test that is broken and will fail, but shouldn't be counted as a failure on "
"a :class:`TestResult`."
msgstr ""

#: ../../../library/unittest.rst:609
msgid ""
"Skipping a test is simply a matter of using the :func:`skip` :term:"
"`decorator` or one of its conditional variants."
msgstr ""

#: ../../../library/unittest.rst:612
msgid "Basic skipping looks like this::"
msgstr ""

#: ../../../library/unittest.rst:614
msgid ""
"class MyTestCase(unittest.TestCase):\n"
"\n"
"    @unittest.skip(\"demonstrating skipping\")\n"
"    def test_nothing(self):\n"
"        self.fail(\"shouldn't happen\")\n"
"\n"
"    @unittest.skipIf(mylib.__version__ < (1, 3),\n"
"                     \"not supported in this library version\")\n"
"    def test_format(self):\n"
"        # Tests that work for only a certain version of the library.\n"
"        pass\n"
"\n"
"    @unittest.skipUnless(sys.platform.startswith(\"win\"), \"requires "
"Windows\")\n"
"    def test_windows_support(self):\n"
"        # windows specific testing code\n"
"        pass"
msgstr ""

#: ../../../library/unittest.rst:631
msgid "This is the output of running the example above in verbose mode::"
msgstr ""

#: ../../../library/unittest.rst:633
msgid ""
"test_format (__main__.MyTestCase) ... skipped 'not supported in this library "
"version'\n"
"test_nothing (__main__.MyTestCase) ... skipped 'demonstrating skipping'\n"
"test_windows_support (__main__.MyTestCase) ... skipped 'requires Windows'\n"
"\n"
"----------------------------------------------------------------------\n"
"Ran 3 tests in 0.005s\n"
"\n"
"OK (skipped=3)"
msgstr ""

#: ../../../library/unittest.rst:642
msgid "Classes can be skipped just like methods::"
msgstr ""

#: ../../../library/unittest.rst:644
msgid ""
"@unittest.skip(\"showing class skipping\")\n"
"class MySkippedTestCase(unittest.TestCase):\n"
"    def test_not_run(self):\n"
"        pass"
msgstr ""

#: ../../../library/unittest.rst:649
msgid ""
":meth:`TestCase.setUp` can also skip the test.  This is useful when a "
"resource that needs to be set up is not available."
msgstr ""

#: ../../../library/unittest.rst:652
msgid "Expected failures use the :func:`expectedFailure` decorator. ::"
msgstr ""

#: ../../../library/unittest.rst:654
msgid ""
"class ExpectedFailureTestCase(unittest.TestCase):\n"
"    @unittest.expectedFailure\n"
"    def test_fail(self):\n"
"        self.assertEqual(1, 0, \"broken\")"
msgstr ""

#: ../../../library/unittest.rst:659
msgid ""
"It's easy to roll your own skipping decorators by making a decorator that "
"calls :func:`skip` on the test when it wants it to be skipped.  This "
"decorator skips the test unless the passed object has a certain attribute::"
msgstr ""

#: ../../../library/unittest.rst:663
msgid ""
"def skipUnlessHasattr(obj, attr):\n"
"    if hasattr(obj, attr):\n"
"        return lambda func: func\n"
"    return unittest.skip(\"{!r} doesn't have {!r}\".format(obj, attr))"
msgstr ""

#: ../../../library/unittest.rst:668
msgid "The following decorators implement test skipping and expected failures:"
msgstr ""

#: ../../../library/unittest.rst:672
msgid ""
"Unconditionally skip the decorated test.  *reason* should describe why the "
"test is being skipped."
msgstr ""

#: ../../../library/unittest.rst:677
msgid "Skip the decorated test if *condition* is true."
msgstr ""

#: ../../../library/unittest.rst:681
msgid "Skip the decorated test unless *condition* is true."
msgstr ""

#: ../../../library/unittest.rst:685
msgid ""
"Mark the test as an expected failure.  If the test fails when run, the test "
"is not counted as a failure."
msgstr ""

#: ../../../library/unittest.rst:690
msgid "This exception is raised to skip a test."
msgstr ""

#: ../../../library/unittest.rst:692
msgid ""
"Usually you can use :meth:`TestCase.skipTest` or one of the skipping "
"decorators instead of raising this directly."
msgstr ""

#: ../../../library/unittest.rst:695
msgid ""
"Skipped tests will not have :meth:`setUp` or :meth:`tearDown` run around "
"them. Skipped classes will not have :meth:`setUpClass` or :meth:"
"`tearDownClass` run."
msgstr ""

#: ../../../library/unittest.rst:702
msgid "Classes and functions"
msgstr ""

#: ../../../library/unittest.rst:704
msgid "This section describes in depth the API of :mod:`unittest`."
msgstr ""

#: ../../../library/unittest.rst:710
msgid "Test cases"
msgstr ""

#: ../../../library/unittest.rst:714
msgid ""
"Instances of the :class:`TestCase` class represent the smallest testable "
"units in the :mod:`unittest` universe.  This class is intended to be used as "
"a base class, with specific tests being implemented by concrete subclasses.  "
"This class implements the interface needed by the test runner to allow it to "
"drive the test, and methods that the test code can use to check for and "
"report various kinds of failure."
msgstr ""

#: ../../../library/unittest.rst:721
msgid ""
"Each instance of :class:`TestCase` will run a single test method: the method "
"named *methodName*.  If you remember, we had an earlier example that went "
"something like this::"
msgstr ""

#: ../../../library/unittest.rst:731
msgid ""
"Here, we create two instances of :class:`WidgetTestCase`, each of which runs "
"a single test."
msgstr ""

#: ../../../library/unittest.rst:734
msgid ""
":class:`TestCase` can be instantiated successfully without providing a "
"method name. This makes it easier to experiment with :class:`TestCase` from "
"the interactive interpreter."
msgstr ""

#: ../../../library/unittest.rst:739
msgid "*methodName* defaults to :meth:`runTest`."
msgstr ""

#: ../../../library/unittest.rst:741
msgid ""
":class:`TestCase` instances provide three groups of methods: one group used "
"to run the test, another used by the test implementation to check conditions "
"and report failures, and some inquiry methods allowing information about the "
"test itself to be gathered."
msgstr ""

#: ../../../library/unittest.rst:746
msgid "Methods in the first group (running the test) are:"
msgstr ""

#: ../../../library/unittest.rst:751
msgid ""
"Method called to prepare the test fixture.  This is called immediately "
"before calling the test method; any exception raised by this method will be "
"considered an error rather than a test failure. The default implementation "
"does nothing."
msgstr ""

#: ../../../library/unittest.rst:759
msgid ""
"Method called immediately after the test method has been called and the "
"result recorded.  This is called even if the test method raised an "
"exception, so the implementation in subclasses may need to be particularly "
"careful about checking internal state.  Any exception raised by this method "
"will be considered an error rather than a test failure.  This method will "
"only be called if the :meth:`setUp` succeeds, regardless of the outcome of "
"the test method. The default implementation does nothing."
msgstr ""

#: ../../../library/unittest.rst:770
msgid ""
"A class method called before tests in an individual class run. "
"``setUpClass`` is called with the class as the only argument and must be "
"decorated as a :func:`classmethod`::"
msgstr ""

#: ../../../library/unittest.rst:774
msgid ""
"@classmethod\n"
"def setUpClass(cls):\n"
"    ..."
msgstr ""

#: ../../../library/unittest.rst:778 ../../../library/unittest.rst:793
msgid "See `Class and Module Fixtures`_ for more details."
msgstr ""

#: ../../../library/unittest.rst:785
msgid ""
"A class method called after tests in an individual class have run. "
"``tearDownClass`` is called with the class as the only argument and must be "
"decorated as a :meth:`classmethod`::"
msgstr ""

#: ../../../library/unittest.rst:789
msgid ""
"@classmethod\n"
"def tearDownClass(cls):\n"
"    ..."
msgstr ""

#: ../../../library/unittest.rst:800
msgid ""
"Run the test, collecting the result into the test result object passed as "
"*result*.  If *result* is omitted or ``None``, a temporary result object is "
"created (by calling the :meth:`defaultTestResult` method) and used. The "
"result object is not returned to :meth:`run`'s caller."
msgstr ""

#: ../../../library/unittest.rst:805
msgid ""
"The same effect may be had by simply calling the :class:`TestCase` instance."
msgstr ""

#: ../../../library/unittest.rst:811
msgid ""
"Calling this during a test method or :meth:`setUp` skips the current test.  "
"See :ref:`unittest-skipping` for more information."
msgstr ""

#: ../../../library/unittest.rst:819
msgid ""
"Run the test without collecting the result.  This allows exceptions raised "
"by the test to be propagated to the caller, and can be used to support "
"running tests under a debugger."
msgstr ""

#: ../../../library/unittest.rst:825
msgid ""
"The :class:`TestCase` class provides a number of methods to check for and "
"report failures, such as:"
msgstr ""

#: ../../../library/unittest.rst:829 ../../../library/unittest.rst:950
#: ../../../library/unittest.rst:1078 ../../../library/unittest.rst:1232
msgid "Method"
msgstr ""

#: ../../../library/unittest.rst:829 ../../../library/unittest.rst:950
#: ../../../library/unittest.rst:1078
msgid "Checks that"
msgstr ""

#: ../../../library/unittest.rst:829 ../../../library/unittest.rst:950
#: ../../../library/unittest.rst:1078 ../../../library/unittest.rst:1232
msgid "New in"
msgstr ""

#: ../../../library/unittest.rst:831
msgid ":meth:`assertEqual(a, b) <TestCase.assertEqual>`"
msgstr ""

#: ../../../library/unittest.rst:831
msgid "``a == b``"
msgstr ""

#: ../../../library/unittest.rst:834
msgid ":meth:`assertNotEqual(a, b) <TestCase.assertNotEqual>`"
msgstr ""

#: ../../../library/unittest.rst:834
msgid "``a != b``"
msgstr ""

#: ../../../library/unittest.rst:837
msgid ":meth:`assertTrue(x) <TestCase.assertTrue>`"
msgstr ""

#: ../../../library/unittest.rst:837
msgid "``bool(x) is True``"
msgstr ""

#: ../../../library/unittest.rst:840
msgid ":meth:`assertFalse(x) <TestCase.assertFalse>`"
msgstr ""

#: ../../../library/unittest.rst:840
msgid "``bool(x) is False``"
msgstr ""

#: ../../../library/unittest.rst:843
msgid ":meth:`assertIs(a, b) <TestCase.assertIs>`"
msgstr ""

#: ../../../library/unittest.rst:843
msgid "``a is b``"
msgstr ""

#: ../../../library/unittest.rst:843 ../../../library/unittest.rst:846
#: ../../../library/unittest.rst:849 ../../../library/unittest.rst:852
#: ../../../library/unittest.rst:855 ../../../library/unittest.rst:858
#: ../../../library/unittest.rst:955 ../../../library/unittest.rst:1086
#: ../../../library/unittest.rst:1089 ../../../library/unittest.rst:1092
#: ../../../library/unittest.rst:1095 ../../../library/unittest.rst:1098
#: ../../../library/unittest.rst:1234 ../../../library/unittest.rst:1237
#: ../../../library/unittest.rst:1240 ../../../library/unittest.rst:1243
#: ../../../library/unittest.rst:1246 ../../../library/unittest.rst:1249
msgid "3.1"
msgstr ""

#: ../../../library/unittest.rst:846
msgid ":meth:`assertIsNot(a, b) <TestCase.assertIsNot>`"
msgstr ""

#: ../../../library/unittest.rst:846
msgid "``a is not b``"
msgstr ""

#: ../../../library/unittest.rst:849
msgid ":meth:`assertIsNone(x) <TestCase.assertIsNone>`"
msgstr ""

#: ../../../library/unittest.rst:849
msgid "``x is None``"
msgstr ""

#: ../../../library/unittest.rst:852
msgid ":meth:`assertIsNotNone(x) <TestCase.assertIsNotNone>`"
msgstr ""

#: ../../../library/unittest.rst:852
msgid "``x is not None``"
msgstr ""

#: ../../../library/unittest.rst:855
msgid ":meth:`assertIn(a, b) <TestCase.assertIn>`"
msgstr ""

#: ../../../library/unittest.rst:855
msgid "``a in b``"
msgstr ""

#: ../../../library/unittest.rst:858
msgid ":meth:`assertNotIn(a, b) <TestCase.assertNotIn>`"
msgstr ""

#: ../../../library/unittest.rst:858
msgid "``a not in b``"
msgstr ""

#: ../../../library/unittest.rst:861
msgid ":meth:`assertIsInstance(a, b) <TestCase.assertIsInstance>`"
msgstr ""

#: ../../../library/unittest.rst:861
msgid "``isinstance(a, b)``"
msgstr ""

#: ../../../library/unittest.rst:861 ../../../library/unittest.rst:864
#: ../../../library/unittest.rst:958 ../../../library/unittest.rst:961
#: ../../../library/unittest.rst:1101 ../../../library/unittest.rst:1104
msgid "3.2"
msgstr ""

#: ../../../library/unittest.rst:864
msgid ":meth:`assertNotIsInstance(a, b) <TestCase.assertNotIsInstance>`"
msgstr ""

#: ../../../library/unittest.rst:864
msgid "``not isinstance(a, b)``"
msgstr ""

#: ../../../library/unittest.rst:868
msgid ""
"All the assert methods (except :meth:`assertRaises`, :meth:"
"`assertRaisesRegex`, :meth:`assertWarns`, :meth:`assertWarnsRegex`) accept a "
"*msg* argument that, if specified, is used as the error message on failure "
"(see also :data:`longMessage`)."
msgstr ""

#: ../../../library/unittest.rst:875
msgid ""
"Test that *first* and *second* are equal.  If the values do not compare "
"equal, the test will fail."
msgstr ""

#: ../../../library/unittest.rst:878
msgid ""
"In addition, if *first* and *second* are the exact same type and one of "
"list, tuple, dict, set, frozenset or str or any type that a subclass "
"registers with :meth:`addTypeEqualityFunc` the type-specific equality "
"function will be called in order to generate a more useful default error "
"message (see also the :ref:`list of type-specific methods <type-specific-"
"methods>`)."
msgstr ""

#: ../../../library/unittest.rst:885
msgid "Added the automatic calling of type-specific equality function."
msgstr ""

#: ../../../library/unittest.rst:888
msgid ""
":meth:`assertMultiLineEqual` added as the default type equality function for "
"comparing strings."
msgstr ""

#: ../../../library/unittest.rst:895
msgid ""
"Test that *first* and *second* are not equal.  If the values do compare "
"equal, the test will fail."
msgstr ""

#: ../../../library/unittest.rst:901
msgid "Test that *expr* is true (or false)."
msgstr ""

#: ../../../library/unittest.rst:903
msgid ""
"Note that this is equivalent to ``bool(expr) is True`` and not to ``expr is "
"True`` (use ``assertIs(expr, True)`` for the latter).  This method should "
"also be avoided when more specific methods are available (e.g. "
"``assertEqual(a, b)`` instead of ``assertTrue(a == b)``), because they "
"provide a better error message in case of failure."
msgstr ""

#: ../../../library/unittest.rst:913
msgid ""
"Test that *first* and *second* evaluate (or don't evaluate) to the same "
"object."
msgstr ""

#: ../../../library/unittest.rst:922
msgid "Test that *expr* is (or is not) None."
msgstr ""

#: ../../../library/unittest.rst:930
msgid "Test that *first* is (or is not) in *second*."
msgstr ""

#: ../../../library/unittest.rst:938
msgid ""
"Test that *obj* is (or is not) an instance of *cls* (which can be a class or "
"a tuple of classes, as supported by :func:`isinstance`). To check for the "
"exact type, use :func:`assertIs(type(obj), cls) <assertIs>`."
msgstr ""

#: ../../../library/unittest.rst:946
msgid ""
"It is also possible to check that exceptions and warnings are raised using "
"the following methods:"
msgstr ""

#: ../../../library/unittest.rst:952
msgid ":meth:`assertRaises(exc, fun, *args, **kwds) <TestCase.assertRaises>`"
msgstr ""

#: ../../../library/unittest.rst:952
msgid "``fun(*args, **kwds)`` raises *exc*"
msgstr ""

#: ../../../library/unittest.rst:955
msgid ""
":meth:`assertRaisesRegex(exc, re, fun, *args, **kwds) <TestCase."
"assertRaisesRegex>`"
msgstr ""

#: ../../../library/unittest.rst:955
msgid "``fun(*args, **kwds)`` raises *exc* and the message matches *re*"
msgstr ""

#: ../../../library/unittest.rst:958
msgid ":meth:`assertWarns(warn, fun, *args, **kwds) <TestCase.assertWarns>`"
msgstr ""

#: ../../../library/unittest.rst:958
msgid "``fun(*args, **kwds)`` raises *warn*"
msgstr ""

#: ../../../library/unittest.rst:961
msgid ""
":meth:`assertWarnsRegex(warn, re, fun, *args, **kwds) <TestCase."
"assertWarnsRegex>`"
msgstr ""

#: ../../../library/unittest.rst:961
msgid "``fun(*args, **kwds)`` raises *warn* and the message matches *re*"
msgstr ""

#: ../../../library/unittest.rst:968
msgid ""
"Test that an exception is raised when *callable* is called with any "
"positional or keyword arguments that are also passed to :meth:"
"`assertRaises`.  The test passes if *exception* is raised, is an error if "
"another exception is raised, or fails if no exception is raised. To catch "
"any of a group of exceptions, a tuple containing the exception classes may "
"be passed as *exception*."
msgstr ""

#: ../../../library/unittest.rst:975
msgid ""
"If only the *exception* argument is given, returns a context manager so that "
"the code under test can be written inline rather than as a function::"
msgstr ""

#: ../../../library/unittest.rst:978
msgid ""
"with self.assertRaises(SomeException):\n"
"    do_something()"
msgstr ""

#: ../../../library/unittest.rst:981
msgid ""
"The context manager will store the caught exception object in its :attr:"
"`exception` attribute.  This can be useful if the intention is to perform "
"additional checks on the exception raised::"
msgstr ""

#: ../../../library/unittest.rst:985
msgid ""
"with self.assertRaises(SomeException) as cm:\n"
"    do_something()\n"
"\n"
"the_exception = cm.exception\n"
"self.assertEqual(the_exception.error_code, 3)"
msgstr ""

#: ../../../library/unittest.rst:991
msgid "Added the ability to use :meth:`assertRaises` as a context manager."
msgstr ""

#: ../../../library/unittest.rst:994
msgid "Added the :attr:`exception` attribute."
msgstr ""

#: ../../../library/unittest.rst:1001
msgid ""
"Like :meth:`assertRaises` but also tests that *regex* matches on the string "
"representation of the raised exception.  *regex* may be a regular expression "
"object or a string containing a regular expression suitable for use by :func:"
"`re.search`.  Examples::"
msgstr ""

#: ../../../library/unittest.rst:1006
msgid ""
"self.assertRaisesRegex(ValueError, 'invalid literal for.*XYZ$',\n"
"                       int, 'XYZ')"
msgstr ""

#: ../../../library/unittest.rst:1009 ../../../library/unittest.rst:1066
msgid "or::"
msgstr ""

#: ../../../library/unittest.rst:1011
msgid ""
"with self.assertRaisesRegex(ValueError, 'literal'):\n"
"   int('XYZ')"
msgstr ""

#: ../../../library/unittest.rst:1014
msgid "under the name ``assertRaisesRegexp``."
msgstr ""

#: ../../../library/unittest.rst:1016
msgid "Renamed to :meth:`assertRaisesRegex`."
msgstr ""

#: ../../../library/unittest.rst:1023
msgid ""
"Test that a warning is triggered when *callable* is called with any "
"positional or keyword arguments that are also passed to :meth:"
"`assertWarns`.  The test passes if *warning* is triggered and fails if it "
"isn't.  Also, any unexpected exception is an error. To catch any of a group "
"of warnings, a tuple containing the warning classes may be passed as "
"*warnings*."
msgstr ""

#: ../../../library/unittest.rst:1030
msgid ""
"If only the *warning* argument is given, returns a context manager so that "
"the code under test can be written inline rather than as a function::"
msgstr ""

#: ../../../library/unittest.rst:1033
msgid ""
"with self.assertWarns(SomeWarning):\n"
"    do_something()"
msgstr ""

#: ../../../library/unittest.rst:1036
msgid ""
"The context manager will store the caught warning object in its :attr:"
"`warning` attribute, and the source line which triggered the warnings in "
"the :attr:`filename` and :attr:`lineno` attributes. This can be useful if "
"the intention is to perform additional checks on the exception raised::"
msgstr ""

#: ../../../library/unittest.rst:1042
msgid ""
"with self.assertWarns(SomeWarning) as cm:\n"
"    do_something()\n"
"\n"
"self.assertIn('myfile.py', cm.filename)\n"
"self.assertEqual(320, cm.lineno)"
msgstr ""

#: ../../../library/unittest.rst:1048
msgid ""
"This method works regardless of the warning filters in place when it is "
"called."
msgstr ""

#: ../../../library/unittest.rst:1057
msgid ""
"Like :meth:`assertWarns` but also tests that *regex* matches on the message "
"of the triggered warning.  *regex* may be a regular expression object or a "
"string containing a regular expression suitable for use by :func:`re."
"search`.  Example::"
msgstr ""

#: ../../../library/unittest.rst:1062
msgid ""
"self.assertWarnsRegex(DeprecationWarning,\n"
"                      r'legacy_function\\(\\) is deprecated',\n"
"                      legacy_function, 'XYZ')"
msgstr ""

#: ../../../library/unittest.rst:1068
msgid ""
"with self.assertWarnsRegex(RuntimeWarning, 'unsafe frobnicating'):\n"
"    frobnicate('/etc/passwd')"
msgstr ""

#: ../../../library/unittest.rst:1075
msgid ""
"There are also other methods used to perform more specific checks, such as:"
msgstr ""

#: ../../../library/unittest.rst:1080
msgid ":meth:`assertAlmostEqual(a, b) <TestCase.assertAlmostEqual>`"
msgstr ""

#: ../../../library/unittest.rst:1080
msgid "``round(a-b, 7) == 0``"
msgstr ""

#: ../../../library/unittest.rst:1083
msgid ":meth:`assertNotAlmostEqual(a, b) <TestCase.assertNotAlmostEqual>`"
msgstr ""

#: ../../../library/unittest.rst:1083
msgid "``round(a-b, 7) != 0``"
msgstr ""

#: ../../../library/unittest.rst:1086
msgid ":meth:`assertGreater(a, b) <TestCase.assertGreater>`"
msgstr ""

#: ../../../library/unittest.rst:1086
msgid "``a > b``"
msgstr ""

#: ../../../library/unittest.rst:1089
msgid ":meth:`assertGreaterEqual(a, b) <TestCase.assertGreaterEqual>`"
msgstr ""

#: ../../../library/unittest.rst:1089
msgid "``a >= b``"
msgstr ""

#: ../../../library/unittest.rst:1092
msgid ":meth:`assertLess(a, b) <TestCase.assertLess>`"
msgstr ""

#: ../../../library/unittest.rst:1092
msgid "``a < b``"
msgstr ""

#: ../../../library/unittest.rst:1095
msgid ":meth:`assertLessEqual(a, b) <TestCase.assertLessEqual>`"
msgstr ""

#: ../../../library/unittest.rst:1095
msgid "``a <= b``"
msgstr ""

#: ../../../library/unittest.rst:1098
msgid ":meth:`assertRegex(s, re) <TestCase.assertRegex>`"
msgstr ""

#: ../../../library/unittest.rst:1098
msgid "``regex.search(s)``"
msgstr ""

#: ../../../library/unittest.rst:1101
msgid ":meth:`assertNotRegex(s, re) <TestCase.assertNotRegex>`"
msgstr ""

#: ../../../library/unittest.rst:1101
msgid "``not regex.search(s)``"
msgstr ""

#: ../../../library/unittest.rst:1104
msgid ":meth:`assertCountEqual(a, b) <TestCase.assertCountEqual>`"
msgstr ""

#: ../../../library/unittest.rst:1104
msgid ""
"*a* and *b* have the same elements in the same number, regardless of their "
"order"
msgstr ""

#: ../../../library/unittest.rst:1113
msgid ""
"Test that *first* and *second* are approximately (or not approximately) "
"equal by computing the difference, rounding to the given number of decimal "
"*places* (default 7), and comparing to zero.  Note that these methods round "
"the values to the given number of *decimal places* (i.e. like the :func:"
"`round` function) and not *significant digits*."
msgstr ""

#: ../../../library/unittest.rst:1119
msgid ""
"If *delta* is supplied instead of *places* then the difference between "
"*first* and *second* must be less (or more) than *delta*."
msgstr ""

#: ../../../library/unittest.rst:1122
msgid "Supplying both *delta* and *places* raises a ``TypeError``."
msgstr ""

#: ../../../library/unittest.rst:1124
msgid ""
":meth:`assertAlmostEqual` automatically considers almost equal objects that "
"compare equal.  :meth:`assertNotAlmostEqual` automatically fails if the "
"objects compare equal.  Added the *delta* keyword argument."
msgstr ""

#: ../../../library/unittest.rst:1135
msgid ""
"Test that *first* is respectively >, >=, < or <= than *second* depending on "
"the method name.  If not, the test will fail::"
msgstr ""

#: ../../../library/unittest.rst:1138
msgid ""
">>> self.assertGreaterEqual(3, 4)\n"
"AssertionError: \"3\" unexpectedly not greater than or equal to \"4\""
msgstr ""

#: ../../../library/unittest.rst:1147
msgid ""
"Test that a *regex* search matches (or does not match) *text*.  In case of "
"failure, the error message will include the pattern and the *text* (or the "
"pattern and the part of *text* that unexpectedly matched).  *regex* may be a "
"regular expression object or a string containing a regular expression "
"suitable for use by :func:`re.search`."
msgstr ""

#: ../../../library/unittest.rst:1153
msgid "under the name ``assertRegexpMatches``."
msgstr ""

#: ../../../library/unittest.rst:1155
msgid ""
"The method ``assertRegexpMatches()`` has been renamed to :meth:`."
"assertRegex`."
msgstr ""

#: ../../../library/unittest.rst:1158
msgid ":meth:`.assertNotRegex`."
msgstr ""

#: ../../../library/unittest.rst:1164
msgid ""
"Tests whether the key/value pairs in *dictionary* are a superset of those in "
"*subset*.  If not, an error message listing the missing keys and mismatched "
"values is generated."
msgstr ""

#: ../../../library/unittest.rst:1168
msgid ""
"Note, the arguments are in the opposite order of what the method name "
"dictates.  Instead, consider using the set-methods on :ref:`dictionary views "
"<dict-views>`, for example: ``d.keys() <= e.keys()`` or ``d.items() <= d."
"items()``."
msgstr ""

#: ../../../library/unittest.rst:1179 ../../../library/unittest.rst:1193
msgid ""
"Test that sequence *first* contains the same elements as *second*, "
"regardless of their order. When they don't, an error message listing the "
"differences between the sequences will be generated."
msgstr ""

#: ../../../library/unittest.rst:1183
msgid ""
"Duplicate elements are *not* ignored when comparing *first* and *second*. It "
"verifies whether each element has the same count in both sequences. "
"Equivalent to: ``assertEqual(Counter(list(first)), Counter(list(second)))`` "
"but works with sequences of unhashable objects as well."
msgstr ""

#: ../../../library/unittest.rst:1197
msgid ""
"Duplicate elements are ignored when comparing *first* and *second*. It is "
"the equivalent of ``assertEqual(set(first), set(second))`` but it works with "
"sequences of unhashable objects as well. Because duplicates are ignored, "
"this method has been deprecated in favour of :meth:`assertCountEqual`."
msgstr ""

#: ../../../library/unittest.rst:1209
msgid ""
"The :meth:`assertEqual` method dispatches the equality check for objects of "
"the same type to different type-specific methods.  These methods are already "
"implemented for most of the built-in types, but it's also possible to "
"register new methods using :meth:`addTypeEqualityFunc`:"
msgstr ""

#: ../../../library/unittest.rst:1216
msgid ""
"Registers a type-specific method called by :meth:`assertEqual` to check if "
"two objects of exactly the same *typeobj* (not subclasses) compare equal.  "
"*function* must take two positional arguments and a third msg=None keyword "
"argument just as :meth:`assertEqual` does.  It must raise :data:`self."
"failureException(msg) <failureException>` when inequality between the first "
"two parameters is detected -- possibly providing useful information and "
"explaining the inequalities in details in the error message."
msgstr ""

#: ../../../library/unittest.rst:1227
msgid ""
"The list of type-specific methods automatically used by :meth:`~TestCase."
"assertEqual` are summarized in the following table.  Note that it's usually "
"not necessary to invoke these methods directly."
msgstr ""

#: ../../../library/unittest.rst:1232
msgid "Used to compare"
msgstr ""

#: ../../../library/unittest.rst:1234
msgid ":meth:`assertMultiLineEqual(a, b) <TestCase.assertMultiLineEqual>`"
msgstr ""

#: ../../../library/unittest.rst:1234
msgid "strings"
msgstr ""

#: ../../../library/unittest.rst:1237
msgid ":meth:`assertSequenceEqual(a, b) <TestCase.assertSequenceEqual>`"
msgstr ""

#: ../../../library/unittest.rst:1237
msgid "sequences"
msgstr ""

#: ../../../library/unittest.rst:1240
msgid ":meth:`assertListEqual(a, b) <TestCase.assertListEqual>`"
msgstr ""

#: ../../../library/unittest.rst:1240
msgid "lists"
msgstr ""

#: ../../../library/unittest.rst:1243
msgid ":meth:`assertTupleEqual(a, b) <TestCase.assertTupleEqual>`"
msgstr ""

#: ../../../library/unittest.rst:1243
msgid "tuples"
msgstr ""

#: ../../../library/unittest.rst:1246
msgid ":meth:`assertSetEqual(a, b) <TestCase.assertSetEqual>`"
msgstr ""

#: ../../../library/unittest.rst:1246
msgid "sets or frozensets"
msgstr ""

#: ../../../library/unittest.rst:1249
msgid ":meth:`assertDictEqual(a, b) <TestCase.assertDictEqual>`"
msgstr ""

#: ../../../library/unittest.rst:1249
msgid "dicts"
msgstr ""

#: ../../../library/unittest.rst:1257
msgid ""
"Test that the multiline string *first* is equal to the string *second*. When "
"not equal a diff of the two strings highlighting the differences will be "
"included in the error message. This method is used by default when comparing "
"strings with :meth:`assertEqual`."
msgstr ""

#: ../../../library/unittest.rst:1267
msgid ""
"Tests that two sequences are equal.  If a *seq_type* is supplied, both "
"*first* and *second* must be instances of *seq_type* or a failure will be "
"raised.  If the sequences are different an error message is constructed that "
"shows the difference between the two."
msgstr ""

#: ../../../library/unittest.rst:1272
msgid ""
"This method is not called directly by :meth:`assertEqual`, but it's used to "
"implement :meth:`assertListEqual` and :meth:`assertTupleEqual`."
msgstr ""

#: ../../../library/unittest.rst:1282
msgid ""
"Tests that two lists or tuples are equal.  If not, an error message is "
"constructed that shows only the differences between the two.  An error is "
"also raised if either of the parameters are of the wrong type. These methods "
"are used by default when comparing lists or tuples with :meth:`assertEqual`."
msgstr ""

#: ../../../library/unittest.rst:1293
msgid ""
"Tests that two sets are equal.  If not, an error message is constructed that "
"lists the differences between the sets.  This method is used by default when "
"comparing sets or frozensets with :meth:`assertEqual`."
msgstr ""

#: ../../../library/unittest.rst:1297
msgid ""
"Fails if either of *first* or *second* does not have a :meth:`set."
"difference` method."
msgstr ""

#: ../../../library/unittest.rst:1305
msgid ""
"Test that two dictionaries are equal.  If not, an error message is "
"constructed that shows the differences in the dictionaries. This method will "
"be used by default to compare dictionaries in calls to :meth:`assertEqual`."
msgstr ""

#: ../../../library/unittest.rst:1316
msgid ""
"Finally the :class:`TestCase` provides the following methods and attributes:"
msgstr ""

#: ../../../library/unittest.rst:1321
msgid ""
"Signals a test failure unconditionally, with *msg* or ``None`` for the error "
"message."
msgstr ""

#: ../../../library/unittest.rst:1327
msgid ""
"This class attribute gives the exception raised by the test method.  If a "
"test framework needs to use a specialized exception, possibly to carry "
"additional information, it must subclass this exception in order to \"play "
"fair\" with the framework.  The initial value of this attribute is :exc:"
"`AssertionError`."
msgstr ""

#: ../../../library/unittest.rst:1336
msgid ""
"If set to ``True`` then any explicit failure message you pass in to the :ref:"
"`assert methods <assert-methods>` will be appended to the end of the normal "
"failure message.  The normal messages contain useful information about the "
"objects involved, for example the message from assertEqual shows you the "
"repr of the two unequal objects. Setting this attribute to ``True`` allows "
"you to have a custom error message in addition to the normal one."
msgstr ""

#: ../../../library/unittest.rst:1344
msgid ""
"This attribute defaults to ``True``. If set to False then a custom message "
"passed to an assert method will silence the normal message."
msgstr ""

#: ../../../library/unittest.rst:1347
msgid ""
"The class setting can be overridden in individual tests by assigning an "
"instance attribute to ``True`` or ``False`` before calling the assert "
"methods."
msgstr ""

#: ../../../library/unittest.rst:1355
msgid ""
"This attribute controls the maximum length of diffs output by assert methods "
"that report diffs on failure. It defaults to 80*8 characters. Assert methods "
"affected by this attribute are :meth:`assertSequenceEqual` (including all "
"the sequence comparison methods that delegate to it), :meth:"
"`assertDictEqual` and :meth:`assertMultiLineEqual`."
msgstr ""

#: ../../../library/unittest.rst:1362
msgid ""
"Setting ``maxDiff`` to None means that there is no maximum length of diffs."
msgstr ""

#: ../../../library/unittest.rst:1368
msgid ""
"Testing frameworks can use the following methods to collect information on "
"the test:"
msgstr ""

#: ../../../library/unittest.rst:1374
msgid ""
"Return the number of tests represented by this test object.  For :class:"
"`TestCase` instances, this will always be ``1``."
msgstr ""

#: ../../../library/unittest.rst:1380
msgid ""
"Return an instance of the test result class that should be used for this "
"test case class (if no other result instance is provided to the :meth:`run` "
"method)."
msgstr ""

#: ../../../library/unittest.rst:1384
msgid ""
"For :class:`TestCase` instances, this will always be an instance of :class:"
"`TestResult`; subclasses of :class:`TestCase` should override this as "
"necessary."
msgstr ""

#: ../../../library/unittest.rst:1391
msgid ""
"Return a string identifying the specific test case.  This is usually the "
"full name of the test method, including the module and class name."
msgstr ""

#: ../../../library/unittest.rst:1397
msgid ""
"Returns a description of the test, or ``None`` if no description has been "
"provided.  The default implementation of this method returns the first line "
"of the test method's docstring, if available, or ``None``."
msgstr ""

#: ../../../library/unittest.rst:1402
msgid ""
"In 3.1 this was changed to add the test name to the short description even "
"in the presence of a docstring.  This caused compatibility issues with "
"unittest extensions and adding the test name was moved to the :class:"
"`TextTestResult` in Python 3.2."
msgstr ""

#: ../../../library/unittest.rst:1411
msgid ""
"Add a function to be called after :meth:`tearDown` to cleanup resources used "
"during the test. Functions will be called in reverse order to the order they "
"are added (LIFO). They are called with any arguments and keyword arguments "
"passed into :meth:`addCleanup` when they are added."
msgstr ""

#: ../../../library/unittest.rst:1417
msgid ""
"If :meth:`setUp` fails, meaning that :meth:`tearDown` is not called, then "
"any cleanup functions added will still be called."
msgstr ""

#: ../../../library/unittest.rst:1425
msgid ""
"This method is called unconditionally after :meth:`tearDown`, or after :meth:"
"`setUp` if :meth:`setUp` raises an exception."
msgstr ""

#: ../../../library/unittest.rst:1428
msgid ""
"It is responsible for calling all the cleanup functions added by :meth:"
"`addCleanup`. If you need cleanup functions to be called *prior* to :meth:"
"`tearDown` then you can call :meth:`doCleanups` yourself."
msgstr ""

#: ../../../library/unittest.rst:1433
msgid ""
":meth:`doCleanups` pops methods off the stack of cleanup functions one at a "
"time, so it can be called at any time."
msgstr ""

#: ../../../library/unittest.rst:1441
msgid ""
"This class implements the portion of the :class:`TestCase` interface which "
"allows the test runner to drive the test, but does not provide the methods "
"which test code can use to check and report errors.  This is used to create "
"test cases using legacy test code, allowing it to be integrated into a :mod:"
"`unittest`-based test framework."
msgstr ""

#: ../../../library/unittest.rst:1451
msgid "Deprecated aliases"
msgstr ""

#: ../../../library/unittest.rst:1453
msgid ""
"For historical reasons, some of the :class:`TestCase` methods had one or "
"more aliases that are now deprecated.  The following table lists the correct "
"names along with their deprecated aliases:"
msgstr ""

#: ../../../library/unittest.rst:1458
msgid "Method Name"
msgstr ""

#: ../../../library/unittest.rst:1458
msgid "Deprecated alias"
msgstr ""

#: ../../../library/unittest.rst:1460
msgid ":meth:`.assertEqual`"
msgstr ""

#: ../../../library/unittest.rst:1460
msgid "failUnlessEqual"
msgstr ""

#: ../../../library/unittest.rst:1460
msgid "assertEquals"
msgstr ""

#: ../../../library/unittest.rst:1461
msgid ":meth:`.assertNotEqual`"
msgstr ""

#: ../../../library/unittest.rst:1461
msgid "failIfEqual"
msgstr ""

#: ../../../library/unittest.rst:1461
msgid "assertNotEquals"
msgstr ""

#: ../../../library/unittest.rst:1462
msgid ":meth:`.assertTrue`"
msgstr ""

#: ../../../library/unittest.rst:1462
msgid "failUnless"
msgstr ""

#: ../../../library/unittest.rst:1462
msgid "assert\\_"
msgstr ""

#: ../../../library/unittest.rst:1463
msgid ":meth:`.assertFalse`"
msgstr ""

#: ../../../library/unittest.rst:1463
msgid "failIf"
msgstr ""

#: ../../../library/unittest.rst:1464
msgid ":meth:`.assertRaises`"
msgstr ""

#: ../../../library/unittest.rst:1464
msgid "failUnlessRaises"
msgstr ""

#: ../../../library/unittest.rst:1465
msgid ":meth:`.assertAlmostEqual`"
msgstr ""

#: ../../../library/unittest.rst:1465
msgid "failUnlessAlmostEqual"
msgstr ""

#: ../../../library/unittest.rst:1465
msgid "assertAlmostEquals"
msgstr ""

#: ../../../library/unittest.rst:1466
msgid ":meth:`.assertNotAlmostEqual`"
msgstr ""

#: ../../../library/unittest.rst:1466
msgid "failIfAlmostEqual"
msgstr ""

#: ../../../library/unittest.rst:1466
msgid "assertNotAlmostEquals"
msgstr ""

#: ../../../library/unittest.rst:1467
msgid ":meth:`.assertRegex`"
msgstr ""

#: ../../../library/unittest.rst:1467
msgid "assertRegexpMatches"
msgstr ""

#: ../../../library/unittest.rst:1468
msgid ":meth:`.assertRaisesRegex`"
msgstr ""

#: ../../../library/unittest.rst:1468
msgid "assertRaisesRegexp"
msgstr ""

#: ../../../library/unittest.rst:1471
msgid "the fail* aliases listed in the second column."
msgstr ""

#: ../../../library/unittest.rst:1473
msgid "the assert* aliases listed in the third column."
msgstr ""

#: ../../../library/unittest.rst:1475
msgid ""
"``assertRegexpMatches`` and ``assertRaisesRegexp`` have been renamed to :"
"meth:`.assertRegex` and :meth:`.assertRaisesRegex`"
msgstr ""

#: ../../../library/unittest.rst:1483
msgid "Grouping tests"
msgstr ""

#: ../../../library/unittest.rst:1487
msgid ""
"This class represents an aggregation of individual tests cases and test "
"suites. The class presents the interface needed by the test runner to allow "
"it to be run as any other test case.  Running a :class:`TestSuite` instance "
"is the same as iterating over the suite, running each test individually."
msgstr ""

#: ../../../library/unittest.rst:1492
msgid ""
"If *tests* is given, it must be an iterable of individual test cases or "
"other test suites that will be used to build the suite initially. Additional "
"methods are provided to add test cases and suites to the collection later on."
msgstr ""

#: ../../../library/unittest.rst:1496
msgid ""
":class:`TestSuite` objects behave much like :class:`TestCase` objects, "
"except they do not actually implement a test.  Instead, they are used to "
"aggregate tests into groups of tests that should be run together. Some "
"additional methods are available to add tests to :class:`TestSuite` "
"instances:"
msgstr ""

#: ../../../library/unittest.rst:1504
msgid "Add a :class:`TestCase` or :class:`TestSuite` to the suite."
msgstr ""

#: ../../../library/unittest.rst:1509
msgid ""
"Add all the tests from an iterable of :class:`TestCase` and :class:"
"`TestSuite` instances to this test suite."
msgstr ""

#: ../../../library/unittest.rst:1512
msgid ""
"This is equivalent to iterating over *tests*, calling :meth:`addTest` for "
"each element."
msgstr ""

#: ../../../library/unittest.rst:1515
msgid ":class:`TestSuite` shares the following methods with :class:`TestCase`:"
msgstr ""

#: ../../../library/unittest.rst:1520
msgid ""
"Run the tests associated with this suite, collecting the result into the "
"test result object passed as *result*.  Note that unlike :meth:`TestCase."
"run`, :meth:`TestSuite.run` requires the result object to be passed in."
msgstr ""

#: ../../../library/unittest.rst:1528
msgid ""
"Run the tests associated with this suite without collecting the result. This "
"allows exceptions raised by the test to be propagated to the caller and can "
"be used to support running tests under a debugger."
msgstr ""

#: ../../../library/unittest.rst:1535
msgid ""
"Return the number of tests represented by this test object, including all "
"individual tests and sub-suites."
msgstr ""

#: ../../../library/unittest.rst:1541
msgid ""
"Tests grouped by a :class:`TestSuite` are always accessed by iteration. "
"Subclasses can lazily provide tests by overriding :meth:`__iter__`. Note "
"that this method maybe called several times on a single suite (for example "
"when counting tests or comparing for equality) so the tests returned must be "
"the same for repeated iterations."
msgstr ""

#: ../../../library/unittest.rst:1547
msgid ""
"In earlier versions the :class:`TestSuite` accessed tests directly rather "
"than through iteration, so overriding :meth:`__iter__` wasn't sufficient for "
"providing tests."
msgstr ""

#: ../../../library/unittest.rst:1552
msgid ""
"In the typical usage of a :class:`TestSuite` object, the :meth:`run` method "
"is invoked by a :class:`TestRunner` rather than by the end-user test harness."
msgstr ""

#: ../../../library/unittest.rst:1557
msgid "Loading and running tests"
msgstr ""

#: ../../../library/unittest.rst:1561
msgid ""
"The :class:`TestLoader` class is used to create test suites from classes and "
"modules.  Normally, there is no need to create an instance of this class; "
"the :mod:`unittest` module provides an instance that can be shared as :data:"
"`unittest.defaultTestLoader`.  Using a subclass or instance, however, allows "
"customization of some configurable properties."
msgstr ""

#: ../../../library/unittest.rst:1567
msgid ":class:`TestLoader` objects have the following methods:"
msgstr ""

#: ../../../library/unittest.rst:1572
msgid ""
"Return a suite of all tests cases contained in the :class:`TestCase`\\ -"
"derived :class:`testCaseClass`."
msgstr ""

#: ../../../library/unittest.rst:1578
msgid ""
"Return a suite of all tests cases contained in the given module. This method "
"searches *module* for classes derived from :class:`TestCase` and creates an "
"instance of the class for each test method defined for the class."
msgstr ""

#: ../../../library/unittest.rst:1585
msgid ""
"While using a hierarchy of :class:`TestCase`\\ -derived classes can be "
"convenient in sharing fixtures and helper functions, defining test methods "
"on base classes that are not intended to be instantiated directly does not "
"play well with this method.  Doing so, however, can be useful when the "
"fixtures are different and defined in subclasses."
msgstr ""

#: ../../../library/unittest.rst:1591
msgid ""
"If a module provides a ``load_tests`` function it will be called to load the "
"tests. This allows modules to customize test loading. This is the "
"`load_tests protocol`_."
msgstr ""

#: ../../../library/unittest.rst:1595
msgid "Support for ``load_tests`` added."
msgstr ""

#: ../../../library/unittest.rst:1601
msgid "Return a suite of all tests cases given a string specifier."
msgstr ""

#: ../../../library/unittest.rst:1603
msgid ""
"The specifier *name* is a \"dotted name\" that may resolve either to a "
"module, a test case class, a test method within a test case class, a :class:"
"`TestSuite` instance, or a callable object which returns a :class:`TestCase` "
"or :class:`TestSuite` instance.  These checks are applied in the order "
"listed here; that is, a method on a possible test case class will be picked "
"up as \"a test method within a test case class\", rather than \"a callable "
"object\"."
msgstr ""

#: ../../../library/unittest.rst:1611
msgid ""
"For example, if you have a module :mod:`SampleTests` containing a :class:"
"`TestCase`\\ -derived class :class:`SampleTestCase` with three test methods "
"(:meth:`test_one`, :meth:`test_two`, and :meth:`test_three`), the specifier "
"``'SampleTests.SampleTestCase'`` would cause this method to return a suite "
"which will run all three test methods. Using the specifier ``'SampleTests."
"SampleTestCase.test_two'`` would cause it to return a test suite which will "
"run only the :meth:`test_two` test method. The specifier can refer to "
"modules and packages which have not been imported; they will be imported as "
"a side-effect."
msgstr ""

#: ../../../library/unittest.rst:1621
msgid "The method optionally resolves *name* relative to the given *module*."
msgstr ""

#: ../../../library/unittest.rst:1626
msgid ""
"Similar to :meth:`loadTestsFromName`, but takes a sequence of names rather "
"than a single name.  The return value is a test suite which supports all the "
"tests defined for each name."
msgstr ""

#: ../../../library/unittest.rst:1633
msgid ""
"Return a sorted sequence of method names found within *testCaseClass*; this "
"should be a subclass of :class:`TestCase`."
msgstr ""

#: ../../../library/unittest.rst:1639
msgid ""
"Find and return all test modules from the specified start directory, "
"recursing into subdirectories to find them. Only test files that match "
"*pattern* will be loaded. (Using shell style pattern matching.) Only module "
"names that are importable (i.e. are valid Python identifiers) will be loaded."
msgstr ""

#: ../../../library/unittest.rst:1645
msgid ""
"All test modules must be importable from the top level of the project. If "
"the start directory is not the top level directory then the top level "
"directory must be specified separately."
msgstr ""

#: ../../../library/unittest.rst:1649
msgid ""
"If importing a module fails, for example due to a syntax error, then this "
"will be recorded as a single error and discovery will continue."
msgstr ""

#: ../../../library/unittest.rst:1652
msgid ""
"If a test package name (directory with :file:`__init__.py`) matches the "
"pattern then the package will be checked for a ``load_tests`` function. If "
"this exists then it will be called with *loader*, *tests*, *pattern*."
msgstr ""

#: ../../../library/unittest.rst:1657
msgid ""
"If load_tests exists then discovery does *not* recurse into the package, "
"``load_tests`` is responsible for loading all tests in the package."
msgstr ""

#: ../../../library/unittest.rst:1660
msgid ""
"The pattern is deliberately not stored as a loader attribute so that "
"packages can continue discovery themselves. *top_level_dir* is stored so "
"``load_tests`` does not need to pass this argument in to ``loader."
"discover()``."
msgstr ""

#: ../../../library/unittest.rst:1665
msgid "*start_dir* can be a dotted module name as well as a directory."
msgstr ""

#: ../../../library/unittest.rst:1670
msgid ""
"The following attributes of a :class:`TestLoader` can be configured either "
"by subclassing or assignment on an instance:"
msgstr ""

#: ../../../library/unittest.rst:1676
msgid ""
"String giving the prefix of method names which will be interpreted as test "
"methods.  The default value is ``'test'``."
msgstr ""

#: ../../../library/unittest.rst:1679
msgid ""
"This affects :meth:`getTestCaseNames` and all the :meth:`loadTestsFrom\\*` "
"methods."
msgstr ""

#: ../../../library/unittest.rst:1685
msgid ""
"Function to be used to compare method names when sorting them in :meth:"
"`getTestCaseNames` and all the :meth:`loadTestsFrom\\*` methods."
msgstr ""

#: ../../../library/unittest.rst:1691
msgid ""
"Callable object that constructs a test suite from a list of tests. No "
"methods on the resulting object are needed.  The default value is the :class:"
"`TestSuite` class."
msgstr ""

#: ../../../library/unittest.rst:1695
msgid "This affects all the :meth:`loadTestsFrom\\*` methods."
msgstr ""

#: ../../../library/unittest.rst:1700
msgid ""
"This class is used to compile information about which tests have succeeded "
"and which have failed."
msgstr ""

#: ../../../library/unittest.rst:1703
msgid ""
"A :class:`TestResult` object stores the results of a set of tests.  The :"
"class:`TestCase` and :class:`TestSuite` classes ensure that results are "
"properly recorded; test authors do not need to worry about recording the "
"outcome of tests."
msgstr ""

#: ../../../library/unittest.rst:1708
msgid ""
"Testing frameworks built on top of :mod:`unittest` may want access to the :"
"class:`TestResult` object generated by running a set of tests for reporting "
"purposes; a :class:`TestResult` instance is returned by the :meth:"
"`TestRunner.run` method for this purpose."
msgstr ""

#: ../../../library/unittest.rst:1713
msgid ""
":class:`TestResult` instances have the following attributes that will be of "
"interest when inspecting the results of running a set of tests:"
msgstr ""

#: ../../../library/unittest.rst:1719
msgid ""
"A list containing 2-tuples of :class:`TestCase` instances and strings "
"holding formatted tracebacks. Each tuple represents a test which raised an "
"unexpected exception."
msgstr ""

#: ../../../library/unittest.rst:1725
msgid ""
"A list containing 2-tuples of :class:`TestCase` instances and strings "
"holding formatted tracebacks. Each tuple represents a test where a failure "
"was explicitly signalled using the :meth:`TestCase.fail\\*` or :meth:"
"`TestCase.assert\\*` methods."
msgstr ""

#: ../../../library/unittest.rst:1732
msgid ""
"A list containing 2-tuples of :class:`TestCase` instances and strings "
"holding the reason for skipping the test."
msgstr ""

#: ../../../library/unittest.rst:1739
msgid ""
"A list containing 2-tuples of :class:`TestCase` instances and strings "
"holding formatted tracebacks.  Each tuple represents an expected failure of "
"the test case."
msgstr ""

#: ../../../library/unittest.rst:1745
msgid ""
"A list containing :class:`TestCase` instances that were marked as expected "
"failures, but succeeded."
msgstr ""

#: ../../../library/unittest.rst:1750
msgid ""
"Set to ``True`` when the execution of tests should stop by :meth:`stop`."
msgstr ""

#: ../../../library/unittest.rst:1755
msgid "The total number of tests run so far."
msgstr ""

#: ../../../library/unittest.rst:1760
msgid ""
"If set to true, ``sys.stdout`` and ``sys.stderr`` will be buffered in "
"between :meth:`startTest` and :meth:`stopTest` being called. Collected "
"output will only be echoed onto the real ``sys.stdout`` and ``sys.stderr`` "
"if the test fails or errors. Any output is also attached to the failure / "
"error message."
msgstr ""

#: ../../../library/unittest.rst:1770
msgid ""
"If set to true :meth:`stop` will be called on the first failure or error, "
"halting the test run."
msgstr ""

#: ../../../library/unittest.rst:1778
msgid ""
"Return ``True`` if all tests run so far have passed, otherwise returns "
"``False``."
msgstr ""

#: ../../../library/unittest.rst:1784
msgid ""
"This method can be called to signal that the set of tests being run should "
"be aborted by setting the :attr:`shouldStop` attribute to ``True``. :class:"
"`TestRunner` objects should respect this flag and return without running any "
"additional tests."
msgstr ""

#: ../../../library/unittest.rst:1789
msgid ""
"For example, this feature is used by the :class:`TextTestRunner` class to "
"stop the test framework when the user signals an interrupt from the "
"keyboard.  Interactive tools which provide :class:`TestRunner` "
"implementations can use this in a similar manner."
msgstr ""

#: ../../../library/unittest.rst:1794
msgid ""
"The following methods of the :class:`TestResult` class are used to maintain "
"the internal data structures, and may be extended in subclasses to support "
"additional reporting requirements.  This is particularly useful in building "
"tools which support interactive reporting while tests are being run."
msgstr ""

#: ../../../library/unittest.rst:1802
msgid "Called when the test case *test* is about to be run."
msgstr ""

#: ../../../library/unittest.rst:1806
msgid ""
"Called after the test case *test* has been executed, regardless of the "
"outcome."
msgstr ""

#: ../../../library/unittest.rst:1811
msgid "Called once before any tests are executed."
msgstr ""

#: ../../../library/unittest.rst:1818
msgid "Called once after all tests are executed."
msgstr ""

#: ../../../library/unittest.rst:1825
msgid ""
"Called when the test case *test* raises an unexpected exception *err* is a "
"tuple of the form returned by :func:`sys.exc_info`: ``(type, value, "
"traceback)``."
msgstr ""

#: ../../../library/unittest.rst:1829
msgid ""
"The default implementation appends a tuple ``(test, formatted_err)`` to the "
"instance's :attr:`errors` attribute, where *formatted_err* is a formatted "
"traceback derived from *err*."
msgstr ""

#: ../../../library/unittest.rst:1836
msgid ""
"Called when the test case *test* signals a failure. *err* is a tuple of the "
"form returned by :func:`sys.exc_info`: ``(type, value, traceback)``."
msgstr ""

#: ../../../library/unittest.rst:1839
msgid ""
"The default implementation appends a tuple ``(test, formatted_err)`` to the "
"instance's :attr:`failures` attribute, where *formatted_err* is a formatted "
"traceback derived from *err*."
msgstr ""

#: ../../../library/unittest.rst:1846
msgid "Called when the test case *test* succeeds."
msgstr ""

#: ../../../library/unittest.rst:1848
msgid "The default implementation does nothing."
msgstr ""

#: ../../../library/unittest.rst:1853
msgid ""
"Called when the test case *test* is skipped.  *reason* is the reason the "
"test gave for skipping."
msgstr ""

#: ../../../library/unittest.rst:1856
msgid ""
"The default implementation appends a tuple ``(test, reason)`` to the "
"instance's :attr:`skipped` attribute."
msgstr ""

#: ../../../library/unittest.rst:1862
msgid ""
"Called when the test case *test* fails, but was marked with the :func:"
"`expectedFailure` decorator."
msgstr ""

#: ../../../library/unittest.rst:1865
msgid ""
"The default implementation appends a tuple ``(test, formatted_err)`` to the "
"instance's :attr:`expectedFailures` attribute, where *formatted_err* is a "
"formatted traceback derived from *err*."
msgstr ""

#: ../../../library/unittest.rst:1872
msgid ""
"Called when the test case *test* was marked with the :func:`expectedFailure` "
"decorator, but succeeded."
msgstr ""

#: ../../../library/unittest.rst:1875
msgid ""
"The default implementation appends the test to the instance's :attr:"
"`unexpectedSuccesses` attribute."
msgstr ""

#: ../../../library/unittest.rst:1881
msgid ""
"A concrete implementation of :class:`TestResult` used by the :class:"
"`TextTestRunner`."
msgstr ""

#: ../../../library/unittest.rst:1884
msgid ""
"This class was previously named ``_TextTestResult``. The old name still "
"exists as an alias but is deprecated."
msgstr ""

#: ../../../library/unittest.rst:1891
msgid ""
"Instance of the :class:`TestLoader` class intended to be shared.  If no "
"customization of the :class:`TestLoader` is needed, this instance can be "
"used instead of repeatedly creating new instances."
msgstr ""

#: ../../../library/unittest.rst:1898
msgid ""
"A basic test runner implementation that outputs results to a stream. If "
"*stream* is ``None``, the default, :data:`sys.stderr` is used as the output "
"stream. This class has a few configurable parameters, but is essentially "
"very simple.  Graphical applications which run test suites should provide "
"alternate implementations."
msgstr ""

#: ../../../library/unittest.rst:1903
msgid ""
"By default this runner shows :exc:`DeprecationWarning`, :exc:"
"`PendingDeprecationWarning`, and :exc:`ImportWarning` even if they are :ref:"
"`ignored by default <warning-ignored>`. Deprecation warnings caused by :ref:"
"`deprecated unittest methods <deprecated-aliases>` are also special-cased "
"and, when the warning filters are ``'default'`` or ``'always'``, they will "
"appear only once per-module, in order to avoid too many warning messages.  "
"This behavior can be overridden using the :option:`-Wd` or :option:`-Wa` "
"options and leaving *warnings* to ``None``."
msgstr ""

#: ../../../library/unittest.rst:1912
msgid "Added the ``warnings`` argument."
msgstr ""

#: ../../../library/unittest.rst:1915
msgid ""
"The default stream is set to :data:`sys.stderr` at instantiation time rather "
"than import time."
msgstr ""

#: ../../../library/unittest.rst:1921
msgid ""
"This method returns the instance of ``TestResult`` used by :meth:`run`. It "
"is not intended to be called directly, but can be overridden in subclasses "
"to provide a custom ``TestResult``."
msgstr ""

#: ../../../library/unittest.rst:1925
msgid ""
"``_makeResult()`` instantiates the class or callable passed in the "
"``TextTestRunner`` constructor as the ``resultclass`` argument. It defaults "
"to :class:`TextTestResult` if no ``resultclass`` is provided. The result "
"class is instantiated with the following arguments::"
msgstr ""

#: ../../../library/unittest.rst:1930
msgid "stream, descriptions, verbosity"
msgstr ""

#: ../../../library/unittest.rst:1937
msgid ""
"A command-line program that loads a set of tests from *module* and runs "
"them; this is primarily for making test modules conveniently executable. The "
"simplest use for this function is to include the following line at the end "
"of a test script::"
msgstr ""

#: ../../../library/unittest.rst:1942
msgid ""
"if __name__ == '__main__':\n"
"    unittest.main()"
msgstr ""

#: ../../../library/unittest.rst:1945
msgid ""
"You can run tests with more detailed information by passing in the verbosity "
"argument::"
msgstr ""

#: ../../../library/unittest.rst:1948
msgid ""
"if __name__ == '__main__':\n"
"    unittest.main(verbosity=2)"
msgstr ""

#: ../../../library/unittest.rst:1951
msgid ""
"The *argv* argument can be a list of options passed to the program, with the "
"first element being the program name.  If not specified or ``None``, the "
"values of :data:`sys.argv` are used."
msgstr ""

#: ../../../library/unittest.rst:1955
msgid ""
"The *testRunner* argument can either be a test runner class or an already "
"created instance of it. By default ``main`` calls :func:`sys.exit` with an "
"exit code indicating success or failure of the tests run."
msgstr ""

#: ../../../library/unittest.rst:1959
msgid ""
"The *testLoader* argument has to be a :class:`TestLoader` instance, and "
"defaults to :data:`defaultTestLoader`."
msgstr ""

#: ../../../library/unittest.rst:1962
msgid ""
"``main`` supports being used from the interactive interpreter by passing in "
"the argument ``exit=False``. This displays the result on standard output "
"without calling :func:`sys.exit`::"
msgstr ""

#: ../../../library/unittest.rst:1966
msgid ""
">>> from unittest import main\n"
">>> main(module='test_module', exit=False)"
msgstr ""

#: ../../../library/unittest.rst:1969
msgid ""
"The *failfast*, *catchbreak* and *buffer* parameters have the same effect as "
"the same-name `command-line options`_."
msgstr ""

#: ../../../library/unittest.rst:1972
msgid ""
"The *warning* argument specifies the :ref:`warning filter <warning-filter>` "
"that should be used while running the tests.  If it's not specified, it will "
"remain ``None`` if a :option:`-W` option is passed to :program:`python`, "
"otherwise it will be set to ``'default'``."
msgstr ""

#: ../../../library/unittest.rst:1977
msgid ""
"Calling ``main`` actually returns an instance of the ``TestProgram`` class. "
"This stores the result of the tests run as the ``result`` attribute."
msgstr ""

#: ../../../library/unittest.rst:1980
msgid "The *exit* parameter was added."
msgstr ""

#: ../../../library/unittest.rst:1983
msgid ""
"The *verbosity*, *failfast*, *catchbreak*, *buffer* and *warnings* "
"parameters were added."
msgstr ""

#: ../../../library/unittest.rst:1989
msgid "load_tests Protocol"
msgstr ""

#: ../../../library/unittest.rst:1993
msgid ""
"Modules or packages can customize how tests are loaded from them during "
"normal test runs or test discovery by implementing a function called "
"``load_tests``."
msgstr ""

#: ../../../library/unittest.rst:1996
msgid ""
"If a test module defines ``load_tests`` it will be called by :meth:"
"`TestLoader.loadTestsFromModule` with the following arguments::"
msgstr ""

#: ../../../library/unittest.rst:1999
msgid "load_tests(loader, standard_tests, None)"
msgstr ""

#: ../../../library/unittest.rst:2001
msgid "It should return a :class:`TestSuite`."
msgstr ""

#: ../../../library/unittest.rst:2003
msgid ""
"*loader* is the instance of :class:`TestLoader` doing the loading. "
"*standard_tests* are the tests that would be loaded by default from the "
"module. It is common for test modules to only want to add or remove tests "
"from the standard set of tests. The third argument is used when loading "
"packages as part of test discovery."
msgstr ""

#: ../../../library/unittest.rst:2009
msgid ""
"A typical ``load_tests`` function that loads tests from a specific set of :"
"class:`TestCase` classes may look like::"
msgstr ""

#: ../../../library/unittest.rst:2012
msgid ""
"test_cases = (TestCase1, TestCase2, TestCase3)\n"
"\n"
"def load_tests(loader, tests, pattern):\n"
"    suite = TestSuite()\n"
"    for test_class in test_cases:\n"
"        tests = loader.loadTestsFromTestCase(test_class)\n"
"        suite.addTests(tests)\n"
"    return suite"
msgstr ""

#: ../../../library/unittest.rst:2021
msgid ""
"If discovery is started, either from the command line or by calling :meth:"
"`TestLoader.discover`, with a pattern that matches a package name then the "
"package :file:`__init__.py` will be checked for ``load_tests``."
msgstr ""

#: ../../../library/unittest.rst:2027
msgid ""
"The default pattern is ``'test*.py'``. This matches all Python files that "
"start with ``'test'`` but *won't* match any test directories."
msgstr ""

#: ../../../library/unittest.rst:2030
msgid "A pattern like ``'test*'`` will match test packages as well as modules."
msgstr ""

#: ../../../library/unittest.rst:2033
msgid ""
"If the package :file:`__init__.py` defines ``load_tests`` then it will be "
"called and discovery not continued into the package. ``load_tests`` is "
"called with the following arguments::"
msgstr ""

#: ../../../library/unittest.rst:2037
msgid "load_tests(loader, standard_tests, pattern)"
msgstr ""

#: ../../../library/unittest.rst:2039
msgid ""
"This should return a :class:`TestSuite` representing all the tests from the "
"package. (``standard_tests`` will only contain tests collected from :file:"
"`__init__.py`.)"
msgstr ""

#: ../../../library/unittest.rst:2043
msgid ""
"Because the pattern is passed into ``load_tests`` the package is free to "
"continue (and potentially modify) test discovery. A 'do nothing' "
"``load_tests`` function for a test package would look like::"
msgstr ""

#: ../../../library/unittest.rst:2047
msgid ""
"def load_tests(loader, standard_tests, pattern):\n"
"    # top level directory cached on loader instance\n"
"    this_dir = os.path.dirname(__file__)\n"
"    package_tests = loader.discover(start_dir=this_dir, pattern=pattern)\n"
"    standard_tests.addTests(package_tests)\n"
"    return standard_tests"
msgstr ""

#: ../../../library/unittest.rst:2056
msgid "Class and Module Fixtures"
msgstr ""

#: ../../../library/unittest.rst:2058
msgid ""
"Class and module level fixtures are implemented in :class:`TestSuite`. When "
"the test suite encounters a test from a new class then :meth:`tearDownClass` "
"from the previous class (if there is one) is called, followed by :meth:"
"`setUpClass` from the new class."
msgstr ""

#: ../../../library/unittest.rst:2063
msgid ""
"Similarly if a test is from a different module from the previous test then "
"``tearDownModule`` from the previous module is run, followed by "
"``setUpModule`` from the new module."
msgstr ""

#: ../../../library/unittest.rst:2067
msgid ""
"After all the tests have run the final ``tearDownClass`` and "
"``tearDownModule`` are run."
msgstr ""

#: ../../../library/unittest.rst:2070
msgid ""
"Note that shared fixtures do not play well with [potential] features like "
"test parallelization and they break test isolation. They should be used with "
"care."
msgstr ""

#: ../../../library/unittest.rst:2073
msgid ""
"The default ordering of tests created by the unittest test loaders is to "
"group all tests from the same modules and classes together. This will lead "
"to ``setUpClass`` / ``setUpModule`` (etc) being called exactly once per "
"class and module. If you randomize the order, so that tests from different "
"modules and classes are adjacent to each other, then these shared fixture "
"functions may be called multiple times in a single test run."
msgstr ""

#: ../../../library/unittest.rst:2080
msgid ""
"Shared fixtures are not intended to work with suites with non-standard "
"ordering. A ``BaseTestSuite`` still exists for frameworks that don't want to "
"support shared fixtures."
msgstr ""

#: ../../../library/unittest.rst:2084
msgid ""
"If there are any exceptions raised during one of the shared fixture "
"functions the test is reported as an error. Because there is no "
"corresponding test instance an ``_ErrorHolder`` object (that has the same "
"interface as a :class:`TestCase`) is created to represent the error. If you "
"are just using the standard unittest test runner then this detail doesn't "
"matter, but if you are a framework author it may be relevant."
msgstr ""

#: ../../../library/unittest.rst:2093
msgid "setUpClass and tearDownClass"
msgstr ""

#: ../../../library/unittest.rst:2095
msgid "These must be implemented as class methods::"
msgstr ""

#: ../../../library/unittest.rst:2097
msgid ""
"import unittest\n"
"\n"
"class Test(unittest.TestCase):\n"
"    @classmethod\n"
"    def setUpClass(cls):\n"
"        cls._connection = createExpensiveConnectionObject()\n"
"\n"
"    @classmethod\n"
"    def tearDownClass(cls):\n"
"        cls._connection.destroy()"
msgstr ""

#: ../../../library/unittest.rst:2108
msgid ""
"If you want the ``setUpClass`` and ``tearDownClass`` on base classes called "
"then you must call up to them yourself. The implementations in :class:"
"`TestCase` are empty."
msgstr ""

#: ../../../library/unittest.rst:2112
msgid ""
"If an exception is raised during a ``setUpClass`` then the tests in the "
"class are not run and the ``tearDownClass`` is not run. Skipped classes will "
"not have ``setUpClass`` or ``tearDownClass`` run. If the exception is a :exc:"
"`SkipTest` exception then the class will be reported as having been skipped "
"instead of as an error."
msgstr ""

#: ../../../library/unittest.rst:2120
msgid "setUpModule and tearDownModule"
msgstr ""

#: ../../../library/unittest.rst:2122
msgid "These should be implemented as functions::"
msgstr ""

#: ../../../library/unittest.rst:2124
msgid ""
"def setUpModule():\n"
"    createConnection()\n"
"\n"
"def tearDownModule():\n"
"    closeConnection()"
msgstr ""

#: ../../../library/unittest.rst:2130
msgid ""
"If an exception is raised in a ``setUpModule`` then none of the tests in the "
"module will be run and the ``tearDownModule`` will not be run. If the "
"exception is a :exc:`SkipTest` exception then the module will be reported as "
"having been skipped instead of as an error."
msgstr ""

#: ../../../library/unittest.rst:2137
msgid "Signal Handling"
msgstr ""

#: ../../../library/unittest.rst:2141
msgid ""
"The :option:`-c/--catch <unittest -c>` command-line option to unittest, "
"along with the ``catchbreak`` parameter to :func:`unittest.main()`, provide "
"more friendly handling of control-C during a test run. With catch break "
"behavior enabled control-C will allow the currently running test to "
"complete, and the test run will then end and report all the results so far. "
"A second control-c will raise a :exc:`KeyboardInterrupt` in the usual way."
msgstr ""

#: ../../../library/unittest.rst:2148
msgid ""
"The control-c handling signal handler attempts to remain compatible with "
"code or tests that install their own :const:`signal.SIGINT` handler. If the "
"``unittest`` handler is called but *isn't* the installed :const:`signal."
"SIGINT` handler, i.e. it has been replaced by the system under test and "
"delegated to, then it calls the default handler. This will normally be the "
"expected behavior by code that replaces an installed handler and delegates "
"to it. For individual tests that need ``unittest`` control-c handling "
"disabled the :func:`removeHandler` decorator can be used."
msgstr ""

#: ../../../library/unittest.rst:2157
msgid ""
"There are a few utility functions for framework authors to enable control-c "
"handling functionality within test frameworks."
msgstr ""

#: ../../../library/unittest.rst:2162
msgid ""
"Install the control-c handler. When a :const:`signal.SIGINT` is received "
"(usually in response to the user pressing control-c) all registered results "
"have :meth:`~TestResult.stop` called."
msgstr ""

#: ../../../library/unittest.rst:2169
msgid ""
"Register a :class:`TestResult` object for control-c handling. Registering a "
"result stores a weak reference to it, so it doesn't prevent the result from "
"being garbage collected."
msgstr ""

#: ../../../library/unittest.rst:2173
msgid ""
"Registering a :class:`TestResult` object has no side-effects if control-c "
"handling is not enabled, so test frameworks can unconditionally register all "
"results they create independently of whether or not handling is enabled."
msgstr ""

#: ../../../library/unittest.rst:2180
msgid ""
"Remove a registered result. Once a result has been removed then :meth:"
"`~TestResult.stop` will no longer be called on that result object in "
"response to a control-c."
msgstr ""

#: ../../../library/unittest.rst:2187
msgid ""
"When called without arguments this function removes the control-c handler if "
"it has been installed. This function can also be used as a test decorator to "
"temporarily remove the handler whilst the test is being executed::"
msgstr ""

#: ../../../library/unittest.rst:2191
msgid ""
"@unittest.removeHandler\n"
"def test_signal_handling(self):\n"
"    ..."
msgstr ""

# SOME DESCRIPTIVE TITLE.
# Copyright (C) 1990-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-10 15:08+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../library/stdtypes.rst:8
msgid "Built-in Types"
msgstr ""

#: ../../../library/stdtypes.rst:10
msgid ""
"The following sections describe the standard types that are built into the "
"interpreter."
msgstr ""

#: ../../../library/stdtypes.rst:15
msgid ""
"The principal built-in types are numerics, sequences, mappings, classes, "
"instances and exceptions."
msgstr ""

#: ../../../library/stdtypes.rst:18
msgid ""
"Some operations are supported by several object types; in particular, "
"practically all objects can be compared, tested for truth value, and "
"converted to a string (with the :func:`repr` function or the slightly "
"different :func:`str` function).  The latter function is implicitly used "
"when an object is written by the :func:`print` function."
msgstr ""

#: ../../../library/stdtypes.rst:28
msgid "Truth Value Testing"
msgstr ""

#: ../../../library/stdtypes.rst:37
msgid ""
"Any object can be tested for truth value, for use in an :keyword:`if` or :"
"keyword:`while` condition or as operand of the Boolean operations below. The "
"following values are considered false:"
msgstr ""

#: ../../../library/stdtypes.rst:43
msgid "``None``"
msgstr ""

#: ../../../library/stdtypes.rst:47
msgid "``False``"
msgstr ""

#: ../../../library/stdtypes.rst:49
msgid "zero of any numeric type, for example, ``0``, ``0.0``, ``0j``."
msgstr ""

#: ../../../library/stdtypes.rst:51
msgid "any empty sequence, for example, ``''``, ``()``, ``[]``."
msgstr ""

#: ../../../library/stdtypes.rst:53
msgid "any empty mapping, for example, ``{}``."
msgstr ""

#: ../../../library/stdtypes.rst:55
msgid ""
"instances of user-defined classes, if the class defines a :meth:`__bool__` "
"or :meth:`__len__` method, when that method returns the integer zero or :"
"class:`bool` value ``False``. [1]_"
msgstr ""

#: ../../../library/stdtypes.rst:61
msgid ""
"All other values are considered true --- so objects of many types are always "
"true."
msgstr ""

#: ../../../library/stdtypes.rst:70
msgid ""
"Operations and built-in functions that have a Boolean result always return "
"``0`` or ``False`` for false and ``1`` or ``True`` for true, unless "
"otherwise stated. (Important exception: the Boolean operations ``or`` and "
"``and`` always return one of their operands.)"
msgstr ""

#: ../../../library/stdtypes.rst:79
msgid "Boolean Operations --- :keyword:`and`, :keyword:`or`, :keyword:`not`"
msgstr ""

#: ../../../library/stdtypes.rst:83
msgid "These are the Boolean operations, ordered by ascending priority:"
msgstr ""

#: ../../../library/stdtypes.rst:86 ../../../library/stdtypes.rst:144
#: ../../../library/stdtypes.rst:272 ../../../library/stdtypes.rst:361
#: ../../../library/stdtypes.rst:407 ../../../library/stdtypes.rst:870
#: ../../../library/stdtypes.rst:1703
msgid "Operation"
msgstr ""

#: ../../../library/stdtypes.rst:86 ../../../library/stdtypes.rst:272
#: ../../../library/stdtypes.rst:361 ../../../library/stdtypes.rst:407
#: ../../../library/stdtypes.rst:870 ../../../library/stdtypes.rst:1703
msgid "Result"
msgstr ""

#: ../../../library/stdtypes.rst:86 ../../../library/stdtypes.rst:272
#: ../../../library/stdtypes.rst:361 ../../../library/stdtypes.rst:407
#: ../../../library/stdtypes.rst:870 ../../../library/stdtypes.rst:1541
#: ../../../library/stdtypes.rst:1703
msgid "Notes"
msgstr ""

#: ../../../library/stdtypes.rst:88
msgid "``x or y``"
msgstr ""

#: ../../../library/stdtypes.rst:88
msgid "if *x* is false, then *y*, else *x*"
msgstr ""

#: ../../../library/stdtypes.rst:88 ../../../library/stdtypes.rst:282
#: ../../../library/stdtypes.rst:872 ../../../library/stdtypes.rst:875
#: ../../../library/stdtypes.rst:1547 ../../../library/stdtypes.rst:1714
msgid "\\(1)"
msgstr ""

#: ../../../library/stdtypes.rst:91
msgid "``x and y``"
msgstr ""

#: ../../../library/stdtypes.rst:91
msgid "if *x* is false, then *x*, else *y*"
msgstr ""

#: ../../../library/stdtypes.rst:91 ../../../library/stdtypes.rst:285
#: ../../../library/stdtypes.rst:305 ../../../library/stdtypes.rst:881
#: ../../../library/stdtypes.rst:1551 ../../../library/stdtypes.rst:1553
#: ../../../library/stdtypes.rst:1723
msgid "\\(2)"
msgstr ""

#: ../../../library/stdtypes.rst:94
msgid "``not x``"
msgstr ""

#: ../../../library/stdtypes.rst:94
msgid "if *x* is false, then ``True``, else ``False``"
msgstr ""

#: ../../../library/stdtypes.rst:94 ../../../library/stdtypes.rst:884
#: ../../../library/stdtypes.rst:1555 ../../../library/stdtypes.rst:1557
#: ../../../library/stdtypes.rst:1559 ../../../library/stdtypes.rst:1561
#: ../../../library/stdtypes.rst:1729 ../../../library/stdtypes.rst:1738
msgid "\\(3)"
msgstr ""

#: ../../../library/stdtypes.rst:103 ../../../library/stdtypes.rst:316
#: ../../../library/stdtypes.rst:425 ../../../library/stdtypes.rst:922
#: ../../../library/stdtypes.rst:1587 ../../../library/stdtypes.rst:1747
msgid "Notes:"
msgstr ""

#: ../../../library/stdtypes.rst:106
msgid ""
"This is a short-circuit operator, so it only evaluates the second argument "
"if the first one is :const:`False`."
msgstr ""

#: ../../../library/stdtypes.rst:110
msgid ""
"This is a short-circuit operator, so it only evaluates the second argument "
"if the first one is :const:`True`."
msgstr ""

#: ../../../library/stdtypes.rst:114
msgid ""
"``not`` has a lower priority than non-Boolean operators, so ``not a == b`` "
"is interpreted as ``not (a == b)``, and ``a == not b`` is a syntax error."
msgstr ""

#: ../../../library/stdtypes.rst:121
msgid "Comparisons"
msgstr ""

#: ../../../library/stdtypes.rst:135
msgid ""
"There are eight comparison operations in Python.  They all have the same "
"priority (which is higher than that of the Boolean operations).  Comparisons "
"can be chained arbitrarily; for example, ``x < y <= z`` is equivalent to ``x "
"< y and y <= z``, except that *y* is evaluated only once (but in both cases "
"*z* is not evaluated at all when ``x < y`` is found to be false)."
msgstr ""

#: ../../../library/stdtypes.rst:141
msgid "This table summarizes the comparison operations:"
msgstr ""

#: ../../../library/stdtypes.rst:144 ../../../library/stdtypes.rst:1518
#: ../../../library/stdtypes.rst:1541
msgid "Meaning"
msgstr ""

#: ../../../library/stdtypes.rst:146
msgid "``<``"
msgstr ""

#: ../../../library/stdtypes.rst:146
msgid "strictly less than"
msgstr ""

#: ../../../library/stdtypes.rst:148
msgid "``<=``"
msgstr ""

#: ../../../library/stdtypes.rst:148
msgid "less than or equal"
msgstr ""

#: ../../../library/stdtypes.rst:150
msgid "``>``"
msgstr ""

#: ../../../library/stdtypes.rst:150
msgid "strictly greater than"
msgstr ""

#: ../../../library/stdtypes.rst:152
msgid "``>=``"
msgstr ""

#: ../../../library/stdtypes.rst:152
msgid "greater than or equal"
msgstr ""

#: ../../../library/stdtypes.rst:154
msgid "``==``"
msgstr ""

#: ../../../library/stdtypes.rst:154
msgid "equal"
msgstr ""

#: ../../../library/stdtypes.rst:156
msgid "``!=``"
msgstr ""

#: ../../../library/stdtypes.rst:156
msgid "not equal"
msgstr ""

#: ../../../library/stdtypes.rst:158
msgid "``is``"
msgstr ""

#: ../../../library/stdtypes.rst:158
msgid "object identity"
msgstr ""

#: ../../../library/stdtypes.rst:160
msgid "``is not``"
msgstr ""

#: ../../../library/stdtypes.rst:160
msgid "negated object identity"
msgstr ""

#: ../../../library/stdtypes.rst:167
msgid ""
"Objects of different types, except different numeric types, never compare "
"equal. Furthermore, some types (for example, function objects) support only "
"a degenerate notion of comparison where any two objects of that type are "
"unequal.  The ``<``, ``<=``, ``>`` and ``>=`` operators will raise a :exc:"
"`TypeError` exception when comparing a complex number with another built-in "
"numeric type, when the objects are of different types that cannot be "
"compared, or in other cases where there is no defined ordering."
msgstr ""

#: ../../../library/stdtypes.rst:183
msgid ""
"Non-identical instances of a class normally compare as non-equal unless the "
"class defines the :meth:`__eq__` method."
msgstr ""

#: ../../../library/stdtypes.rst:186
msgid ""
"Instances of a class cannot be ordered with respect to other instances of "
"the same class, or other types of object, unless the class defines enough of "
"the methods :meth:`__lt__`, :meth:`__le__`, :meth:`__gt__`, and :meth:"
"`__ge__` (in general, :meth:`__lt__` and :meth:`__eq__` are sufficient, if "
"you want the conventional meanings of the comparison operators)."
msgstr ""

#: ../../../library/stdtypes.rst:192
msgid ""
"The behavior of the :keyword:`is` and :keyword:`is not` operators cannot be "
"customized; also they can be applied to any two objects and never raise an "
"exception."
msgstr ""

#: ../../../library/stdtypes.rst:200
msgid ""
"Two more operations with the same syntactic priority, :keyword:`in` and :"
"keyword:`not in`, are supported only by sequence types (below)."
msgstr ""

#: ../../../library/stdtypes.rst:207
msgid "Numeric Types --- :class:`int`, :class:`float`, :class:`complex`"
msgstr ""

#: ../../../library/stdtypes.rst:217
msgid ""
"There are three distinct numeric types: :dfn:`integers`, :dfn:`floating "
"point numbers`, and :dfn:`complex numbers`.  In addition, Booleans are a "
"subtype of integers.  Integers have unlimited precision.  Floating point "
"numbers are usually implemented using :c:type:`double` in C; information "
"about the precision and internal representation of floating point numbers "
"for the machine on which your program is running is available in :data:`sys."
"float_info`.  Complex numbers have a real and imaginary part, which are each "
"a floating point number.  To extract these parts from a complex number *z*, "
"use ``z.real`` and ``z.imag``. (The standard library includes additional "
"numeric types, :mod:`fractions` that hold rationals, and :mod:`decimal` that "
"hold floating-point numbers with user-definable precision.)"
msgstr ""

#: ../../../library/stdtypes.rst:239
msgid ""
"Numbers are created by numeric literals or as the result of built-in "
"functions and operators.  Unadorned integer literals (including hex, octal "
"and binary numbers) yield integers.  Numeric literals containing a decimal "
"point or an exponent sign yield floating point numbers.  Appending ``'j'`` "
"or ``'J'`` to a numeric literal yields an imaginary number (a complex number "
"with a zero real part) which you can add to an integer or float to get a "
"complex number with real and imaginary parts."
msgstr ""

#: ../../../library/stdtypes.rst:260
msgid ""
"Python fully supports mixed arithmetic: when a binary arithmetic operator "
"has operands of different numeric types, the operand with the \"narrower\" "
"type is widened to that of the other, where integer is narrower than "
"floating point, which is narrower than complex.  Comparisons between numbers "
"of mixed type use the same rule. [2]_ The constructors :func:`int`, :func:"
"`float`, and :func:`complex` can be used to produce numbers of a specific "
"type."
msgstr ""

#: ../../../library/stdtypes.rst:267
msgid ""
"All numeric types (except complex) support the following operations, sorted "
"by ascending priority (operations in the same box have the same priority; "
"all numeric operations have a higher priority than comparison operations):"
msgstr ""

#: ../../../library/stdtypes.rst:272
msgid "Full documentation"
msgstr ""

#: ../../../library/stdtypes.rst:274
msgid "``x + y``"
msgstr ""

#: ../../../library/stdtypes.rst:274
msgid "sum of *x* and *y*"
msgstr ""

#: ../../../library/stdtypes.rst:276
msgid "``x - y``"
msgstr ""

#: ../../../library/stdtypes.rst:276
msgid "difference of *x* and *y*"
msgstr ""

#: ../../../library/stdtypes.rst:278
msgid "``x * y``"
msgstr ""

#: ../../../library/stdtypes.rst:278
msgid "product of *x* and *y*"
msgstr ""

#: ../../../library/stdtypes.rst:280
msgid "``x / y``"
msgstr ""

#: ../../../library/stdtypes.rst:280
msgid "quotient of *x* and *y*"
msgstr ""

#: ../../../library/stdtypes.rst:282
msgid "``x // y``"
msgstr ""

#: ../../../library/stdtypes.rst:282
msgid "floored quotient of *x* and *y*"
msgstr ""

#: ../../../library/stdtypes.rst:285
msgid "``x % y``"
msgstr ""

#: ../../../library/stdtypes.rst:285
msgid "remainder of ``x / y``"
msgstr ""

#: ../../../library/stdtypes.rst:287
msgid "``-x``"
msgstr ""

#: ../../../library/stdtypes.rst:287
msgid "*x* negated"
msgstr ""

#: ../../../library/stdtypes.rst:289
msgid "``+x``"
msgstr ""

#: ../../../library/stdtypes.rst:289
msgid "*x* unchanged"
msgstr ""

#: ../../../library/stdtypes.rst:291
msgid "``abs(x)``"
msgstr ""

#: ../../../library/stdtypes.rst:291
msgid "absolute value or magnitude of *x*"
msgstr ""

#: ../../../library/stdtypes.rst:291
msgid ":func:`abs`"
msgstr ""

#: ../../../library/stdtypes.rst:294
msgid "``int(x)``"
msgstr ""

#: ../../../library/stdtypes.rst:294
msgid "*x* converted to integer"
msgstr ""

#: ../../../library/stdtypes.rst:294
msgid "\\(3)\\(6)"
msgstr ""

#: ../../../library/stdtypes.rst:294
msgid ":func:`int`"
msgstr ""

#: ../../../library/stdtypes.rst:296
msgid "``float(x)``"
msgstr ""

#: ../../../library/stdtypes.rst:296
msgid "*x* converted to floating point"
msgstr ""

#: ../../../library/stdtypes.rst:296
msgid "\\(4)\\(6)"
msgstr ""

#: ../../../library/stdtypes.rst:296
msgid ":func:`float`"
msgstr ""

#: ../../../library/stdtypes.rst:298
msgid "``complex(re, im)``"
msgstr ""

#: ../../../library/stdtypes.rst:298
msgid ""
"a complex number with real part *re*, imaginary part *im*. *im* defaults to "
"zero."
msgstr ""

#: ../../../library/stdtypes.rst:298 ../../../library/stdtypes.rst:878
#: ../../../library/stdtypes.rst:1740
msgid "\\(6)"
msgstr ""

#: ../../../library/stdtypes.rst:298
msgid ":func:`complex`"
msgstr ""

#: ../../../library/stdtypes.rst:302
msgid "``c.conjugate()``"
msgstr ""

#: ../../../library/stdtypes.rst:302
msgid "conjugate of the complex number *c*"
msgstr ""

#: ../../../library/stdtypes.rst:305
msgid "``divmod(x, y)``"
msgstr ""

#: ../../../library/stdtypes.rst:305
msgid "the pair ``(x // y, x % y)``"
msgstr ""

#: ../../../library/stdtypes.rst:305
msgid ":func:`divmod`"
msgstr ""

#: ../../../library/stdtypes.rst:307
msgid "``pow(x, y)``"
msgstr ""

#: ../../../library/stdtypes.rst:307 ../../../library/stdtypes.rst:309
msgid "*x* to the power *y*"
msgstr ""

#: ../../../library/stdtypes.rst:307 ../../../library/stdtypes.rst:309
#: ../../../library/stdtypes.rst:1574 ../../../library/stdtypes.rst:1577
#: ../../../library/stdtypes.rst:1580 ../../../library/stdtypes.rst:1735
msgid "\\(5)"
msgstr ""

#: ../../../library/stdtypes.rst:307
msgid ":func:`pow`"
msgstr ""

#: ../../../library/stdtypes.rst:309
msgid "``x ** y``"
msgstr ""

#: ../../../library/stdtypes.rst:319
msgid ""
"Also referred to as integer division.  The resultant value is a whole "
"integer, though the result's type is not necessarily int.  The result is "
"always rounded towards minus infinity: ``1//2`` is ``0``, ``(-1)//2`` is "
"``-1``, ``1//(-2)`` is ``-1``, and ``(-1)//(-2)`` is ``0``."
msgstr ""

#: ../../../library/stdtypes.rst:325
msgid ""
"Not for complex numbers.  Instead convert to floats using :func:`abs` if "
"appropriate."
msgstr ""

#: ../../../library/stdtypes.rst:337
msgid ""
"Conversion from floating point to integer may round or truncate as in C; see "
"functions :func:`floor` and :func:`ceil` in the :mod:`math` module for well-"
"defined conversions."
msgstr ""

#: ../../../library/stdtypes.rst:342
msgid ""
"float also accepts the strings \"nan\" and \"inf\" with an optional prefix "
"\"+\" or \"-\" for Not a Number (NaN) and positive or negative infinity."
msgstr ""

#: ../../../library/stdtypes.rst:346
msgid ""
"Python defines ``pow(0, 0)`` and ``0 ** 0`` to be ``1``, as is common for "
"programming languages."
msgstr ""

#: ../../../library/stdtypes.rst:350
msgid ""
"The numeric literals accepted include the digits ``0`` to ``9`` or any "
"Unicode equivalent (code points with the ``Nd`` property)."
msgstr ""

#: ../../../library/stdtypes.rst:353
msgid ""
"See http://www.unicode.org/Public/6.0.0/ucd/extracted/DerivedNumericType.txt "
"for a complete list of code points with the ``Nd`` property."
msgstr ""

#: ../../../library/stdtypes.rst:357
msgid ""
"All :class:`numbers.Real` types (:class:`int` and :class:`float`) also "
"include the following operations:"
msgstr ""

#: ../../../library/stdtypes.rst:363
msgid "``math.trunc(x)``"
msgstr ""

#: ../../../library/stdtypes.rst:363
msgid "*x* truncated to Integral"
msgstr ""

#: ../../../library/stdtypes.rst:365
msgid "``round(x[, n])``"
msgstr ""

#: ../../../library/stdtypes.rst:365
msgid ""
"*x* rounded to n digits, rounding half to even. If n is omitted, it defaults "
"to 0."
msgstr ""

#: ../../../library/stdtypes.rst:369
msgid "``math.floor(x)``"
msgstr ""

#: ../../../library/stdtypes.rst:369
msgid "the greatest integral float <= *x*"
msgstr ""

#: ../../../library/stdtypes.rst:371
msgid "``math.ceil(x)``"
msgstr ""

#: ../../../library/stdtypes.rst:371
msgid "the least integral float >= *x*"
msgstr ""

#: ../../../library/stdtypes.rst:374
msgid ""
"For additional numeric operations see the :mod:`math` and :mod:`cmath` "
"modules."
msgstr ""

#: ../../../library/stdtypes.rst:383
msgid "Bitwise Operations on Integer Types"
msgstr ""

#: ../../../library/stdtypes.rst:395
msgid ""
"Bitwise operations only make sense for integers.  Negative numbers are "
"treated as their 2's complement value (this assumes a sufficiently large "
"number of bits that no overflow occurs during the operation)."
msgstr ""

#: ../../../library/stdtypes.rst:399
msgid ""
"The priorities of the binary bitwise operations are all lower than the "
"numeric operations and higher than the comparisons; the unary operation "
"``~`` has the same priority as the other unary numeric operations (``+`` and "
"``-``)."
msgstr ""

#: ../../../library/stdtypes.rst:403
msgid ""
"This table lists the bitwise operations sorted in ascending priority "
"(operations in the same box have the same priority):"
msgstr ""

#: ../../../library/stdtypes.rst:409
msgid "``x | y``"
msgstr ""

#: ../../../library/stdtypes.rst:409
msgid "bitwise :dfn:`or` of *x* and *y*"
msgstr ""

#: ../../../library/stdtypes.rst:412
msgid "``x ^ y``"
msgstr ""

#: ../../../library/stdtypes.rst:412
msgid "bitwise :dfn:`exclusive or` of *x* and *y*"
msgstr ""

#: ../../../library/stdtypes.rst:415
msgid "``x & y``"
msgstr ""

#: ../../../library/stdtypes.rst:415
msgid "bitwise :dfn:`and` of *x* and *y*"
msgstr ""

#: ../../../library/stdtypes.rst:418
msgid "``x << n``"
msgstr ""

#: ../../../library/stdtypes.rst:418
msgid "*x* shifted left by *n* bits"
msgstr ""

#: ../../../library/stdtypes.rst:418
msgid "(1)(2)"
msgstr ""

#: ../../../library/stdtypes.rst:420
msgid "``x >> n``"
msgstr ""

#: ../../../library/stdtypes.rst:420
msgid "*x* shifted right by *n* bits"
msgstr ""

#: ../../../library/stdtypes.rst:420
msgid "(1)(3)"
msgstr ""

#: ../../../library/stdtypes.rst:422
msgid "``~x``"
msgstr ""

#: ../../../library/stdtypes.rst:422
msgid "the bits of *x* inverted"
msgstr ""

#: ../../../library/stdtypes.rst:428
msgid ""
"Negative shift counts are illegal and cause a :exc:`ValueError` to be raised."
msgstr ""

#: ../../../library/stdtypes.rst:431
msgid ""
"A left shift by *n* bits is equivalent to multiplication by ``pow(2, n)`` "
"without overflow check."
msgstr ""

#: ../../../library/stdtypes.rst:435
msgid ""
"A right shift by *n* bits is equivalent to division by ``pow(2, n)`` without "
"overflow check."
msgstr ""

#: ../../../library/stdtypes.rst:440
msgid "Additional Methods on Integer Types"
msgstr ""

#: ../../../library/stdtypes.rst:442
msgid ""
"The int type implements the :class:`numbers.Integral` :term:`abstract base "
"class`. In addition, it provides one more method:"
msgstr ""

#: ../../../library/stdtypes.rst:447
msgid ""
"Return the number of bits necessary to represent an integer in binary, "
"excluding the sign and leading zeros::"
msgstr ""

#: ../../../library/stdtypes.rst:450
msgid ""
">>> n = -37\n"
">>> bin(n)\n"
"'-0b100101'\n"
">>> n.bit_length()\n"
"6"
msgstr ""

#: ../../../library/stdtypes.rst:456
msgid ""
"More precisely, if ``x`` is nonzero, then ``x.bit_length()`` is the unique "
"positive integer ``k`` such that ``2**(k-1) <= abs(x) < 2**k``. "
"Equivalently, when ``abs(x)`` is small enough to have a correctly rounded "
"logarithm, then ``k = 1 + int(log(abs(x), 2))``. If ``x`` is zero, then ``x."
"bit_length()`` returns ``0``."
msgstr ""

#: ../../../library/stdtypes.rst:462
msgid "Equivalent to::"
msgstr ""

#: ../../../library/stdtypes.rst:464
msgid ""
"def bit_length(self):\n"
"    s = bin(self)       # binary representation:  bin(-37) --> '-0b100101'\n"
"    s = s.lstrip('-0b') # remove leading zeros and minus sign\n"
"    return len(s)       # len('100101') --> 6"
msgstr ""

#: ../../../library/stdtypes.rst:473
msgid "Return an array of bytes representing an integer."
msgstr ""

#: ../../../library/stdtypes.rst:485
msgid ""
"The integer is represented using *length* bytes.  An :exc:`OverflowError` is "
"raised if the integer is not representable with the given number of bytes."
msgstr ""

#: ../../../library/stdtypes.rst:489 ../../../library/stdtypes.rst:522
msgid ""
"The *byteorder* argument determines the byte order used to represent the "
"integer.  If *byteorder* is ``\"big\"``, the most significant byte is at the "
"beginning of the byte array.  If *byteorder* is ``\"little\"``, the most "
"significant byte is at the end of the byte array.  To request the native "
"byte order of the host system, use :data:`sys.byteorder` as the byte order "
"value."
msgstr ""

#: ../../../library/stdtypes.rst:496
msgid ""
"The *signed* argument determines whether two's complement is used to "
"represent the integer.  If *signed* is ``False`` and a negative integer is "
"given, an :exc:`OverflowError` is raised. The default value for *signed* is "
"``False``."
msgstr ""

#: ../../../library/stdtypes.rst:505
msgid "Return the integer represented by the given array of bytes."
msgstr ""

#: ../../../library/stdtypes.rst:518
msgid ""
"The argument *bytes* must either support the buffer protocol or be an "
"iterable producing bytes. :class:`bytes` and :class:`bytearray` are examples "
"of built-in objects that support the buffer protocol."
msgstr ""

#: ../../../library/stdtypes.rst:529
msgid ""
"The *signed* argument indicates whether two's complement is used to "
"represent the integer."
msgstr ""

#: ../../../library/stdtypes.rst:536
msgid "Additional Methods on Float"
msgstr ""

#: ../../../library/stdtypes.rst:538
msgid ""
"The float type implements the :class:`numbers.Real` :term:`abstract base "
"class`. float also has the following additional methods."
msgstr ""

#: ../../../library/stdtypes.rst:543
msgid ""
"Return a pair of integers whose ratio is exactly equal to the original float "
"and with a positive denominator.  Raises :exc:`OverflowError` on infinities "
"and a :exc:`ValueError` on NaNs."
msgstr ""

#: ../../../library/stdtypes.rst:550
msgid ""
"Return ``True`` if the float instance is finite with integral value, and "
"``False`` otherwise::"
msgstr ""

#: ../../../library/stdtypes.rst:553
msgid ""
">>> (-2.0).is_integer()\n"
"True\n"
">>> (3.2).is_integer()\n"
"False"
msgstr ""

#: ../../../library/stdtypes.rst:558
msgid ""
"Two methods support conversion to and from hexadecimal strings.  Since "
"Python's floats are stored internally as binary numbers, converting a float "
"to or from a *decimal* string usually involves a small rounding error.  In "
"contrast, hexadecimal strings allow exact representation and specification "
"of floating-point numbers.  This can be useful when debugging, and in "
"numerical work."
msgstr ""

#: ../../../library/stdtypes.rst:569
msgid ""
"Return a representation of a floating-point number as a hexadecimal string.  "
"For finite floating-point numbers, this representation will always include a "
"leading ``0x`` and a trailing ``p`` and exponent."
msgstr ""

#: ../../../library/stdtypes.rst:577
msgid ""
"Class method to return the float represented by a hexadecimal string *s*.  "
"The string *s* may have leading and trailing whitespace."
msgstr ""

#: ../../../library/stdtypes.rst:582
msgid ""
"Note that :meth:`float.hex` is an instance method, while :meth:`float."
"fromhex` is a class method."
msgstr ""

#: ../../../library/stdtypes.rst:585
msgid "A hexadecimal string takes the form::"
msgstr ""

#: ../../../library/stdtypes.rst:587
msgid "[sign] ['0x'] integer ['.' fraction] ['p' exponent]"
msgstr ""

#: ../../../library/stdtypes.rst:589
msgid ""
"where the optional ``sign`` may by either ``+`` or ``-``, ``integer`` and "
"``fraction`` are strings of hexadecimal digits, and ``exponent`` is a "
"decimal integer with an optional leading sign.  Case is not significant, and "
"there must be at least one hexadecimal digit in either the integer or the "
"fraction.  This syntax is similar to the syntax specified in section 6.4.4.2 "
"of the C99 standard, and also to the syntax used in Java 1.5 onwards.  In "
"particular, the output of :meth:`float.hex` is usable as a hexadecimal "
"floating-point literal in C or Java code, and hexadecimal strings produced "
"by C's ``%a`` format character or Java's ``Double.toHexString`` are accepted "
"by :meth:`float.fromhex`."
msgstr ""

#: ../../../library/stdtypes.rst:602
msgid ""
"Note that the exponent is written in decimal rather than hexadecimal, and "
"that it gives the power of 2 by which to multiply the coefficient. For "
"example, the hexadecimal string ``0x3.a7p10`` represents the floating-point "
"number ``(3 + 10./16 + 7./16**2) * 2.0**10``, or ``3740.0``::"
msgstr ""

#: ../../../library/stdtypes.rst:608
msgid ""
">>> float.fromhex('0x3.a7p10')\n"
"3740.0"
msgstr ""

#: ../../../library/stdtypes.rst:612
msgid ""
"Applying the reverse conversion to ``3740.0`` gives a different hexadecimal "
"string representing the same number::"
msgstr ""

#: ../../../library/stdtypes.rst:615
msgid ""
">>> float.hex(3740.0)\n"
"'0x1.d380000000000p+11'"
msgstr ""

#: ../../../library/stdtypes.rst:622
msgid "Hashing of numeric types"
msgstr ""

#: ../../../library/stdtypes.rst:624
msgid ""
"For numbers ``x`` and ``y``, possibly of different types, it's a requirement "
"that ``hash(x) == hash(y)`` whenever ``x == y`` (see the :meth:`__hash__` "
"method documentation for more details).  For ease of implementation and "
"efficiency across a variety of numeric types (including :class:`int`, :class:"
"`float`, :class:`decimal.Decimal` and :class:`fractions.Fraction`) Python's "
"hash for numeric types is based on a single mathematical function that's "
"defined for any rational number, and hence applies to all instances of :"
"class:`int` and :class:`fraction.Fraction`, and all finite instances of :"
"class:`float` and :class:`decimal.Decimal`.  Essentially, this function is "
"given by reduction modulo ``P`` for a fixed prime ``P``.  The value of ``P`` "
"is made available to Python as the :attr:`modulus` attribute of :data:`sys."
"hash_info`."
msgstr ""

#: ../../../library/stdtypes.rst:639
msgid ""
"Currently, the prime used is ``P = 2**31 - 1`` on machines with 32-bit C "
"longs and ``P = 2**61 - 1`` on machines with 64-bit C longs."
msgstr ""

#: ../../../library/stdtypes.rst:642
msgid "Here are the rules in detail:"
msgstr ""

#: ../../../library/stdtypes.rst:644
msgid ""
"If ``x = m / n`` is a nonnegative rational number and ``n`` is not divisible "
"by ``P``, define ``hash(x)`` as ``m * invmod(n, P) % P``, where ``invmod(n, "
"P)`` gives the inverse of ``n`` modulo ``P``."
msgstr ""

#: ../../../library/stdtypes.rst:648
msgid ""
"If ``x = m / n`` is a nonnegative rational number and ``n`` is divisible by "
"``P`` (but ``m`` is not) then ``n`` has no inverse modulo ``P`` and the rule "
"above doesn't apply; in this case define ``hash(x)`` to be the constant "
"value ``sys.hash_info.inf``."
msgstr ""

#: ../../../library/stdtypes.rst:653
msgid ""
"If ``x = m / n`` is a negative rational number define ``hash(x)`` as ``-"
"hash(-x)``.  If the resulting hash is ``-1``, replace it with ``-2``."
msgstr ""

#: ../../../library/stdtypes.rst:657
msgid ""
"The particular values ``sys.hash_info.inf``, ``-sys.hash_info.inf`` and "
"``sys.hash_info.nan`` are used as hash values for positive infinity, "
"negative infinity, or nans (respectively).  (All hashable nans have the same "
"hash value.)"
msgstr ""

#: ../../../library/stdtypes.rst:662
msgid ""
"For a :class:`complex` number ``z``, the hash values of the real and "
"imaginary parts are combined by computing ``hash(z.real) + sys.hash_info."
"imag * hash(z.imag)``, reduced modulo ``2**sys.hash_info.width`` so that it "
"lies in ``range(-2**(sys.hash_info.width - 1), 2**(sys.hash_info.width - "
"1))``.  Again, if the result is ``-1``, it's replaced with ``-2``."
msgstr ""

#: ../../../library/stdtypes.rst:670
msgid ""
"To clarify the above rules, here's some example Python code, equivalent to "
"the builtin hash, for computing the hash of a rational number, :class:"
"`float`, or :class:`complex`::"
msgstr ""

#: ../../../library/stdtypes.rst:675
msgid ""
"import sys, math\n"
"\n"
"def hash_fraction(m, n):\n"
"    \"\"\"Compute the hash of a rational number m / n.\n"
"\n"
"    Assumes m and n are integers, with n positive.\n"
"    Equivalent to hash(fractions.Fraction(m, n)).\n"
"\n"
"    \"\"\"\n"
"    P = sys.hash_info.modulus\n"
"    # Remove common factors of P.  (Unnecessary if m and n already "
"coprime.)\n"
"    while m % P == n % P == 0:\n"
"        m, n = m // P, n // P\n"
"\n"
"    if n % P == 0:\n"
"        hash_ = sys.hash_info.inf\n"
"    else:\n"
"        # Fermat's Little Theorem: pow(n, P-1, P) is 1, so\n"
"        # pow(n, P-2, P) gives the inverse of n modulo P.\n"
"        hash_ = (abs(m) % P) * pow(n, P - 2, P) % P\n"
"    if m < 0:\n"
"        hash_ = -hash_\n"
"    if hash_ == -1:\n"
"        hash_ = -2\n"
"    return hash_\n"
"\n"
"def hash_float(x):\n"
"    \"\"\"Compute the hash of a float x.\"\"\"\n"
"\n"
"    if math.isnan(x):\n"
"        return sys.hash_info.nan\n"
"    elif math.isinf(x):\n"
"        return sys.hash_info.inf if x > 0 else -sys.hash_info.inf\n"
"    else:\n"
"        return hash_fraction(*x.as_integer_ratio())\n"
"\n"
"def hash_complex(z):\n"
"    \"\"\"Compute the hash of a complex number z.\"\"\"\n"
"\n"
"    hash_ = hash_float(z.real) + sys.hash_info.imag * hash_float(z.imag)\n"
"    # do a signed reduction modulo 2**sys.hash_info.width\n"
"    M = 2**(sys.hash_info.width - 1)\n"
"    hash_ = (hash_ & (M - 1)) - (hash & M)\n"
"    if hash_ == -1:\n"
"        hash_ == -2\n"
"    return hash_"
msgstr ""

#: ../../../library/stdtypes.rst:725
msgid "Iterator Types"
msgstr ""

#: ../../../library/stdtypes.rst:733
msgid ""
"Python supports a concept of iteration over containers.  This is implemented "
"using two distinct methods; these are used to allow user-defined classes to "
"support iteration.  Sequences, described below in more detail, always "
"support the iteration methods."
msgstr ""

#: ../../../library/stdtypes.rst:738
msgid ""
"One method needs to be defined for container objects to provide iteration "
"support:"
msgstr ""

#: ../../../library/stdtypes.rst:745
msgid ""
"Return an iterator object.  The object is required to support the iterator "
"protocol described below.  If a container supports different types of "
"iteration, additional methods can be provided to specifically request "
"iterators for those iteration types.  (An example of an object supporting "
"multiple forms of iteration would be a tree structure which supports both "
"breadth-first and depth-first traversal.)  This method corresponds to the :"
"attr:`tp_iter` slot of the type structure for Python objects in the Python/C "
"API."
msgstr ""

#: ../../../library/stdtypes.rst:754
msgid ""
"The iterator objects themselves are required to support the following two "
"methods, which together form the :dfn:`iterator protocol`:"
msgstr ""

#: ../../../library/stdtypes.rst:760
msgid ""
"Return the iterator object itself.  This is required to allow both "
"containers and iterators to be used with the :keyword:`for` and :keyword:"
"`in` statements. This method corresponds to the :attr:`tp_iter` slot of the "
"type structure for Python objects in the Python/C API."
msgstr ""

#: ../../../library/stdtypes.rst:768
msgid ""
"Return the next item from the container.  If there are no further items, "
"raise the :exc:`StopIteration` exception.  This method corresponds to the :"
"attr:`tp_iternext` slot of the type structure for Python objects in the "
"Python/C API."
msgstr ""

#: ../../../library/stdtypes.rst:773
msgid ""
"Python defines several iterator objects to support iteration over general "
"and specific sequence types, dictionaries, and other more specialized "
"forms.  The specific types are not important beyond their implementation of "
"the iterator protocol."
msgstr ""

#: ../../../library/stdtypes.rst:778
msgid ""
"Once an iterator's :meth:`~iterator.__next__` method raises :exc:"
"`StopIteration`, it must continue to do so on subsequent calls. "
"Implementations that do not obey this property are deemed broken."
msgstr ""

#: ../../../library/stdtypes.rst:786
msgid "Generator Types"
msgstr ""

#: ../../../library/stdtypes.rst:788
msgid ""
"Python's :term:`generator`\\s provide a convenient way to implement the "
"iterator protocol.  If a container object's :meth:`__iter__` method is "
"implemented as a generator, it will automatically return an iterator object "
"(technically, a generator object) supplying the :meth:`__iter__` and :meth:"
"`~generator.__next__` methods. More information about generators can be "
"found in :ref:`the documentation for the yield expression <yieldexpr>`."
msgstr ""

#: ../../../library/stdtypes.rst:803
msgid ""
"Sequence Types --- :class:`str`, :class:`bytes`, :class:`bytearray`, :class:"
"`list`, :class:`tuple`, :class:`range`"
msgstr ""

#: ../../../library/stdtypes.rst:805
msgid ""
"There are six sequence types: strings, byte sequences (:class:`bytes` "
"objects), byte arrays (:class:`bytearray` objects), lists, tuples, and range "
"objects.  For other containers see the built in :class:`dict` and :class:"
"`set` classes, and the :mod:`collections` module."
msgstr ""

#: ../../../library/stdtypes.rst:821
msgid ""
"Textual data in Python is handled with :class:`str` objects, or :dfn:"
"`strings`. Strings are immutable :ref:`sequences <typesseq>` of Unicode code "
"points. String literals are written in single or double quotes: ``'xyzzy'``, "
"``\"frobozz\"``.  See :ref:`strings` for more about string literals.  In "
"addition to the functionality described here, there are also string-specific "
"methods described in the :ref:`string-methods` section."
msgstr ""

#: ../../../library/stdtypes.rst:828
msgid ""
"Bytes and bytearray objects contain single bytes -- the former is immutable "
"while the latter is a mutable sequence. Bytes objects can be constructed by "
"using the constructor, :func:`bytes`, and from literals; use a ``b`` prefix "
"with normal string syntax: ``b'xyzzy'``.  To construct byte arrays, use the :"
"func:`bytearray` function."
msgstr ""

#: ../../../library/stdtypes.rst:835
msgid ""
"While string objects are sequences of characters (represented by strings of "
"length 1), bytes and bytearray objects are sequences of *integers* (between "
"0 and 255), representing the ASCII value of single bytes.  That means that "
"for a bytes or bytearray object *b*, ``b[0]`` will be an integer, while "
"``b[0:1]`` will be a bytes or bytearray object of length 1.  The "
"representation of bytes objects uses the literal format (``b'...'``) since "
"it is generally more useful than e.g. ``bytes([50, 19, 100])``.  You can "
"always convert a bytes object into a list of integers using ``list(b)``."
msgstr ""

#: ../../../library/stdtypes.rst:844
msgid ""
"Also, while in previous Python versions, byte strings and Unicode strings "
"could be exchanged for each other rather freely (barring encoding issues), "
"strings and bytes are now completely separate concepts.  There's no implicit "
"en-/decoding if you pass an object of the wrong type.  A string always "
"compares unequal to a bytes or bytearray object."
msgstr ""

#: ../../../library/stdtypes.rst:850
msgid ""
"Lists are constructed with square brackets, separating items with commas: "
"``[a, b, c]``.  Tuples are constructed by the comma operator (not within "
"square brackets), with or without enclosing parentheses, but an empty tuple "
"must have the enclosing parentheses, such as ``a, b, c`` or ``()``.  A "
"single item tuple must have a trailing comma, such as ``(d,)``."
msgstr ""

#: ../../../library/stdtypes.rst:856
msgid ""
"Objects of type range are created using the :func:`range` function.  They "
"don't support concatenation or repetition, and using :func:`min` or :func:"
"`max` on them is inefficient."
msgstr ""

#: ../../../library/stdtypes.rst:860
msgid ""
"Most sequence types support the following operations.  The ``in`` and ``not "
"in`` operations have the same priorities as the comparison operations.  The "
"``+`` and ``*`` operations have the same priority as the corresponding "
"numeric operations. [3]_ Additional methods are provided for :ref:`typesseq-"
"mutable`."
msgstr ""

#: ../../../library/stdtypes.rst:865
msgid ""
"This table lists the sequence operations sorted in ascending priority "
"(operations in the same box have the same priority).  In the table, *s* and "
"*t* are sequences of the same type; *n*, *i*, *j* and *k* are integers."
msgstr ""

#: ../../../library/stdtypes.rst:872
msgid "``x in s``"
msgstr ""

#: ../../../library/stdtypes.rst:872
msgid "``True`` if an item of *s* is equal to *x*, else ``False``"
msgstr ""

#: ../../../library/stdtypes.rst:875
msgid "``x not in s``"
msgstr ""

#: ../../../library/stdtypes.rst:875
msgid "``False`` if an item of *s* is equal to *x*, else ``True``"
msgstr ""

#: ../../../library/stdtypes.rst:878
msgid "``s + t``"
msgstr ""

#: ../../../library/stdtypes.rst:878
msgid "the concatenation of *s* and *t*"
msgstr ""

#: ../../../library/stdtypes.rst:881
msgid "``s * n, n * s``"
msgstr ""

#: ../../../library/stdtypes.rst:881
msgid "*n* shallow copies of *s* concatenated"
msgstr ""

#: ../../../library/stdtypes.rst:884
msgid "``s[i]``"
msgstr ""

#: ../../../library/stdtypes.rst:884
msgid "*i*\\ th item of *s*, origin 0"
msgstr ""

#: ../../../library/stdtypes.rst:886
msgid "``s[i:j]``"
msgstr ""

#: ../../../library/stdtypes.rst:886
msgid "slice of *s* from *i* to *j*"
msgstr ""

#: ../../../library/stdtypes.rst:886
msgid "(3)(4)"
msgstr ""

#: ../../../library/stdtypes.rst:888
msgid "``s[i:j:k]``"
msgstr ""

#: ../../../library/stdtypes.rst:888
msgid "slice of *s* from *i* to *j* with step *k*"
msgstr ""

#: ../../../library/stdtypes.rst:888
msgid "(3)(5)"
msgstr ""

#: ../../../library/stdtypes.rst:891
msgid "``len(s)``"
msgstr ""

#: ../../../library/stdtypes.rst:891
msgid "length of *s*"
msgstr ""

#: ../../../library/stdtypes.rst:893
msgid "``min(s)``"
msgstr ""

#: ../../../library/stdtypes.rst:893
msgid "smallest item of *s*"
msgstr ""

#: ../../../library/stdtypes.rst:895
msgid "``max(s)``"
msgstr ""

#: ../../../library/stdtypes.rst:895
msgid "largest item of *s*"
msgstr ""

#: ../../../library/stdtypes.rst:897
msgid "``s.index(i)``"
msgstr ""

#: ../../../library/stdtypes.rst:897
msgid "index of the first occurence of *i* in *s*"
msgstr ""

#: ../../../library/stdtypes.rst:900
msgid "``s.count(i)``"
msgstr ""

#: ../../../library/stdtypes.rst:900
msgid "total number of occurences of *i* in *s*"
msgstr ""

#: ../../../library/stdtypes.rst:904
msgid ""
"Sequence types also support comparisons.  In particular, tuples and lists "
"are compared lexicographically by comparing corresponding elements.  This "
"means that to compare equal, every element must compare equal and the two "
"sequences must be of the same type and have the same length.  (For full "
"details see :ref:`comparisons` in the language reference.)"
msgstr ""

#: ../../../library/stdtypes.rst:925
msgid ""
"When *s* is a string object, the ``in`` and ``not in`` operations act like a "
"substring test."
msgstr ""

#: ../../../library/stdtypes.rst:929
msgid ""
"Values of *n* less than ``0`` are treated as ``0`` (which yields an empty "
"sequence of the same type as *s*).  Note also that the copies are shallow; "
"nested structures are not copied.  This often haunts new Python programmers; "
"consider:"
msgstr ""

#: ../../../library/stdtypes.rst:941
msgid ""
"What has happened is that ``[[]]`` is a one-element list containing an empty "
"list, so all three elements of ``[[]] * 3`` are (pointers to) this single "
"empty list.  Modifying any of the elements of ``lists`` modifies this single "
"list. You can create a list of different lists this way:"
msgstr ""

#: ../../../library/stdtypes.rst:954
msgid ""
"If *i* or *j* is negative, the index is relative to the end of the string: "
"``len(s) + i`` or ``len(s) + j`` is substituted.  But note that ``-0`` is "
"still ``0``."
msgstr ""

#: ../../../library/stdtypes.rst:959
msgid ""
"The slice of *s* from *i* to *j* is defined as the sequence of items with "
"index *k* such that ``i <= k < j``.  If *i* or *j* is greater than "
"``len(s)``, use ``len(s)``.  If *i* is omitted or ``None``, use ``0``.  If "
"*j* is omitted or ``None``, use ``len(s)``.  If *i* is greater than or equal "
"to *j*, the slice is empty."
msgstr ""

#: ../../../library/stdtypes.rst:966
msgid ""
"The slice of *s* from *i* to *j* with step *k* is defined as the sequence of "
"items with index  ``x = i + n*k`` such that ``0 <= n < (j-i)/k``.  In other "
"words, the indices are ``i``, ``i+k``, ``i+2*k``, ``i+3*k`` and so on, "
"stopping when *j* is reached (but never including *j*).  If *i* or *j* is "
"greater than ``len(s)``, use ``len(s)``.  If *i* or *j* are omitted or "
"``None``, they become \"end\" values (which end depends on the sign of "
"*k*).  Note, *k* cannot be zero. If *k* is ``None``, it is treated like "
"``1``."
msgstr ""

#: ../../../library/stdtypes.rst:975
msgid ""
"Concatenating immutable strings always results in a new object.  This means "
"that building up a string by repeated concatenation will have a quadratic "
"runtime cost in the total string length.  To get a linear runtime cost, you "
"must switch to one of the alternatives below:"
msgstr ""

#: ../../../library/stdtypes.rst:980
msgid ""
"if concatenating :class:`str` objects, you can build a list and use :meth:"
"`str.join` at the end;"
msgstr ""

#: ../../../library/stdtypes.rst:983
msgid ""
"if concatenating :class:`bytes` objects, you can similarly use :meth:`bytes."
"join`, or you can do in-place concatenation with a :class:`bytearray` "
"object.  :class:`bytearray` objects are mutable and have an efficient "
"overallocation mechanism."
msgstr ""

#: ../../../library/stdtypes.rst:992
msgid "String Methods"
msgstr ""

#: ../../../library/stdtypes.rst:996
msgid "String objects support the methods listed below."
msgstr ""

#: ../../../library/stdtypes.rst:998
msgid ""
"In addition, Python's strings support the sequence type methods described in "
"the :ref:`typesseq` section. To output formatted strings, see the :ref:"
"`string-formatting` section. Also, see the :mod:`re` module for string "
"functions based on regular expressions."
msgstr ""

#: ../../../library/stdtypes.rst:1005
msgid ""
"Return a copy of the string with its first character capitalized and the "
"rest lowercased."
msgstr ""

#: ../../../library/stdtypes.rst:1011
msgid ""
"Return centered in a string of length *width*. Padding is done using the "
"specified *fillchar* (default is a space)."
msgstr ""

#: ../../../library/stdtypes.rst:1017
msgid ""
"Return the number of non-overlapping occurrences of substring *sub* in the "
"range [*start*, *end*].  Optional arguments *start* and *end* are "
"interpreted as in slice notation."
msgstr ""

#: ../../../library/stdtypes.rst:1024
msgid ""
"Return an encoded version of the string as a bytes object. Default encoding "
"is ``'utf-8'``. *errors* may be given to set a different error handling "
"scheme. The default for *errors* is ``'strict'``, meaning that encoding "
"errors raise a :exc:`UnicodeError`. Other possible values are ``'ignore'``, "
"``'replace'``, ``'xmlcharrefreplace'``, ``'backslashreplace'`` and any other "
"name registered via :func:`codecs.register_error`, see section :ref:`codec-"
"base-classes`. For a list of possible encodings, see section :ref:`standard-"
"encodings`."
msgstr ""

#: ../../../library/stdtypes.rst:1033
msgid "Support for keyword arguments added."
msgstr ""

#: ../../../library/stdtypes.rst:1039
msgid ""
"Return ``True`` if the string ends with the specified *suffix*, otherwise "
"return ``False``.  *suffix* can also be a tuple of suffixes to look for.  "
"With optional *start*, test beginning at that position.  With optional "
"*end*, stop comparing at that position."
msgstr ""

#: ../../../library/stdtypes.rst:1047
msgid ""
"Return a copy of the string where all tab characters are replaced by zero or "
"more spaces, depending on the current column and the given tab size.  The "
"column number is reset to zero after each newline occurring in the string. "
"If *tabsize* is not given, a tab size of ``8`` characters is assumed.  This "
"doesn't understand other non-printing characters or escape sequences."
msgstr ""

#: ../../../library/stdtypes.rst:1056
msgid ""
"Return the lowest index in the string where substring *sub* is found, such "
"that *sub* is contained in the slice ``s[start:end]``.  Optional arguments "
"*start* and *end* are interpreted as in slice notation.  Return ``-1`` if "
"*sub* is not found."
msgstr ""

#: ../../../library/stdtypes.rst:1063
msgid ""
"The :meth:`~str.find` method should be used only if you need to know the "
"position of *sub*.  To check if *sub* is a substring or not, use the :"
"keyword:`in` operator::"
msgstr ""

#: ../../../library/stdtypes.rst:1067
msgid ""
">>> 'Py' in 'Python'\n"
"True"
msgstr ""

#: ../../../library/stdtypes.rst:1073
msgid ""
"Perform a string formatting operation.  The string on which this method is "
"called can contain literal text or replacement fields delimited by braces "
"``{}``.  Each replacement field contains either the numeric index of a "
"positional argument, or the name of a keyword argument.  Returns a copy of "
"the string where each replacement field is replaced with the string value of "
"the corresponding argument."
msgstr ""

#: ../../../library/stdtypes.rst:1083
msgid ""
"See :ref:`formatstrings` for a description of the various formatting options "
"that can be specified in format strings."
msgstr ""

#: ../../../library/stdtypes.rst:1089
msgid ""
"Similar to ``str.format(**mapping)``, except that ``mapping`` is used "
"directly and not copied to a :class:`dict` .  This is useful if for example "
"``mapping`` is a dict subclass:"
msgstr ""

#: ../../../library/stdtypes.rst:1105
msgid ""
"Like :meth:`find`, but raise :exc:`ValueError` when the substring is not "
"found."
msgstr ""

#: ../../../library/stdtypes.rst:1110
msgid ""
"Return true if all characters in the string are alphanumeric and there is at "
"least one character, false otherwise.  A character ``c`` is alphanumeric if "
"one of the following returns ``True``: ``c.isalpha()``, ``c.isdecimal()``, "
"``c.isdigit()``, or ``c.isnumeric()``."
msgstr ""

#: ../../../library/stdtypes.rst:1118
msgid ""
"Return true if all characters in the string are alphabetic and there is at "
"least one character, false otherwise.  Alphabetic characters are those "
"characters defined in the Unicode character database as \"Letter\", i.e., "
"those with general category property being one of \"Lm\", \"Lt\", \"Lu\", "
"\"Ll\", or \"Lo\".  Note that this is different from the \"Alphabetic\" "
"property defined in the Unicode Standard."
msgstr ""

#: ../../../library/stdtypes.rst:1127
msgid ""
"Return true if all characters in the string are decimal characters and there "
"is at least one character, false otherwise. Decimal characters are those "
"from general category \"Nd\". This category includes digit characters, and "
"all characters that can be used to form decimal-radix numbers, e.g. U+0660, "
"ARABIC-INDIC DIGIT ZERO."
msgstr ""

#: ../../../library/stdtypes.rst:1137
msgid ""
"Return true if all characters in the string are digits and there is at least "
"one character, false otherwise.  Digits include decimal characters and "
"digits that need special handling, such as the compatibility superscript "
"digits.  Formally, a digit is a character that has the property value "
"Numeric_Type=Digit or Numeric_Type=Decimal."
msgstr ""

#: ../../../library/stdtypes.rst:1145
msgid ""
"Return true if the string is a valid identifier according to the language "
"definition, section :ref:`identifiers`."
msgstr ""

#: ../../../library/stdtypes.rst:1151
msgid ""
"Return true if all cased characters [4]_ in the string are lowercase and "
"there is at least one cased character, false otherwise."
msgstr ""

#: ../../../library/stdtypes.rst:1157
msgid ""
"Return true if all characters in the string are numeric characters, and "
"there is at least one character, false otherwise. Numeric characters include "
"digit characters, and all characters that have the Unicode numeric value "
"property, e.g. U+2155, VULGAR FRACTION ONE FIFTH.  Formally, numeric "
"characters are those with the property value Numeric_Type=Digit, "
"Numeric_Type=Decimal or Numeric_Type=Numeric."
msgstr ""

#: ../../../library/stdtypes.rst:1167
msgid ""
"Return true if all characters in the string are printable or the string is "
"empty, false otherwise.  Nonprintable characters are those characters "
"defined in the Unicode character database as \"Other\" or \"Separator\", "
"excepting the ASCII space (0x20) which is considered printable.  (Note that "
"printable characters in this context are those which should not be escaped "
"when :func:`repr` is invoked on a string.  It has no bearing on the handling "
"of strings written to :data:`sys.stdout` or :data:`sys.stderr`.)"
msgstr ""

#: ../../../library/stdtypes.rst:1178
msgid ""
"Return true if there are only whitespace characters in the string and there "
"is at least one character, false otherwise.  Whitespace characters  are "
"those characters defined in the Unicode character database as \"Other\" or "
"\"Separator\" and those with bidirectional property being one of \"WS\", "
"\"B\", or \"S\"."
msgstr ""

#: ../../../library/stdtypes.rst:1185
msgid ""
"Return true if the string is a titlecased string and there is at least one "
"character, for example uppercase characters may only follow uncased "
"characters and lowercase characters only cased ones.  Return false otherwise."
msgstr ""

#: ../../../library/stdtypes.rst:1192
msgid ""
"Return true if all cased characters [4]_ in the string are uppercase and "
"there is at least one cased character, false otherwise."
msgstr ""

#: ../../../library/stdtypes.rst:1198
msgid ""
"Return a string which is the concatenation of the strings in the :term:"
"`iterable` *iterable*.  A :exc:`TypeError` will be raised if there are any "
"non-string values in *iterable*, including :class:`bytes` objects.  The "
"separator between elements is the string providing this method."
msgstr ""

#: ../../../library/stdtypes.rst:1206
msgid ""
"Return the string left justified in a string of length *width*. Padding is "
"done using the specified *fillchar* (default is a space).  The original "
"string is returned if *width* is less than or equal to ``len(s)``."
msgstr ""

#: ../../../library/stdtypes.rst:1213
msgid ""
"Return a copy of the string with all the cased characters [4]_ converted to "
"lowercase."
msgstr ""

#: ../../../library/stdtypes.rst:1219
msgid ""
"Return a copy of the string with leading characters removed.  The *chars* "
"argument is a string specifying the set of characters to be removed.  If "
"omitted or ``None``, the *chars* argument defaults to removing whitespace.  "
"The *chars* argument is not a prefix; rather, all combinations of its values "
"are stripped:"
msgstr ""

#: ../../../library/stdtypes.rst:1232
msgid ""
"This static method returns a translation table usable for :meth:`str."
"translate`."
msgstr ""

#: ../../../library/stdtypes.rst:1234
msgid ""
"If there is only one argument, it must be a dictionary mapping Unicode "
"ordinals (integers) or characters (strings of length 1) to Unicode ordinals, "
"strings (of arbitrary lengths) or None.  Character keys will then be "
"converted to ordinals."
msgstr ""

#: ../../../library/stdtypes.rst:1239
msgid ""
"If there are two arguments, they must be strings of equal length, and in the "
"resulting dictionary, each character in x will be mapped to the character at "
"the same position in y.  If there is a third argument, it must be a string, "
"whose characters will be mapped to None in the result."
msgstr ""

#: ../../../library/stdtypes.rst:1247
msgid ""
"Split the string at the first occurrence of *sep*, and return a 3-tuple "
"containing the part before the separator, the separator itself, and the part "
"after the separator.  If the separator is not found, return a 3-tuple "
"containing the string itself, followed by two empty strings."
msgstr ""

#: ../../../library/stdtypes.rst:1255
msgid ""
"Return a copy of the string with all occurrences of substring *old* replaced "
"by *new*.  If the optional argument *count* is given, only the first *count* "
"occurrences are replaced."
msgstr ""

#: ../../../library/stdtypes.rst:1262
msgid ""
"Return the highest index in the string where substring *sub* is found, such "
"that *sub* is contained within ``s[start:end]``.  Optional arguments *start* "
"and *end* are interpreted as in slice notation.  Return ``-1`` on failure."
msgstr ""

#: ../../../library/stdtypes.rst:1269
msgid ""
"Like :meth:`rfind` but raises :exc:`ValueError` when the substring *sub* is "
"not found."
msgstr ""

#: ../../../library/stdtypes.rst:1275
msgid ""
"Return the string right justified in a string of length *width*. Padding is "
"done using the specified *fillchar* (default is a space). The original "
"string is returned if *width* is less than or equal to ``len(s)``."
msgstr ""

#: ../../../library/stdtypes.rst:1282
msgid ""
"Split the string at the last occurrence of *sep*, and return a 3-tuple "
"containing the part before the separator, the separator itself, and the part "
"after the separator.  If the separator is not found, return a 3-tuple "
"containing two empty strings, followed by the string itself."
msgstr ""

#: ../../../library/stdtypes.rst:1290
msgid ""
"Return a list of the words in the string, using *sep* as the delimiter "
"string. If *maxsplit* is given, at most *maxsplit* splits are done, the "
"*rightmost* ones.  If *sep* is not specified or ``None``, any whitespace "
"string is a separator.  Except for splitting from the right, :meth:`rsplit` "
"behaves like :meth:`split` which is described in detail below."
msgstr ""

#: ../../../library/stdtypes.rst:1299
msgid ""
"Return a copy of the string with trailing characters removed.  The *chars* "
"argument is a string specifying the set of characters to be removed.  If "
"omitted or ``None``, the *chars* argument defaults to removing whitespace.  "
"The *chars* argument is not a suffix; rather, all combinations of its values "
"are stripped:"
msgstr ""

#: ../../../library/stdtypes.rst:1312
msgid ""
"Return a list of the words in the string, using *sep* as the delimiter "
"string.  If *maxsplit* is given, at most *maxsplit* splits are done (thus, "
"the list will have at most ``maxsplit+1`` elements).  If *maxsplit* is not "
"specified or ``-1``, then there is no limit on the number of splits (all "
"possible splits are made)."
msgstr ""

#: ../../../library/stdtypes.rst:1318
msgid ""
"If *sep* is given, consecutive delimiters are not grouped together and are "
"deemed to delimit empty strings (for example, ``'1,,2'.split(',')`` returns "
"``['1', '', '2']``).  The *sep* argument may consist of multiple characters "
"(for example, ``'1<>2<>3'.split('<>')`` returns ``['1', '2', '3']``). "
"Splitting an empty string with a specified separator returns ``['']``."
msgstr ""

#: ../../../library/stdtypes.rst:1324
msgid ""
"If *sep* is not specified or is ``None``, a different splitting algorithm is "
"applied: runs of consecutive whitespace are regarded as a single separator, "
"and the result will contain no empty strings at the start or end if the "
"string has leading or trailing whitespace.  Consequently, splitting an empty "
"string or a string consisting of just whitespace with a ``None`` separator "
"returns ``[]``."
msgstr ""

#: ../../../library/stdtypes.rst:1331
msgid ""
"For example, ``' 1  2   3  '.split()`` returns ``['1', '2', '3']``, and ``'  "
"1  2   3  '.split(None, 1)`` returns ``['1', '2   3  ']``."
msgstr ""

#: ../../../library/stdtypes.rst:1340
msgid ""
"Return a list of the lines in the string, breaking at line boundaries. This "
"method uses the :term:`universal newlines` approach to splitting lines. Line "
"breaks are not included in the resulting list unless *keepends* is given and "
"true."
msgstr ""

#: ../../../library/stdtypes.rst:1345
msgid ""
"For example, ``'ab c\\n\\nde fg\\rkl\\r\\n'.splitlines()`` returns ``['ab "
"c', '', 'de fg', 'kl']``, while the same call with ``splitlines(True)`` "
"returns ``['ab c\\n', '\\n', 'de fg\\r', 'kl\\r\\n']``."
msgstr ""

#: ../../../library/stdtypes.rst:1349
msgid ""
"Unlike :meth:`~str.split` when a delimiter string *sep* is given, this "
"method returns an empty list for the empty string, and a terminal line break "
"does not result in an extra line."
msgstr ""

#: ../../../library/stdtypes.rst:1356
msgid ""
"Return ``True`` if string starts with the *prefix*, otherwise return "
"``False``. *prefix* can also be a tuple of prefixes to look for.  With "
"optional *start*, test string beginning at that position.  With optional "
"*end*, stop comparing string at that position."
msgstr ""

#: ../../../library/stdtypes.rst:1364
msgid ""
"Return a copy of the string with the leading and trailing characters "
"removed. The *chars* argument is a string specifying the set of characters "
"to be removed. If omitted or ``None``, the *chars* argument defaults to "
"removing whitespace. The *chars* argument is not a prefix or suffix; rather, "
"all combinations of its values are stripped:"
msgstr ""

#: ../../../library/stdtypes.rst:1378
msgid ""
"Return a copy of the string with uppercase characters converted to lowercase "
"and vice versa."
msgstr ""

#: ../../../library/stdtypes.rst:1384
msgid ""
"Return a titlecased version of the string where words start with an "
"uppercase character and the remaining characters are lowercase."
msgstr ""

#: ../../../library/stdtypes.rst:1387
msgid ""
"The algorithm uses a simple language-independent definition of a word as "
"groups of consecutive letters.  The definition works in many contexts but it "
"means that apostrophes in contractions and possessives form word boundaries, "
"which may not be the desired result::"
msgstr ""

#: ../../../library/stdtypes.rst:1392
msgid ""
">>> \"they're bill's friends from the UK\".title()\n"
"\"They'Re Bill'S Friends From The Uk\""
msgstr ""

#: ../../../library/stdtypes.rst:1395
msgid ""
"A workaround for apostrophes can be constructed using regular expressions::"
msgstr ""

#: ../../../library/stdtypes.rst:1397
msgid ""
">>> import re\n"
">>> def titlecase(s):\n"
"...     return re.sub(r\"[A-Za-z]+('[A-Za-z]+)?\",\n"
"...                   lambda mo: mo.group(0)[0].upper() +\n"
"...                              mo.group(0)[1:].lower(),\n"
"...                   s)\n"
"...\n"
">>> titlecase(\"they're bill's friends.\")\n"
"\"They're Bill's Friends.\""
msgstr ""

#: ../../../library/stdtypes.rst:1410
msgid ""
"Return a copy of the *s* where all characters have been mapped through the "
"*map* which must be a dictionary of Unicode ordinals (integers) to Unicode "
"ordinals, strings or ``None``.  Unmapped characters are left untouched. "
"Characters mapped to ``None`` are deleted."
msgstr ""

#: ../../../library/stdtypes.rst:1415
msgid ""
"You can use :meth:`str.maketrans` to create a translation map from character-"
"to-character mappings in different formats."
msgstr ""

#: ../../../library/stdtypes.rst:1420
msgid ""
"An even more flexible approach is to create a custom character mapping codec "
"using the :mod:`codecs` module (see :mod:`encodings.cp1251` for an example)."
msgstr ""

#: ../../../library/stdtypes.rst:1427
msgid ""
"Return a copy of the string with all the cased characters [4]_ converted to "
"uppercase.  Note that ``str.upper().isupper()`` might be ``False`` if ``s`` "
"contains uncased characters or if the Unicode category of the resulting "
"character(s) is not \"Lu\" (Letter, uppercase), but e.g. \"Lt\" (Letter, "
"titlecase)."
msgstr ""

#: ../../../library/stdtypes.rst:1435
msgid ""
"Return the numeric string left filled with zeros in a string of length "
"*width*.  A sign prefix is handled correctly.  The original string is "
"returned if *width* is less than or equal to ``len(s)``."
msgstr ""

#: ../../../library/stdtypes.rst:1444
msgid "Old String Formatting Operations"
msgstr ""

#: ../../../library/stdtypes.rst:1460
msgid ""
"The formatting operations described here are modelled on C's printf() "
"syntax.  They only support formatting of certain builtin types.  The use of "
"a binary operator means that care may be needed in order to format tuples "
"and dictionaries correctly.  As the new :ref:`string-formatting` syntax is "
"more flexible and handles tuples and dictionaries naturally, it is "
"recommended for new code.  However, there are no current plans to deprecate "
"printf-style formatting."
msgstr ""

#: ../../../library/stdtypes.rst:1468
msgid ""
"String objects have one unique built-in operation: the ``%`` operator "
"(modulo). This is also known as the string *formatting* or *interpolation* "
"operator. Given ``format % values`` (where *format* is a string), ``%`` "
"conversion specifications in *format* are replaced with zero or more "
"elements of *values*. The effect is similar to the using :c:func:`sprintf` "
"in the C language."
msgstr ""

#: ../../../library/stdtypes.rst:1474
msgid ""
"If *format* requires a single argument, *values* may be a single non-tuple "
"object. [5]_  Otherwise, *values* must be a tuple with exactly the number of "
"items specified by the format string, or a single mapping object (for "
"example, a dictionary)."
msgstr ""

#: ../../../library/stdtypes.rst:1479
msgid ""
"A conversion specifier contains two or more characters and has the following "
"components, which must occur in this order:"
msgstr ""

#: ../../../library/stdtypes.rst:1482
msgid "The ``'%'`` character, which marks the start of the specifier."
msgstr ""

#: ../../../library/stdtypes.rst:1484
msgid ""
"Mapping key (optional), consisting of a parenthesised sequence of characters "
"(for example, ``(somename)``)."
msgstr ""

#: ../../../library/stdtypes.rst:1487
msgid ""
"Conversion flags (optional), which affect the result of some conversion "
"types."
msgstr ""

#: ../../../library/stdtypes.rst:1490
msgid ""
"Minimum field width (optional).  If specified as an ``'*'`` (asterisk), the "
"actual width is read from the next element of the tuple in *values*, and the "
"object to convert comes after the minimum field width and optional precision."
msgstr ""

#: ../../../library/stdtypes.rst:1494
msgid ""
"Precision (optional), given as a ``'.'`` (dot) followed by the precision.  "
"If specified as ``'*'`` (an asterisk), the actual precision is read from the "
"next element of the tuple in *values*, and the value to convert comes after "
"the precision."
msgstr ""

#: ../../../library/stdtypes.rst:1499
msgid "Length modifier (optional)."
msgstr ""

#: ../../../library/stdtypes.rst:1501
msgid "Conversion type."
msgstr ""

#: ../../../library/stdtypes.rst:1503
msgid ""
"When the right argument is a dictionary (or other mapping type), then the "
"formats in the string *must* include a parenthesised mapping key into that "
"dictionary inserted immediately after the ``'%'`` character. The mapping key "
"selects the value to be formatted from the mapping.  For example:"
msgstr ""

#: ../../../library/stdtypes.rst:1512
msgid ""
"In this case no ``*`` specifiers may occur in a format (since they require a "
"sequential parameter list)."
msgstr ""

#: ../../../library/stdtypes.rst:1515
msgid "The conversion flag characters are:"
msgstr ""

#: ../../../library/stdtypes.rst:1518
msgid "Flag"
msgstr ""

#: ../../../library/stdtypes.rst:1520
msgid "``'#'``"
msgstr ""

#: ../../../library/stdtypes.rst:1520
msgid ""
"The value conversion will use the \"alternate form\" (where defined below)."
msgstr ""

#: ../../../library/stdtypes.rst:1523
msgid "``'0'``"
msgstr ""

#: ../../../library/stdtypes.rst:1523
msgid "The conversion will be zero padded for numeric values."
msgstr ""

#: ../../../library/stdtypes.rst:1525
msgid "``'-'``"
msgstr ""

#: ../../../library/stdtypes.rst:1525
msgid ""
"The converted value is left adjusted (overrides the ``'0'`` conversion if "
"both are given)."
msgstr ""

#: ../../../library/stdtypes.rst:1528
msgid "``' '``"
msgstr ""

#: ../../../library/stdtypes.rst:1528
msgid ""
"(a space) A blank should be left before a positive number (or empty string) "
"produced by a signed conversion."
msgstr ""

#: ../../../library/stdtypes.rst:1531
msgid "``'+'``"
msgstr ""

#: ../../../library/stdtypes.rst:1531
msgid ""
"A sign character (``'+'`` or ``'-'``) will precede the conversion (overrides "
"a \"space\" flag)."
msgstr ""

#: ../../../library/stdtypes.rst:1535
msgid ""
"A length modifier (``h``, ``l``, or ``L``) may be present, but is ignored as "
"it is not necessary for Python -- so e.g. ``%ld`` is identical to ``%d``."
msgstr ""

#: ../../../library/stdtypes.rst:1538
msgid "The conversion types are:"
msgstr ""

#: ../../../library/stdtypes.rst:1541
msgid "Conversion"
msgstr ""

#: ../../../library/stdtypes.rst:1543
msgid "``'d'``"
msgstr ""

#: ../../../library/stdtypes.rst:1543 ../../../library/stdtypes.rst:1545
msgid "Signed integer decimal."
msgstr ""

#: ../../../library/stdtypes.rst:1545
msgid "``'i'``"
msgstr ""

#: ../../../library/stdtypes.rst:1547
msgid "``'o'``"
msgstr ""

#: ../../../library/stdtypes.rst:1547
msgid "Signed octal value."
msgstr ""

#: ../../../library/stdtypes.rst:1549
msgid "``'u'``"
msgstr ""

#: ../../../library/stdtypes.rst:1549
msgid "Obsolete type -- it is identical to ``'d'``."
msgstr ""

#: ../../../library/stdtypes.rst:1549
msgid "\\(7)"
msgstr ""

#: ../../../library/stdtypes.rst:1551
msgid "``'x'``"
msgstr ""

#: ../../../library/stdtypes.rst:1551
msgid "Signed hexadecimal (lowercase)."
msgstr ""

#: ../../../library/stdtypes.rst:1553
msgid "``'X'``"
msgstr ""

#: ../../../library/stdtypes.rst:1553
msgid "Signed hexadecimal (uppercase)."
msgstr ""

#: ../../../library/stdtypes.rst:1555
msgid "``'e'``"
msgstr ""

#: ../../../library/stdtypes.rst:1555
msgid "Floating point exponential format (lowercase)."
msgstr ""

#: ../../../library/stdtypes.rst:1557
msgid "``'E'``"
msgstr ""

#: ../../../library/stdtypes.rst:1557
msgid "Floating point exponential format (uppercase)."
msgstr ""

#: ../../../library/stdtypes.rst:1559
msgid "``'f'``"
msgstr ""

#: ../../../library/stdtypes.rst:1559 ../../../library/stdtypes.rst:1561
msgid "Floating point decimal format."
msgstr ""

#: ../../../library/stdtypes.rst:1561
msgid "``'F'``"
msgstr ""

#: ../../../library/stdtypes.rst:1563
msgid "``'g'``"
msgstr ""

#: ../../../library/stdtypes.rst:1563
msgid ""
"Floating point format. Uses lowercase exponential format if exponent is less "
"than -4 or not less than precision, decimal format otherwise."
msgstr ""

#: ../../../library/stdtypes.rst:1563 ../../../library/stdtypes.rst:1567
#: ../../../library/stdtypes.rst:1733
msgid "\\(4)"
msgstr ""

#: ../../../library/stdtypes.rst:1567
msgid "``'G'``"
msgstr ""

#: ../../../library/stdtypes.rst:1567
msgid ""
"Floating point format. Uses uppercase exponential format if exponent is less "
"than -4 or not less than precision, decimal format otherwise."
msgstr ""

#: ../../../library/stdtypes.rst:1571
msgid "``'c'``"
msgstr ""

#: ../../../library/stdtypes.rst:1571
msgid "Single character (accepts integer or single character string)."
msgstr ""

#: ../../../library/stdtypes.rst:1574
msgid "``'r'``"
msgstr ""

#: ../../../library/stdtypes.rst:1574
msgid "String (converts any Python object using :func:`repr`)."
msgstr ""

#: ../../../library/stdtypes.rst:1577
msgid "``'s'``"
msgstr ""

#: ../../../library/stdtypes.rst:1577
msgid "String (converts any Python object using :func:`str`)."
msgstr ""

#: ../../../library/stdtypes.rst:1580
msgid "``'a'``"
msgstr ""

#: ../../../library/stdtypes.rst:1580
msgid "String (converts any Python object using :func:`ascii`)."
msgstr ""

#: ../../../library/stdtypes.rst:1583
msgid "``'%'``"
msgstr ""

#: ../../../library/stdtypes.rst:1583
msgid "No argument is converted, results in a ``'%'`` character in the result."
msgstr ""

#: ../../../library/stdtypes.rst:1590
msgid ""
"The alternate form causes a leading zero (``'0'``) to be inserted between "
"left-hand padding and the formatting of the number if the leading character "
"of the result is not already a zero."
msgstr ""

#: ../../../library/stdtypes.rst:1595
msgid ""
"The alternate form causes a leading ``'0x'`` or ``'0X'`` (depending on "
"whether the ``'x'`` or ``'X'`` format was used) to be inserted between left-"
"hand padding and the formatting of the number if the leading character of "
"the result is not already a zero."
msgstr ""

#: ../../../library/stdtypes.rst:1601
msgid ""
"The alternate form causes the result to always contain a decimal point, even "
"if no digits follow it."
msgstr ""

#: ../../../library/stdtypes.rst:1604
msgid ""
"The precision determines the number of digits after the decimal point and "
"defaults to 6."
msgstr ""

#: ../../../library/stdtypes.rst:1608
msgid ""
"The alternate form causes the result to always contain a decimal point, and "
"trailing zeroes are not removed as they would otherwise be."
msgstr ""

#: ../../../library/stdtypes.rst:1611
msgid ""
"The precision determines the number of significant digits before and after "
"the decimal point and defaults to 6."
msgstr ""

#: ../../../library/stdtypes.rst:1615
msgid "If precision is ``N``, the output is truncated to ``N`` characters."
msgstr ""

#: ../../../library/stdtypes.rst:1619
msgid "See :pep:`237`."
msgstr ""

#: ../../../library/stdtypes.rst:1621
msgid ""
"Since Python strings have an explicit length, ``%s`` conversions do not "
"assume that ``'\\0'`` is the end of the string."
msgstr ""

#: ../../../library/stdtypes.rst:1626
msgid ""
"``%f`` conversions for numbers whose absolute value is over 1e50 are no "
"longer replaced by ``%g`` conversions."
msgstr ""

#: ../../../library/stdtypes.rst:1634
msgid ""
"Additional string operations are defined in standard modules :mod:`string` "
"and :mod:`re`."
msgstr ""

#: ../../../library/stdtypes.rst:1641
msgid "Range Type"
msgstr ""

#: ../../../library/stdtypes.rst:1645
msgid ""
"The :class:`range` type is an immutable sequence which is commonly used for "
"looping.  The advantage of the :class:`range` type is that an :class:`range` "
"object will always take the same amount of memory, no matter the size of the "
"range it represents."
msgstr ""

#: ../../../library/stdtypes.rst:1650
msgid ""
"Range objects have relatively little behavior: they support indexing, "
"contains, iteration, the :func:`len` function, and the following methods:"
msgstr ""

#: ../../../library/stdtypes.rst:1655
msgid "Return the number of *i*'s for which ``s[i] == x``."
msgstr ""

#: ../../../library/stdtypes.rst:1661
msgid ""
"Return the smallest *i* such that ``s[i] == x``.  Raises :exc:`ValueError` "
"when *x* is not in the range."
msgstr ""

#: ../../../library/stdtypes.rst:1669
msgid "Mutable Sequence Types"
msgstr ""

#: ../../../library/stdtypes.rst:1676
msgid ""
"List and bytearray objects support additional operations that allow in-place "
"modification of the object.  Other mutable sequence types (when added to the "
"language) should also support these operations.  Strings and tuples are "
"immutable sequence types: such objects cannot be modified once created. The "
"following operations are defined on mutable sequence types (where *x* is an "
"arbitrary object)."
msgstr ""

#: ../../../library/stdtypes.rst:1683
msgid ""
"Note that while lists allow their items to be of any type, bytearray object "
"\"items\" are all integers in the range 0 <= x < 256."
msgstr ""

#: ../../../library/stdtypes.rst:1705
msgid "``s[i] = x``"
msgstr ""

#: ../../../library/stdtypes.rst:1705
msgid "item *i* of *s* is replaced by *x*"
msgstr ""

#: ../../../library/stdtypes.rst:1708
msgid "``s[i:j] = t``"
msgstr ""

#: ../../../library/stdtypes.rst:1708
msgid ""
"slice of *s* from *i* to *j* is replaced by the contents of the iterable *t*"
msgstr ""

#: ../../../library/stdtypes.rst:1712
msgid "``del s[i:j]``"
msgstr ""

#: ../../../library/stdtypes.rst:1712
msgid "same as ``s[i:j] = []``"
msgstr ""

#: ../../../library/stdtypes.rst:1714
msgid "``s[i:j:k] = t``"
msgstr ""

#: ../../../library/stdtypes.rst:1714
msgid "the elements of ``s[i:j:k]`` are replaced by those of *t*"
msgstr ""

#: ../../../library/stdtypes.rst:1717
msgid "``del s[i:j:k]``"
msgstr ""

#: ../../../library/stdtypes.rst:1717
msgid "removes the elements of ``s[i:j:k]`` from the list"
msgstr ""

#: ../../../library/stdtypes.rst:1720
msgid "``s.append(x)``"
msgstr ""

#: ../../../library/stdtypes.rst:1720
msgid "same as ``s[len(s):len(s)] = [x]``"
msgstr ""

#: ../../../library/stdtypes.rst:1723
msgid "``s.extend(x)``"
msgstr ""

#: ../../../library/stdtypes.rst:1723
msgid "same as ``s[len(s):len(s)] = x``"
msgstr ""

#: ../../../library/stdtypes.rst:1726
msgid "``s.count(x)``"
msgstr ""

#: ../../../library/stdtypes.rst:1726
msgid "return number of *i*'s for which ``s[i] == x``"
msgstr ""

#: ../../../library/stdtypes.rst:1729
msgid "``s.index(x[, i[, j]])``"
msgstr ""

#: ../../../library/stdtypes.rst:1729
msgid "return smallest *k* such that ``s[k] == x`` and ``i <= k < j``"
msgstr ""

#: ../../../library/stdtypes.rst:1733
msgid "``s.insert(i, x)``"
msgstr ""

#: ../../../library/stdtypes.rst:1733
msgid "same as ``s[i:i] = [x]``"
msgstr ""

#: ../../../library/stdtypes.rst:1735
msgid "``s.pop([i])``"
msgstr ""

#: ../../../library/stdtypes.rst:1735
msgid "same as ``x = s[i]; del s[i]; return x``"
msgstr ""

#: ../../../library/stdtypes.rst:1738
msgid "``s.remove(x)``"
msgstr ""

#: ../../../library/stdtypes.rst:1738
msgid "same as ``del s[s.index(x)]``"
msgstr ""

#: ../../../library/stdtypes.rst:1740
msgid "``s.reverse()``"
msgstr ""

#: ../../../library/stdtypes.rst:1740
msgid "reverses the items of *s* in place"
msgstr ""

#: ../../../library/stdtypes.rst:1743
msgid "``s.sort([key[, reverse]])``"
msgstr ""

#: ../../../library/stdtypes.rst:1743
msgid "sort the items of *s* in place"
msgstr ""

#: ../../../library/stdtypes.rst:1743
msgid "(6), (7), (8)"
msgstr ""

#: ../../../library/stdtypes.rst:1750
msgid "*t* must have the same length as the slice it is replacing."
msgstr ""

#: ../../../library/stdtypes.rst:1753
msgid "*x* can be any iterable object."
msgstr ""

#: ../../../library/stdtypes.rst:1756
msgid ""
"Raises :exc:`ValueError` when *x* is not found in *s*. When a negative index "
"is passed as the second or third parameter to the :meth:`index` method, the "
"sequence length is added, as for slice indices.  If it is still negative, it "
"is truncated to zero, as for slice indices."
msgstr ""

#: ../../../library/stdtypes.rst:1762
msgid ""
"When a negative index is passed as the first parameter to the :meth:`insert` "
"method, the sequence length is added, as for slice indices.  If it is still "
"negative, it is truncated to zero, as for slice indices."
msgstr ""

#: ../../../library/stdtypes.rst:1767
msgid ""
"The optional argument *i* defaults to ``-1``, so that by default the last "
"item is removed and returned."
msgstr ""

#: ../../../library/stdtypes.rst:1771
msgid ""
"The :meth:`sort` and :meth:`reverse` methods modify the sequence in place "
"for economy of space when sorting or reversing a large sequence.  To remind "
"you that they operate by side effect, they don't return the sorted or "
"reversed sequence."
msgstr ""

#: ../../../library/stdtypes.rst:1777
msgid ""
"The :meth:`sort` method takes optional arguments for controlling the "
"comparisons.  Each must be specified as a keyword argument."
msgstr ""

#: ../../../library/stdtypes.rst:1780
msgid ""
"*key* specifies a function of one argument that is used to extract a "
"comparison key from each list element: ``key=str.lower``.  The default value "
"is ``None``. Use :func:`functools.cmp_to_key` to convert an old-style *cmp* "
"function to a *key* function."
msgstr ""

#: ../../../library/stdtypes.rst:1786
msgid ""
"*reverse* is a boolean value.  If set to ``True``, then the list elements "
"are sorted as if each comparison were reversed."
msgstr ""

#: ../../../library/stdtypes.rst:1789
msgid ""
"The :meth:`sort` method is guaranteed to be stable.  A sort is stable if it "
"guarantees not to change the relative order of elements that compare equal "
"--- this is helpful for sorting in multiple passes (for example, sort by "
"department, then by salary grade)."
msgstr ""

#: ../../../library/stdtypes.rst:1796
msgid ""
"While a list is being sorted, the effect of attempting to mutate, or even "
"inspect, the list is undefined.  The C implementation of Python makes the "
"list appear empty for the duration, and raises :exc:`ValueError` if it can "
"detect that the list has been mutated during a sort."
msgstr ""

#: ../../../library/stdtypes.rst:1802
msgid ":meth:`sort` is not supported by :class:`bytearray` objects."
msgstr ""

#: ../../../library/stdtypes.rst:1808
msgid "Bytes and Byte Array Methods"
msgstr ""

#: ../../../library/stdtypes.rst:1813
msgid ""
"Bytes and bytearray objects, being \"strings of bytes\", have all methods "
"found on strings, with the exception of :func:`encode`, :func:`format` and :"
"func:`isidentifier`, which do not make sense with these types.  For "
"converting the objects to strings, they have a :func:`decode` method."
msgstr ""

#: ../../../library/stdtypes.rst:1818
msgid ""
"Wherever one of these methods needs to interpret the bytes as characters (e."
"g. the :func:`is...` methods), the ASCII character set is assumed."
msgstr ""

#: ../../../library/stdtypes.rst:1823
msgid ""
"The methods on bytes and bytearray objects don't accept strings as their "
"arguments, just as the methods on strings don't accept bytes as their "
"arguments.  For example, you have to write ::"
msgstr ""

#: ../../../library/stdtypes.rst:1827
msgid ""
"a = \"abc\"\n"
"b = a.replace(\"a\", \"f\")"
msgstr ""

#: ../../../library/stdtypes.rst:1830
msgid "and ::"
msgstr ""

#: ../../../library/stdtypes.rst:1832
msgid ""
"a = b\"abc\"\n"
"b = a.replace(b\"a\", b\"f\")"
msgstr ""

#: ../../../library/stdtypes.rst:1839
msgid ""
"Return a string decoded from the given bytes.  Default encoding is "
"``'utf-8'``. *errors* may be given to set a different error handling "
"scheme.  The default for *errors* is ``'strict'``, meaning that encoding "
"errors raise a :exc:`UnicodeError`.  Other possible values are ``'ignore'``, "
"``'replace'`` and any other name registered via :func:`codecs."
"register_error`, see section :ref:`codec-base-classes`. For a list of "
"possible encodings, see section :ref:`standard-encodings`."
msgstr ""

#: ../../../library/stdtypes.rst:1847
msgid "Added support for keyword arguments."
msgstr ""

#: ../../../library/stdtypes.rst:1851
msgid "The bytes and bytearray types have an additional class method:"
msgstr ""

#: ../../../library/stdtypes.rst:1856
msgid ""
"This :class:`bytes` class method returns a bytes or bytearray object, "
"decoding the given string object.  The string must contain two hexadecimal "
"digits per byte, spaces are ignored."
msgstr ""

#: ../../../library/stdtypes.rst:1864
msgid ""
"The maketrans and translate methods differ in semantics from the versions "
"available on strings:"
msgstr ""

#: ../../../library/stdtypes.rst:1870
msgid ""
"Return a copy of the bytes or bytearray object where all bytes occurring in "
"the optional argument *delete* are removed, and the remaining bytes have "
"been mapped through the given translation table, which must be a bytes "
"object of length 256."
msgstr ""

#: ../../../library/stdtypes.rst:1875
msgid ""
"You can use the :func:`bytes.maketrans` method to create a translation table."
msgstr ""

#: ../../../library/stdtypes.rst:1877
msgid ""
"Set the *table* argument to ``None`` for translations that only delete "
"characters::"
msgstr ""

#: ../../../library/stdtypes.rst:1880
msgid ""
">>> b'read this short text'.translate(None, b'aeiou')\n"
"b'rd ths shrt txt'"
msgstr ""

#: ../../../library/stdtypes.rst:1887
msgid ""
"This static method returns a translation table usable for :meth:`bytes."
"translate` that will map each character in *from* into the character at the "
"same position in *to*; *from* and *to* must be bytes objects and have the "
"same length."
msgstr ""

#: ../../../library/stdtypes.rst:1898
msgid "Set Types --- :class:`set`, :class:`frozenset`"
msgstr ""

#: ../../../library/stdtypes.rst:1902
msgid ""
"A :dfn:`set` object is an unordered collection of distinct :term:`hashable` "
"objects. Common uses include membership testing, removing duplicates from a "
"sequence, and computing mathematical operations such as intersection, union, "
"difference, and symmetric difference. (For other containers see the built "
"in :class:`dict`, :class:`list`, and :class:`tuple` classes, and the :mod:"
"`collections` module.)"
msgstr ""

#: ../../../library/stdtypes.rst:1909
msgid ""
"Like other collections, sets support ``x in set``, ``len(set)``, and ``for x "
"in set``.  Being an unordered collection, sets do not record element "
"position or order of insertion.  Accordingly, sets do not support indexing, "
"slicing, or other sequence-like behavior."
msgstr ""

#: ../../../library/stdtypes.rst:1914
msgid ""
"There are currently two built-in set types, :class:`set` and :class:"
"`frozenset`. The :class:`set` type is mutable --- the contents can be "
"changed using methods like :meth:`add` and :meth:`remove`.  Since it is "
"mutable, it has no hash value and cannot be used as either a dictionary key "
"or as an element of another set. The :class:`frozenset` type is immutable "
"and :term:`hashable` --- its contents cannot be altered after it is created; "
"it can therefore be used as a dictionary key or as an element of another set."
msgstr ""

#: ../../../library/stdtypes.rst:1922
msgid ""
"Non-empty sets (not frozensets) can be created by placing a comma-separated "
"list of elements within braces, for example: ``{'jack', 'sjoerd'}``, in "
"addition to the :class:`set` constructor."
msgstr ""

#: ../../../library/stdtypes.rst:1926
msgid "The constructors for both classes work the same:"
msgstr ""

#: ../../../library/stdtypes.rst:1931
msgid ""
"Return a new set or frozenset object whose elements are taken from "
"*iterable*.  The elements of a set must be hashable.  To represent sets of "
"sets, the inner sets must be :class:`frozenset` objects.  If *iterable* is "
"not specified, a new empty set is returned."
msgstr ""

#: ../../../library/stdtypes.rst:1936
msgid ""
"Instances of :class:`set` and :class:`frozenset` provide the following "
"operations:"
msgstr ""

#: ../../../library/stdtypes.rst:1941
msgid "Return the cardinality of set *s*."
msgstr ""

#: ../../../library/stdtypes.rst:1945
msgid "Test *x* for membership in *s*."
msgstr ""

#: ../../../library/stdtypes.rst:1949
msgid "Test *x* for non-membership in *s*."
msgstr ""

#: ../../../library/stdtypes.rst:1953
msgid ""
"Return True if the set has no elements in common with *other*.  Sets are "
"disjoint if and only if their intersection is the empty set."
msgstr ""

#: ../../../library/stdtypes.rst:1959
msgid "Test whether every element in the set is in *other*."
msgstr ""

#: ../../../library/stdtypes.rst:1963
msgid ""
"Test whether the set is a proper subset of *other*, that is, ``set <= other "
"and set != other``."
msgstr ""

#: ../../../library/stdtypes.rst:1969
msgid "Test whether every element in *other* is in the set."
msgstr ""

#: ../../../library/stdtypes.rst:1973
msgid ""
"Test whether the set is a proper superset of *other*, that is, ``set >= "
"other and set != other``."
msgstr ""

#: ../../../library/stdtypes.rst:1979
msgid "Return a new set with elements from the set and all others."
msgstr ""

#: ../../../library/stdtypes.rst:1984
msgid "Return a new set with elements common to the set and all others."
msgstr ""

#: ../../../library/stdtypes.rst:1989
msgid "Return a new set with elements in the set that are not in the others."
msgstr ""

#: ../../../library/stdtypes.rst:1994
msgid ""
"Return a new set with elements in either the set or *other* but not both."
msgstr ""

#: ../../../library/stdtypes.rst:1998
msgid "Return a new set with a shallow copy of *s*."
msgstr ""

#: ../../../library/stdtypes.rst:2001
msgid ""
"Note, the non-operator versions of :meth:`union`, :meth:`intersection`, :"
"meth:`difference`, and :meth:`symmetric_difference`, :meth:`issubset`, and :"
"meth:`issuperset` methods will accept any iterable as an argument.  In "
"contrast, their operator based counterparts require their arguments to be "
"sets.  This precludes error-prone constructions like ``set('abc') & 'cbs'`` "
"in favor of the more readable ``set('abc').intersection('cbs')``."
msgstr ""

#: ../../../library/stdtypes.rst:2008
msgid ""
"Both :class:`set` and :class:`frozenset` support set to set comparisons. Two "
"sets are equal if and only if every element of each set is contained in the "
"other (each is a subset of the other). A set is less than another set if and "
"only if the first set is a proper subset of the second set (is a subset, but "
"is not equal). A set is greater than another set if and only if the first "
"set is a proper superset of the second set (is a superset, but is not equal)."
msgstr ""

#: ../../../library/stdtypes.rst:2015
msgid ""
"Instances of :class:`set` are compared to instances of :class:`frozenset` "
"based on their members.  For example, ``set('abc') == frozenset('abc')`` "
"returns ``True`` and so does ``set('abc') in set([frozenset('abc')])``."
msgstr ""

#: ../../../library/stdtypes.rst:2019
msgid ""
"The subset and equality comparisons do not generalize to a complete ordering "
"function.  For example, any two disjoint sets are not equal and are not "
"subsets of each other, so *all* of the following return ``False``: ``a<b``, "
"``a==b``, or ``a>b``."
msgstr ""

#: ../../../library/stdtypes.rst:2024
msgid ""
"Since sets only define partial ordering (subset relationships), the output "
"of the :meth:`list.sort` method is undefined for lists of sets."
msgstr ""

#: ../../../library/stdtypes.rst:2027
msgid "Set elements, like dictionary keys, must be :term:`hashable`."
msgstr ""

#: ../../../library/stdtypes.rst:2029
msgid ""
"Binary operations that mix :class:`set` instances with :class:`frozenset` "
"return the type of the first operand.  For example: ``frozenset('ab') | "
"set('bc')`` returns an instance of :class:`frozenset`."
msgstr ""

#: ../../../library/stdtypes.rst:2033
msgid ""
"The following table lists operations available for :class:`set` that do not "
"apply to immutable instances of :class:`frozenset`:"
msgstr ""

#: ../../../library/stdtypes.rst:2039
msgid "Update the set, adding elements from all others."
msgstr ""

#: ../../../library/stdtypes.rst:2044
msgid "Update the set, keeping only elements found in it and all others."
msgstr ""

#: ../../../library/stdtypes.rst:2049
msgid "Update the set, removing elements found in others."
msgstr ""

#: ../../../library/stdtypes.rst:2054
msgid ""
"Update the set, keeping only elements found in either set, but not in both."
msgstr ""

#: ../../../library/stdtypes.rst:2058
msgid "Add element *elem* to the set."
msgstr ""

#: ../../../library/stdtypes.rst:2062
msgid ""
"Remove element *elem* from the set.  Raises :exc:`KeyError` if *elem* is not "
"contained in the set."
msgstr ""

#: ../../../library/stdtypes.rst:2067
msgid "Remove element *elem* from the set if it is present."
msgstr ""

#: ../../../library/stdtypes.rst:2071
msgid ""
"Remove and return an arbitrary element from the set.  Raises :exc:`KeyError` "
"if the set is empty."
msgstr ""

#: ../../../library/stdtypes.rst:2076
msgid "Remove all elements from the set."
msgstr ""

#: ../../../library/stdtypes.rst:2079
msgid ""
"Note, the non-operator versions of the :meth:`update`, :meth:"
"`intersection_update`, :meth:`difference_update`, and :meth:"
"`symmetric_difference_update` methods will accept any iterable as an "
"argument."
msgstr ""

#: ../../../library/stdtypes.rst:2084
msgid ""
"Note, the *elem* argument to the :meth:`__contains__`, :meth:`remove`, and :"
"meth:`discard` methods may be a set.  To support searching for an equivalent "
"frozenset, the *elem* set is temporarily mutated during the search and then "
"restored.  During the search, the *elem* set should not be read or mutated "
"since it does not have a meaningful value."
msgstr ""

#: ../../../library/stdtypes.rst:2094
msgid "Mapping Types --- :class:`dict`"
msgstr ""

#: ../../../library/stdtypes.rst:2104
msgid ""
"A :term:`mapping` object maps :term:`hashable` values to arbitrary objects. "
"Mappings are mutable objects.  There is currently only one standard mapping "
"type, the :dfn:`dictionary`.  (For other containers see the built in :class:"
"`list`, :class:`set`, and :class:`tuple` classes, and the :mod:`collections` "
"module.)"
msgstr ""

#: ../../../library/stdtypes.rst:2110
msgid ""
"A dictionary's keys are *almost* arbitrary values.  Values that are not :"
"term:`hashable`, that is, values containing lists, dictionaries or other "
"mutable types (that are compared by value rather than by object identity) "
"may not be used as keys.  Numeric types used for keys obey the normal rules "
"for numeric comparison: if two numbers compare equal (such as ``1`` and "
"``1.0``) then they can be used interchangeably to index the same dictionary "
"entry.  (Note however, that since computers store floating-point numbers as "
"approximations it is usually unwise to use them as dictionary keys.)"
msgstr ""

#: ../../../library/stdtypes.rst:2119
msgid ""
"Dictionaries can be created by placing a comma-separated list of ``key: "
"value`` pairs within braces, for example: ``{'jack': 4098, 'sjoerd': 4127}`` "
"or ``{4098: 'jack', 4127: 'sjoerd'}``, or by the :class:`dict` constructor."
msgstr ""

#: ../../../library/stdtypes.rst:2127
msgid ""
"Return a new dictionary initialized from an optional positional argument and "
"a possibly empty set of keyword arguments."
msgstr ""

#: ../../../library/stdtypes.rst:2130
msgid ""
"If no positional argument is given, an empty dictionary is created. If a "
"positional argument is given and it is a mapping object, a dictionary is "
"created with the same key-value pairs as the mapping object.  Otherwise, the "
"positional argument must be an :term:`iterator` object.  Each item in the "
"iterable must itself be an iterator with exactly two objects.  The first "
"object of each item becomes a key in the new dictionary, and the second "
"object the corresponding value.  If a key occurs more than once, the last "
"value for that key becomes the corresponding value in the new dictionary."
msgstr ""

#: ../../../library/stdtypes.rst:2140
msgid ""
"If keyword arguments are given, the keyword arguments and their values are "
"added to the dictionary created from the positional argument.  If a key "
"being added is already present, the value from the keyword argument replaces "
"the value from the positional argument."
msgstr ""

#: ../../../library/stdtypes.rst:2145
msgid ""
"To illustrate, the following examples all return a dictionary equal to "
"``{\"one\": 1, \"two\": 2, \"three\": 3}``::"
msgstr ""

#: ../../../library/stdtypes.rst:2148
msgid ""
">>> a = dict(one=1, two=2, three=3)\n"
">>> b = {'one': 1, 'two': 2, 'three': 3}\n"
">>> c = dict(zip(['one', 'two', 'three'], [1, 2, 3]))\n"
">>> d = dict([('two', 2), ('one', 1), ('three', 3)])\n"
">>> e = dict({'three': 3, 'one': 1, 'two': 2})\n"
">>> a == b == c == d == e\n"
"True"
msgstr ""

#: ../../../library/stdtypes.rst:2156
msgid ""
"Providing keyword arguments as in the first example only works for keys that "
"are valid Python identifiers.  Otherwise, any valid keys can be used."
msgstr ""

#: ../../../library/stdtypes.rst:2160
msgid ""
"These are the operations that dictionaries support (and therefore, custom "
"mapping types should support too):"
msgstr ""

#: ../../../library/stdtypes.rst:2165
msgid "Return the number of items in the dictionary *d*."
msgstr ""

#: ../../../library/stdtypes.rst:2169
msgid ""
"Return the item of *d* with key *key*.  Raises a :exc:`KeyError` if *key* is "
"not in the map."
msgstr ""

#: ../../../library/stdtypes.rst:2172
msgid ""
"If a subclass of dict defines a method :meth:`__missing__`, if the key *key* "
"is not present, the ``d[key]`` operation calls that method with the key "
"*key* as argument.  The ``d[key]`` operation then returns or raises whatever "
"is returned or raised by the ``__missing__(key)`` call if the key is not "
"present. No other operations or methods invoke :meth:`__missing__`. If :meth:"
"`__missing__` is not defined, :exc:`KeyError` is raised. :meth:`__missing__` "
"must be a method; it cannot be an instance variable::"
msgstr ""

#: ../../../library/stdtypes.rst:2180
msgid ""
">>> class Counter(dict):\n"
"...     def __missing__(self, key):\n"
"...         return 0\n"
">>> c = Counter()\n"
">>> c['red']\n"
"0\n"
">>> c['red'] += 1\n"
">>> c['red']\n"
"1"
msgstr ""

#: ../../../library/stdtypes.rst:2190
msgid ""
"See :class:`collections.Counter` for a complete implementation including "
"other methods helpful for accumulating and managing tallies."
msgstr ""

#: ../../../library/stdtypes.rst:2195
msgid "Set ``d[key]`` to *value*."
msgstr ""

#: ../../../library/stdtypes.rst:2199
msgid ""
"Remove ``d[key]`` from *d*.  Raises a :exc:`KeyError` if *key* is not in the "
"map."
msgstr ""

#: ../../../library/stdtypes.rst:2204
msgid "Return ``True`` if *d* has a key *key*, else ``False``."
msgstr ""

#: ../../../library/stdtypes.rst:2208
msgid "Equivalent to ``not key in d``."
msgstr ""

#: ../../../library/stdtypes.rst:2212
msgid ""
"Return an iterator over the keys of the dictionary.  This is a shortcut for "
"``iter(d.keys())``."
msgstr ""

#: ../../../library/stdtypes.rst:2217
msgid "Remove all items from the dictionary."
msgstr ""

#: ../../../library/stdtypes.rst:2221
msgid "Return a shallow copy of the dictionary."
msgstr ""

#: ../../../library/stdtypes.rst:2225
msgid "Create a new dictionary with keys from *seq* and values set to *value*."
msgstr ""

#: ../../../library/stdtypes.rst:2227
msgid ""
":meth:`fromkeys` is a class method that returns a new dictionary. *value* "
"defaults to ``None``."
msgstr ""

#: ../../../library/stdtypes.rst:2232
msgid ""
"Return the value for *key* if *key* is in the dictionary, else *default*. If "
"*default* is not given, it defaults to ``None``, so that this method never "
"raises a :exc:`KeyError`."
msgstr ""

#: ../../../library/stdtypes.rst:2238
msgid ""
"Return a new view of the dictionary's items (``(key, value)`` pairs).  See "
"below for documentation of view objects."
msgstr ""

#: ../../../library/stdtypes.rst:2243
msgid ""
"Return a new view of the dictionary's keys.  See below for documentation of "
"view objects."
msgstr ""

#: ../../../library/stdtypes.rst:2248
msgid ""
"If *key* is in the dictionary, remove it and return its value, else return "
"*default*.  If *default* is not given and *key* is not in the dictionary, a :"
"exc:`KeyError` is raised."
msgstr ""

#: ../../../library/stdtypes.rst:2254
msgid ""
"Remove and return an arbitrary ``(key, value)`` pair from the dictionary."
msgstr ""

#: ../../../library/stdtypes.rst:2256
msgid ""
":meth:`popitem` is useful to destructively iterate over a dictionary, as "
"often used in set algorithms.  If the dictionary is empty, calling :meth:"
"`popitem` raises a :exc:`KeyError`."
msgstr ""

#: ../../../library/stdtypes.rst:2262
msgid ""
"If *key* is in the dictionary, return its value.  If not, insert *key* with "
"a value of *default* and return *default*.  *default* defaults to ``None``."
msgstr ""

#: ../../../library/stdtypes.rst:2268
msgid ""
"Update the dictionary with the key/value pairs from *other*, overwriting "
"existing keys.  Return ``None``."
msgstr ""

#: ../../../library/stdtypes.rst:2271
msgid ""
":meth:`update` accepts either another dictionary object or an iterable of "
"key/value pairs (as tuples or other iterables of length two).  If keyword "
"arguments are specified, the dictionary is then updated with those key/value "
"pairs: ``d.update(red=1, blue=2)``."
msgstr ""

#: ../../../library/stdtypes.rst:2278
msgid ""
"Return a new view of the dictionary's values.  See below for documentation "
"of view objects."
msgstr ""

#: ../../../library/stdtypes.rst:2285
msgid "Dictionary view objects"
msgstr ""

#: ../../../library/stdtypes.rst:2287
msgid ""
"The objects returned by :meth:`dict.keys`, :meth:`dict.values` and :meth:"
"`dict.items` are *view objects*.  They provide a dynamic view on the "
"dictionary's entries, which means that when the dictionary changes, the view "
"reflects these changes."
msgstr ""

#: ../../../library/stdtypes.rst:2292
msgid ""
"Dictionary views can be iterated over to yield their respective data, and "
"support membership tests:"
msgstr ""

#: ../../../library/stdtypes.rst:2297
msgid "Return the number of entries in the dictionary."
msgstr ""

#: ../../../library/stdtypes.rst:2301
msgid ""
"Return an iterator over the keys, values or items (represented as tuples of "
"``(key, value)``) in the dictionary."
msgstr ""

#: ../../../library/stdtypes.rst:2304
msgid ""
"Keys and values are iterated over in an arbitrary order which is non-random, "
"varies across Python implementations, and depends on the dictionary's "
"history of insertions and deletions. If keys, values and items views are "
"iterated over with no intervening modifications to the dictionary, the order "
"of items will directly correspond.  This allows the creation of ``(value, "
"key)`` pairs using :func:`zip`: ``pairs = zip(d.values(), d.keys())``.  "
"Another way to create the same list is ``pairs = [(v, k) for (k, v) in d."
"items()]``."
msgstr ""

#: ../../../library/stdtypes.rst:2312
msgid ""
"Iterating views while adding or deleting entries in the dictionary may raise "
"a :exc:`RuntimeError` or fail to iterate over all entries."
msgstr ""

#: ../../../library/stdtypes.rst:2317
msgid ""
"Return ``True`` if *x* is in the underlying dictionary's keys, values or "
"items (in the latter case, *x* should be a ``(key, value)`` tuple)."
msgstr ""

#: ../../../library/stdtypes.rst:2321
msgid ""
"Keys views are set-like since their entries are unique and hashable.  If all "
"values are hashable, so that ``(key, value)`` pairs are unique and hashable, "
"then the items view is also set-like.  (Values views are not treated as set-"
"like since the entries are generally not unique.)  For set-like views, all "
"of the operations defined for the abstract base class :class:`collections."
"Set` are available (for example, ``==``, ``<``, or ``^``)."
msgstr ""

#: ../../../library/stdtypes.rst:2328
msgid "An example of dictionary view usage::"
msgstr ""

#: ../../../library/stdtypes.rst:2330
msgid ""
">>> dishes = {'eggs': 2, 'sausage': 1, 'bacon': 1, 'spam': 500}\n"
">>> keys = dishes.keys()\n"
">>> values = dishes.values()\n"
"\n"
">>> # iteration\n"
">>> n = 0\n"
">>> for val in values:\n"
"...     n += val\n"
">>> print(n)\n"
"504\n"
"\n"
">>> # keys and values are iterated over in the same order\n"
">>> list(keys)\n"
"['eggs', 'bacon', 'sausage', 'spam']\n"
">>> list(values)\n"
"[2, 1, 1, 500]\n"
"\n"
">>> # view objects are dynamic and reflect dict changes\n"
">>> del dishes['eggs']\n"
">>> del dishes['sausage']\n"
">>> list(keys)\n"
"['spam', 'bacon']\n"
"\n"
">>> # set operations\n"
">>> keys & {'eggs', 'bacon', 'salad'}\n"
"{'bacon'}\n"
">>> keys ^ {'sausage', 'juice'}\n"
"{'juice', 'sausage', 'bacon', 'spam'}"
msgstr ""

#: ../../../library/stdtypes.rst:2363
msgid "memoryview type"
msgstr ""

#: ../../../library/stdtypes.rst:2365
msgid ""
":class:`memoryview` objects allow Python code to access the internal data of "
"an object that supports the :ref:`buffer protocol <bufferobjects>` without "
"copying.  Memory is generally interpreted as simple bytes."
msgstr ""

#: ../../../library/stdtypes.rst:2371
msgid ""
"Create a :class:`memoryview` that references *obj*.  *obj* must support the "
"buffer protocol.  Built-in objects that support the buffer protocol include :"
"class:`bytes` and :class:`bytearray`."
msgstr ""

#: ../../../library/stdtypes.rst:2375
msgid ""
"A :class:`memoryview` has the notion of an *element*, which is the atomic "
"memory unit handled by the originating object *obj*.  For many simple types "
"such as :class:`bytes` and :class:`bytearray`, an element is a single byte, "
"but other types such as :class:`array.array` may have bigger elements."
msgstr ""

#: ../../../library/stdtypes.rst:2381
msgid ""
"``len(view)`` returns the total number of elements in the memoryview, "
"*view*.  The :class:`~memoryview.itemsize` attribute will give you the "
"number of bytes in a single element."
msgstr ""

#: ../../../library/stdtypes.rst:2385
msgid ""
"A :class:`memoryview` supports slicing to expose its data.  Taking a single "
"index will return a single element as a :class:`bytes` object.  Full slicing "
"will result in a subview::"
msgstr ""

#: ../../../library/stdtypes.rst:2389
msgid ""
">>> v = memoryview(b'abcefg')\n"
">>> v[1]\n"
"b'b'\n"
">>> v[-1]\n"
"b'g'\n"
">>> v[1:4]\n"
"<memory at 0x77ab28>\n"
">>> bytes(v[1:4])\n"
"b'bce'"
msgstr ""

#: ../../../library/stdtypes.rst:2399
msgid ""
"If the object the memoryview is over supports changing its data, the "
"memoryview supports slice assignment::"
msgstr ""

#: ../../../library/stdtypes.rst:2402
msgid ""
">>> data = bytearray(b'abcefg')\n"
">>> v = memoryview(data)\n"
">>> v.readonly\n"
"False\n"
">>> v[0] = b'z'\n"
">>> data\n"
"bytearray(b'zbcefg')\n"
">>> v[1:4] = b'123'\n"
">>> data\n"
"bytearray(b'z123fg')\n"
">>> v[2] = b'spam'\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"ValueError: cannot modify size of memoryview object"
msgstr ""

#: ../../../library/stdtypes.rst:2417
msgid "Notice how the size of the memoryview object cannot be changed."
msgstr ""

#: ../../../library/stdtypes.rst:2419
msgid ":class:`memoryview` has several methods:"
msgstr ""

#: ../../../library/stdtypes.rst:2423
msgid ""
"Return the data in the buffer as a bytestring.  This is equivalent to "
"calling the :class:`bytes` constructor on the memoryview. ::"
msgstr ""

#: ../../../library/stdtypes.rst:2426
msgid ""
">>> m = memoryview(b\"abc\")\n"
">>> m.tobytes()\n"
"b'abc'\n"
">>> bytes(m)\n"
"b'abc'"
msgstr ""

#: ../../../library/stdtypes.rst:2434
msgid "Return the data in the buffer as a list of integers. ::"
msgstr ""

#: ../../../library/stdtypes.rst:2436
msgid ""
">>> memoryview(b'abc').tolist()\n"
"[97, 98, 99]"
msgstr ""

#: ../../../library/stdtypes.rst:2441
msgid ""
"Release the underlying buffer exposed by the memoryview object.  Many "
"objects take special actions when a view is held on them (for example, a :"
"class:`bytearray` would temporarily forbid resizing); therefore, calling "
"release() is handy to remove these restrictions (and free any dangling "
"resources) as soon as possible."
msgstr ""

#: ../../../library/stdtypes.rst:2447
msgid ""
"After this method has been called, any further operation on the view raises "
"a :class:`ValueError` (except :meth:`release()` itself which can be called "
"multiple times)::"
msgstr ""

#: ../../../library/stdtypes.rst:2451
msgid ""
">>> m = memoryview(b'abc')\n"
">>> m.release()\n"
">>> m[0]\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"ValueError: operation forbidden on released memoryview object"
msgstr ""

#: ../../../library/stdtypes.rst:2458
msgid ""
"The context management protocol can be used for a similar effect, using the "
"``with`` statement::"
msgstr ""

#: ../../../library/stdtypes.rst:2461
msgid ""
">>> with memoryview(b'abc') as m:\n"
"...     m[0]\n"
"...\n"
"b'a'\n"
">>> m[0]\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"ValueError: operation forbidden on released memoryview object"
msgstr ""

#: ../../../library/stdtypes.rst:2472
msgid "There are also several readonly attributes available:"
msgstr ""

#: ../../../library/stdtypes.rst:2476
msgid ""
"A string containing the format (in :mod:`struct` module style) for each "
"element in the view.  This defaults to ``'B'``, a simple bytestring."
msgstr ""

#: ../../../library/stdtypes.rst:2481
msgid "The size in bytes of each element of the memoryview::"
msgstr ""

#: ../../../library/stdtypes.rst:2483
msgid ""
">>> m = memoryview(array.array('H', [1,2,3]))\n"
">>> m.itemsize\n"
"2\n"
">>> m[0]\n"
"b'\\x01\\x00'\n"
">>> len(m[0]) == m.itemsize\n"
"True"
msgstr ""

#: ../../../library/stdtypes.rst:2493
msgid ""
"A tuple of integers the length of :attr:`ndim` giving the shape of the "
"memory as a N-dimensional array."
msgstr ""

#: ../../../library/stdtypes.rst:2498
msgid ""
"An integer indicating how many dimensions of a multi-dimensional array the "
"memory represents."
msgstr ""

#: ../../../library/stdtypes.rst:2503
msgid ""
"A tuple of integers the length of :attr:`ndim` giving the size in bytes to "
"access each element for each dimension of the array."
msgstr ""

#: ../../../library/stdtypes.rst:2508
msgid "A bool indicating whether the memory is read only."
msgstr ""

#: ../../../library/stdtypes.rst:2516
msgid "Context Manager Types"
msgstr ""

#: ../../../library/stdtypes.rst:2523
msgid ""
"Python's :keyword:`with` statement supports the concept of a runtime context "
"defined by a context manager.  This is implemented using a pair of methods "
"that allow user-defined classes to define a runtime context that is entered "
"before the statement body is executed and exited when the statement ends:"
msgstr ""

#: ../../../library/stdtypes.rst:2531
msgid ""
"Enter the runtime context and return either this object or another object "
"related to the runtime context. The value returned by this method is bound "
"to the identifier in the :keyword:`as` clause of :keyword:`with` statements "
"using this context manager."
msgstr ""

#: ../../../library/stdtypes.rst:2536
msgid ""
"An example of a context manager that returns itself is a :term:`file "
"object`. File objects return themselves from __enter__() to allow :func:"
"`open` to be used as the context expression in a :keyword:`with` statement."
msgstr ""

#: ../../../library/stdtypes.rst:2540
msgid ""
"An example of a context manager that returns a related object is the one "
"returned by :func:`decimal.localcontext`. These managers set the active "
"decimal context to a copy of the original decimal context and then return "
"the copy. This allows changes to be made to the current decimal context in "
"the body of the :keyword:`with` statement without affecting code outside "
"the :keyword:`with` statement."
msgstr ""

#: ../../../library/stdtypes.rst:2550
msgid ""
"Exit the runtime context and return a Boolean flag indicating if any "
"exception that occurred should be suppressed. If an exception occurred while "
"executing the body of the :keyword:`with` statement, the arguments contain "
"the exception type, value and traceback information. Otherwise, all three "
"arguments are ``None``."
msgstr ""

#: ../../../library/stdtypes.rst:2555
msgid ""
"Returning a true value from this method will cause the :keyword:`with` "
"statement to suppress the exception and continue execution with the "
"statement immediately following the :keyword:`with` statement. Otherwise the "
"exception continues propagating after this method has finished executing. "
"Exceptions that occur during execution of this method will replace any "
"exception that occurred in the body of the :keyword:`with` statement."
msgstr ""

#: ../../../library/stdtypes.rst:2562
msgid ""
"The exception passed in should never be reraised explicitly - instead, this "
"method should return a false value to indicate that the method completed "
"successfully and does not want to suppress the raised exception. This allows "
"context management code (such as ``contextlib.nested``) to easily detect "
"whether or not an :meth:`__exit__` method has actually failed."
msgstr ""

#: ../../../library/stdtypes.rst:2568
msgid ""
"Python defines several context managers to support easy thread "
"synchronisation, prompt closure of files or other objects, and simpler "
"manipulation of the active decimal arithmetic context. The specific types "
"are not treated specially beyond their implementation of the context "
"management protocol. See the :mod:`contextlib` module for some examples."
msgstr ""

#: ../../../library/stdtypes.rst:2574
msgid ""
"Python's :term:`generator`\\s and the :class:`contextlib.contextmanager` "
"decorator provide a convenient way to implement these protocols.  If a "
"generator function is decorated with the :class:`contextlib.contextmanager` "
"decorator, it will return a context manager implementing the necessary :meth:"
"`__enter__` and :meth:`__exit__` methods, rather than the iterator produced "
"by an undecorated generator function."
msgstr ""

#: ../../../library/stdtypes.rst:2581
msgid ""
"Note that there is no specific slot for any of these methods in the type "
"structure for Python objects in the Python/C API. Extension types wanting to "
"define these methods must provide them as a normal Python accessible method. "
"Compared to the overhead of setting up the runtime context, the overhead of "
"a single class dictionary lookup is negligible."
msgstr ""

#: ../../../library/stdtypes.rst:2591
msgid "Other Built-in Types"
msgstr ""

#: ../../../library/stdtypes.rst:2593
msgid ""
"The interpreter supports several other kinds of objects. Most of these "
"support only one or two operations."
msgstr ""

#: ../../../library/stdtypes.rst:2600
msgid "Modules"
msgstr ""

#: ../../../library/stdtypes.rst:2602
msgid ""
"The only special operation on a module is attribute access: ``m.name``, "
"where *m* is a module and *name* accesses a name defined in *m*'s symbol "
"table. Module attributes can be assigned to.  (Note that the :keyword:"
"`import` statement is not, strictly speaking, an operation on a module "
"object; ``import foo`` does not require a module object named *foo* to "
"exist, rather it requires an (external) *definition* for a module named "
"*foo* somewhere.)"
msgstr ""

#: ../../../library/stdtypes.rst:2609
msgid ""
"A special attribute of every module is :attr:`__dict__`. This is the "
"dictionary containing the module's symbol table. Modifying this dictionary "
"will actually change the module's symbol table, but direct assignment to "
"the :attr:`__dict__` attribute is not possible (you can write ``m."
"__dict__['a'] = 1``, which defines ``m.a`` to be ``1``, but you can't write "
"``m.__dict__ = {}``).  Modifying :attr:`__dict__` directly is not "
"recommended."
msgstr ""

#: ../../../library/stdtypes.rst:2616
msgid ""
"Modules built into the interpreter are written like this: ``<module "
"'sys' (built-in)>``.  If loaded from a file, they are written as ``<module "
"'os' from '/usr/local/lib/pythonX.Y/os.pyc'>``."
msgstr ""

#: ../../../library/stdtypes.rst:2624
msgid "Classes and Class Instances"
msgstr ""

#: ../../../library/stdtypes.rst:2626
msgid "See :ref:`objects` and :ref:`class` for these."
msgstr ""

#: ../../../library/stdtypes.rst:2632
msgid "Functions"
msgstr ""

#: ../../../library/stdtypes.rst:2634
msgid ""
"Function objects are created by function definitions.  The only operation on "
"a function object is to call it: ``func(argument-list)``."
msgstr ""

#: ../../../library/stdtypes.rst:2637
msgid ""
"There are really two flavors of function objects: built-in functions and "
"user-defined functions.  Both support the same operation (to call the "
"function), but the implementation is different, hence the different object "
"types."
msgstr ""

#: ../../../library/stdtypes.rst:2641
msgid "See :ref:`function` for more information."
msgstr ""

#: ../../../library/stdtypes.rst:2647
msgid "Methods"
msgstr ""

#: ../../../library/stdtypes.rst:2651
msgid ""
"Methods are functions that are called using the attribute notation. There "
"are two flavors: built-in methods (such as :meth:`append` on lists) and "
"class instance methods.  Built-in methods are described with the types that "
"support them."
msgstr ""

#: ../../../library/stdtypes.rst:2656
msgid ""
"If you access a method (a function defined in a class namespace) through an "
"instance, you get a special object: a :dfn:`bound method` (also called :dfn:"
"`instance method`) object. When called, it will add the ``self`` argument to "
"the argument list.  Bound methods have two special read-only attributes: ``m."
"__self__`` is the object on which the method operates, and ``m.__func__`` is "
"the function implementing the method.  Calling ``m(arg-1, arg-2, ..., arg-"
"n)`` is completely equivalent to calling ``m.__func__(m.__self__, arg-1, "
"arg-2, ..., arg-n)``."
msgstr ""

#: ../../../library/stdtypes.rst:2665
msgid ""
"Like function objects, bound method objects support getting arbitrary "
"attributes.  However, since method attributes are actually stored on the "
"underlying function object (``meth.__func__``), setting method attributes on "
"bound methods is disallowed.  Attempting to set an attribute on a method "
"results in an :exc:`AttributeError` being raised.  In order to set a method "
"attribute, you need to explicitly set it on the underlying function object::"
msgstr ""

#: ../../../library/stdtypes.rst:2672
msgid ""
">>> class C:\n"
"...     def method(self):\n"
"...         pass\n"
"...\n"
">>> c = C()\n"
">>> c.method.whoami = 'my name is method'  # can't set on the method\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"AttributeError: 'method' object has no attribute 'whoami'\n"
">>> c.method.__func__.whoami = 'my name is method'\n"
">>> c.method.whoami\n"
"'my name is method'"
msgstr ""

#: ../../../library/stdtypes.rst:2685 ../../../library/stdtypes.rst:2713
msgid "See :ref:`types` for more information."
msgstr ""

#: ../../../library/stdtypes.rst:2691
msgid "Code Objects"
msgstr ""

#: ../../../library/stdtypes.rst:2699
msgid ""
"Code objects are used by the implementation to represent \"pseudo-compiled\" "
"executable Python code such as a function body. They differ from function "
"objects because they don't contain a reference to their global execution "
"environment.  Code objects are returned by the built-in :func:`compile` "
"function and can be extracted from function objects through their :attr:"
"`__code__` attribute. See also the :mod:`code` module."
msgstr ""

#: ../../../library/stdtypes.rst:2710
msgid ""
"A code object can be executed or evaluated by passing it (instead of a "
"source string) to the :func:`exec` or :func:`eval`  built-in functions."
msgstr ""

#: ../../../library/stdtypes.rst:2719
msgid "Type Objects"
msgstr ""

#: ../../../library/stdtypes.rst:2725
msgid ""
"Type objects represent the various object types.  An object's type is "
"accessed by the built-in function :func:`type`.  There are no special "
"operations on types.  The standard module :mod:`types` defines names for all "
"standard built-in types."
msgstr ""

#: ../../../library/stdtypes.rst:2730
msgid "Types are written like this: ``<class 'int'>``."
msgstr ""

#: ../../../library/stdtypes.rst:2736
msgid "The Null Object"
msgstr ""

#: ../../../library/stdtypes.rst:2738
msgid ""
"This object is returned by functions that don't explicitly return a value.  "
"It supports no special operations.  There is exactly one null object, named "
"``None`` (a built-in name)."
msgstr ""

#: ../../../library/stdtypes.rst:2742
msgid "It is written as ``None``."
msgstr ""

#: ../../../library/stdtypes.rst:2748
msgid "The Ellipsis Object"
msgstr ""

#: ../../../library/stdtypes.rst:2750
msgid ""
"This object is commonly used by slicing (see :ref:`slicings`).  It supports "
"no special operations.  There is exactly one ellipsis object, named :const:"
"`Ellipsis` (a built-in name)."
msgstr ""

#: ../../../library/stdtypes.rst:2754
msgid "It is written as ``Ellipsis`` or ``...``."
msgstr ""

#: ../../../library/stdtypes.rst:2760
msgid "The NotImplemented Object"
msgstr ""

#: ../../../library/stdtypes.rst:2762
msgid ""
"This object is returned from comparisons and binary operations when they are "
"asked to operate on types they don't support. See :ref:`comparisons` for "
"more information."
msgstr ""

#: ../../../library/stdtypes.rst:2766
msgid "It is written as ``NotImplemented``."
msgstr ""

#: ../../../library/stdtypes.rst:2772
msgid "Boolean Values"
msgstr ""

#: ../../../library/stdtypes.rst:2774
msgid ""
"Boolean values are the two constant objects ``False`` and ``True``.  They "
"are used to represent truth values (although other values can also be "
"considered false or true).  In numeric contexts (for example when used as "
"the argument to an arithmetic operator), they behave like the integers 0 and "
"1, respectively. The built-in function :func:`bool` can be used to convert "
"any value to a Boolean, if the value can be interpreted as a truth value "
"(see section :ref:`truth` above)."
msgstr ""

#: ../../../library/stdtypes.rst:2787
msgid "They are written as ``False`` and ``True``, respectively."
msgstr ""

#: ../../../library/stdtypes.rst:2793
msgid "Internal Objects"
msgstr ""

#: ../../../library/stdtypes.rst:2795
msgid ""
"See :ref:`types` for this information.  It describes stack frame objects, "
"traceback objects, and slice objects."
msgstr ""

#: ../../../library/stdtypes.rst:2802
msgid "Special Attributes"
msgstr ""

#: ../../../library/stdtypes.rst:2804
msgid ""
"The implementation adds a few special read-only attributes to several object "
"types, where they are relevant.  Some of these are not reported by the :func:"
"`dir` built-in function."
msgstr ""

#: ../../../library/stdtypes.rst:2811
msgid ""
"A dictionary or other mapping object used to store an object's (writable) "
"attributes."
msgstr ""

#: ../../../library/stdtypes.rst:2817
msgid "The class to which a class instance belongs."
msgstr ""

#: ../../../library/stdtypes.rst:2822
msgid "The tuple of base classes of a class object."
msgstr ""

#: ../../../library/stdtypes.rst:2827
msgid "The name of the class or type."
msgstr ""

#: ../../../library/stdtypes.rst:2832
msgid ""
"This attribute is a tuple of classes that are considered when looking for "
"base classes during method resolution."
msgstr ""

#: ../../../library/stdtypes.rst:2838
msgid ""
"This method can be overridden by a metaclass to customize the method "
"resolution order for its instances.  It is called at class instantiation, "
"and its result is stored in :attr:`__mro__`."
msgstr ""

#: ../../../library/stdtypes.rst:2845
msgid ""
"Each class keeps a list of weak references to its immediate subclasses.  "
"This method returns a list of all those references still alive. Example::"
msgstr ""

#: ../../../library/stdtypes.rst:2849
msgid ""
">>> int.__subclasses__()\n"
"[<class 'bool'>]"
msgstr ""

#: ../../../library/stdtypes.rst:2854
msgid "Footnotes"
msgstr ""

#: ../../../library/stdtypes.rst:2855
msgid ""
"Additional information on these special methods may be found in the Python "
"Reference Manual (:ref:`customization`)."
msgstr ""

#: ../../../library/stdtypes.rst:2858
msgid ""
"As a consequence, the list ``[1, 2]`` is considered equal to ``[1.0, 2.0]``, "
"and similarly for tuples."
msgstr ""

#: ../../../library/stdtypes.rst:2861
msgid "They must have since the parser can't tell the type of the operands."
msgstr ""

#: ../../../library/stdtypes.rst:2863
msgid ""
"Cased characters are those with general category property being one of "
"\"Lu\" (Letter, uppercase), \"Ll\" (Letter, lowercase), or \"Lt\" (Letter, "
"titlecase)."
msgstr ""

#: ../../../library/stdtypes.rst:2866
msgid ""
"To format only a tuple you should therefore provide a singleton tuple whose "
"only element is the tuple to be formatted."
msgstr ""

#: ../../../library/stdtypes.rst:13
msgid "built-in"
msgstr ""

#: ../../../library/stdtypes.rst:13 ../../../library/stdtypes.rst:312
#: ../../../library/stdtypes.rst:385 ../../../library/stdtypes.rst:910
#: ../../../library/stdtypes.rst:1671 ../../../library/stdtypes.rst:1686
#: ../../../library/stdtypes.rst:2096 ../../../library/stdtypes.rst:2721
msgid "types"
msgstr ""

#: ../../../library/stdtypes.rst:30
msgid "if"
msgstr ""

#: ../../../library/stdtypes.rst:30
msgid "while"
msgstr ""

#: ../../../library/stdtypes.rst:30
msgid "truth"
msgstr ""

#: ../../../library/stdtypes.rst:30
msgid "value"
msgstr ""

#: ../../../library/stdtypes.rst:30 ../../../library/stdtypes.rst:81
#: ../../../library/stdtypes.rst:209 ../../../library/stdtypes.rst:2782
msgid "Boolean"
msgstr ""

#: ../../../library/stdtypes.rst:30 ../../../library/stdtypes.rst:81
#: ../../../library/stdtypes.rst:385
msgid "operations"
msgstr ""

#: ../../../library/stdtypes.rst:30
msgid "false"
msgstr ""

#: ../../../library/stdtypes.rst:41
msgid "None (Built-in object)"
msgstr ""

#: ../../../library/stdtypes.rst:45
msgid "False (Built-in object)"
msgstr ""

#: ../../../library/stdtypes.rst:59
msgid "true"
msgstr ""

#: ../../../library/stdtypes.rst:64 ../../../library/stdtypes.rst:98
msgid "or"
msgstr ""

#: ../../../library/stdtypes.rst:64 ../../../library/stdtypes.rst:98
msgid "and"
msgstr ""

#: ../../../library/stdtypes.rst:64 ../../../library/stdtypes.rst:2782
msgid "False"
msgstr ""

#: ../../../library/stdtypes.rst:64 ../../../library/stdtypes.rst:2782
msgid "True"
msgstr ""

#: ../../../library/stdtypes.rst:98
msgid "not"
msgstr ""

#: ../../../library/stdtypes.rst:123
msgid "chaining"
msgstr ""

#: ../../../library/stdtypes.rst:123
msgid "comparisons"
msgstr ""

#: ../../../library/stdtypes.rst:123
msgid "comparison"
msgstr ""

#: ../../../library/stdtypes.rst:123
msgid "=="
msgstr ""

#: ../../../library/stdtypes.rst:123
msgid "<"
msgstr ""

#: ../../../library/stdtypes.rst:123
msgid "<="
msgstr ""

#: ../../../library/stdtypes.rst:123
msgid ">"
msgstr ""

#: ../../../library/stdtypes.rst:123
msgid ">="
msgstr ""

#: ../../../library/stdtypes.rst:123
msgid "!="
msgstr ""

#: ../../../library/stdtypes.rst:123
msgid "is"
msgstr ""

#: ../../../library/stdtypes.rst:123
msgid "is not"
msgstr ""

#: ../../../library/stdtypes.rst:163 ../../../library/stdtypes.rst:209
#: ../../../library/stdtypes.rst:230 ../../../library/stdtypes.rst:312
#: ../../../library/stdtypes.rst:329
msgid "numeric"
msgstr ""

#: ../../../library/stdtypes.rst:163
msgid "objects"
msgstr ""

#: ../../../library/stdtypes.rst:163
msgid "comparing"
msgstr ""

#: ../../../library/stdtypes.rst:175
msgid "__eq__() (instance method)"
msgstr ""

#: ../../../library/stdtypes.rst:175
msgid "__ne__() (instance method)"
msgstr ""

#: ../../../library/stdtypes.rst:175
msgid "__lt__() (instance method)"
msgstr ""

#: ../../../library/stdtypes.rst:175
msgid "__le__() (instance method)"
msgstr ""

#: ../../../library/stdtypes.rst:175
msgid "__gt__() (instance method)"
msgstr ""

#: ../../../library/stdtypes.rst:175
msgid "__ge__() (instance method)"
msgstr ""

#: ../../../library/stdtypes.rst:196 ../../../library/stdtypes.rst:910
msgid "in"
msgstr ""

#: ../../../library/stdtypes.rst:196 ../../../library/stdtypes.rst:910
msgid "not in"
msgstr ""

#: ../../../library/stdtypes.rst:209 ../../../library/stdtypes.rst:230
#: ../../../library/stdtypes.rst:385
msgid "integer"
msgstr ""

#: ../../../library/stdtypes.rst:209 ../../../library/stdtypes.rst:230
msgid "floating point"
msgstr ""

#: ../../../library/stdtypes.rst:209 ../../../library/stdtypes.rst:230
msgid "complex number"
msgstr ""

#: ../../../library/stdtypes.rst:209 ../../../library/stdtypes.rst:329
msgid "C"
msgstr ""

#: ../../../library/stdtypes.rst:209 ../../../library/stdtypes.rst:329
msgid "language"
msgstr ""

#: ../../../library/stdtypes.rst:230
msgid "literals"
msgstr ""

#: ../../../library/stdtypes.rst:230
msgid "hexadecimal"
msgstr ""

#: ../../../library/stdtypes.rst:230
msgid "octal"
msgstr ""

#: ../../../library/stdtypes.rst:230
msgid "binary"
msgstr ""

#: ../../../library/stdtypes.rst:247
msgid "arithmetic"
msgstr ""

#: ../../../library/stdtypes.rst:247
msgid "int"
msgstr ""

#: ../../../library/stdtypes.rst:247
msgid "float"
msgstr ""

#: ../../../library/stdtypes.rst:247
msgid "complex"
msgstr ""

#: ../../../library/stdtypes.rst:247
msgid "+"
msgstr ""

#: ../../../library/stdtypes.rst:247
msgid "-"
msgstr ""

#: ../../../library/stdtypes.rst:247
msgid "*"
msgstr ""

#: ../../../library/stdtypes.rst:247
msgid "/"
msgstr ""

#: ../../../library/stdtypes.rst:247
msgid "//"
msgstr ""

#: ../../../library/stdtypes.rst:247
msgid "%"
msgstr ""

#: ../../../library/stdtypes.rst:247
msgid "**"
msgstr ""

#: ../../../library/stdtypes.rst:312 ../../../library/stdtypes.rst:385
#: ../../../library/stdtypes.rst:910 ../../../library/stdtypes.rst:1686
#: ../../../library/stdtypes.rst:2096
msgid "operations on"
msgstr ""

#: ../../../library/stdtypes.rst:312
msgid "conjugate() (complex number method)"
msgstr ""

#: ../../../library/stdtypes.rst:329
msgid "math"
msgstr ""

#: ../../../library/stdtypes.rst:329
msgid "floor() (in module math)"
msgstr ""

#: ../../../library/stdtypes.rst:329
msgid "ceil() (in module math)"
msgstr ""

#: ../../../library/stdtypes.rst:329
msgid "trunc() (in module math)"
msgstr ""

#: ../../../library/stdtypes.rst:329
msgid "conversions"
msgstr ""

#: ../../../library/stdtypes.rst:385
msgid "bitwise"
msgstr ""

#: ../../../library/stdtypes.rst:385
msgid "shifting"
msgstr ""

#: ../../../library/stdtypes.rst:385
msgid "masking"
msgstr ""

#: ../../../library/stdtypes.rst:385
msgid "^"
msgstr ""

#: ../../../library/stdtypes.rst:385
msgid "&"
msgstr ""

#: ../../../library/stdtypes.rst:385
msgid "<<"
msgstr ""

#: ../../../library/stdtypes.rst:385
msgid ">>"
msgstr ""

#: ../../../library/stdtypes.rst:727
msgid "iterator protocol"
msgstr ""

#: ../../../library/stdtypes.rst:727 ../../../library/stdtypes.rst:2518
msgid "protocol"
msgstr ""

#: ../../../library/stdtypes.rst:727
msgid "iterator"
msgstr ""

#: ../../../library/stdtypes.rst:727 ../../../library/stdtypes.rst:810
#: ../../../library/stdtypes.rst:910 ../../../library/stdtypes.rst:1671
#: ../../../library/stdtypes.rst:1686
msgid "sequence"
msgstr ""

#: ../../../library/stdtypes.rst:727
msgid "iteration"
msgstr ""

#: ../../../library/stdtypes.rst:727
msgid "container"
msgstr ""

#: ../../../library/stdtypes.rst:727
msgid "iteration over"
msgstr ""

#: ../../../library/stdtypes.rst:797 ../../../library/stdtypes.rst:810
#: ../../../library/stdtypes.rst:994 ../../../library/stdtypes.rst:1446
#: ../../../library/stdtypes.rst:1630
msgid "string"
msgstr ""

#: ../../../library/stdtypes.rst:797
msgid "sequence types"
msgstr ""

#: ../../../library/stdtypes.rst:810 ../../../library/stdtypes.rst:1810
msgid "bytes"
msgstr ""

#: ../../../library/stdtypes.rst:810 ../../../library/stdtypes.rst:1671
#: ../../../library/stdtypes.rst:1810
msgid "bytearray"
msgstr ""

#: ../../../library/stdtypes.rst:810
msgid "tuple"
msgstr ""

#: ../../../library/stdtypes.rst:810 ../../../library/stdtypes.rst:1671
#: ../../../library/stdtypes.rst:1686
msgid "list"
msgstr ""

#: ../../../library/stdtypes.rst:810 ../../../library/stdtypes.rst:1643
msgid "range"
msgstr ""

#: ../../../library/stdtypes.rst:810
msgid "str() (built-in function)"
msgstr ""

#: ../../../library/stdtypes.rst:810
msgid "(see also string)"
msgstr ""

#: ../../../library/stdtypes.rst:910 ../../../library/stdtypes.rst:2096
msgid "len"
msgstr ""

#: ../../../library/stdtypes.rst:910
msgid "min"
msgstr ""

#: ../../../library/stdtypes.rst:910
msgid "max"
msgstr ""

#: ../../../library/stdtypes.rst:910
msgid "concatenation"
msgstr ""

#: ../../../library/stdtypes.rst:910
msgid "operation"
msgstr ""

#: ../../../library/stdtypes.rst:910
msgid "repetition"
msgstr ""

#: ../../../library/stdtypes.rst:910 ../../../library/stdtypes.rst:1686
msgid "subscript"
msgstr ""

#: ../../../library/stdtypes.rst:910 ../../../library/stdtypes.rst:1686
msgid "slice"
msgstr ""

#: ../../../library/stdtypes.rst:994 ../../../library/stdtypes.rst:1810
msgid "methods"
msgstr ""

#: ../../../library/stdtypes.rst:1335
msgid "universal newlines"
msgstr ""

#: ../../../library/stdtypes.rst:1335
msgid "str.splitlines method"
msgstr ""

#: ../../../library/stdtypes.rst:1446
msgid "formatting, string (%)"
msgstr ""

#: ../../../library/stdtypes.rst:1446
msgid "interpolation, string (%)"
msgstr ""

#: ../../../library/stdtypes.rst:1446
msgid "formatting"
msgstr ""

#: ../../../library/stdtypes.rst:1446
msgid "interpolation"
msgstr ""

#: ../../../library/stdtypes.rst:1446
msgid "printf-style formatting"
msgstr ""

#: ../../../library/stdtypes.rst:1446
msgid "sprintf-style formatting"
msgstr ""

#: ../../../library/stdtypes.rst:1446
msgid "% formatting"
msgstr ""

#: ../../../library/stdtypes.rst:1446
msgid "% interpolation"
msgstr ""

#: ../../../library/stdtypes.rst:1630
msgid "re"
msgstr ""

#: ../../../library/stdtypes.rst:1671
msgid "mutable"
msgstr ""

#: ../../../library/stdtypes.rst:1686 ../../../library/stdtypes.rst:2096
#: ../../../library/stdtypes.rst:2721
msgid "type"
msgstr ""

#: ../../../library/stdtypes.rst:1686
msgid "assignment"
msgstr ""

#: ../../../library/stdtypes.rst:1686 ../../../library/stdtypes.rst:2096
msgid "del"
msgstr ""

#: ../../../library/stdtypes.rst:1686
msgid "append() (sequence method)"
msgstr ""

#: ../../../library/stdtypes.rst:1686
msgid "extend() (sequence method)"
msgstr ""

#: ../../../library/stdtypes.rst:1686
msgid "count() (sequence method)"
msgstr ""

#: ../../../library/stdtypes.rst:1686
msgid "index() (sequence method)"
msgstr ""

#: ../../../library/stdtypes.rst:1686
msgid "insert() (sequence method)"
msgstr ""

#: ../../../library/stdtypes.rst:1686
msgid "pop() (sequence method)"
msgstr ""

#: ../../../library/stdtypes.rst:1686
msgid "remove() (sequence method)"
msgstr ""

#: ../../../library/stdtypes.rst:1686
msgid "reverse() (sequence method)"
msgstr ""

#: ../../../library/stdtypes.rst:1686
msgid "sort() (sequence method)"
msgstr ""

#: ../../../library/stdtypes.rst:1900
msgid "set"
msgstr ""

#: ../../../library/stdtypes.rst:2096
msgid "mapping"
msgstr ""

#: ../../../library/stdtypes.rst:2096
msgid "dictionary"
msgstr ""

#: ../../../library/stdtypes.rst:2518
msgid "context manager"
msgstr ""

#: ../../../library/stdtypes.rst:2518
msgid "context management protocol"
msgstr ""

#: ../../../library/stdtypes.rst:2518
msgid "context management"
msgstr ""

#: ../../../library/stdtypes.rst:2649
msgid "method"
msgstr ""

#: ../../../library/stdtypes.rst:2693
msgid "code"
msgstr ""

#: ../../../library/stdtypes.rst:2695
msgid "compile"
msgstr ""

#: ../../../library/stdtypes.rst:2695
msgid "__code__ (function object attribute)"
msgstr ""

#: ../../../library/stdtypes.rst:2706
msgid "exec"
msgstr ""

#: ../../../library/stdtypes.rst:2706
msgid "eval"
msgstr ""

#: ../../../library/stdtypes.rst:2782
msgid "values"
msgstr ""

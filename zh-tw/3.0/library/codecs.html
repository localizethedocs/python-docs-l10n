
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" lang="zh_TW">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>codecs — Codec registry and base classes &#8212; Python 3.0.1 說明文件</title>
    <link rel="stylesheet" href="../_static/pydoctheme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/language_data.js"></script>
    <script type="text/javascript" src="../_static/translations.js"></script>
    
    <link rel="canonical" href="https://projects.localizethedocs.org/python-docs-l10n/library/codecs.html" />
    <link rel="search" type="application/opensearchdescription+xml"
          title="在 Python 3.0.1 說明文件 中搜尋"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="關於這些文件" href="../about.html" />
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="搜尋" href="../search.html" />
    <link rel="copyright" title="版權所有" href="../copyright.html" />
    <link rel="next" title="unicodedata — Unicode Database" href="unicodedata.html" />
    <link rel="prev" title="textwrap — Text wrapping and filling" href="textwrap.html" />
    
    <link rel="canonical" href="https://docs.python.org/3/library/codecs.html" />
    
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>

    <link rel="shortcut icon" type="image/png" href="../_static/py.png" />
    
    <script type="text/javascript" src="../_static/copybutton.js"></script>
    
     

            <script type="text/javascript" src="../_static/rtd_switcher.js"></script>
            <meta name="readthedocs-addons-api-version" content="1">
            <script type="text/javascript" src="../ltd-provenance.js"></script>
            <script type="text/javascript" src="../ltd-current.js"></script>
            <script type="text/javascript" src="../../../ltd-config.js"></script>
            <script type="text/javascript" src="../../../ltd-flyout.js"></script>

  </head><body>
  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>瀏覽</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="總索引"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 模組索引"
             >模組</a> |</li>
        <li class="right" >
          <a href="unicodedata.html" title="unicodedata — Unicode Database"
             accesskey="N">下一頁</a> |</li>
        <li class="right" >
          <a href="textwrap.html" title="textwrap — Text wrapping and filling"
             accesskey="P">上一頁</a> |</li>

    <li><img src="../_static/py.png" alt=""
             style="vertical-align: middle; margin-top: -1px"/></li>
    <li><a href="https://www.python.org/">Python</a> &#187;</li>
    

          <li id="cpython-language-and-version">
            <a href="../index.html">Python 3.0.1 說明文件</a> &#187;
          </li>

          <li class="nav-item nav-item-1"><a href="index.html" >The Python Standard Library</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="strings.html" accesskey="U">String Services</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="快速搜尋" type="text" name="q" />
          <input type="submit" value="搜" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="module-codecs">
<span id="codecs-codec-registry-and-base-classes"></span><h1><a class="reference internal" href="#module-codecs" title="codecs: Encode and decode data and streams."><code class="xref py py-mod docutils literal notranslate"><span class="pre">codecs</span></code></a> — Codec registry and base classes<a class="headerlink" href="#module-codecs" title="本標題的永久連結">¶</a></h1>
<p id="index-0">This module defines base classes for standard Python codecs (encoders and
decoders) and provides access to the internal Python codec registry which
manages the codec and error handling lookup process.</p>
<p>It defines the following functions:</p>
<dl class="function">
<dt id="codecs.register">
<code class="descclassname">codecs.</code><code class="descname">register</code><span class="sig-paren">(</span><em>search_function</em><span class="sig-paren">)</span><a class="headerlink" href="#codecs.register" title="本定義的永久連結">¶</a></dt>
<dd><p>Register a codec search function. Search functions are expected to take one
argument, the encoding name in all lower case letters, and return a
<code class="xref py py-class docutils literal notranslate"><span class="pre">CodecInfo</span></code> object having the following attributes:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">name</span></code> The name of the encoding;</li>
<li><code class="docutils literal notranslate"><span class="pre">encode</span></code> The stateless encoding function;</li>
<li><code class="docutils literal notranslate"><span class="pre">decode</span></code> The stateless decoding function;</li>
<li><code class="docutils literal notranslate"><span class="pre">incrementalencoder</span></code> An incremental encoder class or factory function;</li>
<li><code class="docutils literal notranslate"><span class="pre">incrementaldecoder</span></code> An incremental decoder class or factory function;</li>
<li><code class="docutils literal notranslate"><span class="pre">streamwriter</span></code> A stream writer class or factory function;</li>
<li><code class="docutils literal notranslate"><span class="pre">streamreader</span></code> A stream reader class or factory function.</li>
</ul>
<p>The various functions or classes take the following arguments:</p>
<p><em>encode</em> and <em>decode</em>: These must be functions or methods which have the same
interface as the <code class="xref py py-meth docutils literal notranslate"><span class="pre">encode()</span></code>/<code class="xref py py-meth docutils literal notranslate"><span class="pre">decode()</span></code> methods of Codec instances (see
Codec Interface). The functions/methods are expected to work in a stateless
mode.</p>
<p><em>incrementalencoder</em> and <em>incrementaldecoder</em>: These have to be factory
functions providing the following interface:</p>
<p><code class="docutils literal notranslate"><span class="pre">factory(errors='strict')</span></code></p>
<p>The factory functions must return objects providing the interfaces defined by
the base classes <a class="reference internal" href="#codecs.IncrementalEncoder" title="codecs.IncrementalEncoder"><code class="xref py py-class docutils literal notranslate"><span class="pre">IncrementalEncoder</span></code></a> and <a class="reference internal" href="#codecs.IncrementalDecoder" title="codecs.IncrementalDecoder"><code class="xref py py-class docutils literal notranslate"><span class="pre">IncrementalDecoder</span></code></a>,
respectively. Incremental codecs can maintain state.</p>
<p><em>streamreader</em> and <em>streamwriter</em>: These have to be factory functions providing
the following interface:</p>
<p><code class="docutils literal notranslate"><span class="pre">factory(stream,</span> <span class="pre">errors='strict')</span></code></p>
<p>The factory functions must return objects providing the interfaces defined by
the base classes <a class="reference internal" href="#codecs.StreamWriter" title="codecs.StreamWriter"><code class="xref py py-class docutils literal notranslate"><span class="pre">StreamWriter</span></code></a> and <a class="reference internal" href="#codecs.StreamReader" title="codecs.StreamReader"><code class="xref py py-class docutils literal notranslate"><span class="pre">StreamReader</span></code></a>, respectively.
Stream codecs can maintain state.</p>
<p>Possible values for errors are <code class="docutils literal notranslate"><span class="pre">'strict'</span></code> (raise an exception in case of an
encoding error), <code class="docutils literal notranslate"><span class="pre">'replace'</span></code> (replace malformed data with a suitable
replacement marker, such as <code class="docutils literal notranslate"><span class="pre">'?'</span></code>), <code class="docutils literal notranslate"><span class="pre">'ignore'</span></code> (ignore malformed data and
continue without further notice), <code class="docutils literal notranslate"><span class="pre">'xmlcharrefreplace'</span></code> (replace with the
appropriate XML character reference (for encoding only)) and
<code class="docutils literal notranslate"><span class="pre">'backslashreplace'</span></code> (replace with backslashed escape sequences (for encoding
only)) as well as any other error handling name defined via
<a class="reference internal" href="#codecs.register_error" title="codecs.register_error"><code class="xref py py-func docutils literal notranslate"><span class="pre">register_error()</span></code></a>.</p>
<p>In case a search function cannot find a given encoding, it should return
<code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="codecs.lookup">
<code class="descclassname">codecs.</code><code class="descname">lookup</code><span class="sig-paren">(</span><em>encoding</em><span class="sig-paren">)</span><a class="headerlink" href="#codecs.lookup" title="本定義的永久連結">¶</a></dt>
<dd><p>Looks up the codec info in the Python codec registry and returns a
<code class="xref py py-class docutils literal notranslate"><span class="pre">CodecInfo</span></code> object as defined above.</p>
<p>Encodings are first looked up in the registry’s cache. If not found, the list of
registered search functions is scanned. If no <code class="xref py py-class docutils literal notranslate"><span class="pre">CodecInfo</span></code> object is
found, a <a class="reference internal" href="exceptions.html#exceptions.LookupError" title="exceptions.LookupError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">LookupError</span></code></a> is raised. Otherwise, the <code class="xref py py-class docutils literal notranslate"><span class="pre">CodecInfo</span></code> object
is stored in the cache and returned to the caller.</p>
</dd></dl>

<p>To simplify access to the various codecs, the module provides these additional
functions which use <a class="reference internal" href="#codecs.lookup" title="codecs.lookup"><code class="xref py py-func docutils literal notranslate"><span class="pre">lookup()</span></code></a> for the codec lookup:</p>
<dl class="function">
<dt id="codecs.getencoder">
<code class="descclassname">codecs.</code><code class="descname">getencoder</code><span class="sig-paren">(</span><em>encoding</em><span class="sig-paren">)</span><a class="headerlink" href="#codecs.getencoder" title="本定義的永久連結">¶</a></dt>
<dd><p>Look up the codec for the given encoding and return its encoder function.</p>
<p>Raises a <a class="reference internal" href="exceptions.html#exceptions.LookupError" title="exceptions.LookupError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">LookupError</span></code></a> in case the encoding cannot be found.</p>
</dd></dl>

<dl class="function">
<dt id="codecs.getdecoder">
<code class="descclassname">codecs.</code><code class="descname">getdecoder</code><span class="sig-paren">(</span><em>encoding</em><span class="sig-paren">)</span><a class="headerlink" href="#codecs.getdecoder" title="本定義的永久連結">¶</a></dt>
<dd><p>Look up the codec for the given encoding and return its decoder function.</p>
<p>Raises a <a class="reference internal" href="exceptions.html#exceptions.LookupError" title="exceptions.LookupError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">LookupError</span></code></a> in case the encoding cannot be found.</p>
</dd></dl>

<dl class="function">
<dt id="codecs.getincrementalencoder">
<code class="descclassname">codecs.</code><code class="descname">getincrementalencoder</code><span class="sig-paren">(</span><em>encoding</em><span class="sig-paren">)</span><a class="headerlink" href="#codecs.getincrementalencoder" title="本定義的永久連結">¶</a></dt>
<dd><p>Look up the codec for the given encoding and return its incremental encoder
class or factory function.</p>
<p>Raises a <a class="reference internal" href="exceptions.html#exceptions.LookupError" title="exceptions.LookupError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">LookupError</span></code></a> in case the encoding cannot be found or the codec
doesn’t support an incremental encoder.</p>
</dd></dl>

<dl class="function">
<dt id="codecs.getincrementaldecoder">
<code class="descclassname">codecs.</code><code class="descname">getincrementaldecoder</code><span class="sig-paren">(</span><em>encoding</em><span class="sig-paren">)</span><a class="headerlink" href="#codecs.getincrementaldecoder" title="本定義的永久連結">¶</a></dt>
<dd><p>Look up the codec for the given encoding and return its incremental decoder
class or factory function.</p>
<p>Raises a <a class="reference internal" href="exceptions.html#exceptions.LookupError" title="exceptions.LookupError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">LookupError</span></code></a> in case the encoding cannot be found or the codec
doesn’t support an incremental decoder.</p>
</dd></dl>

<dl class="function">
<dt id="codecs.getreader">
<code class="descclassname">codecs.</code><code class="descname">getreader</code><span class="sig-paren">(</span><em>encoding</em><span class="sig-paren">)</span><a class="headerlink" href="#codecs.getreader" title="本定義的永久連結">¶</a></dt>
<dd><p>Look up the codec for the given encoding and return its StreamReader class or
factory function.</p>
<p>Raises a <a class="reference internal" href="exceptions.html#exceptions.LookupError" title="exceptions.LookupError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">LookupError</span></code></a> in case the encoding cannot be found.</p>
</dd></dl>

<dl class="function">
<dt id="codecs.getwriter">
<code class="descclassname">codecs.</code><code class="descname">getwriter</code><span class="sig-paren">(</span><em>encoding</em><span class="sig-paren">)</span><a class="headerlink" href="#codecs.getwriter" title="本定義的永久連結">¶</a></dt>
<dd><p>Look up the codec for the given encoding and return its StreamWriter class or
factory function.</p>
<p>Raises a <a class="reference internal" href="exceptions.html#exceptions.LookupError" title="exceptions.LookupError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">LookupError</span></code></a> in case the encoding cannot be found.</p>
</dd></dl>

<dl class="function">
<dt id="codecs.register_error">
<code class="descclassname">codecs.</code><code class="descname">register_error</code><span class="sig-paren">(</span><em>name</em>, <em>error_handler</em><span class="sig-paren">)</span><a class="headerlink" href="#codecs.register_error" title="本定義的永久連結">¶</a></dt>
<dd><p>Register the error handling function <em>error_handler</em> under the name <em>name</em>.
<em>error_handler</em> will be called during encoding and decoding in case of an error,
when <em>name</em> is specified as the errors parameter.</p>
<p>For encoding <em>error_handler</em> will be called with a <a class="reference internal" href="exceptions.html#exceptions.UnicodeEncodeError" title="exceptions.UnicodeEncodeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">UnicodeEncodeError</span></code></a>
instance, which contains information about the location of the error. The error
handler must either raise this or a different exception or return a tuple with a
replacement for the unencodable part of the input and a position where encoding
should continue. The encoder will encode the replacement and continue encoding
the original input at the specified position. Negative position values will be
treated as being relative to the end of the input string. If the resulting
position is out of bound an <a class="reference internal" href="exceptions.html#exceptions.IndexError" title="exceptions.IndexError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">IndexError</span></code></a> will be raised.</p>
<p>Decoding and translating works similar, except <a class="reference internal" href="exceptions.html#exceptions.UnicodeDecodeError" title="exceptions.UnicodeDecodeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">UnicodeDecodeError</span></code></a> or
<a class="reference internal" href="exceptions.html#exceptions.UnicodeTranslateError" title="exceptions.UnicodeTranslateError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">UnicodeTranslateError</span></code></a> will be passed to the handler and that the
replacement from the error handler will be put into the output directly.</p>
</dd></dl>

<dl class="function">
<dt id="codecs.lookup_error">
<code class="descclassname">codecs.</code><code class="descname">lookup_error</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#codecs.lookup_error" title="本定義的永久連結">¶</a></dt>
<dd><p>Return the error handler previously registered under the name <em>name</em>.</p>
<p>Raises a <a class="reference internal" href="exceptions.html#exceptions.LookupError" title="exceptions.LookupError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">LookupError</span></code></a> in case the handler cannot be found.</p>
</dd></dl>

<dl class="function">
<dt id="codecs.strict_errors">
<code class="descclassname">codecs.</code><code class="descname">strict_errors</code><span class="sig-paren">(</span><em>exception</em><span class="sig-paren">)</span><a class="headerlink" href="#codecs.strict_errors" title="本定義的永久連結">¶</a></dt>
<dd><p>Implements the <code class="docutils literal notranslate"><span class="pre">strict</span></code> error handling.</p>
</dd></dl>

<dl class="function">
<dt id="codecs.replace_errors">
<code class="descclassname">codecs.</code><code class="descname">replace_errors</code><span class="sig-paren">(</span><em>exception</em><span class="sig-paren">)</span><a class="headerlink" href="#codecs.replace_errors" title="本定義的永久連結">¶</a></dt>
<dd><p>Implements the <code class="docutils literal notranslate"><span class="pre">replace</span></code> error handling.</p>
</dd></dl>

<dl class="function">
<dt id="codecs.ignore_errors">
<code class="descclassname">codecs.</code><code class="descname">ignore_errors</code><span class="sig-paren">(</span><em>exception</em><span class="sig-paren">)</span><a class="headerlink" href="#codecs.ignore_errors" title="本定義的永久連結">¶</a></dt>
<dd><p>Implements the <code class="docutils literal notranslate"><span class="pre">ignore</span></code> error handling.</p>
</dd></dl>

<dl class="function">
<dt id="codecs.xmlcharrefreplace_errors">
<code class="descclassname">codecs.</code><code class="descname">xmlcharrefreplace_errors</code><span class="sig-paren">(</span><em>exception</em><span class="sig-paren">)</span><a class="headerlink" href="#codecs.xmlcharrefreplace_errors" title="本定義的永久連結">¶</a></dt>
<dd><p>Implements the <code class="docutils literal notranslate"><span class="pre">xmlcharrefreplace</span></code> error handling.</p>
</dd></dl>

<dl class="function">
<dt id="codecs.backslashreplace_errors">
<code class="descclassname">codecs.</code><code class="descname">backslashreplace_errors</code><span class="sig-paren">(</span><em>exception</em><span class="sig-paren">)</span><a class="headerlink" href="#codecs.backslashreplace_errors" title="本定義的永久連結">¶</a></dt>
<dd><p>Implements the <code class="docutils literal notranslate"><span class="pre">backslashreplace</span></code> error handling.</p>
</dd></dl>

<p>To simplify working with encoded files or stream, the module also defines these
utility functions:</p>
<dl class="function">
<dt id="codecs.open">
<code class="descclassname">codecs.</code><code class="descname">open</code><span class="sig-paren">(</span><em>filename</em>, <em>mode</em><span class="optional">[</span>, <em>encoding</em><span class="optional">[</span>, <em>errors</em><span class="optional">[</span>, <em>buffering</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#codecs.open" title="本定義的永久連結">¶</a></dt>
<dd><p>Open an encoded file using the given <em>mode</em> and return a wrapped version
providing transparent encoding/decoding.  The default file mode is <code class="docutils literal notranslate"><span class="pre">'r'</span></code>
meaning to open the file in read mode.</p>
<div class="admonition note">
<p class="first admonition-title">備註</p>
<p class="last">The wrapped version’s methods will accept and return strings only.  Bytes
arguments will be rejected.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">備註</p>
<p class="last">Files are always opened in binary mode, even if no binary mode was
specified.  This is done to avoid data loss due to encodings using 8-bit
values.  This means that no automatic conversion of <code class="docutils literal notranslate"><span class="pre">b'\n'</span></code> is done
on reading and writing.</p>
</div>
<p><em>encoding</em> specifies the encoding which is to be used for the file.</p>
<p><em>errors</em> may be given to define the error handling. It defaults to <code class="docutils literal notranslate"><span class="pre">'strict'</span></code>
which causes a <a class="reference internal" href="exceptions.html#exceptions.ValueError" title="exceptions.ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a> to be raised in case an encoding error occurs.</p>
<p><em>buffering</em> has the same meaning as for the built-in <a class="reference internal" href="functions.html#open" title="open"><code class="xref py py-func docutils literal notranslate"><span class="pre">open()</span></code></a> function.  It
defaults to line buffered.</p>
</dd></dl>

<dl class="function">
<dt id="codecs.EncodedFile">
<code class="descclassname">codecs.</code><code class="descname">EncodedFile</code><span class="sig-paren">(</span><em>file</em>, <em>input</em><span class="optional">[</span>, <em>output</em><span class="optional">[</span>, <em>errors</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#codecs.EncodedFile" title="本定義的永久連結">¶</a></dt>
<dd><p>Return a wrapped version of file which provides transparent encoding
translation.</p>
<p>Bytes written to the wrapped file are interpreted according to the given
<em>input</em> encoding and then written to the original file as bytes using the
<em>output</em> encoding.</p>
<p>If <em>output</em> is not given, it defaults to <em>input</em>.</p>
<p><em>errors</em> may be given to define the error handling. It defaults to <code class="docutils literal notranslate"><span class="pre">'strict'</span></code>,
which causes <a class="reference internal" href="exceptions.html#exceptions.ValueError" title="exceptions.ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a> to be raised in case an encoding error occurs.</p>
</dd></dl>

<dl class="function">
<dt id="codecs.iterencode">
<code class="descclassname">codecs.</code><code class="descname">iterencode</code><span class="sig-paren">(</span><em>iterable</em>, <em>encoding</em><span class="optional">[</span>, <em>errors</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#codecs.iterencode" title="本定義的永久連結">¶</a></dt>
<dd><p>Uses an incremental encoder to iteratively encode the input provided by
<em>iterable</em>. This function is a <a class="reference internal" href="../glossary.html#term-generator"><span class="xref std std-term">generator</span></a>.  <em>errors</em> (as well as any
other keyword argument) is passed through to the incremental encoder.</p>
</dd></dl>

<dl class="function">
<dt id="codecs.iterdecode">
<code class="descclassname">codecs.</code><code class="descname">iterdecode</code><span class="sig-paren">(</span><em>iterable</em>, <em>encoding</em><span class="optional">[</span>, <em>errors</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#codecs.iterdecode" title="本定義的永久連結">¶</a></dt>
<dd><p>Uses an incremental decoder to iteratively decode the input provided by
<em>iterable</em>. This function is a <a class="reference internal" href="../glossary.html#term-generator"><span class="xref std std-term">generator</span></a>.  <em>errors</em> (as well as any
other keyword argument) is passed through to the incremental decoder.</p>
</dd></dl>

<p>The module also provides the following constants which are useful for reading
and writing to platform dependent files:</p>
<dl class="data">
<dt id="codecs.BOM">
<code class="descclassname">codecs.</code><code class="descname">BOM</code><a class="headerlink" href="#codecs.BOM" title="本定義的永久連結">¶</a></dt>
<dt id="codecs.BOM_BE">
<code class="descclassname">codecs.</code><code class="descname">BOM_BE</code><a class="headerlink" href="#codecs.BOM_BE" title="本定義的永久連結">¶</a></dt>
<dt id="codecs.BOM_LE">
<code class="descclassname">codecs.</code><code class="descname">BOM_LE</code><a class="headerlink" href="#codecs.BOM_LE" title="本定義的永久連結">¶</a></dt>
<dt id="codecs.BOM_UTF8">
<code class="descclassname">codecs.</code><code class="descname">BOM_UTF8</code><a class="headerlink" href="#codecs.BOM_UTF8" title="本定義的永久連結">¶</a></dt>
<dt id="codecs.BOM_UTF16">
<code class="descclassname">codecs.</code><code class="descname">BOM_UTF16</code><a class="headerlink" href="#codecs.BOM_UTF16" title="本定義的永久連結">¶</a></dt>
<dt id="codecs.BOM_UTF16_BE">
<code class="descclassname">codecs.</code><code class="descname">BOM_UTF16_BE</code><a class="headerlink" href="#codecs.BOM_UTF16_BE" title="本定義的永久連結">¶</a></dt>
<dt id="codecs.BOM_UTF16_LE">
<code class="descclassname">codecs.</code><code class="descname">BOM_UTF16_LE</code><a class="headerlink" href="#codecs.BOM_UTF16_LE" title="本定義的永久連結">¶</a></dt>
<dt id="codecs.BOM_UTF32">
<code class="descclassname">codecs.</code><code class="descname">BOM_UTF32</code><a class="headerlink" href="#codecs.BOM_UTF32" title="本定義的永久連結">¶</a></dt>
<dt id="codecs.BOM_UTF32_BE">
<code class="descclassname">codecs.</code><code class="descname">BOM_UTF32_BE</code><a class="headerlink" href="#codecs.BOM_UTF32_BE" title="本定義的永久連結">¶</a></dt>
<dt id="codecs.BOM_UTF32_LE">
<code class="descclassname">codecs.</code><code class="descname">BOM_UTF32_LE</code><a class="headerlink" href="#codecs.BOM_UTF32_LE" title="本定義的永久連結">¶</a></dt>
<dd><p>These constants define various encodings of the Unicode byte order mark (BOM)
used in UTF-16 and UTF-32 data streams to indicate the byte order used in the
stream or file and in UTF-8 as a Unicode signature. <a class="reference internal" href="#codecs.BOM_UTF16" title="codecs.BOM_UTF16"><code class="xref py py-const docutils literal notranslate"><span class="pre">BOM_UTF16</span></code></a> is either
<a class="reference internal" href="#codecs.BOM_UTF16_BE" title="codecs.BOM_UTF16_BE"><code class="xref py py-const docutils literal notranslate"><span class="pre">BOM_UTF16_BE</span></code></a> or <a class="reference internal" href="#codecs.BOM_UTF16_LE" title="codecs.BOM_UTF16_LE"><code class="xref py py-const docutils literal notranslate"><span class="pre">BOM_UTF16_LE</span></code></a> depending on the platform’s
native byte order, <a class="reference internal" href="#codecs.BOM" title="codecs.BOM"><code class="xref py py-const docutils literal notranslate"><span class="pre">BOM</span></code></a> is an alias for <a class="reference internal" href="#codecs.BOM_UTF16" title="codecs.BOM_UTF16"><code class="xref py py-const docutils literal notranslate"><span class="pre">BOM_UTF16</span></code></a>,
<a class="reference internal" href="#codecs.BOM_LE" title="codecs.BOM_LE"><code class="xref py py-const docutils literal notranslate"><span class="pre">BOM_LE</span></code></a> for <a class="reference internal" href="#codecs.BOM_UTF16_LE" title="codecs.BOM_UTF16_LE"><code class="xref py py-const docutils literal notranslate"><span class="pre">BOM_UTF16_LE</span></code></a> and <a class="reference internal" href="#codecs.BOM_BE" title="codecs.BOM_BE"><code class="xref py py-const docutils literal notranslate"><span class="pre">BOM_BE</span></code></a> for
<a class="reference internal" href="#codecs.BOM_UTF16_BE" title="codecs.BOM_UTF16_BE"><code class="xref py py-const docutils literal notranslate"><span class="pre">BOM_UTF16_BE</span></code></a>. The others represent the BOM in UTF-8 and UTF-32
encodings.</p>
</dd></dl>

<div class="section" id="codec-base-classes">
<span id="id1"></span><h2>Codec Base Classes<a class="headerlink" href="#codec-base-classes" title="本標題的永久連結">¶</a></h2>
<p>The <a class="reference internal" href="#module-codecs" title="codecs: Encode and decode data and streams."><code class="xref py py-mod docutils literal notranslate"><span class="pre">codecs</span></code></a> module defines a set of base classes which define the
interface and can also be used to easily write your own codecs for use in
Python.</p>
<p>Each codec has to define four interfaces to make it usable as codec in Python:
stateless encoder, stateless decoder, stream reader and stream writer. The
stream reader and writers typically reuse the stateless encoder/decoder to
implement the file protocols.</p>
<p>The <code class="xref py py-class docutils literal notranslate"><span class="pre">Codec</span></code> class defines the interface for stateless encoders/decoders.</p>
<p>To simplify and standardize error handling, the <code class="xref py py-meth docutils literal notranslate"><span class="pre">encode()</span></code> and
<code class="xref py py-meth docutils literal notranslate"><span class="pre">decode()</span></code> methods may implement different error handling schemes by
providing the <em>errors</em> string argument.  The following string values are defined
and implemented by all standard Python codecs:</p>
<table border="1" class="docutils">
<colgroup>
<col width="35%" />
<col width="65%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Value</th>
<th class="head">Meaning</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">'strict'</span></code></td>
<td>Raise <a class="reference internal" href="exceptions.html#exceptions.UnicodeError" title="exceptions.UnicodeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">UnicodeError</span></code></a> (or a subclass);
this is the default.</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">'ignore'</span></code></td>
<td>Ignore the character and continue with the
next.</td>
</tr>
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">'replace'</span></code></td>
<td>Replace with a suitable replacement
character; Python will use the official
U+FFFD REPLACEMENT CHARACTER for the built-in
Unicode codecs on decoding and 『?』 on
encoding.</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">'xmlcharrefreplace'</span></code></td>
<td>Replace with the appropriate XML character
reference (only for encoding).</td>
</tr>
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">'backslashreplace'</span></code></td>
<td>Replace with backslashed escape sequences
(only for encoding).</td>
</tr>
</tbody>
</table>
<p>The set of allowed values can be extended via <a class="reference internal" href="#codecs.register_error" title="codecs.register_error"><code class="xref py py-meth docutils literal notranslate"><span class="pre">register_error()</span></code></a>.</p>
<div class="section" id="codec-objects">
<span id="id2"></span><h3>Codec Objects<a class="headerlink" href="#codec-objects" title="本標題的永久連結">¶</a></h3>
<p>The <code class="xref py py-class docutils literal notranslate"><span class="pre">Codec</span></code> class defines these methods which also define the function
interfaces of the stateless encoder and decoder:</p>
<dl class="method">
<dt id="codecs.Codec.encode">
<code class="descclassname">Codec.</code><code class="descname">encode</code><span class="sig-paren">(</span><em>input</em><span class="optional">[</span>, <em>errors</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#codecs.Codec.encode" title="本定義的永久連結">¶</a></dt>
<dd><p>Encodes the object <em>input</em> and returns a tuple (output object, length consumed).
Encoding converts a string object to a bytes object using a particular
character set encoding (e.g., <code class="docutils literal notranslate"><span class="pre">cp1252</span></code> or <code class="docutils literal notranslate"><span class="pre">iso-8859-1</span></code>).</p>
<p><em>errors</em> defines the error handling to apply. It defaults to <code class="docutils literal notranslate"><span class="pre">'strict'</span></code>
handling.</p>
<p>The method may not store state in the <code class="xref py py-class docutils literal notranslate"><span class="pre">Codec</span></code> instance. Use
<code class="xref py py-class docutils literal notranslate"><span class="pre">StreamCodec</span></code> for codecs which have to keep state in order to make
encoding/decoding efficient.</p>
<p>The encoder must be able to handle zero length input and return an empty object
of the output object type in this situation.</p>
</dd></dl>

<dl class="method">
<dt id="codecs.Codec.decode">
<code class="descclassname">Codec.</code><code class="descname">decode</code><span class="sig-paren">(</span><em>input</em><span class="optional">[</span>, <em>errors</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#codecs.Codec.decode" title="本定義的永久連結">¶</a></dt>
<dd><p>Decodes the object <em>input</em> and returns a tuple (output object, length
consumed).  Decoding converts a bytes object encoded using a particular
character set encoding to a string object.</p>
<p><em>input</em> must be a bytes object or one which provides the read-only character
buffer interface – for example, buffer objects and memory mapped files.</p>
<p><em>errors</em> defines the error handling to apply. It defaults to <code class="docutils literal notranslate"><span class="pre">'strict'</span></code>
handling.</p>
<p>The method may not store state in the <code class="xref py py-class docutils literal notranslate"><span class="pre">Codec</span></code> instance. Use
<code class="xref py py-class docutils literal notranslate"><span class="pre">StreamCodec</span></code> for codecs which have to keep state in order to make
encoding/decoding efficient.</p>
<p>The decoder must be able to handle zero length input and return an empty object
of the output object type in this situation.</p>
</dd></dl>

<p>The <a class="reference internal" href="#codecs.IncrementalEncoder" title="codecs.IncrementalEncoder"><code class="xref py py-class docutils literal notranslate"><span class="pre">IncrementalEncoder</span></code></a> and <a class="reference internal" href="#codecs.IncrementalDecoder" title="codecs.IncrementalDecoder"><code class="xref py py-class docutils literal notranslate"><span class="pre">IncrementalDecoder</span></code></a> classes provide
the basic interface for incremental encoding and decoding. Encoding/decoding the
input isn’t done with one call to the stateless encoder/decoder function, but
with multiple calls to the <code class="xref py py-meth docutils literal notranslate"><span class="pre">encode()</span></code>/<code class="xref py py-meth docutils literal notranslate"><span class="pre">decode()</span></code> method of the
incremental encoder/decoder. The incremental encoder/decoder keeps track of the
encoding/decoding process during method calls.</p>
<p>The joined output of calls to the <code class="xref py py-meth docutils literal notranslate"><span class="pre">encode()</span></code>/<code class="xref py py-meth docutils literal notranslate"><span class="pre">decode()</span></code> method is the
same as if all the single inputs were joined into one, and this input was
encoded/decoded with the stateless encoder/decoder.</p>
</div>
<div class="section" id="incrementalencoder-objects">
<span id="incremental-encoder-objects"></span><h3>IncrementalEncoder Objects<a class="headerlink" href="#incrementalencoder-objects" title="本標題的永久連結">¶</a></h3>
<p>The <a class="reference internal" href="#codecs.IncrementalEncoder" title="codecs.IncrementalEncoder"><code class="xref py py-class docutils literal notranslate"><span class="pre">IncrementalEncoder</span></code></a> class is used for encoding an input in multiple
steps. It defines the following methods which every incremental encoder must
define in order to be compatible with the Python codec registry.</p>
<dl class="class">
<dt id="codecs.IncrementalEncoder">
<em class="property">class </em><code class="descclassname">codecs.</code><code class="descname">IncrementalEncoder</code><span class="sig-paren">(</span><span class="optional">[</span><em>errors</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#codecs.IncrementalEncoder" title="本定義的永久連結">¶</a></dt>
<dd><p>Constructor for an <a class="reference internal" href="#codecs.IncrementalEncoder" title="codecs.IncrementalEncoder"><code class="xref py py-class docutils literal notranslate"><span class="pre">IncrementalEncoder</span></code></a> instance.</p>
<p>All incremental encoders must provide this constructor interface. They are free
to add additional keyword arguments, but only the ones defined here are used by
the Python codec registry.</p>
<p>The <a class="reference internal" href="#codecs.IncrementalEncoder" title="codecs.IncrementalEncoder"><code class="xref py py-class docutils literal notranslate"><span class="pre">IncrementalEncoder</span></code></a> may implement different error handling schemes
by providing the <em>errors</em> keyword argument. These parameters are predefined:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">'strict'</span></code> Raise <a class="reference internal" href="exceptions.html#exceptions.ValueError" title="exceptions.ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a> (or a subclass); this is the default.</li>
<li><code class="docutils literal notranslate"><span class="pre">'ignore'</span></code> Ignore the character and continue with the next.</li>
<li><code class="docutils literal notranslate"><span class="pre">'replace'</span></code> Replace with a suitable replacement character</li>
<li><code class="docutils literal notranslate"><span class="pre">'xmlcharrefreplace'</span></code> Replace with the appropriate XML character reference</li>
<li><code class="docutils literal notranslate"><span class="pre">'backslashreplace'</span></code> Replace with backslashed escape sequences.</li>
</ul>
<p>The <em>errors</em> argument will be assigned to an attribute of the same name.
Assigning to this attribute makes it possible to switch between different error
handling strategies during the lifetime of the <a class="reference internal" href="#codecs.IncrementalEncoder" title="codecs.IncrementalEncoder"><code class="xref py py-class docutils literal notranslate"><span class="pre">IncrementalEncoder</span></code></a>
object.</p>
<p>The set of allowed values for the <em>errors</em> argument can be extended with
<a class="reference internal" href="#codecs.register_error" title="codecs.register_error"><code class="xref py py-func docutils literal notranslate"><span class="pre">register_error()</span></code></a>.</p>
<dl class="method">
<dt id="codecs.IncrementalEncoder.encode">
<code class="descname">encode</code><span class="sig-paren">(</span><em>object</em><span class="optional">[</span>, <em>final</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#codecs.IncrementalEncoder.encode" title="本定義的永久連結">¶</a></dt>
<dd><p>Encodes <em>object</em> (taking the current state of the encoder into account)
and returns the resulting encoded object. If this is the last call to
<a class="reference internal" href="#codecs.IncrementalEncoder.encode" title="codecs.IncrementalEncoder.encode"><code class="xref py py-meth docutils literal notranslate"><span class="pre">encode()</span></code></a> <em>final</em> must be true (the default is false).</p>
</dd></dl>

<dl class="method">
<dt id="codecs.IncrementalEncoder.reset">
<code class="descname">reset</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#codecs.IncrementalEncoder.reset" title="本定義的永久連結">¶</a></dt>
<dd><p>Reset the encoder to the initial state.</p>
</dd></dl>

</dd></dl>

<dl class="method">
<dt id="codecs.IncrementalEncoder.getstate">
<code class="descclassname">IncrementalEncoder.</code><code class="descname">getstate</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#codecs.IncrementalEncoder.getstate" title="本定義的永久連結">¶</a></dt>
<dd><p>Return the current state of the encoder which must be an integer. The
implementation should make sure that <code class="docutils literal notranslate"><span class="pre">0</span></code> is the most common state. (States
that are more complicated than integers can be converted into an integer by
marshaling/pickling the state and encoding the bytes of the resulting string
into an integer).</p>
</dd></dl>

<dl class="method">
<dt id="codecs.IncrementalEncoder.setstate">
<code class="descclassname">IncrementalEncoder.</code><code class="descname">setstate</code><span class="sig-paren">(</span><em>state</em><span class="sig-paren">)</span><a class="headerlink" href="#codecs.IncrementalEncoder.setstate" title="本定義的永久連結">¶</a></dt>
<dd><p>Set the state of the encoder to <em>state</em>. <em>state</em> must be an encoder state
returned by <a class="reference internal" href="#codecs.IncrementalEncoder.getstate" title="codecs.IncrementalEncoder.getstate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">getstate()</span></code></a>.</p>
</dd></dl>

</div>
<div class="section" id="incrementaldecoder-objects">
<span id="incremental-decoder-objects"></span><h3>IncrementalDecoder Objects<a class="headerlink" href="#incrementaldecoder-objects" title="本標題的永久連結">¶</a></h3>
<p>The <a class="reference internal" href="#codecs.IncrementalDecoder" title="codecs.IncrementalDecoder"><code class="xref py py-class docutils literal notranslate"><span class="pre">IncrementalDecoder</span></code></a> class is used for decoding an input in multiple
steps. It defines the following methods which every incremental decoder must
define in order to be compatible with the Python codec registry.</p>
<dl class="class">
<dt id="codecs.IncrementalDecoder">
<em class="property">class </em><code class="descclassname">codecs.</code><code class="descname">IncrementalDecoder</code><span class="sig-paren">(</span><span class="optional">[</span><em>errors</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#codecs.IncrementalDecoder" title="本定義的永久連結">¶</a></dt>
<dd><p>Constructor for an <a class="reference internal" href="#codecs.IncrementalDecoder" title="codecs.IncrementalDecoder"><code class="xref py py-class docutils literal notranslate"><span class="pre">IncrementalDecoder</span></code></a> instance.</p>
<p>All incremental decoders must provide this constructor interface. They are free
to add additional keyword arguments, but only the ones defined here are used by
the Python codec registry.</p>
<p>The <a class="reference internal" href="#codecs.IncrementalDecoder" title="codecs.IncrementalDecoder"><code class="xref py py-class docutils literal notranslate"><span class="pre">IncrementalDecoder</span></code></a> may implement different error handling schemes
by providing the <em>errors</em> keyword argument. These parameters are predefined:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">'strict'</span></code> Raise <a class="reference internal" href="exceptions.html#exceptions.ValueError" title="exceptions.ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a> (or a subclass); this is the default.</li>
<li><code class="docutils literal notranslate"><span class="pre">'ignore'</span></code> Ignore the character and continue with the next.</li>
<li><code class="docutils literal notranslate"><span class="pre">'replace'</span></code> Replace with a suitable replacement character.</li>
</ul>
<p>The <em>errors</em> argument will be assigned to an attribute of the same name.
Assigning to this attribute makes it possible to switch between different error
handling strategies during the lifetime of the <a class="reference internal" href="#codecs.IncrementalDecoder" title="codecs.IncrementalDecoder"><code class="xref py py-class docutils literal notranslate"><span class="pre">IncrementalDecoder</span></code></a>
object.</p>
<p>The set of allowed values for the <em>errors</em> argument can be extended with
<a class="reference internal" href="#codecs.register_error" title="codecs.register_error"><code class="xref py py-func docutils literal notranslate"><span class="pre">register_error()</span></code></a>.</p>
<dl class="method">
<dt id="codecs.IncrementalDecoder.decode">
<code class="descname">decode</code><span class="sig-paren">(</span><em>object</em><span class="optional">[</span>, <em>final</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#codecs.IncrementalDecoder.decode" title="本定義的永久連結">¶</a></dt>
<dd><p>Decodes <em>object</em> (taking the current state of the decoder into account)
and returns the resulting decoded object. If this is the last call to
<a class="reference internal" href="#codecs.IncrementalDecoder.decode" title="codecs.IncrementalDecoder.decode"><code class="xref py py-meth docutils literal notranslate"><span class="pre">decode()</span></code></a> <em>final</em> must be true (the default is false). If <em>final</em> is
true the decoder must decode the input completely and must flush all
buffers. If this isn’t possible (e.g. because of incomplete byte sequences
at the end of the input) it must initiate error handling just like in the
stateless case (which might raise an exception).</p>
</dd></dl>

<dl class="method">
<dt id="codecs.IncrementalDecoder.reset">
<code class="descname">reset</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#codecs.IncrementalDecoder.reset" title="本定義的永久連結">¶</a></dt>
<dd><p>Reset the decoder to the initial state.</p>
</dd></dl>

<dl class="method">
<dt id="codecs.IncrementalDecoder.getstate">
<code class="descname">getstate</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#codecs.IncrementalDecoder.getstate" title="本定義的永久連結">¶</a></dt>
<dd><p>Return the current state of the decoder. This must be a tuple with two
items, the first must be the buffer containing the still undecoded
input. The second must be an integer and can be additional state
info. (The implementation should make sure that <code class="docutils literal notranslate"><span class="pre">0</span></code> is the most common
additional state info.) If this additional state info is <code class="docutils literal notranslate"><span class="pre">0</span></code> it must be
possible to set the decoder to the state which has no input buffered and
<code class="docutils literal notranslate"><span class="pre">0</span></code> as the additional state info, so that feeding the previously
buffered input to the decoder returns it to the previous state without
producing any output. (Additional state info that is more complicated than
integers can be converted into an integer by marshaling/pickling the info
and encoding the bytes of the resulting string into an integer.)</p>
</dd></dl>

<dl class="method">
<dt id="codecs.IncrementalDecoder.setstate">
<code class="descname">setstate</code><span class="sig-paren">(</span><em>state</em><span class="sig-paren">)</span><a class="headerlink" href="#codecs.IncrementalDecoder.setstate" title="本定義的永久連結">¶</a></dt>
<dd><p>Set the state of the encoder to <em>state</em>. <em>state</em> must be a decoder state
returned by <a class="reference internal" href="#codecs.IncrementalDecoder.getstate" title="codecs.IncrementalDecoder.getstate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">getstate()</span></code></a>.</p>
</dd></dl>

</dd></dl>

<p>The <a class="reference internal" href="#codecs.StreamWriter" title="codecs.StreamWriter"><code class="xref py py-class docutils literal notranslate"><span class="pre">StreamWriter</span></code></a> and <a class="reference internal" href="#codecs.StreamReader" title="codecs.StreamReader"><code class="xref py py-class docutils literal notranslate"><span class="pre">StreamReader</span></code></a> classes provide generic
working interfaces which can be used to implement new encoding submodules very
easily. See <code class="xref py py-mod docutils literal notranslate"><span class="pre">encodings.utf_8</span></code> for an example of how this is done.</p>
</div>
<div class="section" id="streamwriter-objects">
<span id="stream-writer-objects"></span><h3>StreamWriter Objects<a class="headerlink" href="#streamwriter-objects" title="本標題的永久連結">¶</a></h3>
<p>The <a class="reference internal" href="#codecs.StreamWriter" title="codecs.StreamWriter"><code class="xref py py-class docutils literal notranslate"><span class="pre">StreamWriter</span></code></a> class is a subclass of <code class="xref py py-class docutils literal notranslate"><span class="pre">Codec</span></code> and defines the
following methods which every stream writer must define in order to be
compatible with the Python codec registry.</p>
<dl class="class">
<dt id="codecs.StreamWriter">
<em class="property">class </em><code class="descclassname">codecs.</code><code class="descname">StreamWriter</code><span class="sig-paren">(</span><em>stream</em><span class="optional">[</span>, <em>errors</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#codecs.StreamWriter" title="本定義的永久連結">¶</a></dt>
<dd><p>Constructor for a <a class="reference internal" href="#codecs.StreamWriter" title="codecs.StreamWriter"><code class="xref py py-class docutils literal notranslate"><span class="pre">StreamWriter</span></code></a> instance.</p>
<p>All stream writers must provide this constructor interface. They are free to add
additional keyword arguments, but only the ones defined here are used by the
Python codec registry.</p>
<p><em>stream</em> must be a file-like object open for writing binary data.</p>
<p>The <a class="reference internal" href="#codecs.StreamWriter" title="codecs.StreamWriter"><code class="xref py py-class docutils literal notranslate"><span class="pre">StreamWriter</span></code></a> may implement different error handling schemes by
providing the <em>errors</em> keyword argument. These parameters are predefined:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">'strict'</span></code> Raise <a class="reference internal" href="exceptions.html#exceptions.ValueError" title="exceptions.ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a> (or a subclass); this is the default.</li>
<li><code class="docutils literal notranslate"><span class="pre">'ignore'</span></code> Ignore the character and continue with the next.</li>
<li><code class="docutils literal notranslate"><span class="pre">'replace'</span></code> Replace with a suitable replacement character</li>
<li><code class="docutils literal notranslate"><span class="pre">'xmlcharrefreplace'</span></code> Replace with the appropriate XML character reference</li>
<li><code class="docutils literal notranslate"><span class="pre">'backslashreplace'</span></code> Replace with backslashed escape sequences.</li>
</ul>
<p>The <em>errors</em> argument will be assigned to an attribute of the same name.
Assigning to this attribute makes it possible to switch between different error
handling strategies during the lifetime of the <a class="reference internal" href="#codecs.StreamWriter" title="codecs.StreamWriter"><code class="xref py py-class docutils literal notranslate"><span class="pre">StreamWriter</span></code></a> object.</p>
<p>The set of allowed values for the <em>errors</em> argument can be extended with
<a class="reference internal" href="#codecs.register_error" title="codecs.register_error"><code class="xref py py-func docutils literal notranslate"><span class="pre">register_error()</span></code></a>.</p>
<dl class="method">
<dt id="codecs.StreamWriter.write">
<code class="descname">write</code><span class="sig-paren">(</span><em>object</em><span class="sig-paren">)</span><a class="headerlink" href="#codecs.StreamWriter.write" title="本定義的永久連結">¶</a></dt>
<dd><p>Writes the object’s contents encoded to the stream.</p>
</dd></dl>

<dl class="method">
<dt id="codecs.StreamWriter.writelines">
<code class="descname">writelines</code><span class="sig-paren">(</span><em>list</em><span class="sig-paren">)</span><a class="headerlink" href="#codecs.StreamWriter.writelines" title="本定義的永久連結">¶</a></dt>
<dd><p>Writes the concatenated list of strings to the stream (possibly by reusing
the <a class="reference internal" href="#codecs.StreamWriter.write" title="codecs.StreamWriter.write"><code class="xref py py-meth docutils literal notranslate"><span class="pre">write()</span></code></a> method).</p>
</dd></dl>

<dl class="method">
<dt id="codecs.StreamWriter.reset">
<code class="descname">reset</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#codecs.StreamWriter.reset" title="本定義的永久連結">¶</a></dt>
<dd><p>Flushes and resets the codec buffers used for keeping state.</p>
<p>Calling this method should ensure that the data on the output is put into
a clean state that allows appending of new fresh data without having to
rescan the whole stream to recover state.</p>
</dd></dl>

</dd></dl>

<p>In addition to the above methods, the <a class="reference internal" href="#codecs.StreamWriter" title="codecs.StreamWriter"><code class="xref py py-class docutils literal notranslate"><span class="pre">StreamWriter</span></code></a> must also inherit
all other methods and attributes from the underlying stream.</p>
</div>
<div class="section" id="streamreader-objects">
<span id="stream-reader-objects"></span><h3>StreamReader Objects<a class="headerlink" href="#streamreader-objects" title="本標題的永久連結">¶</a></h3>
<p>The <a class="reference internal" href="#codecs.StreamReader" title="codecs.StreamReader"><code class="xref py py-class docutils literal notranslate"><span class="pre">StreamReader</span></code></a> class is a subclass of <code class="xref py py-class docutils literal notranslate"><span class="pre">Codec</span></code> and defines the
following methods which every stream reader must define in order to be
compatible with the Python codec registry.</p>
<dl class="class">
<dt id="codecs.StreamReader">
<em class="property">class </em><code class="descclassname">codecs.</code><code class="descname">StreamReader</code><span class="sig-paren">(</span><em>stream</em><span class="optional">[</span>, <em>errors</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#codecs.StreamReader" title="本定義的永久連結">¶</a></dt>
<dd><p>Constructor for a <a class="reference internal" href="#codecs.StreamReader" title="codecs.StreamReader"><code class="xref py py-class docutils literal notranslate"><span class="pre">StreamReader</span></code></a> instance.</p>
<p>All stream readers must provide this constructor interface. They are free to add
additional keyword arguments, but only the ones defined here are used by the
Python codec registry.</p>
<p><em>stream</em> must be a file-like object open for reading (binary) data.</p>
<p>The <a class="reference internal" href="#codecs.StreamReader" title="codecs.StreamReader"><code class="xref py py-class docutils literal notranslate"><span class="pre">StreamReader</span></code></a> may implement different error handling schemes by
providing the <em>errors</em> keyword argument. These parameters are defined:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">'strict'</span></code> Raise <a class="reference internal" href="exceptions.html#exceptions.ValueError" title="exceptions.ValueError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code></a> (or a subclass); this is the default.</li>
<li><code class="docutils literal notranslate"><span class="pre">'ignore'</span></code> Ignore the character and continue with the next.</li>
<li><code class="docutils literal notranslate"><span class="pre">'replace'</span></code> Replace with a suitable replacement character.</li>
</ul>
<p>The <em>errors</em> argument will be assigned to an attribute of the same name.
Assigning to this attribute makes it possible to switch between different error
handling strategies during the lifetime of the <a class="reference internal" href="#codecs.StreamReader" title="codecs.StreamReader"><code class="xref py py-class docutils literal notranslate"><span class="pre">StreamReader</span></code></a> object.</p>
<p>The set of allowed values for the <em>errors</em> argument can be extended with
<a class="reference internal" href="#codecs.register_error" title="codecs.register_error"><code class="xref py py-func docutils literal notranslate"><span class="pre">register_error()</span></code></a>.</p>
<dl class="method">
<dt id="codecs.StreamReader.read">
<code class="descname">read</code><span class="sig-paren">(</span><span class="optional">[</span><em>size</em><span class="optional">[</span>, <em>chars</em><span class="optional">[</span>, <em>firstline</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#codecs.StreamReader.read" title="本定義的永久連結">¶</a></dt>
<dd><p>Decodes data from the stream and returns the resulting object.</p>
<p><em>chars</em> indicates the number of characters to read from the
stream. <a class="reference internal" href="#codecs.StreamReader.read" title="codecs.StreamReader.read"><code class="xref py py-func docutils literal notranslate"><span class="pre">read()</span></code></a> will never return more than <em>chars</em> characters, but
it might return less, if there are not enough characters available.</p>
<p><em>size</em> indicates the approximate maximum number of bytes to read from the
stream for decoding purposes. The decoder can modify this setting as
appropriate. The default value -1 indicates to read and decode as much as
possible.  <em>size</em> is intended to prevent having to decode huge files in
one step.</p>
<p><em>firstline</em> indicates that it would be sufficient to only return the first
line, if there are decoding errors on later lines.</p>
<p>The method should use a greedy read strategy meaning that it should read
as much data as is allowed within the definition of the encoding and the
given size, e.g.  if optional encoding endings or state markers are
available on the stream, these should be read too.</p>
</dd></dl>

<dl class="method">
<dt id="codecs.StreamReader.readline">
<code class="descname">readline</code><span class="sig-paren">(</span><span class="optional">[</span><em>size</em><span class="optional">[</span>, <em>keepends</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#codecs.StreamReader.readline" title="本定義的永久連結">¶</a></dt>
<dd><p>Read one line from the input stream and return the decoded data.</p>
<p><em>size</em>, if given, is passed as size argument to the stream’s
<a class="reference internal" href="readline.html#module-readline" title="readline: GNU readline support for Python. (Unix)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">readline()</span></code></a> method.</p>
<p>If <em>keepends</em> is false line-endings will be stripped from the lines
returned.</p>
</dd></dl>

<dl class="method">
<dt id="codecs.StreamReader.readlines">
<code class="descname">readlines</code><span class="sig-paren">(</span><span class="optional">[</span><em>sizehint</em><span class="optional">[</span>, <em>keepends</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#codecs.StreamReader.readlines" title="本定義的永久連結">¶</a></dt>
<dd><p>Read all lines available on the input stream and return them as a list of
lines.</p>
<p>Line-endings are implemented using the codec’s decoder method and are
included in the list entries if <em>keepends</em> is true.</p>
<p><em>sizehint</em>, if given, is passed as the <em>size</em> argument to the stream’s
<a class="reference internal" href="#codecs.StreamReader.read" title="codecs.StreamReader.read"><code class="xref py py-meth docutils literal notranslate"><span class="pre">read()</span></code></a> method.</p>
</dd></dl>

<dl class="method">
<dt id="codecs.StreamReader.reset">
<code class="descname">reset</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#codecs.StreamReader.reset" title="本定義的永久連結">¶</a></dt>
<dd><p>Resets the codec buffers used for keeping state.</p>
<p>Note that no stream repositioning should take place.  This method is
primarily intended to be able to recover from decoding errors.</p>
</dd></dl>

</dd></dl>

<p>In addition to the above methods, the <a class="reference internal" href="#codecs.StreamReader" title="codecs.StreamReader"><code class="xref py py-class docutils literal notranslate"><span class="pre">StreamReader</span></code></a> must also inherit
all other methods and attributes from the underlying stream.</p>
<p>The next two base classes are included for convenience. They are not needed by
the codec registry, but may provide useful in practice.</p>
</div>
<div class="section" id="streamreaderwriter-objects">
<span id="stream-reader-writer"></span><h3>StreamReaderWriter Objects<a class="headerlink" href="#streamreaderwriter-objects" title="本標題的永久連結">¶</a></h3>
<p>The <a class="reference internal" href="#codecs.StreamReaderWriter" title="codecs.StreamReaderWriter"><code class="xref py py-class docutils literal notranslate"><span class="pre">StreamReaderWriter</span></code></a> allows wrapping streams which work in both read
and write modes.</p>
<p>The design is such that one can use the factory functions returned by the
<a class="reference internal" href="#codecs.lookup" title="codecs.lookup"><code class="xref py py-func docutils literal notranslate"><span class="pre">lookup()</span></code></a> function to construct the instance.</p>
<dl class="class">
<dt id="codecs.StreamReaderWriter">
<em class="property">class </em><code class="descclassname">codecs.</code><code class="descname">StreamReaderWriter</code><span class="sig-paren">(</span><em>stream</em>, <em>Reader</em>, <em>Writer</em>, <em>errors</em><span class="sig-paren">)</span><a class="headerlink" href="#codecs.StreamReaderWriter" title="本定義的永久連結">¶</a></dt>
<dd><p>Creates a <a class="reference internal" href="#codecs.StreamReaderWriter" title="codecs.StreamReaderWriter"><code class="xref py py-class docutils literal notranslate"><span class="pre">StreamReaderWriter</span></code></a> instance. <em>stream</em> must be a file-like
object. <em>Reader</em> and <em>Writer</em> must be factory functions or classes providing the
<a class="reference internal" href="#codecs.StreamReader" title="codecs.StreamReader"><code class="xref py py-class docutils literal notranslate"><span class="pre">StreamReader</span></code></a> and <a class="reference internal" href="#codecs.StreamWriter" title="codecs.StreamWriter"><code class="xref py py-class docutils literal notranslate"><span class="pre">StreamWriter</span></code></a> interface resp. Error handling
is done in the same way as defined for the stream readers and writers.</p>
</dd></dl>

<p><a class="reference internal" href="#codecs.StreamReaderWriter" title="codecs.StreamReaderWriter"><code class="xref py py-class docutils literal notranslate"><span class="pre">StreamReaderWriter</span></code></a> instances define the combined interfaces of
<a class="reference internal" href="#codecs.StreamReader" title="codecs.StreamReader"><code class="xref py py-class docutils literal notranslate"><span class="pre">StreamReader</span></code></a> and <a class="reference internal" href="#codecs.StreamWriter" title="codecs.StreamWriter"><code class="xref py py-class docutils literal notranslate"><span class="pre">StreamWriter</span></code></a> classes. They inherit all other
methods and attributes from the underlying stream.</p>
</div>
<div class="section" id="streamrecoder-objects">
<span id="stream-recoder-objects"></span><h3>StreamRecoder Objects<a class="headerlink" href="#streamrecoder-objects" title="本標題的永久連結">¶</a></h3>
<p>The <a class="reference internal" href="#codecs.StreamRecoder" title="codecs.StreamRecoder"><code class="xref py py-class docutils literal notranslate"><span class="pre">StreamRecoder</span></code></a> provide a frontend - backend view of encoding data
which is sometimes useful when dealing with different encoding environments.</p>
<p>The design is such that one can use the factory functions returned by the
<a class="reference internal" href="#codecs.lookup" title="codecs.lookup"><code class="xref py py-func docutils literal notranslate"><span class="pre">lookup()</span></code></a> function to construct the instance.</p>
<dl class="class">
<dt id="codecs.StreamRecoder">
<em class="property">class </em><code class="descclassname">codecs.</code><code class="descname">StreamRecoder</code><span class="sig-paren">(</span><em>stream</em>, <em>encode</em>, <em>decode</em>, <em>Reader</em>, <em>Writer</em>, <em>errors</em><span class="sig-paren">)</span><a class="headerlink" href="#codecs.StreamRecoder" title="本定義的永久連結">¶</a></dt>
<dd><p>Creates a <a class="reference internal" href="#codecs.StreamRecoder" title="codecs.StreamRecoder"><code class="xref py py-class docutils literal notranslate"><span class="pre">StreamRecoder</span></code></a> instance which implements a two-way conversion:
<em>encode</em> and <em>decode</em> work on the frontend (the input to <code class="xref py py-meth docutils literal notranslate"><span class="pre">read()</span></code> and output
of <code class="xref py py-meth docutils literal notranslate"><span class="pre">write()</span></code>) while <em>Reader</em> and <em>Writer</em> work on the backend (reading and
writing to the stream).</p>
<p>You can use these objects to do transparent direct recodings from e.g. Latin-1
to UTF-8 and back.</p>
<p><em>stream</em> must be a file-like object.</p>
<p><em>encode</em>, <em>decode</em> must adhere to the <code class="xref py py-class docutils literal notranslate"><span class="pre">Codec</span></code> interface. <em>Reader</em>,
<em>Writer</em> must be factory functions or classes providing objects of the
<a class="reference internal" href="#codecs.StreamReader" title="codecs.StreamReader"><code class="xref py py-class docutils literal notranslate"><span class="pre">StreamReader</span></code></a> and <a class="reference internal" href="#codecs.StreamWriter" title="codecs.StreamWriter"><code class="xref py py-class docutils literal notranslate"><span class="pre">StreamWriter</span></code></a> interface respectively.</p>
<p><em>encode</em> and <em>decode</em> are needed for the frontend translation, <em>Reader</em> and
<em>Writer</em> for the backend translation.</p>
<p>Error handling is done in the same way as defined for the stream readers and
writers.</p>
</dd></dl>

<p><a class="reference internal" href="#codecs.StreamRecoder" title="codecs.StreamRecoder"><code class="xref py py-class docutils literal notranslate"><span class="pre">StreamRecoder</span></code></a> instances define the combined interfaces of
<a class="reference internal" href="#codecs.StreamReader" title="codecs.StreamReader"><code class="xref py py-class docutils literal notranslate"><span class="pre">StreamReader</span></code></a> and <a class="reference internal" href="#codecs.StreamWriter" title="codecs.StreamWriter"><code class="xref py py-class docutils literal notranslate"><span class="pre">StreamWriter</span></code></a> classes. They inherit all other
methods and attributes from the underlying stream.</p>
</div>
</div>
<div class="section" id="encodings-and-unicode">
<span id="encodings-overview"></span><h2>Encodings and Unicode<a class="headerlink" href="#encodings-and-unicode" title="本標題的永久連結">¶</a></h2>
<p>Strings are stored internally as sequences of codepoints (to be precise
as <a href="#id3"><span class="problematic" id="id4">:ctype:`Py_UNICODE`</span></a> arrays). Depending on the way Python is compiled (either
via <code class="xref std std-option docutils literal notranslate"><span class="pre">--without-wide-unicode</span></code> or <code class="xref std std-option docutils literal notranslate"><span class="pre">--with-wide-unicode</span></code>, with the
former being the default) <a href="#id5"><span class="problematic" id="id6">:ctype:`Py_UNICODE`</span></a> is either a 16-bit or 32-bit data
type. Once a string object is used outside of CPU and memory, CPU endianness
and how these arrays are stored as bytes become an issue.  Transforming a
string object into a sequence of bytes is called encoding and recreating the
string object from the sequence of bytes is known as decoding.  There are many
different methods for how this transformation can be done (these methods are
also called encodings). The simplest method is to map the codepoints 0-255 to
the bytes <code class="docutils literal notranslate"><span class="pre">0x0</span></code>-<code class="docutils literal notranslate"><span class="pre">0xff</span></code>. This means that a string object that contains
codepoints above <code class="docutils literal notranslate"><span class="pre">U+00FF</span></code> can’t be encoded with this method (which is called
<code class="docutils literal notranslate"><span class="pre">'latin-1'</span></code> or <code class="docutils literal notranslate"><span class="pre">'iso-8859-1'</span></code>). <a class="reference internal" href="stdtypes.html#str.encode" title="str.encode"><code class="xref py py-func docutils literal notranslate"><span class="pre">str.encode()</span></code></a> will raise a
<a class="reference internal" href="exceptions.html#exceptions.UnicodeEncodeError" title="exceptions.UnicodeEncodeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">UnicodeEncodeError</span></code></a> that looks like this: <code class="docutils literal notranslate"><span class="pre">UnicodeEncodeError:</span> <span class="pre">'latin-1'</span>
<span class="pre">codec</span> <span class="pre">can't</span> <span class="pre">encode</span> <span class="pre">character</span> <span class="pre">'\u1234'</span> <span class="pre">in</span> <span class="pre">position</span> <span class="pre">3:</span> <span class="pre">ordinal</span> <span class="pre">not</span> <span class="pre">in</span>
<span class="pre">range(256)</span></code>.</p>
<p>There’s another group of encodings (the so called charmap encodings) that choose
a different subset of all Unicode code points and how these codepoints are
mapped to the bytes <code class="docutils literal notranslate"><span class="pre">0x0</span></code>-<code class="docutils literal notranslate"><span class="pre">0xff</span></code>. To see how this is done simply open
e.g. <code class="file docutils literal notranslate"><span class="pre">encodings/cp1252.py</span></code> (which is an encoding that is used primarily on
Windows). There’s a string constant with 256 characters that shows you which
character is mapped to which byte value.</p>
<p>All of these encodings can only encode 256 of the 65536 (or 1114111) codepoints
defined in Unicode. A simple and straightforward way that can store each Unicode
code point, is to store each codepoint as two consecutive bytes. There are two
possibilities: Store the bytes in big endian or in little endian order. These
two encodings are called UTF-16-BE and UTF-16-LE respectively. Their
disadvantage is that if e.g. you use UTF-16-BE on a little endian machine you
will always have to swap bytes on encoding and decoding. UTF-16 avoids this
problem: Bytes will always be in natural endianness. When these bytes are read
by a CPU with a different endianness, then bytes have to be swapped though. To
be able to detect the endianness of a UTF-16 byte sequence, there’s the so
called BOM (the 「Byte Order Mark」). This is the Unicode character <code class="docutils literal notranslate"><span class="pre">U+FEFF</span></code>.
This character will be prepended to every UTF-16 byte sequence. The byte swapped
version of this character (<code class="docutils literal notranslate"><span class="pre">0xFFFE</span></code>) is an illegal character that may not
appear in a Unicode text. So when the first character in an UTF-16 byte sequence
appears to be a <code class="docutils literal notranslate"><span class="pre">U+FFFE</span></code> the bytes have to be swapped on decoding.
Unfortunately upto Unicode 4.0 the character <code class="docutils literal notranslate"><span class="pre">U+FEFF</span></code> had a second purpose as
a <code class="docutils literal notranslate"><span class="pre">ZERO</span> <span class="pre">WIDTH</span> <span class="pre">NO-BREAK</span> <span class="pre">SPACE</span></code>: A character that has no width and doesn’t allow
a word to be split. It can e.g. be used to give hints to a ligature algorithm.
With Unicode 4.0 using <code class="docutils literal notranslate"><span class="pre">U+FEFF</span></code> as a <code class="docutils literal notranslate"><span class="pre">ZERO</span> <span class="pre">WIDTH</span> <span class="pre">NO-BREAK</span> <span class="pre">SPACE</span></code> has been
deprecated (with <code class="docutils literal notranslate"><span class="pre">U+2060</span></code> (<code class="docutils literal notranslate"><span class="pre">WORD</span> <span class="pre">JOINER</span></code>) assuming this role). Nevertheless
Unicode software still must be able to handle <code class="docutils literal notranslate"><span class="pre">U+FEFF</span></code> in both roles: As a BOM
it’s a device to determine the storage layout of the encoded bytes, and vanishes
once the byte sequence has been decoded into a string; as a <code class="docutils literal notranslate"><span class="pre">ZERO</span> <span class="pre">WIDTH</span>
<span class="pre">NO-BREAK</span> <span class="pre">SPACE</span></code> it’s a normal character that will be decoded like any other.</p>
<p>There’s another encoding that is able to encoding the full range of Unicode
characters: UTF-8. UTF-8 is an 8-bit encoding, which means there are no issues
with byte order in UTF-8. Each byte in a UTF-8 byte sequence consists of two
parts: Marker bits (the most significant bits) and payload bits. The marker bits
are a sequence of zero to six 1 bits followed by a 0 bit. Unicode characters are
encoded like this (with x being payload bits, which when concatenated give the
Unicode character):</p>
<table border="1" class="docutils">
<colgroup>
<col width="43%" />
<col width="57%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Range</th>
<th class="head">Encoding</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">U-00000000</span></code> … <code class="docutils literal notranslate"><span class="pre">U-0000007F</span></code></td>
<td>0xxxxxxx</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">U-00000080</span></code> … <code class="docutils literal notranslate"><span class="pre">U-000007FF</span></code></td>
<td>110xxxxx 10xxxxxx</td>
</tr>
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">U-00000800</span></code> … <code class="docutils literal notranslate"><span class="pre">U-0000FFFF</span></code></td>
<td>1110xxxx 10xxxxxx 10xxxxxx</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">U-00010000</span></code> … <code class="docutils literal notranslate"><span class="pre">U-001FFFFF</span></code></td>
<td>11110xxx 10xxxxxx 10xxxxxx 10xxxxxx</td>
</tr>
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">U-00200000</span></code> … <code class="docutils literal notranslate"><span class="pre">U-03FFFFFF</span></code></td>
<td>111110xx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">U-04000000</span></code> … <code class="docutils literal notranslate"><span class="pre">U-7FFFFFFF</span></code></td>
<td>1111110x 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx
10xxxxxx</td>
</tr>
</tbody>
</table>
<p>The least significant bit of the Unicode character is the rightmost x bit.</p>
<p>As UTF-8 is an 8-bit encoding no BOM is required and any <code class="docutils literal notranslate"><span class="pre">U+FEFF</span></code> character in
the decoded string (even if it’s the first character) is treated as a <code class="docutils literal notranslate"><span class="pre">ZERO</span>
<span class="pre">WIDTH</span> <span class="pre">NO-BREAK</span> <span class="pre">SPACE</span></code>.</p>
<p>Without external information it’s impossible to reliably determine which
encoding was used for encoding a string. Each charmap encoding can
decode any random byte sequence. However that’s not possible with UTF-8, as
UTF-8 byte sequences have a structure that doesn’t allow arbitrary byte
sequences. To increase the reliability with which a UTF-8 encoding can be
detected, Microsoft invented a variant of UTF-8 (that Python 2.5 calls
<code class="docutils literal notranslate"><span class="pre">&quot;utf-8-sig&quot;</span></code>) for its Notepad program: Before any of the Unicode characters
is written to the file, a UTF-8 encoded BOM (which looks like this as a byte
sequence: <code class="docutils literal notranslate"><span class="pre">0xef</span></code>, <code class="docutils literal notranslate"><span class="pre">0xbb</span></code>, <code class="docutils literal notranslate"><span class="pre">0xbf</span></code>) is written. As it’s rather improbable
that any charmap encoded file starts with these byte values (which would e.g.
map to</p>
<blockquote>
<div><div class="line-block">
<div class="line">LATIN SMALL LETTER I WITH DIAERESIS</div>
<div class="line">RIGHT-POINTING DOUBLE ANGLE QUOTATION MARK</div>
<div class="line">INVERTED QUESTION MARK</div>
</div>
</div></blockquote>
<p>in iso-8859-1), this increases the probability that a utf-8-sig encoding can be
correctly guessed from the byte sequence. So here the BOM is not used to be able
to determine the byte order used for generating the byte sequence, but as a
signature that helps in guessing the encoding. On encoding the utf-8-sig codec
will write <code class="docutils literal notranslate"><span class="pre">0xef</span></code>, <code class="docutils literal notranslate"><span class="pre">0xbb</span></code>, <code class="docutils literal notranslate"><span class="pre">0xbf</span></code> as the first three bytes to the file. On
decoding utf-8-sig will skip those three bytes if they appear as the first three
bytes in the file.</p>
</div>
<div class="section" id="standard-encodings">
<span id="id7"></span><h2>Standard Encodings<a class="headerlink" href="#standard-encodings" title="本標題的永久連結">¶</a></h2>
<p>Python comes with a number of codecs built-in, either implemented as C functions
or with dictionaries as mapping tables. The following table lists the codecs by
name, together with a few common aliases, and the languages for which the
encoding is likely used. Neither the list of aliases nor the list of languages
is meant to be exhaustive. Notice that spelling alternatives that only differ in
case or use a hyphen instead of an underscore are also valid aliases.</p>
<p>Many of the character sets support the same languages. They vary in individual
characters (e.g. whether the EURO SIGN is supported or not), and in the
assignment of characters to code positions. For the European languages in
particular, the following variants typically exist:</p>
<ul class="simple">
<li>an ISO 8859 codeset</li>
<li>a Microsoft Windows code page, which is typically derived from a 8859 codeset,
but replaces control characters with additional graphic characters</li>
<li>an IBM EBCDIC code page</li>
<li>an IBM PC code page, which is ASCII compatible</li>
</ul>
<table border="1" class="docutils">
<colgroup>
<col width="21%" />
<col width="40%" />
<col width="40%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Codec</th>
<th class="head">Aliases</th>
<th class="head">Languages</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>ascii</td>
<td>646, us-ascii</td>
<td>English</td>
</tr>
<tr class="row-odd"><td>big5</td>
<td>big5-tw, csbig5</td>
<td>Traditional Chinese</td>
</tr>
<tr class="row-even"><td>big5hkscs</td>
<td>big5-hkscs, hkscs</td>
<td>Traditional Chinese</td>
</tr>
<tr class="row-odd"><td>cp037</td>
<td>IBM037, IBM039</td>
<td>English</td>
</tr>
<tr class="row-even"><td>cp424</td>
<td>EBCDIC-CP-HE, IBM424</td>
<td>Hebrew</td>
</tr>
<tr class="row-odd"><td>cp437</td>
<td>437, IBM437</td>
<td>English</td>
</tr>
<tr class="row-even"><td>cp500</td>
<td>EBCDIC-CP-BE, EBCDIC-CP-CH,
IBM500</td>
<td>Western Europe</td>
</tr>
<tr class="row-odd"><td>cp737</td>
<td>&#160;</td>
<td>Greek</td>
</tr>
<tr class="row-even"><td>cp775</td>
<td>IBM775</td>
<td>Baltic languages</td>
</tr>
<tr class="row-odd"><td>cp850</td>
<td>850, IBM850</td>
<td>Western Europe</td>
</tr>
<tr class="row-even"><td>cp852</td>
<td>852, IBM852</td>
<td>Central and Eastern Europe</td>
</tr>
<tr class="row-odd"><td>cp855</td>
<td>855, IBM855</td>
<td>Bulgarian, Byelorussian,
Macedonian, Russian, Serbian</td>
</tr>
<tr class="row-even"><td>cp856</td>
<td>&#160;</td>
<td>Hebrew</td>
</tr>
<tr class="row-odd"><td>cp857</td>
<td>857, IBM857</td>
<td>Turkish</td>
</tr>
<tr class="row-even"><td>cp860</td>
<td>860, IBM860</td>
<td>Portuguese</td>
</tr>
<tr class="row-odd"><td>cp861</td>
<td>861, CP-IS, IBM861</td>
<td>Icelandic</td>
</tr>
<tr class="row-even"><td>cp862</td>
<td>862, IBM862</td>
<td>Hebrew</td>
</tr>
<tr class="row-odd"><td>cp863</td>
<td>863, IBM863</td>
<td>Canadian</td>
</tr>
<tr class="row-even"><td>cp864</td>
<td>IBM864</td>
<td>Arabic</td>
</tr>
<tr class="row-odd"><td>cp865</td>
<td>865, IBM865</td>
<td>Danish, Norwegian</td>
</tr>
<tr class="row-even"><td>cp866</td>
<td>866, IBM866</td>
<td>Russian</td>
</tr>
<tr class="row-odd"><td>cp869</td>
<td>869, CP-GR, IBM869</td>
<td>Greek</td>
</tr>
<tr class="row-even"><td>cp874</td>
<td>&#160;</td>
<td>Thai</td>
</tr>
<tr class="row-odd"><td>cp875</td>
<td>&#160;</td>
<td>Greek</td>
</tr>
<tr class="row-even"><td>cp932</td>
<td>932, ms932, mskanji, ms-kanji</td>
<td>Japanese</td>
</tr>
<tr class="row-odd"><td>cp949</td>
<td>949, ms949, uhc</td>
<td>Korean</td>
</tr>
<tr class="row-even"><td>cp950</td>
<td>950, ms950</td>
<td>Traditional Chinese</td>
</tr>
<tr class="row-odd"><td>cp1006</td>
<td>&#160;</td>
<td>Urdu</td>
</tr>
<tr class="row-even"><td>cp1026</td>
<td>ibm1026</td>
<td>Turkish</td>
</tr>
<tr class="row-odd"><td>cp1140</td>
<td>ibm1140</td>
<td>Western Europe</td>
</tr>
<tr class="row-even"><td>cp1250</td>
<td>windows-1250</td>
<td>Central and Eastern Europe</td>
</tr>
<tr class="row-odd"><td>cp1251</td>
<td>windows-1251</td>
<td>Bulgarian, Byelorussian,
Macedonian, Russian, Serbian</td>
</tr>
<tr class="row-even"><td>cp1252</td>
<td>windows-1252</td>
<td>Western Europe</td>
</tr>
<tr class="row-odd"><td>cp1253</td>
<td>windows-1253</td>
<td>Greek</td>
</tr>
<tr class="row-even"><td>cp1254</td>
<td>windows-1254</td>
<td>Turkish</td>
</tr>
<tr class="row-odd"><td>cp1255</td>
<td>windows-1255</td>
<td>Hebrew</td>
</tr>
<tr class="row-even"><td>cp1256</td>
<td>windows1256</td>
<td>Arabic</td>
</tr>
<tr class="row-odd"><td>cp1257</td>
<td>windows-1257</td>
<td>Baltic languages</td>
</tr>
<tr class="row-even"><td>cp1258</td>
<td>windows-1258</td>
<td>Vietnamese</td>
</tr>
<tr class="row-odd"><td>euc_jp</td>
<td>eucjp, ujis, u-jis</td>
<td>Japanese</td>
</tr>
<tr class="row-even"><td>euc_jis_2004</td>
<td>jisx0213, eucjis2004</td>
<td>Japanese</td>
</tr>
<tr class="row-odd"><td>euc_jisx0213</td>
<td>eucjisx0213</td>
<td>Japanese</td>
</tr>
<tr class="row-even"><td>euc_kr</td>
<td>euckr, korean, ksc5601,
ks_c-5601, ks_c-5601-1987,
ksx1001, ks_x-1001</td>
<td>Korean</td>
</tr>
<tr class="row-odd"><td>gb2312</td>
<td>chinese, csiso58gb231280, euc-
cn, euccn, eucgb2312-cn,
gb2312-1980, gb2312-80, iso-
ir-58</td>
<td>Simplified Chinese</td>
</tr>
<tr class="row-even"><td>gbk</td>
<td>936, cp936, ms936</td>
<td>Unified Chinese</td>
</tr>
<tr class="row-odd"><td>gb18030</td>
<td>gb18030-2000</td>
<td>Unified Chinese</td>
</tr>
<tr class="row-even"><td>hz</td>
<td>hzgb, hz-gb, hz-gb-2312</td>
<td>Simplified Chinese</td>
</tr>
<tr class="row-odd"><td>iso2022_jp</td>
<td>csiso2022jp, iso2022jp,
iso-2022-jp</td>
<td>Japanese</td>
</tr>
<tr class="row-even"><td>iso2022_jp_1</td>
<td>iso2022jp-1, iso-2022-jp-1</td>
<td>Japanese</td>
</tr>
<tr class="row-odd"><td>iso2022_jp_2</td>
<td>iso2022jp-2, iso-2022-jp-2</td>
<td>Japanese, Korean, Simplified
Chinese, Western Europe, Greek</td>
</tr>
<tr class="row-even"><td>iso2022_jp_2004</td>
<td>iso2022jp-2004,
iso-2022-jp-2004</td>
<td>Japanese</td>
</tr>
<tr class="row-odd"><td>iso2022_jp_3</td>
<td>iso2022jp-3, iso-2022-jp-3</td>
<td>Japanese</td>
</tr>
<tr class="row-even"><td>iso2022_jp_ext</td>
<td>iso2022jp-ext, iso-2022-jp-ext</td>
<td>Japanese</td>
</tr>
<tr class="row-odd"><td>iso2022_kr</td>
<td>csiso2022kr, iso2022kr,
iso-2022-kr</td>
<td>Korean</td>
</tr>
<tr class="row-even"><td>latin_1</td>
<td>iso-8859-1, iso8859-1, 8859,
cp819, latin, latin1, L1</td>
<td>West Europe</td>
</tr>
<tr class="row-odd"><td>iso8859_2</td>
<td>iso-8859-2, latin2, L2</td>
<td>Central and Eastern Europe</td>
</tr>
<tr class="row-even"><td>iso8859_3</td>
<td>iso-8859-3, latin3, L3</td>
<td>Esperanto, Maltese</td>
</tr>
<tr class="row-odd"><td>iso8859_4</td>
<td>iso-8859-4, latin4, L4</td>
<td>Baltic languages</td>
</tr>
<tr class="row-even"><td>iso8859_5</td>
<td>iso-8859-5, cyrillic</td>
<td>Bulgarian, Byelorussian,
Macedonian, Russian, Serbian</td>
</tr>
<tr class="row-odd"><td>iso8859_6</td>
<td>iso-8859-6, arabic</td>
<td>Arabic</td>
</tr>
<tr class="row-even"><td>iso8859_7</td>
<td>iso-8859-7, greek, greek8</td>
<td>Greek</td>
</tr>
<tr class="row-odd"><td>iso8859_8</td>
<td>iso-8859-8, hebrew</td>
<td>Hebrew</td>
</tr>
<tr class="row-even"><td>iso8859_9</td>
<td>iso-8859-9, latin5, L5</td>
<td>Turkish</td>
</tr>
<tr class="row-odd"><td>iso8859_10</td>
<td>iso-8859-10, latin6, L6</td>
<td>Nordic languages</td>
</tr>
<tr class="row-even"><td>iso8859_13</td>
<td>iso-8859-13</td>
<td>Baltic languages</td>
</tr>
<tr class="row-odd"><td>iso8859_14</td>
<td>iso-8859-14, latin8, L8</td>
<td>Celtic languages</td>
</tr>
<tr class="row-even"><td>iso8859_15</td>
<td>iso-8859-15</td>
<td>Western Europe</td>
</tr>
<tr class="row-odd"><td>johab</td>
<td>cp1361, ms1361</td>
<td>Korean</td>
</tr>
<tr class="row-even"><td>koi8_r</td>
<td>&#160;</td>
<td>Russian</td>
</tr>
<tr class="row-odd"><td>koi8_u</td>
<td>&#160;</td>
<td>Ukrainian</td>
</tr>
<tr class="row-even"><td>mac_cyrillic</td>
<td>maccyrillic</td>
<td>Bulgarian, Byelorussian,
Macedonian, Russian, Serbian</td>
</tr>
<tr class="row-odd"><td>mac_greek</td>
<td>macgreek</td>
<td>Greek</td>
</tr>
<tr class="row-even"><td>mac_iceland</td>
<td>maciceland</td>
<td>Icelandic</td>
</tr>
<tr class="row-odd"><td>mac_latin2</td>
<td>maclatin2, maccentraleurope</td>
<td>Central and Eastern Europe</td>
</tr>
<tr class="row-even"><td>mac_roman</td>
<td>macroman</td>
<td>Western Europe</td>
</tr>
<tr class="row-odd"><td>mac_turkish</td>
<td>macturkish</td>
<td>Turkish</td>
</tr>
<tr class="row-even"><td>ptcp154</td>
<td>csptcp154, pt154, cp154,
cyrillic-asian</td>
<td>Kazakh</td>
</tr>
<tr class="row-odd"><td>shift_jis</td>
<td>csshiftjis, shiftjis, sjis,
s_jis</td>
<td>Japanese</td>
</tr>
<tr class="row-even"><td>shift_jis_2004</td>
<td>shiftjis2004, sjis_2004,
sjis2004</td>
<td>Japanese</td>
</tr>
<tr class="row-odd"><td>shift_jisx0213</td>
<td>shiftjisx0213, sjisx0213,
s_jisx0213</td>
<td>Japanese</td>
</tr>
<tr class="row-even"><td>utf_32</td>
<td>U32, utf32</td>
<td>all languages</td>
</tr>
<tr class="row-odd"><td>utf_32_be</td>
<td>UTF-32BE</td>
<td>all languages</td>
</tr>
<tr class="row-even"><td>utf_32_le</td>
<td>UTF-32LE</td>
<td>all languages</td>
</tr>
<tr class="row-odd"><td>utf_16</td>
<td>U16, utf16</td>
<td>all languages</td>
</tr>
<tr class="row-even"><td>utf_16_be</td>
<td>UTF-16BE</td>
<td>all languages (BMP only)</td>
</tr>
<tr class="row-odd"><td>utf_16_le</td>
<td>UTF-16LE</td>
<td>all languages (BMP only)</td>
</tr>
<tr class="row-even"><td>utf_7</td>
<td>U7, unicode-1-1-utf-7</td>
<td>all languages</td>
</tr>
<tr class="row-odd"><td>utf_8</td>
<td>U8, UTF, utf8</td>
<td>all languages</td>
</tr>
<tr class="row-even"><td>utf_8_sig</td>
<td>&#160;</td>
<td>all languages</td>
</tr>
</tbody>
</table>
<table border="1" class="docutils">
<colgroup>
<col width="36%" />
<col width="16%" />
<col width="48%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Codec</th>
<th class="head">Aliases</th>
<th class="head">Purpose</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>idna</td>
<td>&#160;</td>
<td>Implements <span class="target" id="index-1"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc3490.html"><strong>RFC 3490</strong></a>,
see also
<a class="reference internal" href="#module-encodings.idna" title="encodings.idna: Internationalized Domain Names implementation"><code class="xref py py-mod docutils literal notranslate"><span class="pre">encodings.idna</span></code></a></td>
</tr>
<tr class="row-odd"><td>mbcs</td>
<td>dbcs</td>
<td>Windows only: Encode
operand according to the
ANSI codepage (CP_ACP)</td>
</tr>
<tr class="row-even"><td>palmos</td>
<td>&#160;</td>
<td>Encoding of PalmOS 3.5</td>
</tr>
<tr class="row-odd"><td>punycode</td>
<td>&#160;</td>
<td>Implements <span class="target" id="index-2"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc3492.html"><strong>RFC 3492</strong></a></td>
</tr>
<tr class="row-even"><td>raw_unicode_escape</td>
<td>&#160;</td>
<td>Produce a string that is
suitable as raw Unicode
literal in Python source
code</td>
</tr>
<tr class="row-odd"><td>undefined</td>
<td>&#160;</td>
<td>Raise an exception for
all conversions. Can be
used as the system
encoding if no automatic
coercion between byte and
Unicode strings is
desired.</td>
</tr>
<tr class="row-even"><td>unicode_escape</td>
<td>&#160;</td>
<td>Produce a string that is
suitable as Unicode
literal in Python source
code</td>
</tr>
<tr class="row-odd"><td>unicode_internal</td>
<td>&#160;</td>
<td>Return the internal
representation of the
operand</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="module-encodings.idna">
<span id="encodings-idna-internationalized-domain-names-in-applications"></span><h2><a class="reference internal" href="#module-encodings.idna" title="encodings.idna: Internationalized Domain Names implementation"><code class="xref py py-mod docutils literal notranslate"><span class="pre">encodings.idna</span></code></a> — Internationalized Domain Names in Applications<a class="headerlink" href="#module-encodings.idna" title="本標題的永久連結">¶</a></h2>
<p>This module implements <span class="target" id="index-3"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc3490.html"><strong>RFC 3490</strong></a> (Internationalized Domain Names in
Applications) and <span class="target" id="index-4"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc3492.html"><strong>RFC 3492</strong></a> (Nameprep: A Stringprep Profile for
Internationalized Domain Names (IDN)). It builds upon the <code class="docutils literal notranslate"><span class="pre">punycode</span></code> encoding
and <a class="reference internal" href="stringprep.html#module-stringprep" title="stringprep: String preparation, as per RFC 3453(已棄用)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">stringprep</span></code></a>.</p>
<p>These RFCs together define a protocol to support non-ASCII characters in domain
names. A domain name containing non-ASCII characters (such as
<code class="docutils literal notranslate"><span class="pre">www.Alliancefrançaise.nu</span></code>) is converted into an ASCII-compatible encoding
(ACE, such as <code class="docutils literal notranslate"><span class="pre">www.xn--alliancefranaise-npb.nu</span></code>). The ACE form of the domain
name is then used in all places where arbitrary characters are not allowed by
the protocol, such as DNS queries, HTTP <em class="mailheader">Host</em> fields, and so
on. This conversion is carried out in the application; if possible invisible to
the user: The application should transparently convert Unicode domain labels to
IDNA on the wire, and convert back ACE labels to Unicode before presenting them
to the user.</p>
<p>Python supports this conversion in several ways: The <code class="docutils literal notranslate"><span class="pre">idna</span></code> codec allows to
convert between Unicode and the ACE. Furthermore, the <a class="reference internal" href="socket.html#module-socket" title="socket: Low-level networking interface."><code class="xref py py-mod docutils literal notranslate"><span class="pre">socket</span></code></a> module
transparently converts Unicode host names to ACE, so that applications need not
be concerned about converting host names themselves when they pass them to the
socket module. On top of that, modules that have host names as function
parameters, such as <a class="reference internal" href="http.client.html#module-http.client" title="http.client: HTTP and HTTPS protocol client (requires sockets)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">http.client</span></code></a> and <a class="reference internal" href="ftplib.html#module-ftplib" title="ftplib: FTP protocol client (requires sockets)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">ftplib</span></code></a>, accept Unicode host
names (<a class="reference internal" href="http.client.html#module-http.client" title="http.client: HTTP and HTTPS protocol client (requires sockets)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">http.client</span></code></a> then also transparently sends an IDNA hostname in the
<em class="mailheader">Host</em> field if it sends that field at all).</p>
<p>When receiving host names from the wire (such as in reverse name lookup), no
automatic conversion to Unicode is performed: Applications wishing to present
such host names to the user should decode them to Unicode.</p>
<p>The module <a class="reference internal" href="#module-encodings.idna" title="encodings.idna: Internationalized Domain Names implementation"><code class="xref py py-mod docutils literal notranslate"><span class="pre">encodings.idna</span></code></a> also implements the nameprep procedure, which
performs certain normalizations on host names, to achieve case-insensitivity of
international domain names, and to unify similar characters. The nameprep
functions can be used directly if desired.</p>
<dl class="function">
<dt id="encodings.idna.nameprep">
<code class="descclassname">encodings.idna.</code><code class="descname">nameprep</code><span class="sig-paren">(</span><em>label</em><span class="sig-paren">)</span><a class="headerlink" href="#encodings.idna.nameprep" title="本定義的永久連結">¶</a></dt>
<dd><p>Return the nameprepped version of <em>label</em>. The implementation currently assumes
query strings, so <code class="docutils literal notranslate"><span class="pre">AllowUnassigned</span></code> is true.</p>
</dd></dl>

<dl class="function">
<dt id="encodings.idna.ToASCII">
<code class="descclassname">encodings.idna.</code><code class="descname">ToASCII</code><span class="sig-paren">(</span><em>label</em><span class="sig-paren">)</span><a class="headerlink" href="#encodings.idna.ToASCII" title="本定義的永久連結">¶</a></dt>
<dd><p>Convert a label to ASCII, as specified in <span class="target" id="index-5"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc3490.html"><strong>RFC 3490</strong></a>. <code class="docutils literal notranslate"><span class="pre">UseSTD3ASCIIRules</span></code> is
assumed to be false.</p>
</dd></dl>

<dl class="function">
<dt id="encodings.idna.ToUnicode">
<code class="descclassname">encodings.idna.</code><code class="descname">ToUnicode</code><span class="sig-paren">(</span><em>label</em><span class="sig-paren">)</span><a class="headerlink" href="#encodings.idna.ToUnicode" title="本定義的永久連結">¶</a></dt>
<dd><p>Convert a label to Unicode, as specified in <span class="target" id="index-6"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc3490.html"><strong>RFC 3490</strong></a>.</p>
</dd></dl>

</div>
<div class="section" id="module-encodings.utf_8_sig">
<span id="encodings-utf-8-sig-utf-8-codec-with-bom-signature"></span><h2><a class="reference internal" href="#module-encodings.utf_8_sig" title="encodings.utf_8_sig: UTF-8 codec with BOM signature"><code class="xref py py-mod docutils literal notranslate"><span class="pre">encodings.utf_8_sig</span></code></a> — UTF-8 codec with BOM signature<a class="headerlink" href="#module-encodings.utf_8_sig" title="本標題的永久連結">¶</a></h2>
<p>This module implements a variant of the UTF-8 codec: On encoding a UTF-8 encoded
BOM will be prepended to the UTF-8 encoded bytes. For the stateful encoder this
is only done once (on the first write to the byte stream).  For decoding an
optional UTF-8 encoded BOM at the start of the data will be skipped.</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#"><code class="docutils literal notranslate"><span class="pre">codecs</span></code> — Codec registry and base classes</a><ul>
<li><a class="reference internal" href="#codec-base-classes">Codec Base Classes</a><ul>
<li><a class="reference internal" href="#codec-objects">Codec Objects</a></li>
<li><a class="reference internal" href="#incrementalencoder-objects">IncrementalEncoder Objects</a></li>
<li><a class="reference internal" href="#incrementaldecoder-objects">IncrementalDecoder Objects</a></li>
<li><a class="reference internal" href="#streamwriter-objects">StreamWriter Objects</a></li>
<li><a class="reference internal" href="#streamreader-objects">StreamReader Objects</a></li>
<li><a class="reference internal" href="#streamreaderwriter-objects">StreamReaderWriter Objects</a></li>
<li><a class="reference internal" href="#streamrecoder-objects">StreamRecoder Objects</a></li>
</ul>
</li>
<li><a class="reference internal" href="#encodings-and-unicode">Encodings and Unicode</a></li>
<li><a class="reference internal" href="#standard-encodings">Standard Encodings</a></li>
<li><a class="reference internal" href="#module-encodings.idna"><code class="docutils literal notranslate"><span class="pre">encodings.idna</span></code> — Internationalized Domain Names in Applications</a></li>
<li><a class="reference internal" href="#module-encodings.utf_8_sig"><code class="docutils literal notranslate"><span class="pre">encodings.utf_8_sig</span></code> — UTF-8 codec with BOM signature</a></li>
</ul>
</li>
</ul>

  <h4>上個主題</h4>
  <p class="topless"><a href="textwrap.html"
                        title="上一章"><code class="docutils literal notranslate"><span class="pre">textwrap</span></code> — Text wrapping and filling</a></p>
  <h4>下個主題</h4>
  <p class="topless"><a href="unicodedata.html"
                        title="下一章"><code class="docutils literal notranslate"><span class="pre">unicodedata</span></code> — Unicode Database</a></p>
  <div role="note" aria-label="source link">
    <h3>本頁</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/library/codecs.rst.txt"
            rel="nofollow">顯示原始碼</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>快速搜尋</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="搜" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>瀏覽</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="總索引"
             >索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 模組索引"
             >模組</a> |</li>
        <li class="right" >
          <a href="unicodedata.html" title="unicodedata — Unicode Database"
             >下一頁</a> |</li>
        <li class="right" >
          <a href="textwrap.html" title="textwrap — Text wrapping and filling"
             >上一頁</a> |</li>

    <li><img src="../_static/py.png" alt=""
             style="vertical-align: middle; margin-top: -1px"/></li>
    <li><a href="https://www.python.org/">Python</a> &#187;</li>
    

          <li id="cpython-language-and-version">
            <a href="../index.html">Python 3.0.1 說明文件</a> &#187;
          </li>

          <li class="nav-item nav-item-1"><a href="index.html" >The Python Standard Library</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="strings.html" >String Services</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="快速搜尋" type="text" name="q" />
          <input type="submit" value="搜" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">版權所有</a> 1990-2025, Python Software Foundation.
    <br />

    The Python Software Foundation is a non-profit corporation.
<a href="https://www.python.org/psf/donations/">Please donate.</a>
<br />
    <br />

    最後更新於 10月 29, 2025。
    
    <br />

    Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.8.4.
    </div>

  </body>
</html>
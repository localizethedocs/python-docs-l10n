
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" lang="zh_TW">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>18.1.2. email: Parsing email messages &#8212; Python 2.6.9 說明文件</title>
    <link rel="stylesheet" href="../_static/pydoctheme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/language_data.js"></script>
    <script type="text/javascript" src="../_static/translations.js"></script>
    
    <link rel="canonical" href="https://projects.localizethedocs.org/python-docs-l10n/library/email.parser.html" />
    <link rel="search" type="application/opensearchdescription+xml"
          title="在 Python 2.6.9 說明文件 中搜尋"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="關於這些文件" href="../about.html" />
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="搜尋" href="../search.html" />
    <link rel="copyright" title="版權所有" href="../copyright.html" />
    <link rel="next" title="18.1.3. email: Generating MIME documents" href="email.generator.html" />
    <link rel="prev" title="18.1.1. email: Representing an email message" href="email.message.html" />
    
    <link rel="canonical" href="https://docs.python.org/3/library/email.parser.html" />
    
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>

    <link rel="shortcut icon" type="image/png" href="../_static/py.png" />
    
    <script type="text/javascript" src="../_static/copybutton.js"></script>
    
     

            <script type="text/javascript" src="../_static/rtd_switcher.js"></script>
            <meta name="readthedocs-addons-api-version" content="1">
            <script type="text/javascript" src="../ltd-provenance.js"></script>
            <script type="text/javascript" src="../ltd-current.js"></script>
            <script type="text/javascript" src="../../../ltd-config.js"></script>
            <script type="text/javascript" src="../../../ltd-flyout.js"></script>

  </head><body>
  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>瀏覽</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="總索引"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 模組索引"
             >模組</a> |</li>
        <li class="right" >
          <a href="email.generator.html" title="18.1.3. email: Generating MIME documents"
             accesskey="N">下一頁</a> |</li>
        <li class="right" >
          <a href="email.message.html" title="18.1.1. email: Representing an email message"
             accesskey="P">上一頁</a> |</li>

    <li><img src="../_static/py.png" alt=""
             style="vertical-align: middle; margin-top: -1px"/></li>
    <li><a href="https://www.python.org/">Python</a> &#187;</li>
    

          <li id="cpython-language-and-version">
            <a href="../index.html">Python 2.6.9 說明文件</a> &#187;
          </li>

          <li class="nav-item nav-item-1"><a href="index.html" >The Python Standard Library</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="netdata.html" >18. Internet Data Handling</a> &#187;</li>
          <li class="nav-item nav-item-3"><a href="email.html" accesskey="U">18.1. <code class="docutils literal notranslate"><span class="pre">email</span></code> — An email and MIME handling package</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="快速搜尋" type="text" name="q" />
          <input type="submit" value="搜" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="module-email.parser">
<span id="email-parsing-email-messages"></span><h1>18.1.2. <a class="reference internal" href="email.html#module-email" title="email: Package supporting the parsing, manipulating, and generating email messages, including MIME documents."><code class="xref py py-mod docutils literal notranslate"><span class="pre">email</span></code></a>: Parsing email messages<a class="headerlink" href="#module-email.parser" title="本標題的永久連結">¶</a></h1>
<p>Message object structures can be created in one of two ways: they can be created
from whole cloth by instantiating <a class="reference internal" href="email.message.html#email.message.Message" title="email.message.Message"><code class="xref py py-class docutils literal notranslate"><span class="pre">Message</span></code></a> objects and
stringing them together via <code class="xref py py-meth docutils literal notranslate"><span class="pre">attach()</span></code> and <code class="xref py py-meth docutils literal notranslate"><span class="pre">set_payload()</span></code> calls, or they
can be created by parsing a flat text representation of the email message.</p>
<p>The <a class="reference internal" href="email.html#module-email" title="email: Package supporting the parsing, manipulating, and generating email messages, including MIME documents."><code class="xref py py-mod docutils literal notranslate"><span class="pre">email</span></code></a> package provides a standard parser that understands most email
document structures, including MIME documents.  You can pass the parser a string
or a file object, and the parser will return to you the root
<a class="reference internal" href="email.message.html#email.message.Message" title="email.message.Message"><code class="xref py py-class docutils literal notranslate"><span class="pre">Message</span></code></a> instance of the object structure.  For simple,
non-MIME messages the payload of this root object will likely be a string
containing the text of the message.  For MIME messages, the root object will
return <code class="docutils literal notranslate"><span class="pre">True</span></code> from its <code class="xref py py-meth docutils literal notranslate"><span class="pre">is_multipart()</span></code> method, and the subparts can be
accessed via the <code class="xref py py-meth docutils literal notranslate"><span class="pre">get_payload()</span></code> and <code class="xref py py-meth docutils literal notranslate"><span class="pre">walk()</span></code> methods.</p>
<p>There are actually two parser interfaces available for use, the classic
<a class="reference internal" href="#email.parser.Parser" title="email.parser.Parser"><code class="xref py py-class docutils literal notranslate"><span class="pre">Parser</span></code></a> API and the incremental <a class="reference internal" href="#email.parser.FeedParser" title="email.parser.FeedParser"><code class="xref py py-class docutils literal notranslate"><span class="pre">FeedParser</span></code></a> API.  The classic
<a class="reference internal" href="#email.parser.Parser" title="email.parser.Parser"><code class="xref py py-class docutils literal notranslate"><span class="pre">Parser</span></code></a> API is fine if you have the entire text of the message in memory
as a string, or if the entire message lives in a file on the file system.
<a class="reference internal" href="#email.parser.FeedParser" title="email.parser.FeedParser"><code class="xref py py-class docutils literal notranslate"><span class="pre">FeedParser</span></code></a> is more appropriate for when you’re reading the message from
a stream which might block waiting for more input (e.g. reading an email message
from a socket).  The <a class="reference internal" href="#email.parser.FeedParser" title="email.parser.FeedParser"><code class="xref py py-class docutils literal notranslate"><span class="pre">FeedParser</span></code></a> can consume and parse the message
incrementally, and only returns the root object when you close the parser <a class="footnote-reference" href="#id2" id="id1">[1]</a>.</p>
<p>Note that the parser can be extended in limited ways, and of course you can
implement your own parser completely from scratch.  There is no magical
connection between the <a class="reference internal" href="email.html#module-email" title="email: Package supporting the parsing, manipulating, and generating email messages, including MIME documents."><code class="xref py py-mod docutils literal notranslate"><span class="pre">email</span></code></a> package’s bundled parser and the
<a class="reference internal" href="email.message.html#email.message.Message" title="email.message.Message"><code class="xref py py-class docutils literal notranslate"><span class="pre">Message</span></code></a> class, so your custom parser can create message
object trees any way it finds necessary.</p>
<div class="section" id="feedparser-api">
<h2>18.1.2.1. FeedParser API<a class="headerlink" href="#feedparser-api" title="本標題的永久連結">¶</a></h2>
<div class="versionadded">
<p><span class="versionmodified">2.4 版新加入.</span></p>
</div>
<p>The <a class="reference internal" href="#email.parser.FeedParser" title="email.parser.FeedParser"><code class="xref py py-class docutils literal notranslate"><span class="pre">FeedParser</span></code></a>, imported from the <code class="xref py py-mod docutils literal notranslate"><span class="pre">email.feedparser</span></code> module,
provides an API that is conducive to incremental parsing of email messages, such
as would be necessary when reading the text of an email message from a source
that can block (e.g. a socket).  The <a class="reference internal" href="#email.parser.FeedParser" title="email.parser.FeedParser"><code class="xref py py-class docutils literal notranslate"><span class="pre">FeedParser</span></code></a> can of course be used
to parse an email message fully contained in a string or a file, but the classic
<a class="reference internal" href="#email.parser.Parser" title="email.parser.Parser"><code class="xref py py-class docutils literal notranslate"><span class="pre">Parser</span></code></a> API may be more convenient for such use cases.  The semantics
and results of the two parser APIs are identical.</p>
<p>The <a class="reference internal" href="#email.parser.FeedParser" title="email.parser.FeedParser"><code class="xref py py-class docutils literal notranslate"><span class="pre">FeedParser</span></code></a>’s API is simple; you create an instance, feed it a bunch
of text until there’s no more to feed it, then close the parser to retrieve the
root message object.  The <a class="reference internal" href="#email.parser.FeedParser" title="email.parser.FeedParser"><code class="xref py py-class docutils literal notranslate"><span class="pre">FeedParser</span></code></a> is extremely accurate when parsing
standards-compliant messages, and it does a very good job of parsing
non-compliant messages, providing information about how a message was deemed
broken.  It will populate a message object’s <em>defects</em> attribute with a list of
any problems it found in a message.  See the <a class="reference internal" href="email.errors.html#module-email.errors" title="email.errors: The exception classes used by the email package."><code class="xref py py-mod docutils literal notranslate"><span class="pre">email.errors</span></code></a> module for the
list of defects that it can find.</p>
<p>Here is the API for the <a class="reference internal" href="#email.parser.FeedParser" title="email.parser.FeedParser"><code class="xref py py-class docutils literal notranslate"><span class="pre">FeedParser</span></code></a>:</p>
<dl class="class">
<dt id="email.parser.FeedParser">
<em class="property">class </em><code class="descclassname">email.parser.</code><code class="descname">FeedParser</code><span class="sig-paren">(</span><span class="optional">[</span><em>_factory</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#email.parser.FeedParser" title="本定義的永久連結">¶</a></dt>
<dd><p>Create a <a class="reference internal" href="#email.parser.FeedParser" title="email.parser.FeedParser"><code class="xref py py-class docutils literal notranslate"><span class="pre">FeedParser</span></code></a> instance.  Optional <em>_factory</em> is a no-argument
callable that will be called whenever a new message object is needed.  It
defaults to the <a class="reference internal" href="email.message.html#email.message.Message" title="email.message.Message"><code class="xref py py-class docutils literal notranslate"><span class="pre">email.message.Message</span></code></a> class.</p>
<dl class="method">
<dt id="email.parser.FeedParser.feed">
<code class="descname">feed</code><span class="sig-paren">(</span><em>data</em><span class="sig-paren">)</span><a class="headerlink" href="#email.parser.FeedParser.feed" title="本定義的永久連結">¶</a></dt>
<dd><p>Feed the <a class="reference internal" href="#email.parser.FeedParser" title="email.parser.FeedParser"><code class="xref py py-class docutils literal notranslate"><span class="pre">FeedParser</span></code></a> some more data.  <em>data</em> should be a string
containing one or more lines.  The lines can be partial and the
<a class="reference internal" href="#email.parser.FeedParser" title="email.parser.FeedParser"><code class="xref py py-class docutils literal notranslate"><span class="pre">FeedParser</span></code></a> will stitch such partial lines together properly.  The
lines in the string can have any of the common three line endings,
carriage return, newline, or carriage return and newline (they can even be
mixed).</p>
</dd></dl>

<dl class="method">
<dt id="email.parser.FeedParser.close">
<code class="descname">close</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#email.parser.FeedParser.close" title="本定義的永久連結">¶</a></dt>
<dd><p>Closing a <a class="reference internal" href="#email.parser.FeedParser" title="email.parser.FeedParser"><code class="xref py py-class docutils literal notranslate"><span class="pre">FeedParser</span></code></a> completes the parsing of all previously fed
data, and returns the root message object.  It is undefined what happens
if you feed more data to a closed <a class="reference internal" href="#email.parser.FeedParser" title="email.parser.FeedParser"><code class="xref py py-class docutils literal notranslate"><span class="pre">FeedParser</span></code></a>.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="parser-class-api">
<h2>18.1.2.2. Parser class API<a class="headerlink" href="#parser-class-api" title="本標題的永久連結">¶</a></h2>
<p>The <a class="reference internal" href="#email.parser.Parser" title="email.parser.Parser"><code class="xref py py-class docutils literal notranslate"><span class="pre">Parser</span></code></a> class, imported from the <a class="reference internal" href="#module-email.parser" title="email.parser: Parse flat text email messages to produce a message object structure."><code class="xref py py-mod docutils literal notranslate"><span class="pre">email.parser</span></code></a> module,
provides an API that can be used to parse a message when the complete contents
of the message are available in a string or file.  The <a class="reference internal" href="#module-email.parser" title="email.parser: Parse flat text email messages to produce a message object structure."><code class="xref py py-mod docutils literal notranslate"><span class="pre">email.parser</span></code></a>
module also provides a second class, called <code class="xref py py-class docutils literal notranslate"><span class="pre">HeaderParser</span></code> which can be
used if you’re only interested in the headers of the message.
<code class="xref py py-class docutils literal notranslate"><span class="pre">HeaderParser</span></code> can be much faster in these situations, since it does not
attempt to parse the message body, instead setting the payload to the raw body
as a string. <code class="xref py py-class docutils literal notranslate"><span class="pre">HeaderParser</span></code> has the same API as the <a class="reference internal" href="#email.parser.Parser" title="email.parser.Parser"><code class="xref py py-class docutils literal notranslate"><span class="pre">Parser</span></code></a>
class.</p>
<dl class="class">
<dt id="email.parser.Parser">
<em class="property">class </em><code class="descclassname">email.parser.</code><code class="descname">Parser</code><span class="sig-paren">(</span><span class="optional">[</span><em>_class</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#email.parser.Parser" title="本定義的永久連結">¶</a></dt>
<dd><p>The constructor for the <a class="reference internal" href="#email.parser.Parser" title="email.parser.Parser"><code class="xref py py-class docutils literal notranslate"><span class="pre">Parser</span></code></a> class takes an optional argument
<em>_class</em>.  This must be a callable factory (such as a function or a class), and
it is used whenever a sub-message object needs to be created.  It defaults to
<a class="reference internal" href="email.message.html#email.message.Message" title="email.message.Message"><code class="xref py py-class docutils literal notranslate"><span class="pre">Message</span></code></a> (see <a class="reference internal" href="email.message.html#module-email.message" title="email.message: The base class representing email messages."><code class="xref py py-mod docutils literal notranslate"><span class="pre">email.message</span></code></a>).  The factory will
be called without arguments.</p>
<p>The optional <em>strict</em> flag is ignored.</p>
<div class="deprecated">
<p><span class="versionmodified">2.4 版後已棄用: </span>Because the <a class="reference internal" href="#email.parser.Parser" title="email.parser.Parser"><code class="xref py py-class docutils literal notranslate"><span class="pre">Parser</span></code></a> class is a backward compatible API wrapper
around the new-in-Python 2.4 <a class="reference internal" href="#email.parser.FeedParser" title="email.parser.FeedParser"><code class="xref py py-class docutils literal notranslate"><span class="pre">FeedParser</span></code></a>, <em>all</em> parsing is
effectively non-strict.  You should simply stop passing a <em>strict</em> flag to
the <a class="reference internal" href="#email.parser.Parser" title="email.parser.Parser"><code class="xref py py-class docutils literal notranslate"><span class="pre">Parser</span></code></a> constructor.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">2.2.2 版更變: </span>The <em>strict</em> flag was added.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">2.4 版更變: </span>The <em>strict</em> flag was deprecated.</p>
</div>
<p>The other public <a class="reference internal" href="#email.parser.Parser" title="email.parser.Parser"><code class="xref py py-class docutils literal notranslate"><span class="pre">Parser</span></code></a> methods are:</p>
<dl class="method">
<dt id="email.parser.Parser.parse">
<code class="descname">parse</code><span class="sig-paren">(</span><em>fp</em><span class="optional">[</span>, <em>headersonly</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#email.parser.Parser.parse" title="本定義的永久連結">¶</a></dt>
<dd><p>Read all the data from the file-like object <em>fp</em>, parse the resulting
text, and return the root message object.  <em>fp</em> must support both the
<a class="reference internal" href="readline.html#module-readline" title="readline: GNU readline support for Python. (Unix)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">readline()</span></code></a> and the <code class="xref py py-meth docutils literal notranslate"><span class="pre">read()</span></code> methods on file-like objects.</p>
<p>The text contained in <em>fp</em> must be formatted as a block of <span class="target" id="index-0"></span><a class="rfc reference external" href="https://tools.ietf.org/html/rfc2822.html"><strong>RFC 2822</strong></a>
style headers and header continuation lines, optionally preceded by a
envelope header.  The header block is terminated either by the end of the
data or by a blank line.  Following the header block is the body of the
message (which may contain MIME-encoded subparts).</p>
<p>Optional <em>headersonly</em> is as with the <a class="reference internal" href="#email.parser.Parser.parse" title="email.parser.Parser.parse"><code class="xref py py-meth docutils literal notranslate"><span class="pre">parse()</span></code></a> method.</p>
<div class="versionchanged">
<p><span class="versionmodified">2.2.2 版更變: </span>The <em>headersonly</em> flag was added.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="email.parser.Parser.parsestr">
<code class="descname">parsestr</code><span class="sig-paren">(</span><em>text</em><span class="optional">[</span>, <em>headersonly</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#email.parser.Parser.parsestr" title="本定義的永久連結">¶</a></dt>
<dd><p>Similar to the <a class="reference internal" href="#email.parser.Parser.parse" title="email.parser.Parser.parse"><code class="xref py py-meth docutils literal notranslate"><span class="pre">parse()</span></code></a> method, except it takes a string object
instead of a file-like object.  Calling this method on a string is exactly
equivalent to wrapping <em>text</em> in a <a class="reference internal" href="stringio.html#module-StringIO" title="StringIO: Read and write strings as if they were files."><code class="xref py py-class docutils literal notranslate"><span class="pre">StringIO</span></code></a> instance first and
calling <a class="reference internal" href="#email.parser.Parser.parse" title="email.parser.Parser.parse"><code class="xref py py-meth docutils literal notranslate"><span class="pre">parse()</span></code></a>.</p>
<p>Optional <em>headersonly</em> is a flag specifying whether to stop parsing after
reading the headers or not.  The default is <code class="docutils literal notranslate"><span class="pre">False</span></code>, meaning it parses
the entire contents of the file.</p>
<div class="versionchanged">
<p><span class="versionmodified">2.2.2 版更變: </span>The <em>headersonly</em> flag was added.</p>
</div>
</dd></dl>

</dd></dl>

<p>Since creating a message object structure from a string or a file object is such
a common task, two functions are provided as a convenience.  They are available
in the top-level <a class="reference internal" href="email.html#module-email" title="email: Package supporting the parsing, manipulating, and generating email messages, including MIME documents."><code class="xref py py-mod docutils literal notranslate"><span class="pre">email</span></code></a> package namespace.</p>
<dl class="function">
<dt id="email.message_from_string">
<code class="descclassname">email.</code><code class="descname">message_from_string</code><span class="sig-paren">(</span><em>s</em><span class="optional">[</span>, <em>_class</em><span class="optional">[</span>, <em>strict</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#email.message_from_string" title="本定義的永久連結">¶</a></dt>
<dd><p>Return a message object structure from a string.  This is exactly equivalent to
<code class="docutils literal notranslate"><span class="pre">Parser().parsestr(s)</span></code>.  Optional <em>_class</em> and <em>strict</em> are interpreted as
with the <code class="xref py py-class docutils literal notranslate"><span class="pre">Parser</span></code> class constructor.</p>
<div class="versionchanged">
<p><span class="versionmodified">2.2.2 版更變: </span>The <em>strict</em> flag was added.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="email.message_from_file">
<code class="descclassname">email.</code><code class="descname">message_from_file</code><span class="sig-paren">(</span><em>fp</em><span class="optional">[</span>, <em>_class</em><span class="optional">[</span>, <em>strict</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#email.message_from_file" title="本定義的永久連結">¶</a></dt>
<dd><p>Return a message object structure tree from an open file object.  This is
exactly equivalent to <code class="docutils literal notranslate"><span class="pre">Parser().parse(fp)</span></code>.  Optional <em>_class</em> and <em>strict</em>
are interpreted as with the <code class="xref py py-class docutils literal notranslate"><span class="pre">Parser</span></code> class constructor.</p>
<div class="versionchanged">
<p><span class="versionmodified">2.2.2 版更變: </span>The <em>strict</em> flag was added.</p>
</div>
</dd></dl>

<p>Here’s an example of how you might use this at an interactive Python prompt:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">email</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">msg</span> <span class="o">=</span> <span class="n">email</span><span class="o">.</span><span class="n">message_from_string</span><span class="p">(</span><span class="n">myString</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="additional-notes">
<h2>18.1.2.3. Additional notes<a class="headerlink" href="#additional-notes" title="本標題的永久連結">¶</a></h2>
<p>Here are some notes on the parsing semantics:</p>
<ul class="simple">
<li>Most non-<em class="mimetype">multipart</em> type messages are parsed as a single message
object with a string payload.  These objects will return <code class="docutils literal notranslate"><span class="pre">False</span></code> for
<code class="xref py py-meth docutils literal notranslate"><span class="pre">is_multipart()</span></code>.  Their <code class="xref py py-meth docutils literal notranslate"><span class="pre">get_payload()</span></code> method will return a string
object.</li>
<li>All <em class="mimetype">multipart</em> type messages will be parsed as a container message
object with a list of sub-message objects for their payload.  The outer
container message will return <code class="docutils literal notranslate"><span class="pre">True</span></code> for <code class="xref py py-meth docutils literal notranslate"><span class="pre">is_multipart()</span></code> and their
<code class="xref py py-meth docutils literal notranslate"><span class="pre">get_payload()</span></code> method will return the list of <a class="reference internal" href="email.message.html#email.message.Message" title="email.message.Message"><code class="xref py py-class docutils literal notranslate"><span class="pre">Message</span></code></a>
subparts.</li>
<li>Most messages with a content type of <em class="mimetype">message/*</em> (e.g.
<em class="mimetype">message/delivery-status</em> and <em class="mimetype">message/rfc822</em>) will also be
parsed as container object containing a list payload of length 1.  Their
<code class="xref py py-meth docutils literal notranslate"><span class="pre">is_multipart()</span></code> method will return <code class="docutils literal notranslate"><span class="pre">True</span></code>.  The single element in the
list payload will be a sub-message object.</li>
<li>Some non-standards compliant messages may not be internally consistent about
their <em class="mimetype">multipart</em>-edness.  Such messages may have a
<em class="mailheader">Content-Type</em> header of type <em class="mimetype">multipart</em>, but their
<code class="xref py py-meth docutils literal notranslate"><span class="pre">is_multipart()</span></code> method may return <code class="docutils literal notranslate"><span class="pre">False</span></code>.  If such messages were parsed
with the <code class="xref py py-class docutils literal notranslate"><span class="pre">FeedParser</span></code>, they will have an instance of the
<code class="xref py py-class docutils literal notranslate"><span class="pre">MultipartInvariantViolationDefect</span></code> class in their <em>defects</em> attribute
list.  See <a class="reference internal" href="email.errors.html#module-email.errors" title="email.errors: The exception classes used by the email package."><code class="xref py py-mod docutils literal notranslate"><span class="pre">email.errors</span></code></a> for details.</li>
</ul>
<p class="rubric">Footnotes</p>
<table class="docutils footnote" frame="void" id="id2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>As of email package version 3.0, introduced in Python 2.4, the classic
<code class="xref py py-class docutils literal notranslate"><span class="pre">Parser</span></code> was re-implemented in terms of the <code class="xref py py-class docutils literal notranslate"><span class="pre">FeedParser</span></code>, so the
semantics and results are identical between the two parsers.</td></tr>
</tbody>
</table>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">18.1.2. <code class="docutils literal notranslate"><span class="pre">email</span></code>: Parsing email messages</a><ul>
<li><a class="reference internal" href="#feedparser-api">18.1.2.1. FeedParser API</a></li>
<li><a class="reference internal" href="#parser-class-api">18.1.2.2. Parser class API</a></li>
<li><a class="reference internal" href="#additional-notes">18.1.2.3. Additional notes</a></li>
</ul>
</li>
</ul>

  <h4>上個主題</h4>
  <p class="topless"><a href="email.message.html"
                        title="上一章">18.1.1. <code class="docutils literal notranslate"><span class="pre">email</span></code>: Representing an email message</a></p>
  <h4>下個主題</h4>
  <p class="topless"><a href="email.generator.html"
                        title="下一章">18.1.3. <code class="docutils literal notranslate"><span class="pre">email</span></code>: Generating MIME documents</a></p>
  <div role="note" aria-label="source link">
    <h3>本頁</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/library/email.parser.rst.txt"
            rel="nofollow">顯示原始碼</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>快速搜尋</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="搜" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>瀏覽</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="總索引"
             >索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 模組索引"
             >模組</a> |</li>
        <li class="right" >
          <a href="email.generator.html" title="18.1.3. email: Generating MIME documents"
             >下一頁</a> |</li>
        <li class="right" >
          <a href="email.message.html" title="18.1.1. email: Representing an email message"
             >上一頁</a> |</li>

    <li><img src="../_static/py.png" alt=""
             style="vertical-align: middle; margin-top: -1px"/></li>
    <li><a href="https://www.python.org/">Python</a> &#187;</li>
    

          <li id="cpython-language-and-version">
            <a href="../index.html">Python 2.6.9 說明文件</a> &#187;
          </li>

          <li class="nav-item nav-item-1"><a href="index.html" >The Python Standard Library</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="netdata.html" >18. Internet Data Handling</a> &#187;</li>
          <li class="nav-item nav-item-3"><a href="email.html" >18.1. <code class="docutils literal notranslate"><span class="pre">email</span></code> — An email and MIME handling package</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="快速搜尋" type="text" name="q" />
          <input type="submit" value="搜" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">版權所有</a> 1990-2026, Python Software Foundation.
    <br />

    The Python Software Foundation is a non-profit corporation.
<a href="https://www.python.org/psf/donations/">Please donate.</a>
<br />
    <br />

    最後更新於 2月 24, 2026。
    
    <br />

    Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.8.4.
    </div>

  </body>
</html>
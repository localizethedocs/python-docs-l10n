# SOME DESCRIPTIVE TITLE.
# Copyright (C) 1990-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 2.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-10 15:09+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../c-api/structures.rst:6
msgid "Common Object Structures"
msgstr ""

#: ../../../c-api/structures.rst:8
msgid ""
"There are a large number of structures which are used in the definition of "
"object types for Python.  This section describes these structures and how "
"they are used."
msgstr ""

#: ../../../c-api/structures.rst:12
msgid ""
"All Python objects ultimately share a small number of fields at the "
"beginning of the object's representation in memory.  These are represented "
"by the :ctype:`PyObject` and :ctype:`PyVarObject` types, which are defined, "
"in turn, by the expansions of some macros also used, whether directly or "
"indirectly, in the definition of all other Python objects."
msgstr ""

#: ../../../c-api/structures.rst:36
msgid ""
"These macros are used in the definition of :ctype:`PyObject` and :ctype:"
"`PyVarObject`:"
msgstr ""

#: ../../../c-api/structures.rst:121
msgid ""
"The :attr:`ml_meth` is a C function pointer.  The functions may be of "
"different types, but they always return :ctype:`PyObject\\*`.  If the "
"function is not of the :ctype:`PyCFunction`, the compiler will require a "
"cast in the method table. Even though :ctype:`PyCFunction` defines the first "
"parameter as :ctype:`PyObject\\*`, it is common that the method "
"implementation uses a the specific C type of the *self* object."
msgstr ""

#: ../../../c-api/structures.rst:128
msgid ""
"The :attr:`ml_flags` field is a bitfield which can include the following "
"flags. The individual flags indicate either a calling convention or a "
"binding convention.  Of the calling convention flags, only :const:"
"`METH_VARARGS` and :const:`METH_KEYWORDS` can be combined (but note that :"
"const:`METH_KEYWORDS` alone is equivalent to ``METH_VARARGS | "
"METH_KEYWORDS``). Any of the calling convention flags can be combined with a "
"binding flag."
msgstr ""

#: ../../../c-api/structures.rst:138
msgid ""
"This is the typical calling convention, where the methods have the type :"
"ctype:`PyCFunction`. The function expects two :ctype:`PyObject\\*` values. "
"The first one is the *self* object for methods; for module functions, it has "
"the value given to :cfunc:`Py_InitModule4` (or *NULL* if :cfunc:"
"`Py_InitModule` was used).  The second parameter (often called *args*) is a "
"tuple object representing all arguments. This parameter is typically "
"processed using :cfunc:`PyArg_ParseTuple` or :cfunc:`PyArg_UnpackTuple`."
msgstr ""

#: ../../../c-api/structures.rst:150
msgid ""
"Methods with these flags must be of type :ctype:`PyCFunctionWithKeywords`. "
"The function expects three parameters: *self*, *args*, and a dictionary of "
"all the keyword arguments.  The flag is typically combined with :const:"
"`METH_VARARGS`, and the parameters are typically processed using :cfunc:"
"`PyArg_ParseTupleAndKeywords`."
msgstr ""

#: ../../../c-api/structures.rst:159
msgid ""
"Methods without parameters don't need to check whether arguments are given "
"if they are listed with the :const:`METH_NOARGS` flag.  They need to be of "
"type :ctype:`PyCFunction`.  When used with object methods, the first "
"parameter is typically named ``self`` and will hold a reference to the "
"object instance. In all cases the second parameter will be *NULL*."
msgstr ""

#: ../../../c-api/structures.rst:168
msgid ""
"Methods with a single object argument can be listed with the :const:`METH_O` "
"flag, instead of invoking :cfunc:`PyArg_ParseTuple` with a ``\"O\"`` "
"argument. They have the type :ctype:`PyCFunction`, with the *self* "
"parameter, and a :ctype:`PyObject\\*` parameter representing the single "
"argument."
msgstr ""

#: ../../../c-api/structures.rst:176
msgid ""
"This calling convention is deprecated.  The method must be of type :ctype:"
"`PyCFunction`.  The second argument is *NULL* if no arguments are given, a "
"single object if exactly one argument is given, and a tuple of objects if "
"more than one argument is given.  There is no way for a function using this "
"convention to distinguish between a call with multiple arguments and a call "
"with a tuple as the only argument."
msgstr ""

#: ../../../c-api/structures.rst:183
msgid ""
"These two constants are not used to indicate the calling convention but the "
"binding when use with methods of classes.  These may not be used for "
"functions defined for modules.  At most one of these flags may be set for "
"any given method."
msgstr ""

#: ../../../c-api/structures.rst:193
msgid ""
"The method will be passed the type object as the first parameter rather than "
"an instance of the type.  This is used to create *class methods*, similar to "
"what is created when using the :func:`classmethod` built-in function."
msgstr ""

#: ../../../c-api/structures.rst:205
msgid ""
"The method will be passed *NULL* as the first parameter rather than an "
"instance of the type.  This is used to create *static methods*, similar to "
"what is created when using the :func:`staticmethod` built-in function."
msgstr ""

#: ../../../c-api/structures.rst:211
msgid ""
"One other constant controls whether a method is loaded in place of another "
"definition with the same method name."
msgstr ""

#: ../../../c-api/structures.rst:217
msgid ""
"The method will be loaded in place of existing definitions.  Without "
"*METH_COEXIST*, the default is to skip repeated definitions.  Since slot "
"wrappers are loaded before the method table, the existence of a "
"*sq_contains* slot, for example, would generate a wrapped method named :meth:"
"`__contains__` and preclude the loading of a corresponding PyCFunction with "
"the same name.  With the flag defined, the PyCFunction will be loaded in "
"place of the wrapper object and will co-exist with the slot.  This is "
"helpful because calls to PyCFunctions are optimized more than wrapper object "
"calls."
msgstr ""

#: ../../../c-api/structures.rst:191
msgid "classmethod"
msgstr ""

#: ../../../c-api/structures.rst:203
msgid "staticmethod"
msgstr ""

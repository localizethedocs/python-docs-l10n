# SOME DESCRIPTIVE TITLE.
# Copyright (C) 1990-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 2.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-11 04:42+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../library/io.rst:2
msgid ":mod:`io` --- Core tools for working with streams"
msgstr ""

#: ../../../library/io.rst:12
msgid ""
"The :mod:`io` module provides the Python interfaces to stream handling.  The "
"built-in :func:`open` function is defined in this module."
msgstr ""

#: ../../../library/io.rst:15
msgid ""
"At the top of the I/O hierarchy is the abstract base class :class:`IOBase`.  "
"It defines the basic interface to a stream.  Note, however, that there is no "
"separation between reading and writing to streams; implementations are "
"allowed to throw an :exc:`IOError` if they do not support a given operation."
msgstr ""

#: ../../../library/io.rst:20
msgid ""
"Extending :class:`IOBase` is :class:`RawIOBase` which deals simply with the "
"reading and writing of raw bytes to a stream.  :class:`FileIO` subclasses :"
"class:`RawIOBase` to provide an interface to files in the machine's file "
"system."
msgstr ""

#: ../../../library/io.rst:25
msgid ""
":class:`BufferedIOBase` deals with buffering on a raw byte stream (:class:"
"`RawIOBase`).  Its subclasses, :class:`BufferedWriter`, :class:"
"`BufferedReader`, and :class:`BufferedRWPair` buffer streams that are "
"readable, writable, and both readable and writable. :class:`BufferedRandom` "
"provides a buffered interface to random access streams.  :class:`BytesIO` is "
"a simple stream of in-memory bytes."
msgstr ""

#: ../../../library/io.rst:32
msgid ""
"Another :class:`IOBase` subclass, :class:`TextIOBase`, deals with streams "
"whose bytes represent text, and handles encoding and decoding from and to "
"strings. :class:`TextIOWrapper`, which extends it, is a buffered text "
"interface to a buffered raw stream (:class:`BufferedIOBase`). Finally, :"
"class:`StringIO` is an in-memory stream for text."
msgstr ""

#: ../../../library/io.rst:39
msgid ""
"Argument names are not part of the specification, and only the arguments of :"
"func:`.open` are intended to be used as keyword arguments."
msgstr ""

#: ../../../library/io.rst:44
msgid "Module Interface"
msgstr ""

#: ../../../library/io.rst:48
msgid ""
"An int containing the default buffer size used by the module's buffered I/O "
"classes.  :func:`.open` uses the file's blksize (as obtained by :func:`os."
"stat`) if possible."
msgstr ""

#: ../../../library/io.rst:54
msgid ""
"Open *file* and return a stream.  If the file cannot be opened, an :exc:"
"`IOError` is raised."
msgstr ""

#: ../../../library/io.rst:57
msgid ""
"*file* is either a string giving the name (and the path if the file isn't in "
"the current working directory) of the file to be opened or a file descriptor "
"of the file to be opened.  (If a file descriptor is given, for example, "
"from :func:`os.fdopen`, it is closed when the returned I/O object is closed, "
"unless *closefd* is set to ``False``.)"
msgstr ""

#: ../../../library/io.rst:63
msgid ""
"*mode* is an optional string that specifies the mode in which the file is "
"opened.  It defaults to ``'r'`` which means open for reading in text mode. "
"Other common values are ``'w'`` for writing (truncating the file if it "
"already exists), and ``'a'`` for appending (which on *some* Unix systems, "
"means that *all* writes append to the end of the file regardless of the "
"current seek position).  In text mode, if *encoding* is not specified the "
"encoding used is platform dependent. (For reading and writing raw bytes use "
"binary mode and leave *encoding* unspecified.)  The available modes are:"
msgstr ""

#: ../../../library/io.rst:73
msgid "Character"
msgstr ""

#: ../../../library/io.rst:73
msgid "Meaning"
msgstr ""

#: ../../../library/io.rst:75
msgid "``'r'``"
msgstr ""

#: ../../../library/io.rst:75
msgid "open for reading (default)"
msgstr ""

#: ../../../library/io.rst:76
msgid "``'w'``"
msgstr ""

#: ../../../library/io.rst:76
msgid "open for writing, truncating the file first"
msgstr ""

#: ../../../library/io.rst:77
msgid "``'a'``"
msgstr ""

#: ../../../library/io.rst:77
msgid "open for writing, appending to the end of the file if it exists"
msgstr ""

#: ../../../library/io.rst:78
msgid "``'b'``"
msgstr ""

#: ../../../library/io.rst:78
msgid "binary mode"
msgstr ""

#: ../../../library/io.rst:79
msgid "``'t'``"
msgstr ""

#: ../../../library/io.rst:79
msgid "text mode (default)"
msgstr ""

#: ../../../library/io.rst:80
msgid "``'+'``"
msgstr ""

#: ../../../library/io.rst:80
msgid "open a disk file for updating (reading and writing)"
msgstr ""

#: ../../../library/io.rst:81
msgid "``'U'``"
msgstr ""

#: ../../../library/io.rst:81
msgid ""
"universal newline mode (for backwards compatibility; should not be used in "
"new code)"
msgstr ""

#: ../../../library/io.rst:85
msgid ""
"The default mode is ``'rt'`` (open for reading text).  For binary random "
"access, the mode ``'w+b'`` opens and truncates the file to 0 bytes, while "
"``'r+b'`` opens the file without truncation."
msgstr ""

#: ../../../library/io.rst:89
msgid ""
"Python distinguishes between files opened in binary and text modes, even "
"when the underlying operating system doesn't.  Files opened in binary mode "
"(including ``'b'`` in the *mode* argument) return contents as ``bytes`` "
"objects without any decoding.  In text mode (the default, or when ``'t'`` is "
"included in the *mode* argument), the contents of the file are returned as "
"strings, the bytes having been first decoded using a platform-dependent "
"encoding or using the specified *encoding* if given."
msgstr ""

#: ../../../library/io.rst:97
msgid ""
"*buffering* is an optional integer used to set the buffering policy. Pass 0 "
"to switch buffering off (only allowed in binary mode), 1 to select line "
"buffering (only usable in text mode), and an integer > 1 to indicate the "
"size of a fixed-size chunk buffer.  When no *buffering* argument is given, "
"the default buffering policy works as follows:"
msgstr ""

#: ../../../library/io.rst:103
msgid ""
"Binary files are buffered in fixed-size chunks; the size of the buffer is "
"chosen using a heuristic trying to determine the underlying device's \"block "
"size\" and falling back on :attr:`DEFAULT_BUFFER_SIZE`. On many systems, the "
"buffer will typically be 4096 or 8192 bytes long."
msgstr ""

#: ../../../library/io.rst:108
msgid ""
"\"Interactive\" text files (files for which :meth:`isatty` returns True) use "
"line buffering.  Other text files use the policy described above for binary "
"files."
msgstr ""

#: ../../../library/io.rst:112
msgid ""
"*encoding* is the name of the encoding used to decode or encode the file. "
"This should only be used in text mode.  The default encoding is platform "
"dependent, but any encoding supported by Python can be used.  See the :mod:"
"`codecs` module for the list of supported encodings."
msgstr ""

#: ../../../library/io.rst:117 ../../../library/io.rst:610
msgid ""
"*errors* is an optional string that specifies how encoding and decoding "
"errors are to be handled.  Pass ``'strict'`` to raise a :exc:`ValueError` "
"exception if there is an encoding error (the default of ``None`` has the "
"same effect), or pass ``'ignore'`` to ignore errors.  (Note that ignoring "
"encoding errors can lead to data loss.)  ``'replace'`` causes a replacement "
"marker (such as ``'?'``) to be inserted where there is malformed data.  When "
"writing, ``'xmlcharrefreplace'`` (replace with the appropriate XML character "
"reference) or ``'backslashreplace'`` (replace with backslashed escape "
"sequences) can be used.  Any other error handling name that has been "
"registered with :func:`codecs.register_error` is also valid."
msgstr ""

#: ../../../library/io.rst:128
msgid ""
"*newline* controls how universal newlines works (it only applies to text "
"mode).  It can be ``None``, ``''``, ``'\\n'``, ``'\\r'``, and ``'\\r\\n'``.  "
"It works as follows:"
msgstr ""

#: ../../../library/io.rst:132
msgid ""
"On input, if *newline* is ``None``, universal newlines mode is enabled. "
"Lines in the input can end in ``'\\n'``, ``'\\r'``, or ``'\\r\\n'``, and "
"these are translated into ``'\\n'`` before being returned to the caller.  If "
"it is ``''``, universal newline mode is enabled, but line endings are "
"returned to the caller untranslated.  If it has any of the other legal "
"values, input lines are only terminated by the given string, and the line "
"ending is returned to the caller untranslated."
msgstr ""

#: ../../../library/io.rst:140
msgid ""
"On output, if *newline* is ``None``, any ``'\\n'`` characters written are "
"translated to the system default line separator, :data:`os.linesep`.  If "
"*newline* is ``''``, no translation takes place.  If *newline* is any of the "
"other legal values, any ``'\\n'`` characters written are translated to the "
"given string."
msgstr ""

#: ../../../library/io.rst:146
msgid ""
"If *closefd* is ``False`` and a file descriptor rather than a filename was "
"given, the underlying file descriptor will be kept open when the file is "
"closed.  If a filename is given *closefd* has no effect but must be ``True`` "
"(the default)."
msgstr ""

#: ../../../library/io.rst:151
msgid ""
"The type of file object returned by the :func:`.open` function depends on "
"the mode.  When :func:`.open` is used to open a file in a text mode "
"(``'w'``, ``'r'``, ``'wt'``, ``'rt'``, etc.), it returns a :class:"
"`TextIOWrapper`. When used to open a file in a binary mode, the returned "
"class varies: in read binary mode, it returns a :class:`BufferedReader`; in "
"write binary and append binary modes, it returns a :class:`BufferedWriter`, "
"and in read/write mode, it returns a :class:`BufferedRandom`."
msgstr ""

#: ../../../library/io.rst:160
msgid ""
"It is also possible to use a string or bytearray as a file for both reading "
"and writing.  For strings :class:`StringIO` can be used like a file opened "
"in a text mode, and for bytearrays a :class:`BytesIO` can be used like a "
"file opened in a binary mode."
msgstr ""

#: ../../../library/io.rst:168
msgid ""
"Error raised when blocking would occur on a non-blocking stream.  It "
"inherits :exc:`IOError`."
msgstr ""

#: ../../../library/io.rst:171
msgid ""
"In addition to those of :exc:`IOError`, :exc:`BlockingIOError` has one "
"attribute:"
msgstr ""

#: ../../../library/io.rst:176
msgid ""
"An integer containing the number of characters written to the stream before "
"it blocked."
msgstr ""

#: ../../../library/io.rst:182
msgid ""
"An exception inheriting :exc:`IOError` and :exc:`ValueError` that is raised "
"when an unsupported operation is called on a stream."
msgstr ""

#: ../../../library/io.rst:187
msgid "I/O Base Classes"
msgstr ""

#: ../../../library/io.rst:191
msgid ""
"The abstract base class for all I/O classes, acting on streams of bytes. "
"There is no public constructor."
msgstr ""

#: ../../../library/io.rst:194
msgid ""
"This class provides empty abstract implementations for many methods that "
"derived classes can override selectively; the default implementations "
"represent a file that cannot be read, written or seeked."
msgstr ""

#: ../../../library/io.rst:199
msgid ""
"Even though :class:`IOBase` does not declare :meth:`read`, :meth:`readinto`, "
"or :meth:`write` because their signatures will vary, implementations and "
"clients should consider those methods part of the interface.  Also, "
"implementations may raise a :exc:`IOError` when operations they do not "
"support are called."
msgstr ""

#: ../../../library/io.rst:205
msgid ""
"The basic type used for binary data read from or written to a file is :class:"
"`bytes`.  :class:`bytearray`\\s are accepted too, and in some cases (such "
"as :class:`readinto`) required.  Text I/O classes work with :class:`str` "
"data."
msgstr ""

#: ../../../library/io.rst:210
msgid ""
"Note that calling any method (even inquiries) on a closed stream is "
"undefined.  Implementations may raise :exc:`IOError` in this case."
msgstr ""

#: ../../../library/io.rst:213
msgid ""
"IOBase (and its subclasses) support the iterator protocol, meaning that an :"
"class:`IOBase` object can be iterated over yielding the lines in a stream."
msgstr ""

#: ../../../library/io.rst:216
msgid ""
"IOBase is also a context manager and therefore supports the :keyword:`with` "
"statement.  In this example, *file* is closed after the :keyword:`with` "
"statement's suite is finished---even if an exception occurs::"
msgstr ""

#: ../../../library/io.rst:223
msgid ":class:`IOBase` provides these data attributes and methods:"
msgstr ""

#: ../../../library/io.rst:227
msgid ""
"Flush and close this stream. This method has no effect if the file is "
"already closed. Once the file is closed, any operation on the file (e.g. "
"reading or writing) will raise an :exc:`ValueError`."
msgstr ""

#: ../../../library/io.rst:231
msgid ""
"As a convenience, it is allowed to call this method more than once; only the "
"first call, however, will have an effect."
msgstr ""

#: ../../../library/io.rst:236
msgid "True if the stream is closed."
msgstr ""

#: ../../../library/io.rst:240
msgid ""
"Return the underlying file descriptor (an integer) of the stream if it "
"exists.  An :exc:`IOError` is raised if the IO object does not use a file "
"descriptor."
msgstr ""

#: ../../../library/io.rst:246
msgid ""
"Flush the write buffers of the stream if applicable.  This does nothing for "
"read-only and non-blocking streams."
msgstr ""

#: ../../../library/io.rst:251
msgid ""
"Return ``True`` if the stream is interactive (i.e., connected to a terminal/"
"tty device)."
msgstr ""

#: ../../../library/io.rst:256
msgid ""
"Return ``True`` if the stream can be read from.  If False, :meth:`read` will "
"raise :exc:`IOError`."
msgstr ""

#: ../../../library/io.rst:261
msgid ""
"Read and return one line from the stream.  If *limit* is specified, at most "
"*limit* bytes will be read."
msgstr ""

#: ../../../library/io.rst:264
msgid ""
"The line terminator is always ``b'\\n'`` for binary files; for text files, "
"the *newlines* argument to :func:`.open` can be used to select the line "
"terminator(s) recognized."
msgstr ""

#: ../../../library/io.rst:270
msgid ""
"Read and return a list of lines from the stream.  *hint* can be specified to "
"control the number of lines read: no more lines will be read if the total "
"size (in bytes/characters) of all lines so far exceeds *hint*."
msgstr ""

#: ../../../library/io.rst:276
msgid ""
"Change the stream position to the given byte *offset*.  *offset* is "
"interpreted relative to the position indicated by *whence*.  Values for "
"*whence* are:"
msgstr ""

#: ../../../library/io.rst:280
msgid ""
"``0`` -- start of the stream (the default); *offset* should be zero or "
"positive"
msgstr ""

#: ../../../library/io.rst:281
msgid "``1`` -- current stream position; *offset* may be negative"
msgstr ""

#: ../../../library/io.rst:282
msgid "``2`` -- end of the stream; *offset* is usually negative"
msgstr ""

#: ../../../library/io.rst:284
msgid "Return the new absolute position."
msgstr ""

#: ../../../library/io.rst:288
msgid ""
"Return ``True`` if the stream supports random access.  If ``False``, :meth:"
"`seek`, :meth:`tell` and :meth:`truncate` will raise :exc:`IOError`."
msgstr ""

#: ../../../library/io.rst:293
msgid "Return the current stream position."
msgstr ""

#: ../../../library/io.rst:297
msgid ""
"Resize the stream to the given *size* in bytes (or the current position if "
"*size* is not specified).  The current stream position isn't changed. This "
"resizing can extend or reduce the current file size.  In case of extension, "
"the contents of the new file area depend on the platform (on most systems, "
"additional bytes are zero-filled, on Windows they're undetermined).  The new "
"file size is returned."
msgstr ""

#: ../../../library/io.rst:306
msgid ""
"Return ``True`` if the stream supports writing.  If ``False``, :meth:`write` "
"and :meth:`truncate` will raise :exc:`IOError`."
msgstr ""

#: ../../../library/io.rst:311
msgid ""
"Write a list of lines to the stream.  Line separators are not added, so it "
"is usual for each of the lines provided to have a line separator at the end."
msgstr ""

#: ../../../library/io.rst:318
msgid ""
"Base class for raw binary I/O.  It inherits :class:`IOBase`.  There is no "
"public constructor."
msgstr ""

#: ../../../library/io.rst:321
msgid ""
"In addition to the attributes and methods from :class:`IOBase`, RawIOBase "
"provides the following methods:"
msgstr ""

#: ../../../library/io.rst:326
msgid ""
"Read and return all the bytes from the stream until EOF, or if *n* is "
"specified, up to *n* bytes.  Only one system call is ever made.  An empty "
"bytes object is returned on EOF; ``None`` is returned if the object is set "
"not to block and has no data to read."
msgstr ""

#: ../../../library/io.rst:333
msgid ""
"Read and return all the bytes from the stream until EOF, using multiple "
"calls to the stream if necessary."
msgstr ""

#: ../../../library/io.rst:338 ../../../library/io.rst:386
msgid ""
"Read up to len(b) bytes into bytearray *b* and return the number of bytes "
"read."
msgstr ""

#: ../../../library/io.rst:343
msgid ""
"Write the given bytes or bytearray object, *b*, to the underlying raw stream "
"and return the number of bytes written (This is never less than ``len(b)``, "
"since if the write fails, an :exc:`IOError` will be raised)."
msgstr ""

#: ../../../library/io.rst:350
msgid ""
"Base class for streams that support buffering.  It inherits :class:`IOBase`. "
"There is no public constructor."
msgstr ""

#: ../../../library/io.rst:353
msgid ""
"The main difference with :class:`RawIOBase` is that the :meth:`read` method "
"supports omitting the *size* argument, and does not have a default "
"implementation that defers to :meth:`readinto`."
msgstr ""

#: ../../../library/io.rst:357
msgid ""
"In addition, :meth:`read`, :meth:`readinto`, and :meth:`write` may raise :"
"exc:`BlockingIOError` if the underlying raw stream is in non-blocking mode "
"and not ready; unlike their raw counterparts, they will never return "
"``None``."
msgstr ""

#: ../../../library/io.rst:362
msgid ""
"A typical implementation should not inherit from a :class:`RawIOBase` "
"implementation, but wrap one like :class:`BufferedWriter` and :class:"
"`BufferedReader`."
msgstr ""

#: ../../../library/io.rst:366
msgid ""
":class:`BufferedIOBase` provides or overrides these methods in addition to "
"those from :class:`IOBase`:"
msgstr ""

#: ../../../library/io.rst:371
msgid ""
"Read and return up to *n* bytes.  If the argument is omitted, ``None``, or "
"negative, data is read and returned until EOF is reached.  An empty bytes "
"object is returned if the stream is already at EOF."
msgstr ""

#: ../../../library/io.rst:375
msgid ""
"If the argument is positive, and the underlying raw stream is not "
"interactive, multiple raw reads may be issued to satisfy the byte count "
"(unless EOF is reached first).  But for interactive raw streams, at most one "
"raw read will be issued, and a short result does not imply that EOF is "
"imminent."
msgstr ""

#: ../../../library/io.rst:381 ../../../library/io.rst:392
msgid ""
"A :exc:`BlockingIOError` is raised if the underlying raw stream has no data "
"at the moment."
msgstr ""

#: ../../../library/io.rst:389
msgid ""
"Like :meth:`read`, multiple reads may be issued to the underlying raw "
"stream, unless the latter is 'interactive.'"
msgstr ""

#: ../../../library/io.rst:397
msgid ""
"Write the given bytes or bytearray object, *b*, to the underlying raw stream "
"and return the number of bytes written (never less than ``len(b)``, since if "
"the write fails an :exc:`IOError` will be raised)."
msgstr ""

#: ../../../library/io.rst:401
msgid ""
"A :exc:`BlockingIOError` is raised if the buffer is full, and the underlying "
"raw stream cannot accept more data at the moment."
msgstr ""

#: ../../../library/io.rst:406
msgid "Raw File I/O"
msgstr ""

#: ../../../library/io.rst:410
msgid ""
":class:`FileIO` represents a file containing bytes data.  It implements the :"
"class:`RawIOBase` interface (and therefore the :class:`IOBase` interface, "
"too)."
msgstr ""

#: ../../../library/io.rst:414
msgid ""
"The *mode* can be ``'r'``, ``'w'`` or ``'a'`` for reading (default), "
"writing, or appending.  The file will be created if it doesn't exist when "
"opened for writing or appending; it will be truncated when opened for "
"writing.  Add a ``'+'`` to the mode to allow simultaneous reading and "
"writing."
msgstr ""

#: ../../../library/io.rst:419
msgid ""
"In addition to the attributes and methods from :class:`IOBase` and :class:"
"`RawIOBase`, :class:`FileIO` provides the following data attributes and "
"methods:"
msgstr ""

#: ../../../library/io.rst:425
msgid "The mode as given in the constructor."
msgstr ""

#: ../../../library/io.rst:429
msgid ""
"The file name.  This is the file descriptor of the file when no name is "
"given in the constructor."
msgstr ""

#: ../../../library/io.rst:434
msgid ""
"Read and return at most *n* bytes.  Only one system call is made, so it is "
"possible that less data than was requested is returned.  Use :func:`len` on "
"the returned bytes object to see how many bytes were actually returned. (In "
"non-blocking mode, ``None`` is returned when no data is available.)"
msgstr ""

#: ../../../library/io.rst:441
msgid ""
"Read and return the entire file's contents in a single bytes object.  As "
"much as immediately available is returned in non-blocking mode.  If the EOF "
"has been reached, ``b''`` is returned."
msgstr ""

#: ../../../library/io.rst:447
msgid ""
"Write the bytes or bytearray object, *b*, to the file, and return the number "
"actually written. Only one system call is made, so it is possible that only "
"some of the data is written."
msgstr ""

#: ../../../library/io.rst:451
msgid ""
"Note that the inherited ``readinto()`` method should not be used on :class:"
"`FileIO` objects."
msgstr ""

#: ../../../library/io.rst:456
msgid "Buffered Streams"
msgstr ""

#: ../../../library/io.rst:460
msgid ""
"A stream implementation using an in-memory bytes buffer.  It inherits :class:"
"`BufferedIOBase`."
msgstr ""

#: ../../../library/io.rst:463
msgid "The argument *initial_bytes* is an optional initial bytearray."
msgstr ""

#: ../../../library/io.rst:465
msgid ""
":class:`BytesIO` provides or overrides these methods in addition to those "
"from :class:`BufferedIOBase` and :class:`IOBase`:"
msgstr ""

#: ../../../library/io.rst:470
msgid "Return ``bytes`` containing the entire contents of the buffer."
msgstr ""

#: ../../../library/io.rst:474
msgid "In :class:`BytesIO`, this is the same as :meth:`read`."
msgstr ""

#: ../../../library/io.rst:479
msgid ""
"A buffer for a readable, sequential :class:`RawIOBase` object.  It inherits :"
"class:`BufferedIOBase`."
msgstr ""

#: ../../../library/io.rst:482
msgid ""
"The constructor creates a :class:`BufferedReader` for the given readable "
"*raw* stream and *buffer_size*.  If *buffer_size* is omitted, :data:"
"`DEFAULT_BUFFER_SIZE` is used."
msgstr ""

#: ../../../library/io.rst:486
msgid ""
":class:`BufferedReader` provides or overrides these methods in addition to "
"those from :class:`BufferedIOBase` and :class:`IOBase`:"
msgstr ""

#: ../../../library/io.rst:491
msgid ""
"Return 1 (or *n* if specified) bytes from a buffer without advancing the "
"position.  Only a single read on the raw stream is done to satisfy the call. "
"The number of bytes returned may be less than requested since at most all "
"the buffer's bytes from the current position to the end are returned."
msgstr ""

#: ../../../library/io.rst:499
msgid ""
"Read and return *n* bytes, or if *n* is not given or negative, until EOF or "
"if the read call would block in non-blocking mode."
msgstr ""

#: ../../../library/io.rst:504
msgid ""
"Read and return up to *n* bytes with only one call on the raw stream.  If at "
"least one byte is buffered, only buffered bytes are returned. Otherwise, one "
"raw stream read call is made."
msgstr ""

#: ../../../library/io.rst:511
msgid ""
"A buffer for a writeable sequential RawIO object.  It inherits :class:"
"`BufferedIOBase`."
msgstr ""

#: ../../../library/io.rst:514
msgid ""
"The constructor creates a :class:`BufferedWriter` for the given writeable "
"*raw* stream.  If the *buffer_size* is not given, it defaults to :data:"
"`DEAFULT_BUFFER_SIZE`.  If *max_buffer_size* is omitted, it defaults to "
"twice the buffer size."
msgstr ""

#: ../../../library/io.rst:519
msgid ""
":class:`BufferedWriter` provides or overrides these methods in addition to "
"those from :class:`BufferedIOBase` and :class:`IOBase`:"
msgstr ""

#: ../../../library/io.rst:524
msgid ""
"Force bytes held in the buffer into the raw stream.  A :exc:"
"`BlockingIOError` should be raised if the raw stream blocks."
msgstr ""

#: ../../../library/io.rst:529
msgid ""
"Write the bytes or bytearray object, *b*, onto the raw stream and return the "
"number of bytes written.  A :exc:`BlockingIOError` is raised when the raw "
"stream blocks."
msgstr ""

#: ../../../library/io.rst:536
msgid ""
"A combined buffered writer and reader object for a raw stream that can be "
"written to and read from.  It has and supports both :meth:`read`, :meth:"
"`write`, and their variants.  This is useful for sockets and two-way pipes. "
"It inherits :class:`BufferedIOBase`."
msgstr ""

#: ../../../library/io.rst:541
msgid ""
"*reader* and *writer* are :class:`RawIOBase` objects that are readable and "
"writeable respectively.  If the *buffer_size* is omitted it defaults to :"
"data:`DEFAULT_BUFFER_SIZE`.  The *max_buffer_size* (for the buffered writer) "
"defaults to twice the buffer size."
msgstr ""

#: ../../../library/io.rst:546
msgid ""
":class:`BufferedRWPair` implements all of :class:`BufferedIOBase`\\'s "
"methods."
msgstr ""

#: ../../../library/io.rst:551
msgid ""
"A buffered interface to random access streams.  It inherits :class:"
"`BufferedReader` and :class:`BufferedWriter`."
msgstr ""

#: ../../../library/io.rst:554
msgid ""
"The constructor creates a reader and writer for a seekable raw stream, given "
"in the first argument.  If the *buffer_size* is omitted it defaults to :data:"
"`DEFAULT_BUFFER_SIZE`.  The *max_buffer_size* (for the buffered writer) "
"defaults to twice the buffer size."
msgstr ""

#: ../../../library/io.rst:559
msgid ""
":class:`BufferedRandom` is capable of anything :class:`BufferedReader` or :"
"class:`BufferedWriter` can do."
msgstr ""

#: ../../../library/io.rst:564
msgid "Text I/O"
msgstr ""

#: ../../../library/io.rst:568
msgid ""
"Base class for text streams.  This class provides a character and line based "
"interface to stream I/O.  There is no :meth:`readinto` method because "
"Python's character strings are immutable.  It inherits :class:`IOBase`. "
"There is no public constructor."
msgstr ""

#: ../../../library/io.rst:573
msgid ""
":class:`TextIOBase` provides or overrides these data attributes and methods "
"in addition to those from :class:`IOBase`:"
msgstr ""

#: ../../../library/io.rst:578
msgid ""
"The name of the encoding used to decode the stream's bytes into strings, and "
"to encode strings into bytes."
msgstr ""

#: ../../../library/io.rst:583
msgid ""
"A string, a tuple of strings, or ``None``, indicating the newlines "
"translated so far."
msgstr ""

#: ../../../library/io.rst:588
msgid ""
"Read and return at most *n* characters from the stream as a single :class:"
"`str`.  If *n* is negative or ``None``, reads to EOF."
msgstr ""

#: ../../../library/io.rst:593
msgid ""
"Read until newline or EOF and return a single ``str``.  If the stream is "
"already at EOF, an empty string is returned."
msgstr ""

#: ../../../library/io.rst:598
msgid ""
"Write the string *s* to the stream and return the number of characters "
"written."
msgstr ""

#: ../../../library/io.rst:604
msgid ""
"A buffered text stream over a :class:`BufferedIOBase` raw stream, *buffer*. "
"It inherits :class:`TextIOBase`."
msgstr ""

#: ../../../library/io.rst:607
msgid ""
"*encoding* gives the name of the encoding that the stream will be decoded or "
"encoded with.  It defaults to :func:`locale.getpreferredencoding`."
msgstr ""

#: ../../../library/io.rst:621
msgid ""
"*newline* can be ``None``, ``''``, ``'\\n'``, ``'\\r'``, or ``'\\r\\n'``.  "
"It controls the handling of line endings.  If it is ``None``, universal "
"newlines is enabled.  With this enabled, on input, the lines endings "
"``'\\n'``, ``'\\r'``, or ``'\\r\\n'`` are translated to ``'\\n'`` before "
"being returned to the caller.  Conversely, on output, ``'\\n'`` is "
"translated to the system default line separator, :data:`os.linesep`.  If "
"*newline* is any other of its legal values, that newline becomes the newline "
"when the file is read and it is returned untranslated.  On output, ``'\\n'`` "
"is converted to the *newline*."
msgstr ""

#: ../../../library/io.rst:630
msgid ""
"If *line_buffering* is ``True``, :meth:`flush` is implied when a call to "
"write contains a newline character."
msgstr ""

#: ../../../library/io.rst:633
msgid ""
":class:`TextIOWrapper` provides these data attributes in addition to those "
"of :class:`TextIOBase` and its parents:"
msgstr ""

#: ../../../library/io.rst:638
msgid "The encoding and decoding error setting."
msgstr ""

#: ../../../library/io.rst:642
msgid "Whether line buffering is enabled."
msgstr ""

#: ../../../library/io.rst:647
msgid "An in-memory stream for text.  It inherits :class:`TextIOWrapper`."
msgstr ""

#: ../../../library/io.rst:649
msgid ""
"Create a new StringIO stream with an inital value, encoding, error handling, "
"and newline setting.  See :class:`TextIOWrapper`\\'s constructor for more "
"information."
msgstr ""

#: ../../../library/io.rst:653
msgid ""
":class:`StringIO` provides this method in addition to those from :class:"
"`TextIOWrapper` and its parents:"
msgstr ""

#: ../../../library/io.rst:658
msgid "Return a ``str`` containing the entire contents of the buffer."
msgstr ""

#: ../../../library/io.rst:663
msgid ""
"A helper codec that decodes newlines for universal newlines mode.  It "
"inherits :class:`codecs.IncrementalDecoder`."
msgstr ""

# SOME DESCRIPTIVE TITLE.
# Copyright (C) 1990-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 2.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-10 15:09+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../library/atexit.rst:3
msgid ":mod:`atexit` --- Exit handlers"
msgstr ""

#: ../../../library/atexit.rst:13
msgid ""
"The :mod:`atexit` module defines a single function to register cleanup "
"functions.  Functions thus registered are automatically executed upon normal "
"interpreter termination."
msgstr ""

#: ../../../library/atexit.rst:17
msgid ""
"Note: the functions registered via this module are not called when the "
"program is killed by a signal, when a Python fatal internal error is "
"detected, or when :func:`os._exit` is called."
msgstr ""

#: ../../../library/atexit.rst:23
msgid ""
"This is an alternate interface to the functionality provided by the ``sys."
"exitfunc`` variable."
msgstr ""

#: ../../../library/atexit.rst:26
msgid ""
"Note: This module is unlikely to work correctly when used with other code "
"that sets ``sys.exitfunc``.  In particular, other core Python modules are "
"free to use :mod:`atexit` without the programmer's knowledge.  Authors who "
"use ``sys.exitfunc`` should convert their code to use :mod:`atexit` "
"instead.  The simplest way to convert code that sets ``sys.exitfunc`` is to "
"import :mod:`atexit` and register the function that had been bound to ``sys."
"exitfunc``."
msgstr ""

#: ../../../library/atexit.rst:36
msgid ""
"Register *func* as a function to be executed at termination.  Any optional "
"arguments that are to be passed to *func* must be passed as arguments to :"
"func:`register`."
msgstr ""

#: ../../../library/atexit.rst:40
msgid ""
"At normal program termination (for instance, if :func:`sys.exit` is called "
"or the main module's execution completes), all functions registered are "
"called in last in, first out order.  The assumption is that lower level "
"modules will normally be imported before higher level modules and thus must "
"be cleaned up later."
msgstr ""

#: ../../../library/atexit.rst:46
msgid ""
"If an exception is raised during execution of the exit handlers, a traceback "
"is printed (unless :exc:`SystemExit` is raised) and the exception "
"information is saved.  After all exit handlers have had a chance to run the "
"last exception to be raised is re-raised."
msgstr ""

#: ../../../library/atexit.rst:51
msgid ""
"This function now returns *func* which makes it possible to use it as a "
"decorator without binding the original name to ``None``."
msgstr ""

#: ../../../library/atexit.rst:58
msgid "Module :mod:`readline`"
msgstr ""

#: ../../../library/atexit.rst:59
msgid ""
"Useful example of :mod:`atexit` to read and write :mod:`readline` history "
"files."
msgstr ""

#: ../../../library/atexit.rst:65
msgid ":mod:`atexit` Example"
msgstr ""

#: ../../../library/atexit.rst:67
msgid ""
"The following simple example demonstrates how a module can initialize a "
"counter from a file when it is imported and save the counter's updated value "
"automatically when the program terminates without relying on the application "
"making an explicit call into this module at termination. ::"
msgstr ""

#: ../../../library/atexit.rst:72
msgid ""
"try:\n"
"    _count = int(open(\"/tmp/counter\").read())\n"
"except IOError:\n"
"    _count = 0\n"
"\n"
"def incrcounter(n):\n"
"    global _count\n"
"    _count = _count + n\n"
"\n"
"def savecounter():\n"
"    open(\"/tmp/counter\", \"w\").write(\"%d\" % _count)\n"
"\n"
"import atexit\n"
"atexit.register(savecounter)"
msgstr ""

#: ../../../library/atexit.rst:87
msgid ""
"Positional and keyword arguments may also be passed to :func:`register` to "
"be passed along to the registered function when it is called::"
msgstr ""

#: ../../../library/atexit.rst:90
msgid ""
"def goodbye(name, adjective):\n"
"    print 'Goodbye, %s, it was %s to meet you.' % (name, adjective)\n"
"\n"
"import atexit\n"
"atexit.register(goodbye, 'Donny', 'nice')\n"
"\n"
"# or:\n"
"atexit.register(goodbye, adjective='nice', name='Donny')"
msgstr ""

#: ../../../library/atexit.rst:99
msgid "Usage as a :term:`decorator`::"
msgstr ""

#: ../../../library/atexit.rst:101
msgid ""
"import atexit\n"
"\n"
"@atexit.register\n"
"def goodbye():\n"
"    print \"You are now leaving the Python sector.\""
msgstr ""

#: ../../../library/atexit.rst:107
msgid "This obviously only works with functions that don't take arguments."
msgstr ""

#: ../../../library/atexit.rst:21
msgid "exitfunc (in sys)"
msgstr ""

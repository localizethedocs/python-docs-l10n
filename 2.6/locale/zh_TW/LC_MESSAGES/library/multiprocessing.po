# SOME DESCRIPTIVE TITLE.
# Copyright (C) 1990-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 2.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-10 15:09+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../library/multiprocessing.rst:2
msgid ":mod:`multiprocessing` --- Process-based \"threading\" interface"
msgstr ""

#: ../../../library/multiprocessing.rst:11
msgid "Introduction"
msgstr ""

#: ../../../library/multiprocessing.rst:13
msgid ""
":mod:`multiprocessing` is a package that supports spawning processes using "
"an API similar to the :mod:`threading` module.  The :mod:`multiprocessing` "
"package offers both local and remote concurrency, effectively side-stepping "
"the :term:`Global Interpreter Lock` by using subprocesses instead of "
"threads.  Due to this, the :mod:`multiprocessing` module allows the "
"programmer to fully leverage multiple processors on a given machine.  It "
"runs on both Unix and Windows."
msgstr ""

#: ../../../library/multiprocessing.rst:23
msgid ""
"Some of this package's functionality requires a functioning shared semaphore "
"implementation on the host operating system. Without one, the :mod:"
"`multiprocessing.synchronize` module will be disabled, and attempts to "
"import it will result in an :exc:`ImportError`. See :issue:`3770` for "
"additional information."
msgstr ""

#: ../../../library/multiprocessing.rst:31
msgid ""
"Functionality within this package requires that the ``__main__`` method be "
"importable by the children. This is covered in :ref:`multiprocessing-"
"programming` however it is worth pointing out here. This means that some "
"examples, such as the :class:`multiprocessing.Pool` examples will not work "
"in the interactive interpreter. For example::"
msgstr ""

#: ../../../library/multiprocessing.rst:37
msgid ""
">>> from multiprocessing import Pool\n"
">>> p = Pool(5)\n"
">>> def f(x):\n"
"...     return x*x\n"
"...\n"
">>> p.map(f, [1,2,3])\n"
"Process PoolWorker-1:\n"
"Process PoolWorker-2:\n"
"Process PoolWorker-3:\n"
"Traceback (most recent call last):\n"
"Traceback (most recent call last):\n"
"Traceback (most recent call last):\n"
"AttributeError: 'module' object has no attribute 'f'\n"
"AttributeError: 'module' object has no attribute 'f'\n"
"AttributeError: 'module' object has no attribute 'f'"
msgstr ""

#: ../../../library/multiprocessing.rst:53
msgid ""
"(If you try this it will actually output three full tracebacks interleaved "
"in a semi-random fashion, and then you may have to stop the master process "
"somehow.)"
msgstr ""

#: ../../../library/multiprocessing.rst:59
msgid "The :class:`Process` class"
msgstr ""

#: ../../../library/multiprocessing.rst:61
msgid ""
"In :mod:`multiprocessing`, processes are spawned by creating a :class:"
"`Process` object and then calling its :meth:`~Process.start` method.  :class:"
"`Process` follows the API of :class:`threading.Thread`.  A trivial example "
"of a multiprocess program is ::"
msgstr ""

#: ../../../library/multiprocessing.rst:66
msgid ""
"from multiprocessing import Process\n"
"\n"
"def f(name):\n"
"    print 'hello', name\n"
"\n"
"if __name__ == '__main__':\n"
"    p = Process(target=f, args=('bob',))\n"
"    p.start()\n"
"    p.join()"
msgstr ""

#: ../../../library/multiprocessing.rst:76
msgid ""
"To show the individual process IDs involved, here is an expanded example::"
msgstr ""

#: ../../../library/multiprocessing.rst:78
msgid ""
"from multiprocessing import Process\n"
"import os\n"
"\n"
"def info(title):\n"
"    print title\n"
"    print 'module name:', __name__\n"
"    print 'parent process:', os.getppid()\n"
"    print 'process id:', os.getpid()\n"
"\n"
"def f(name):\n"
"    info('function f')\n"
"    print 'hello', name\n"
"\n"
"if __name__ == '__main__':\n"
"    info('main line')\n"
"    p = Process(target=f, args=('bob',))\n"
"    p.start()\n"
"    p.join()"
msgstr ""

#: ../../../library/multiprocessing.rst:97
msgid ""
"For an explanation of why (on Windows) the ``if __name__ == '__main__'`` "
"part is necessary, see :ref:`multiprocessing-programming`."
msgstr ""

#: ../../../library/multiprocessing.rst:103
msgid "Exchanging objects between processes"
msgstr ""

#: ../../../library/multiprocessing.rst:105
msgid ""
":mod:`multiprocessing` supports two types of communication channel between "
"processes:"
msgstr ""

#: ../../../library/multiprocessing.rst:108
msgid "**Queues**"
msgstr ""

#: ../../../library/multiprocessing.rst:110
msgid ""
"The :class:`Queue` class is a near clone of :class:`Queue.Queue`.  For "
"example::"
msgstr ""

#: ../../../library/multiprocessing.rst:113
msgid ""
"from multiprocessing import Process, Queue\n"
"\n"
"def f(q):\n"
"    q.put([42, None, 'hello'])\n"
"\n"
"if __name__ == '__main__':\n"
"    q = Queue()\n"
"    p = Process(target=f, args=(q,))\n"
"    p.start()\n"
"    print q.get()    # prints \"[42, None, 'hello']\"\n"
"    p.join()"
msgstr ""

#: ../../../library/multiprocessing.rst:125
msgid "Queues are thread and process safe."
msgstr ""

#: ../../../library/multiprocessing.rst:127
msgid "**Pipes**"
msgstr ""

#: ../../../library/multiprocessing.rst:129
msgid ""
"The :func:`Pipe` function returns a pair of connection objects connected by "
"a pipe which by default is duplex (two-way).  For example::"
msgstr ""

#: ../../../library/multiprocessing.rst:132
msgid ""
"from multiprocessing import Process, Pipe\n"
"\n"
"def f(conn):\n"
"    conn.send([42, None, 'hello'])\n"
"    conn.close()\n"
"\n"
"if __name__ == '__main__':\n"
"    parent_conn, child_conn = Pipe()\n"
"    p = Process(target=f, args=(child_conn,))\n"
"    p.start()\n"
"    print parent_conn.recv()   # prints \"[42, None, 'hello']\"\n"
"    p.join()"
msgstr ""

#: ../../../library/multiprocessing.rst:145
msgid ""
"The two connection objects returned by :func:`Pipe` represent the two ends "
"of the pipe.  Each connection object has :meth:`~Connection.send` and :meth:"
"`~Connection.recv` methods (among others).  Note that data in a pipe may "
"become corrupted if two processes (or threads) try to read from or write to "
"the *same* end of the pipe at the same time.  Of course there is no risk of "
"corruption from processes using different ends of the pipe at the same time."
msgstr ""

#: ../../../library/multiprocessing.rst:155
msgid "Synchronization between processes"
msgstr ""

#: ../../../library/multiprocessing.rst:157
msgid ""
":mod:`multiprocessing` contains equivalents of all the synchronization "
"primitives from :mod:`threading`.  For instance one can use a lock to ensure "
"that only one process prints to standard output at a time::"
msgstr ""

#: ../../../library/multiprocessing.rst:161
msgid ""
"from multiprocessing import Process, Lock\n"
"\n"
"def f(l, i):\n"
"    l.acquire()\n"
"    print 'hello world', i\n"
"    l.release()\n"
"\n"
"if __name__ == '__main__':\n"
"    lock = Lock()\n"
"\n"
"    for num in range(10):\n"
"        Process(target=f, args=(lock, num)).start()"
msgstr ""

#: ../../../library/multiprocessing.rst:174
msgid ""
"Without using the lock output from the different processes is liable to get "
"all mixed up."
msgstr ""

#: ../../../library/multiprocessing.rst:179
msgid "Sharing state between processes"
msgstr ""

#: ../../../library/multiprocessing.rst:181
msgid ""
"As mentioned above, when doing concurrent programming it is usually best to "
"avoid using shared state as far as possible.  This is particularly true when "
"using multiple processes."
msgstr ""

#: ../../../library/multiprocessing.rst:185
msgid ""
"However, if you really do need to use some shared data then :mod:"
"`multiprocessing` provides a couple of ways of doing so."
msgstr ""

#: ../../../library/multiprocessing.rst:188
msgid "**Shared memory**"
msgstr ""

#: ../../../library/multiprocessing.rst:190
msgid ""
"Data can be stored in a shared memory map using :class:`Value` or :class:"
"`Array`.  For example, the following code ::"
msgstr ""

#: ../../../library/multiprocessing.rst:193
msgid ""
"from multiprocessing import Process, Value, Array\n"
"\n"
"def f(n, a):\n"
"    n.value = 3.1415927\n"
"    for i in range(len(a)):\n"
"        a[i] = -a[i]\n"
"\n"
"if __name__ == '__main__':\n"
"    num = Value('d', 0.0)\n"
"    arr = Array('i', range(10))\n"
"\n"
"    p = Process(target=f, args=(num, arr))\n"
"    p.start()\n"
"    p.join()\n"
"\n"
"    print num.value\n"
"    print arr[:]"
msgstr ""

#: ../../../library/multiprocessing.rst:211
#: ../../../library/multiprocessing.rst:258
msgid "will print ::"
msgstr ""

#: ../../../library/multiprocessing.rst:213
msgid ""
"3.1415927\n"
"[0, -1, -2, -3, -4, -5, -6, -7, -8, -9]"
msgstr ""

#: ../../../library/multiprocessing.rst:216
msgid ""
"The ``'d'`` and ``'i'`` arguments used when creating ``num`` and ``arr`` are "
"typecodes of the kind used by the :mod:`array` module: ``'d'`` indicates a "
"double precision float and ``'i'`` indicates a signed integer.  These shared "
"objects will be process and thread safe."
msgstr ""

#: ../../../library/multiprocessing.rst:221
msgid ""
"For more flexibility in using shared memory one can use the :mod:"
"`multiprocessing.sharedctypes` module which supports the creation of "
"arbitrary ctypes objects allocated from shared memory."
msgstr ""

#: ../../../library/multiprocessing.rst:225
msgid "**Server process**"
msgstr ""

#: ../../../library/multiprocessing.rst:227
msgid ""
"A manager object returned by :func:`Manager` controls a server process which "
"holds Python objects and allows other processes to manipulate them using "
"proxies."
msgstr ""

#: ../../../library/multiprocessing.rst:231
msgid ""
"A manager returned by :func:`Manager` will support types :class:`list`, :"
"class:`dict`, :class:`Namespace`, :class:`Lock`, :class:`RLock`, :class:"
"`Semaphore`, :class:`BoundedSemaphore`, :class:`Condition`, :class:`Event`, :"
"class:`Queue`, :class:`Value` and :class:`Array`.  For example, ::"
msgstr ""

#: ../../../library/multiprocessing.rst:237
msgid ""
"from multiprocessing import Process, Manager\n"
"\n"
"def f(d, l):\n"
"    d[1] = '1'\n"
"    d['2'] = 2\n"
"    d[0.25] = None\n"
"    l.reverse()\n"
"\n"
"if __name__ == '__main__':\n"
"    manager = Manager()\n"
"\n"
"    d = manager.dict()\n"
"    l = manager.list(range(10))\n"
"\n"
"    p = Process(target=f, args=(d, l))\n"
"    p.start()\n"
"    p.join()\n"
"\n"
"    print d\n"
"    print l"
msgstr ""

#: ../../../library/multiprocessing.rst:260
msgid ""
"{0.25: None, 1: '1', '2': 2}\n"
"[9, 8, 7, 6, 5, 4, 3, 2, 1, 0]"
msgstr ""

#: ../../../library/multiprocessing.rst:263
msgid ""
"Server process managers are more flexible than using shared memory objects "
"because they can be made to support arbitrary object types.  Also, a single "
"manager can be shared by processes on different computers over a network. "
"They are, however, slower than using shared memory."
msgstr ""

#: ../../../library/multiprocessing.rst:270
msgid "Using a pool of workers"
msgstr ""

#: ../../../library/multiprocessing.rst:272
msgid ""
"The :class:`~multiprocessing.pool.Pool` class represents a pool of worker "
"processes.  It has methods which allows tasks to be offloaded to the worker "
"processes in a few different ways."
msgstr ""

#: ../../../library/multiprocessing.rst:276
msgid "For example::"
msgstr ""

#: ../../../library/multiprocessing.rst:278
msgid ""
"from multiprocessing import Pool\n"
"\n"
"def f(x):\n"
"    return x*x\n"
"\n"
"if __name__ == '__main__':\n"
"    pool = Pool(processes=4)              # start 4 worker processes\n"
"    result = pool.apply_async(f, [10])     # evaluate \"f(10)\" "
"asynchronously\n"
"    print result.get(timeout=1)           # prints \"100\" unless your "
"computer is *very* slow\n"
"    print pool.map(f, range(10))          # prints \"[0, 1, 4,..., 81]\""
msgstr ""

#: ../../../library/multiprocessing.rst:291
msgid "Reference"
msgstr ""

#: ../../../library/multiprocessing.rst:293
msgid ""
"The :mod:`multiprocessing` package mostly replicates the API of the :mod:"
"`threading` module."
msgstr ""

#: ../../../library/multiprocessing.rst:298
msgid ":class:`Process` and exceptions"
msgstr ""

#: ../../../library/multiprocessing.rst:302
msgid ""
"Process objects represent activity that is run in a separate process. The :"
"class:`Process` class has equivalents of all the methods of :class:"
"`threading.Thread`."
msgstr ""

#: ../../../library/multiprocessing.rst:306
msgid ""
"The constructor should always be called with keyword arguments. *group* "
"should always be ``None``; it exists solely for compatibility with :class:"
"`threading.Thread`.  *target* is the callable object to be invoked by the :"
"meth:`run()` method.  It defaults to ``None``, meaning nothing is called. "
"*name* is the process name.  By default, a unique name is constructed of the "
"form 'Process-N\\ :sub:`1`:N\\ :sub:`2`:...:N\\ :sub:`k`' where N\\ :sub:`1`,"
"N\\ :sub:`2`,...,N\\ :sub:`k` is a sequence of integers whose length is "
"determined by the *generation* of the process.  *args* is the argument tuple "
"for the target invocation.  *kwargs* is a dictionary of keyword arguments "
"for the target invocation.  By default, no arguments are passed to *target*."
msgstr ""

#: ../../../library/multiprocessing.rst:318
msgid ""
"If a subclass overrides the constructor, it must make sure it invokes the "
"base class constructor (:meth:`Process.__init__`) before doing anything else "
"to the process."
msgstr ""

#: ../../../library/multiprocessing.rst:324
msgid "Method representing the process's activity."
msgstr ""

#: ../../../library/multiprocessing.rst:326
msgid ""
"You may override this method in a subclass.  The standard :meth:`run` method "
"invokes the callable object passed to the object's constructor as the target "
"argument, if any, with sequential and keyword arguments taken from the "
"*args* and *kwargs* arguments, respectively."
msgstr ""

#: ../../../library/multiprocessing.rst:333
msgid "Start the process's activity."
msgstr ""

#: ../../../library/multiprocessing.rst:335
msgid ""
"This must be called at most once per process object.  It arranges for the "
"object's :meth:`run` method to be invoked in a separate process."
msgstr ""

#: ../../../library/multiprocessing.rst:340
msgid ""
"Block the calling thread until the process whose :meth:`join` method is "
"called terminates or until the optional timeout occurs."
msgstr ""

#: ../../../library/multiprocessing.rst:343
msgid "If *timeout* is ``None`` then there is no timeout."
msgstr ""

#: ../../../library/multiprocessing.rst:345
msgid "A process can be joined many times."
msgstr ""

#: ../../../library/multiprocessing.rst:347
msgid ""
"A process cannot join itself because this would cause a deadlock.  It is an "
"error to attempt to join a process before it has been started."
msgstr ""

#: ../../../library/multiprocessing.rst:352
msgid "The process's name."
msgstr ""

#: ../../../library/multiprocessing.rst:354
msgid ""
"The name is a string used for identification purposes only.  It has no "
"semantics.  Multiple processes may be given the same name.  The initial name "
"is set by the constructor."
msgstr ""

#: ../../../library/multiprocessing.rst:360
msgid "Return whether the process is alive."
msgstr ""

#: ../../../library/multiprocessing.rst:362
msgid ""
"Roughly, a process object is alive from the moment the :meth:`start` method "
"returns until the child process terminates."
msgstr ""

#: ../../../library/multiprocessing.rst:367
msgid ""
"The process's daemon flag, a Boolean value.  This must be set before :meth:"
"`start` is called."
msgstr ""

#: ../../../library/multiprocessing.rst:370
msgid "The initial value is inherited from the creating process."
msgstr ""

#: ../../../library/multiprocessing.rst:372
msgid ""
"When a process exits, it attempts to terminate all of its daemonic child "
"processes."
msgstr ""

#: ../../../library/multiprocessing.rst:375
msgid ""
"Note that a daemonic process is not allowed to create child processes. "
"Otherwise a daemonic process would leave its children orphaned if it gets "
"terminated when its parent process exits. Additionally, these are **not** "
"Unix daemons or services, they are normal processes that will be terminated "
"(and not joined) if non-dameonic processes have exited."
msgstr ""

#: ../../../library/multiprocessing.rst:381
msgid ""
"In addition to the  :class:`Threading.Thread` API, :class:`Process` objects "
"also support the following attributes and methods:"
msgstr ""

#: ../../../library/multiprocessing.rst:386
msgid ""
"Return the process ID.  Before the process is spawned, this will be ``None``."
msgstr ""

#: ../../../library/multiprocessing.rst:391
msgid ""
"The child's exit code.  This will be ``None`` if the process has not yet "
"terminated.  A negative value *-N* indicates that the child was terminated "
"by signal *N*."
msgstr ""

#: ../../../library/multiprocessing.rst:397
msgid "The process's authentication key (a byte string)."
msgstr ""

#: ../../../library/multiprocessing.rst:399
msgid ""
"When :mod:`multiprocessing` is initialized the main process is assigned a "
"random string using :func:`os.random`."
msgstr ""

#: ../../../library/multiprocessing.rst:402
msgid ""
"When a :class:`Process` object is created, it will inherit the "
"authentication key of its parent process, although this may be changed by "
"setting :attr:`authkey` to another byte string."
msgstr ""

#: ../../../library/multiprocessing.rst:406
msgid "See :ref:`multiprocessing-auth-keys`."
msgstr ""

#: ../../../library/multiprocessing.rst:410
msgid ""
"Terminate the process.  On Unix this is done using the ``SIGTERM`` signal; "
"on Windows :cfunc:`TerminateProcess` is used.  Note that exit handlers and "
"finally clauses, etc., will not be executed."
msgstr ""

#: ../../../library/multiprocessing.rst:414
msgid ""
"Note that descendant processes of the process will *not* be terminated -- "
"they will simply become orphaned."
msgstr ""

#: ../../../library/multiprocessing.rst:419
msgid ""
"If this method is used when the associated process is using a pipe or queue "
"then the pipe or queue is liable to become corrupted and may become unusable "
"by other process.  Similarly, if the process has acquired a lock or "
"semaphore etc. then terminating it is liable to cause other processes to "
"deadlock."
msgstr ""

#: ../../../library/multiprocessing.rst:425
msgid ""
"Note that the :meth:`start`, :meth:`join`, :meth:`is_alive` and :attr:"
"`exit_code` methods should only be called by the process that created the "
"process object."
msgstr ""

#: ../../../library/multiprocessing.rst:429
msgid "Example usage of some of the methods of :class:`Process`:"
msgstr ""

#: ../../../library/multiprocessing.rst:431
msgid ""
">>> import multiprocessing, time, signal\n"
">>> p = multiprocessing.Process(target=time.sleep, args=(1000,))\n"
">>> print p, p.is_alive()\n"
"<Process(Process-1, initial)> False\n"
">>> p.start()\n"
">>> print p, p.is_alive()\n"
"<Process(Process-1, started)> True\n"
">>> p.terminate()\n"
">>> time.sleep(0.1)\n"
">>> print p, p.is_alive()\n"
"<Process(Process-1, stopped[SIGTERM])> False\n"
">>> p.exitcode == -signal.SIGTERM\n"
"True"
msgstr ""

#: ../../../library/multiprocessing.rst:450
msgid ""
"Exception raised by :meth:`Connection.recv_bytes_into()` when the supplied "
"buffer object is too small for the message read."
msgstr ""

#: ../../../library/multiprocessing.rst:453
msgid ""
"If ``e`` is an instance of :exc:`BufferTooShort` then ``e.args[0]`` will "
"give the message as a byte string."
msgstr ""

#: ../../../library/multiprocessing.rst:458
msgid "Pipes and Queues"
msgstr ""

#: ../../../library/multiprocessing.rst:460
msgid ""
"When using multiple processes, one generally uses message passing for "
"communication between processes and avoids having to use any synchronization "
"primitives like locks."
msgstr ""

#: ../../../library/multiprocessing.rst:464
msgid ""
"For passing messages one can use :func:`Pipe` (for a connection between two "
"processes) or a queue (which allows multiple producers and consumers)."
msgstr ""

#: ../../../library/multiprocessing.rst:467
msgid ""
"The :class:`Queue` and :class:`JoinableQueue` types are multi-producer, "
"multi-consumer FIFO queues modelled on the :class:`Queue.Queue` class in the "
"standard library.  They differ in that :class:`Queue` lacks the :meth:"
"`~Queue.Queue.task_done` and :meth:`~Queue.Queue.join` methods introduced "
"into Python 2.5's :class:`Queue.Queue` class."
msgstr ""

#: ../../../library/multiprocessing.rst:473
msgid ""
"If you use :class:`JoinableQueue` then you **must** call :meth:"
"`JoinableQueue.task_done` for each task removed from the queue or else the "
"semaphore used to count the number of unfinished tasks may eventually "
"overflow raising an exception."
msgstr ""

#: ../../../library/multiprocessing.rst:478
msgid ""
"Note that one can also create a shared queue by using a manager object -- "
"see :ref:`multiprocessing-managers`."
msgstr ""

#: ../../../library/multiprocessing.rst:483
msgid ""
":mod:`multiprocessing` uses the usual :exc:`Queue.Empty` and :exc:`Queue."
"Full` exceptions to signal a timeout.  They are not available in the :mod:"
"`multiprocessing` namespace so you need to import them from :mod:`Queue`."
msgstr ""

#: ../../../library/multiprocessing.rst:491
msgid ""
"If a process is killed using :meth:`Process.terminate` or :func:`os.kill` "
"while it is trying to use a :class:`Queue`, then the data in the queue is "
"likely to become corrupted.  This may cause any other processes to get an "
"exception when it tries to use the queue later on."
msgstr ""

#: ../../../library/multiprocessing.rst:498
msgid ""
"As mentioned above, if a child process has put items on a queue (and it has "
"not used :meth:`JoinableQueue.cancel_join_thread`), then that process will "
"not terminate until all buffered items have been flushed to the pipe."
msgstr ""

#: ../../../library/multiprocessing.rst:502
msgid ""
"This means that if you try joining that process you may get a deadlock "
"unless you are sure that all items which have been put on the queue have "
"been consumed.  Similarly, if the child process is non-daemonic then the "
"parent process may hang on exit when it tries to join all its non-daemonic "
"children."
msgstr ""

#: ../../../library/multiprocessing.rst:507
msgid ""
"Note that a queue created using a manager does not have this issue.  See :"
"ref:`multiprocessing-programming`."
msgstr ""

#: ../../../library/multiprocessing.rst:510
msgid ""
"For an example of the usage of queues for interprocess communication see :"
"ref:`multiprocessing-examples`."
msgstr ""

#: ../../../library/multiprocessing.rst:516
msgid ""
"Returns a pair ``(conn1, conn2)`` of :class:`Connection` objects "
"representing the ends of a pipe."
msgstr ""

#: ../../../library/multiprocessing.rst:519
msgid ""
"If *duplex* is ``True`` (the default) then the pipe is bidirectional.  If "
"*duplex* is ``False`` then the pipe is unidirectional: ``conn1`` can only be "
"used for receiving messages and ``conn2`` can only be used for sending "
"messages."
msgstr ""

#: ../../../library/multiprocessing.rst:527
msgid ""
"Returns a process shared queue implemented using a pipe and a few locks/"
"semaphores.  When a process first puts an item on the queue a feeder thread "
"is started which transfers objects from a buffer into the pipe."
msgstr ""

#: ../../../library/multiprocessing.rst:531
msgid ""
"The usual :exc:`Queue.Empty` and :exc:`Queue.Full` exceptions from the "
"standard library's :mod:`Queue` module are raised to signal timeouts."
msgstr ""

#: ../../../library/multiprocessing.rst:534
msgid ""
":class:`Queue` implements all the methods of :class:`Queue.Queue` except "
"for :meth:`~Queue.Queue.task_done` and :meth:`~Queue.Queue.join`."
msgstr ""

#: ../../../library/multiprocessing.rst:539
msgid ""
"Return the approximate size of the queue.  Because of multithreading/"
"multiprocessing semantics, this number is not reliable."
msgstr ""

#: ../../../library/multiprocessing.rst:542
msgid ""
"Note that this may raise :exc:`NotImplementedError` on Unix platforms like "
"Mac OS X where ``sem_getvalue()`` is not implemented."
msgstr ""

#: ../../../library/multiprocessing.rst:547
msgid ""
"Return ``True`` if the queue is empty, ``False`` otherwise.  Because of "
"multithreading/multiprocessing semantics, this is not reliable."
msgstr ""

#: ../../../library/multiprocessing.rst:552
msgid ""
"Return ``True`` if the queue is full, ``False`` otherwise.  Because of "
"multithreading/multiprocessing semantics, this is not reliable."
msgstr ""

#: ../../../library/multiprocessing.rst:557
msgid ""
"Put item into the queue.  If the optional argument *block* is ``True`` (the "
"default) and *timeout* is ``None`` (the default), block if necessary until a "
"free slot is available.  If *timeout* is a positive number, it blocks at "
"most *timeout* seconds and raises the :exc:`Queue.Full` exception if no free "
"slot was available within that time.  Otherwise (*block* is ``False``), put "
"an item on the queue if a free slot is immediately available, else raise "
"the :exc:`Queue.Full` exception (*timeout* is ignored in that case)."
msgstr ""

#: ../../../library/multiprocessing.rst:568
msgid "Equivalent to ``put(item, False)``."
msgstr ""

#: ../../../library/multiprocessing.rst:572
msgid ""
"Remove and return an item from the queue.  If optional args *block* is "
"``True`` (the default) and *timeout* is ``None`` (the default), block if "
"necessary until an item is available.  If *timeout* is a positive number, it "
"blocks at most *timeout* seconds and raises the :exc:`Queue.Empty` exception "
"if no item was available within that time.  Otherwise (block is ``False``), "
"return an item if one is immediately available, else raise the :exc:`Queue."
"Empty` exception (*timeout* is ignored in that case)."
msgstr ""

#: ../../../library/multiprocessing.rst:583
msgid "Equivalent to ``get(False)``."
msgstr ""

#: ../../../library/multiprocessing.rst:585
msgid ""
":class:`multiprocessing.Queue` has a few additional methods not found in :"
"class:`Queue.Queue`.  These methods are usually unnecessary for most code:"
msgstr ""

#: ../../../library/multiprocessing.rst:591
msgid ""
"Indicate that no more data will be put on this queue by the current "
"process.  The background thread will quit once it has flushed all buffered "
"data to the pipe.  This is called automatically when the queue is garbage "
"collected."
msgstr ""

#: ../../../library/multiprocessing.rst:598
msgid ""
"Join the background thread.  This can only be used after :meth:`close` has "
"been called.  It blocks until the background thread exits, ensuring that all "
"data in the buffer has been flushed to the pipe."
msgstr ""

#: ../../../library/multiprocessing.rst:602
msgid ""
"By default if a process is not the creator of the queue then on exit it will "
"attempt to join the queue's background thread.  The process can call :meth:"
"`cancel_join_thread` to make :meth:`join_thread` do nothing."
msgstr ""

#: ../../../library/multiprocessing.rst:608
msgid ""
"Prevent :meth:`join_thread` from blocking.  In particular, this prevents the "
"background thread from being joined automatically when the process exits -- "
"see :meth:`join_thread`."
msgstr ""

#: ../../../library/multiprocessing.rst:615
msgid ""
":class:`JoinableQueue`, a :class:`Queue` subclass, is a queue which "
"additionally has :meth:`task_done` and :meth:`join` methods."
msgstr ""

#: ../../../library/multiprocessing.rst:620
msgid ""
"Indicate that a formerly enqueued task is complete. Used by queue consumer "
"threads.  For each :meth:`~Queue.get` used to fetch a task, a subsequent "
"call to :meth:`task_done` tells the queue that the processing on the task is "
"complete."
msgstr ""

#: ../../../library/multiprocessing.rst:625
msgid ""
"If a :meth:`~Queue.join` is currently blocking, it will resume when all "
"items have been processed (meaning that a :meth:`task_done` call was "
"received for every item that had been :meth:`~Queue.put` into the queue)."
msgstr ""

#: ../../../library/multiprocessing.rst:629
msgid ""
"Raises a :exc:`ValueError` if called more times than there were items placed "
"in the queue."
msgstr ""

#: ../../../library/multiprocessing.rst:635
msgid "Block until all items in the queue have been gotten and processed."
msgstr ""

#: ../../../library/multiprocessing.rst:637
msgid ""
"The count of unfinished tasks goes up whenever an item is added to the "
"queue.  The count goes down whenever a consumer thread calls :meth:"
"`task_done` to indicate that the item was retrieved and all work on it is "
"complete.  When the count of unfinished tasks drops to zero, :meth:`~Queue."
"join` unblocks."
msgstr ""

#: ../../../library/multiprocessing.rst:645
msgid "Miscellaneous"
msgstr ""

#: ../../../library/multiprocessing.rst:649
msgid "Return list of all live children of the current process."
msgstr ""

#: ../../../library/multiprocessing.rst:651
msgid ""
"Calling this has the side affect of \"joining\" any processes which have "
"already finished."
msgstr ""

#: ../../../library/multiprocessing.rst:656
msgid ""
"Return the number of CPUs in the system.  May raise :exc:"
"`NotImplementedError`."
msgstr ""

#: ../../../library/multiprocessing.rst:661
msgid ""
"Return the :class:`Process` object corresponding to the current process."
msgstr ""

#: ../../../library/multiprocessing.rst:663
msgid "An analogue of :func:`threading.current_thread`."
msgstr ""

#: ../../../library/multiprocessing.rst:667
msgid ""
"Add support for when a program which uses :mod:`multiprocessing` has been "
"frozen to produce a Windows executable.  (Has been tested with **py2exe**, "
"**PyInstaller** and **cx_Freeze**.)"
msgstr ""

#: ../../../library/multiprocessing.rst:671
msgid ""
"One needs to call this function straight after the ``if __name__ == "
"'__main__'`` line of the main module.  For example::"
msgstr ""

#: ../../../library/multiprocessing.rst:674
msgid ""
"from multiprocessing import Process, freeze_support\n"
"\n"
"def f():\n"
"    print 'hello world!'\n"
"\n"
"if __name__ == '__main__':\n"
"    freeze_support()\n"
"    Process(target=f).start()"
msgstr ""

#: ../../../library/multiprocessing.rst:683
msgid ""
"If the ``freeze_support()`` line is omitted then trying to run the frozen "
"executable will raise :exc:`RuntimeError`."
msgstr ""

#: ../../../library/multiprocessing.rst:686
msgid ""
"If the module is being run normally by the Python interpreter then :func:"
"`freeze_support` has no effect."
msgstr ""

#: ../../../library/multiprocessing.rst:691
msgid ""
"Sets the path of the Python interpreter to use when starting a child "
"process. (By default :data:`sys.executable` is used).  Embedders will "
"probably need to do some thing like ::"
msgstr ""

#: ../../../library/multiprocessing.rst:695
msgid "setExecutable(os.path.join(sys.exec_prefix, 'pythonw.exe'))"
msgstr ""

#: ../../../library/multiprocessing.rst:697
msgid "before they can create child processes.  (Windows only)"
msgstr ""

#: ../../../library/multiprocessing.rst:702
msgid ""
":mod:`multiprocessing` contains no analogues of :func:`threading."
"active_count`, :func:`threading.enumerate`, :func:`threading.settrace`, :"
"func:`threading.setprofile`, :class:`threading.Timer`, or :class:`threading."
"local`."
msgstr ""

#: ../../../library/multiprocessing.rst:709
msgid "Connection Objects"
msgstr ""

#: ../../../library/multiprocessing.rst:711
msgid ""
"Connection objects allow the sending and receiving of picklable objects or "
"strings.  They can be thought of as message oriented connected sockets."
msgstr ""

#: ../../../library/multiprocessing.rst:714
msgid ""
"Connection objects usually created using :func:`Pipe` -- see also :ref:"
"`multiprocessing-listeners-clients`."
msgstr ""

#: ../../../library/multiprocessing.rst:721
msgid ""
"Send an object to the other end of the connection which should be read "
"using :meth:`recv`."
msgstr ""

#: ../../../library/multiprocessing.rst:724
msgid "The object must be picklable."
msgstr ""

#: ../../../library/multiprocessing.rst:728
msgid ""
"Return an object sent from the other end of the connection using :meth:"
"`send`.  Raises :exc:`EOFError` if there is nothing left to receive and the "
"other end was closed."
msgstr ""

#: ../../../library/multiprocessing.rst:734
msgid "Returns the file descriptor or handle used by the connection."
msgstr ""

#: ../../../library/multiprocessing.rst:738
msgid "Close the connection."
msgstr ""

#: ../../../library/multiprocessing.rst:740
msgid "This is called automatically when the connection is garbage collected."
msgstr ""

#: ../../../library/multiprocessing.rst:744
msgid "Return whether there is any data available to be read."
msgstr ""

#: ../../../library/multiprocessing.rst:746
msgid ""
"If *timeout* is not specified then it will return immediately.  If *timeout* "
"is a number then this specifies the maximum time in seconds to block.  If "
"*timeout* is ``None`` then an infinite timeout is used."
msgstr ""

#: ../../../library/multiprocessing.rst:752
msgid ""
"Send byte data from an object supporting the buffer interface as a complete "
"message."
msgstr ""

#: ../../../library/multiprocessing.rst:755
msgid ""
"If *offset* is given then data is read from that position in *buffer*.  If "
"*size* is given then that many bytes will be read from buffer."
msgstr ""

#: ../../../library/multiprocessing.rst:760
msgid ""
"Return a complete message of byte data sent from the other end of the "
"connection as a string.  Raises :exc:`EOFError` if there is nothing left to "
"receive and the other end has closed."
msgstr ""

#: ../../../library/multiprocessing.rst:764
msgid ""
"If *maxlength* is specified and the message is longer than *maxlength* then :"
"exc:`IOError` is raised and the connection will no longer be readable."
msgstr ""

#: ../../../library/multiprocessing.rst:770
msgid ""
"Read into *buffer* a complete message of byte data sent from the other end "
"of the connection and return the number of bytes in the message.  Raises :"
"exc:`EOFError` if there is nothing left to receive and the other end was "
"closed."
msgstr ""

#: ../../../library/multiprocessing.rst:775
msgid ""
"*buffer* must be an object satisfying the writable buffer interface.  If "
"*offset* is given then the message will be written into the buffer from that "
"position.  Offset must be a non-negative integer less than the length of "
"*buffer* (in bytes)."
msgstr ""

#: ../../../library/multiprocessing.rst:780
msgid ""
"If the buffer is too short then a :exc:`BufferTooShort` exception is raised "
"and the complete message is available as ``e.args[0]`` where ``e`` is the "
"exception instance."
msgstr ""

#: ../../../library/multiprocessing.rst:785
msgid "For example:"
msgstr ""

#: ../../../library/multiprocessing.rst:787
msgid ""
">>> from multiprocessing import Pipe\n"
">>> a, b = Pipe()\n"
">>> a.send([1, 'hello', None])\n"
">>> b.recv()\n"
"[1, 'hello', None]\n"
">>> b.send_bytes('thank you')\n"
">>> a.recv_bytes()\n"
"'thank you'\n"
">>> import array\n"
">>> arr1 = array.array('i', range(5))\n"
">>> arr2 = array.array('i', [0] * 10)\n"
">>> a.send_bytes(arr1)\n"
">>> count = b.recv_bytes_into(arr2)\n"
">>> assert count == len(arr1) * arr1.itemsize\n"
">>> arr2\n"
"array('i', [0, 1, 2, 3, 4, 0, 0, 0, 0, 0])"
msgstr ""

#: ../../../library/multiprocessing.rst:809
msgid ""
"The :meth:`Connection.recv` method automatically unpickles the data it "
"receives, which can be a security risk unless you can trust the process "
"which sent the message."
msgstr ""

#: ../../../library/multiprocessing.rst:813
msgid ""
"Therefore, unless the connection object was produced using :func:`Pipe` you "
"should only use the :meth:`~Connection.recv` and :meth:`~Connection.send` "
"methods after performing some sort of authentication.  See :ref:"
"`multiprocessing-auth-keys`."
msgstr ""

#: ../../../library/multiprocessing.rst:820
msgid ""
"If a process is killed while it is trying to read or write to a pipe then "
"the data in the pipe is likely to become corrupted, because it may become "
"impossible to be sure where the message boundaries lie."
msgstr ""

#: ../../../library/multiprocessing.rst:826
msgid "Synchronization primitives"
msgstr ""

#: ../../../library/multiprocessing.rst:828
msgid ""
"Generally synchronization primitives are not as necessary in a multiprocess "
"program as they are in a multithreaded program.  See the documentation for :"
"mod:`threading` module."
msgstr ""

#: ../../../library/multiprocessing.rst:832
msgid ""
"Note that one can also create synchronization primitives by using a manager "
"object -- see :ref:`multiprocessing-managers`."
msgstr ""

#: ../../../library/multiprocessing.rst:837
msgid ""
"A bounded semaphore object: a clone of :class:`threading.BoundedSemaphore`."
msgstr ""

#: ../../../library/multiprocessing.rst:839
msgid ""
"(On Mac OS X, this is indistinguishable from :class:`Semaphore` because "
"``sem_getvalue()`` is not implemented on that platform)."
msgstr ""

#: ../../../library/multiprocessing.rst:844
msgid "A condition variable: a clone of :class:`threading.Condition`."
msgstr ""

#: ../../../library/multiprocessing.rst:846
msgid ""
"If *lock* is specified then it should be a :class:`Lock` or :class:`RLock` "
"object from :mod:`multiprocessing`."
msgstr ""

#: ../../../library/multiprocessing.rst:851
msgid "A clone of :class:`threading.Event`."
msgstr ""

#: ../../../library/multiprocessing.rst:855
msgid "A non-recursive lock object: a clone of :class:`threading.Lock`."
msgstr ""

#: ../../../library/multiprocessing.rst:859
msgid "A recursive lock object: a clone of :class:`threading.RLock`."
msgstr ""

#: ../../../library/multiprocessing.rst:863
msgid "A bounded semaphore object: a clone of :class:`threading.Semaphore`."
msgstr ""

#: ../../../library/multiprocessing.rst:867
msgid ""
"The :meth:`acquire` method of :class:`BoundedSemaphore`, :class:`Lock`, :"
"class:`RLock` and :class:`Semaphore` has a timeout parameter not supported "
"by the equivalents in :mod:`threading`.  The signature is "
"``acquire(block=True, timeout=None)`` with keyword parameters being "
"acceptable.  If *block* is ``True`` and *timeout* is not ``None`` then it "
"specifies a timeout in seconds.  If *block* is ``False`` then *timeout* is "
"ignored."
msgstr ""

#: ../../../library/multiprocessing.rst:875
msgid ""
"On Mac OS X, ``sem_timedwait`` is unsupported, so calling ``acquire()`` with "
"a timeout will emulate that function's behavior using a sleeping loop."
msgstr ""

#: ../../../library/multiprocessing.rst:880
msgid ""
"If the SIGINT signal generated by Ctrl-C arrives while the main thread is "
"blocked by a call to :meth:`BoundedSemaphore.acquire`, :meth:`Lock."
"acquire`, :meth:`RLock.acquire`, :meth:`Semaphore.acquire`, :meth:`Condition."
"acquire` or :meth:`Condition.wait` then the call will be immediately "
"interrupted and :exc:`KeyboardInterrupt` will be raised."
msgstr ""

#: ../../../library/multiprocessing.rst:886
msgid ""
"This differs from the behaviour of :mod:`threading` where SIGINT will be "
"ignored while the equivalent blocking calls are in progress."
msgstr ""

#: ../../../library/multiprocessing.rst:891
msgid "Shared :mod:`ctypes` Objects"
msgstr ""

#: ../../../library/multiprocessing.rst:893
msgid ""
"It is possible to create shared objects using shared memory which can be "
"inherited by child processes."
msgstr ""

#: ../../../library/multiprocessing.rst:898
msgid ""
"Return a :mod:`ctypes` object allocated from shared memory.  By default the "
"return value is actually a synchronized wrapper for the object."
msgstr ""

#: ../../../library/multiprocessing.rst:901
#: ../../../library/multiprocessing.rst:976
msgid ""
"*typecode_or_type* determines the type of the returned object: it is either "
"a ctypes type or a one character typecode of the kind used by the :mod:"
"`array` module.  *\\*args* is passed on to the constructor for the type."
msgstr ""

#: ../../../library/multiprocessing.rst:905
#: ../../../library/multiprocessing.rst:926
#: ../../../library/multiprocessing.rst:994
#: ../../../library/multiprocessing.rst:1009
msgid ""
"If *lock* is ``True`` (the default) then a new lock object is created to "
"synchronize access to the value.  If *lock* is a :class:`Lock` or :class:"
"`RLock` object then that will be used to synchronize access to the value.  "
"If *lock* is ``False`` then access to the returned object will not be "
"automatically protected by a lock, so it will not necessarily be \"process-"
"safe\"."
msgstr ""

#: ../../../library/multiprocessing.rst:912
#: ../../../library/multiprocessing.rst:1001
#: ../../../library/multiprocessing.rst:1016
msgid "Note that *lock* is a keyword-only argument."
msgstr ""

#: ../../../library/multiprocessing.rst:916
msgid ""
"Return a ctypes array allocated from shared memory.  By default the return "
"value is actually a synchronized wrapper for the array."
msgstr ""

#: ../../../library/multiprocessing.rst:919
msgid ""
"*typecode_or_type* determines the type of the elements of the returned "
"array: it is either a ctypes type or a one character typecode of the kind "
"used by the :mod:`array` module.  If *size_or_initializer* is an integer, "
"then it determines the length of the array, and the array will be initially "
"zeroed. Otherwise, *size_or_initializer* is a sequence which is used to "
"initialize the array and whose length determines the length of the array."
msgstr ""

#: ../../../library/multiprocessing.rst:933
msgid "Note that *lock* is a keyword only argument."
msgstr ""

#: ../../../library/multiprocessing.rst:935
msgid ""
"Note that an array of :data:`ctypes.c_char` has *value* and *raw* attributes "
"which allow one to use it to store and retrieve strings."
msgstr ""

#: ../../../library/multiprocessing.rst:940
msgid "The :mod:`multiprocessing.sharedctypes` module"
msgstr ""

#: ../../../library/multiprocessing.rst:945
msgid ""
"The :mod:`multiprocessing.sharedctypes` module provides functions for "
"allocating :mod:`ctypes` objects from shared memory which can be inherited "
"by child processes."
msgstr ""

#: ../../../library/multiprocessing.rst:951
msgid ""
"Although it is possible to store a pointer in shared memory remember that "
"this will refer to a location in the address space of a specific process. "
"However, the pointer is quite likely to be invalid in the context of a "
"second process and trying to dereference the pointer from the second process "
"may cause a crash."
msgstr ""

#: ../../../library/multiprocessing.rst:959
msgid "Return a ctypes array allocated from shared memory."
msgstr ""

#: ../../../library/multiprocessing.rst:961
msgid ""
"*typecode_or_type* determines the type of the elements of the returned "
"array: it is either a ctypes type or a one character typecode of the kind "
"used by the :mod:`array` module.  If *size_or_initializer* is an integer "
"then it determines the length of the array, and the array will be initially "
"zeroed. Otherwise *size_or_initializer* is a sequence which is used to "
"initialize the array and whose length determines the length of the array."
msgstr ""

#: ../../../library/multiprocessing.rst:968
msgid ""
"Note that setting and getting an element is potentially non-atomic -- use :"
"func:`Array` instead to make sure that access is automatically synchronized "
"using a lock."
msgstr ""

#: ../../../library/multiprocessing.rst:974
msgid "Return a ctypes object allocated from shared memory."
msgstr ""

#: ../../../library/multiprocessing.rst:980
msgid ""
"Note that setting and getting the value is potentially non-atomic -- use :"
"func:`Value` instead to make sure that access is automatically synchronized "
"using a lock."
msgstr ""

#: ../../../library/multiprocessing.rst:984
msgid ""
"Note that an array of :data:`ctypes.c_char` has ``value`` and ``raw`` "
"attributes which allow one to use it to store and retrieve strings -- see "
"documentation for :mod:`ctypes`."
msgstr ""

#: ../../../library/multiprocessing.rst:990
msgid ""
"The same as :func:`RawArray` except that depending on the value of *lock* a "
"process-safe synchronization wrapper may be returned instead of a raw ctypes "
"array."
msgstr ""

#: ../../../library/multiprocessing.rst:1005
msgid ""
"The same as :func:`RawValue` except that depending on the value of *lock* a "
"process-safe synchronization wrapper may be returned instead of a raw ctypes "
"object."
msgstr ""

#: ../../../library/multiprocessing.rst:1020
msgid ""
"Return a ctypes object allocated from shared memory which is a copy of the "
"ctypes object *obj*."
msgstr ""

#: ../../../library/multiprocessing.rst:1025
msgid ""
"Return a process-safe wrapper object for a ctypes object which uses *lock* "
"to synchronize access.  If *lock* is ``None`` (the default) then a :class:"
"`multiprocessing.RLock` object is created automatically."
msgstr ""

#: ../../../library/multiprocessing.rst:1029
msgid ""
"A synchronized wrapper will have two methods in addition to those of the "
"object it wraps: :meth:`get_obj` returns the wrapped object and :meth:"
"`get_lock` returns the lock object used for synchronization."
msgstr ""

#: ../../../library/multiprocessing.rst:1033
msgid ""
"Note that accessing the ctypes object through the wrapper can be a lot "
"slower than accessing the raw ctypes object."
msgstr ""

#: ../../../library/multiprocessing.rst:1037
msgid ""
"The table below compares the syntax for creating shared ctypes objects from "
"shared memory with the normal ctypes syntax.  (In the table ``MyStruct`` is "
"some subclass of :class:`ctypes.Structure`.)"
msgstr ""

#: ../../../library/multiprocessing.rst:1042
msgid "ctypes"
msgstr ""

#: ../../../library/multiprocessing.rst:1042
msgid "sharedctypes using type"
msgstr ""

#: ../../../library/multiprocessing.rst:1042
msgid "sharedctypes using typecode"
msgstr ""

#: ../../../library/multiprocessing.rst:1044
msgid "c_double(2.4)"
msgstr ""

#: ../../../library/multiprocessing.rst:1044
msgid "RawValue(c_double, 2.4)"
msgstr ""

#: ../../../library/multiprocessing.rst:1044
msgid "RawValue('d', 2.4)"
msgstr ""

#: ../../../library/multiprocessing.rst:1045
msgid "MyStruct(4, 6)"
msgstr ""

#: ../../../library/multiprocessing.rst:1045
msgid "RawValue(MyStruct, 4, 6)"
msgstr ""

#: ../../../library/multiprocessing.rst:1046
msgid "(c_short * 7)()"
msgstr ""

#: ../../../library/multiprocessing.rst:1046
msgid "RawArray(c_short, 7)"
msgstr ""

#: ../../../library/multiprocessing.rst:1046
msgid "RawArray('h', 7)"
msgstr ""

#: ../../../library/multiprocessing.rst:1047
msgid "(c_int * 3)(9, 2, 8)"
msgstr ""

#: ../../../library/multiprocessing.rst:1047
msgid "RawArray(c_int, (9, 2, 8))"
msgstr ""

#: ../../../library/multiprocessing.rst:1047
msgid "RawArray('i', (9, 2, 8))"
msgstr ""

#: ../../../library/multiprocessing.rst:1051
msgid ""
"Below is an example where a number of ctypes objects are modified by a child "
"process::"
msgstr ""

#: ../../../library/multiprocessing.rst:1054
msgid ""
"from multiprocessing import Process, Lock\n"
"from multiprocessing.sharedctypes import Value, Array\n"
"from ctypes import Structure, c_double\n"
"\n"
"class Point(Structure):\n"
"    _fields_ = [('x', c_double), ('y', c_double)]\n"
"\n"
"def modify(n, x, s, A):\n"
"    n.value **= 2\n"
"    x.value **= 2\n"
"    s.value = s.value.upper()\n"
"    for a in A:\n"
"        a.x **= 2\n"
"        a.y **= 2\n"
"\n"
"if __name__ == '__main__':\n"
"    lock = Lock()\n"
"\n"
"    n = Value('i', 7)\n"
"    x = Value(c_double, 1.0/3.0, lock=False)\n"
"    s = Array('c', 'hello world', lock=lock)\n"
"    A = Array(Point, [(1.875,-6.25), (-5.75,2.0), (2.375,9.5)], lock=lock)\n"
"\n"
"    p = Process(target=modify, args=(n, x, s, A))\n"
"    p.start()\n"
"    p.join()\n"
"\n"
"    print n.value\n"
"    print x.value\n"
"    print s.value\n"
"    print [(a.x, a.y) for a in A]"
msgstr ""

#: ../../../library/multiprocessing.rst:1089
msgid "The results printed are ::"
msgstr ""

#: ../../../library/multiprocessing.rst:1091
msgid ""
"49\n"
"0.1111111111111111\n"
"HELLO WORLD\n"
"[(3.515625, 39.0625), (33.0625, 4.0), (5.640625, 90.25)]"
msgstr ""

#: ../../../library/multiprocessing.rst:1102
msgid "Managers"
msgstr ""

#: ../../../library/multiprocessing.rst:1104
msgid ""
"Managers provide a way to create data which can be shared between different "
"processes. A manager object controls a server process which manages *shared "
"objects*.  Other processes can access the shared objects by using proxies."
msgstr ""

#: ../../../library/multiprocessing.rst:1110
msgid ""
"Returns a started :class:`~multiprocessing.managers.SyncManager` object "
"which can be used for sharing objects between processes.  The returned "
"manager object corresponds to a spawned child process and has methods which "
"will create shared objects and return corresponding proxies."
msgstr ""

#: ../../../library/multiprocessing.rst:1118
msgid ""
"Manager processes will be shutdown as soon as they are garbage collected or "
"their parent process exits.  The manager classes are defined in the :mod:"
"`multiprocessing.managers` module:"
msgstr ""

#: ../../../library/multiprocessing.rst:1124
msgid "Create a BaseManager object."
msgstr ""

#: ../../../library/multiprocessing.rst:1126
msgid ""
"Once created one should call :meth:`start` or ``get_server()."
"serve_forever()`` to ensure that the manager object refers to a started "
"manager process."
msgstr ""

#: ../../../library/multiprocessing.rst:1129
msgid ""
"*address* is the address on which the manager process listens for new "
"connections.  If *address* is ``None`` then an arbitrary one is chosen."
msgstr ""

#: ../../../library/multiprocessing.rst:1132
msgid ""
"*authkey* is the authentication key which will be used to check the validity "
"of incoming connections to the server process.  If *authkey* is ``None`` "
"then ``current_process().authkey``.  Otherwise *authkey* is used and it must "
"be a string."
msgstr ""

#: ../../../library/multiprocessing.rst:1139
msgid "Start a subprocess to start the manager."
msgstr ""

#: ../../../library/multiprocessing.rst:1143
msgid ""
"Returns a :class:`Server` object which represents the actual server under "
"the control of the Manager. The :class:`Server` object supports the :meth:"
"`serve_forever` method::"
msgstr ""

#: ../../../library/multiprocessing.rst:1147
msgid ""
">>> from multiprocessing.managers import BaseManager\n"
">>> manager = BaseManager(address=('', 50000), authkey='abc')\n"
">>> server = manager.get_server()\n"
">>> server.serve_forever()"
msgstr ""

#: ../../../library/multiprocessing.rst:1152
msgid ":class:`Server` additionally has an :attr:`address` attribute."
msgstr ""

#: ../../../library/multiprocessing.rst:1156
msgid "Connect a local manager object to a remote manager process::"
msgstr ""

#: ../../../library/multiprocessing.rst:1158
msgid ""
">>> from multiprocessing.managers import BaseManager\n"
">>> m = BaseManager(address=('127.0.0.1', 5000), authkey='abc')\n"
">>> m.connect()"
msgstr ""

#: ../../../library/multiprocessing.rst:1164
msgid ""
"Stop the process used by the manager.  This is only available if :meth:"
"`start` has been used to start the server process."
msgstr ""

#: ../../../library/multiprocessing.rst:1167
msgid "This can be called multiple times."
msgstr ""

#: ../../../library/multiprocessing.rst:1171
msgid ""
"A classmethod which can be used for registering a type or callable with the "
"manager class."
msgstr ""

#: ../../../library/multiprocessing.rst:1174
msgid ""
"*typeid* is a \"type identifier\" which is used to identify a particular "
"type of shared object.  This must be a string."
msgstr ""

#: ../../../library/multiprocessing.rst:1177
msgid ""
"*callable* is a callable used for creating objects for this type "
"identifier.  If a manager instance will be created using the :meth:"
"`from_address` classmethod or if the *create_method* argument is ``False`` "
"then this can be left as ``None``."
msgstr ""

#: ../../../library/multiprocessing.rst:1182
msgid ""
"*proxytype* is a subclass of :class:`BaseProxy` which is used to create "
"proxies for shared objects with this *typeid*.  If ``None`` then a proxy "
"class is created automatically."
msgstr ""

#: ../../../library/multiprocessing.rst:1186
msgid ""
"*exposed* is used to specify a sequence of method names which proxies for "
"this typeid should be allowed to access using :meth:`BaseProxy."
"_callMethod`.  (If *exposed* is ``None`` then :attr:`proxytype._exposed_` is "
"used instead if it exists.)  In the case where no exposed list is specified, "
"all \"public methods\" of the shared object will be accessible.  (Here a "
"\"public method\" means any attribute which has a :meth:`__call__` method "
"and whose name does not begin with ``'_'``.)"
msgstr ""

#: ../../../library/multiprocessing.rst:1195
msgid ""
"*method_to_typeid* is a mapping used to specify the return type of those "
"exposed methods which should return a proxy.  It maps method names to typeid "
"strings.  (If *method_to_typeid* is ``None`` then :attr:`proxytype."
"_method_to_typeid_` is used instead if it exists.)  If a method's name is "
"not a key of this mapping or if the mapping is ``None`` then the object "
"returned by the method will be copied by value."
msgstr ""

#: ../../../library/multiprocessing.rst:1202
msgid ""
"*create_method* determines whether a method should be created with name "
"*typeid* which can be used to tell the server process to create a new shared "
"object and return a proxy for it.  By default it is ``True``."
msgstr ""

#: ../../../library/multiprocessing.rst:1206
msgid ":class:`BaseManager` instances also have one read-only property:"
msgstr ""

#: ../../../library/multiprocessing.rst:1210
msgid "The address used by the manager."
msgstr ""

#: ../../../library/multiprocessing.rst:1215
msgid ""
"A subclass of :class:`BaseManager` which can be used for the synchronization "
"of processes.  Objects of this type are returned by :func:`multiprocessing."
"Manager`."
msgstr ""

#: ../../../library/multiprocessing.rst:1219
msgid "It also supports creation of shared lists and dictionaries."
msgstr ""

#: ../../../library/multiprocessing.rst:1223
msgid ""
"Create a shared :class:`threading.BoundedSemaphore` object and return a "
"proxy for it."
msgstr ""

#: ../../../library/multiprocessing.rst:1228
msgid ""
"Create a shared :class:`threading.Condition` object and return a proxy for "
"it."
msgstr ""

#: ../../../library/multiprocessing.rst:1231
msgid ""
"If *lock* is supplied then it should be a proxy for a :class:`threading."
"Lock` or :class:`threading.RLock` object."
msgstr ""

#: ../../../library/multiprocessing.rst:1236
msgid ""
"Create a shared :class:`threading.Event` object and return a proxy for it."
msgstr ""

#: ../../../library/multiprocessing.rst:1240
msgid ""
"Create a shared :class:`threading.Lock` object and return a proxy for it."
msgstr ""

#: ../../../library/multiprocessing.rst:1244
msgid "Create a shared :class:`Namespace` object and return a proxy for it."
msgstr ""

#: ../../../library/multiprocessing.rst:1248
msgid "Create a shared :class:`Queue.Queue` object and return a proxy for it."
msgstr ""

#: ../../../library/multiprocessing.rst:1252
msgid ""
"Create a shared :class:`threading.RLock` object and return a proxy for it."
msgstr ""

#: ../../../library/multiprocessing.rst:1256
msgid ""
"Create a shared :class:`threading.Semaphore` object and return a proxy for "
"it."
msgstr ""

#: ../../../library/multiprocessing.rst:1261
msgid "Create an array and return a proxy for it."
msgstr ""

#: ../../../library/multiprocessing.rst:1265
msgid ""
"Create an object with a writable ``value`` attribute and return a proxy for "
"it."
msgstr ""

#: ../../../library/multiprocessing.rst:1272
msgid "Create a shared ``dict`` object and return a proxy for it."
msgstr ""

#: ../../../library/multiprocessing.rst:1277
msgid "Create a shared ``list`` object and return a proxy for it."
msgstr ""

#: ../../../library/multiprocessing.rst:1281
msgid "Namespace objects"
msgstr ""

#: ../../../library/multiprocessing.rst:1283
msgid ""
"A namespace object has no public methods, but does have writable attributes. "
"Its representation shows the values of its attributes."
msgstr ""

#: ../../../library/multiprocessing.rst:1286
msgid ""
"However, when using a proxy for a namespace object, an attribute beginning "
"with ``'_'`` will be an attribute of the proxy and not an attribute of the "
"referent:"
msgstr ""

#: ../../../library/multiprocessing.rst:1289
msgid ""
">>> manager = multiprocessing.Manager()\n"
">>> Global = manager.Namespace()\n"
">>> Global.x = 10\n"
">>> Global.y = 'hello'\n"
">>> Global._z = 12.3    # this is an attribute of the proxy\n"
">>> print Global\n"
"Namespace(x=10, y='hello')"
msgstr ""

#: ../../../library/multiprocessing.rst:1301
msgid "Customized managers"
msgstr ""

#: ../../../library/multiprocessing.rst:1303
msgid ""
"To create one's own manager, one creates a subclass of :class:`BaseManager` "
"and use the :meth:`~BaseManager.register` classmethod to register new types "
"or callables with the manager class.  For example::"
msgstr ""

#: ../../../library/multiprocessing.rst:1307
msgid ""
"from multiprocessing.managers import BaseManager\n"
"\n"
"class MathsClass(object):\n"
"    def add(self, x, y):\n"
"        return x + y\n"
"    def mul(self, x, y):\n"
"        return x * y\n"
"\n"
"class MyManager(BaseManager):\n"
"    pass\n"
"\n"
"MyManager.register('Maths', MathsClass)\n"
"\n"
"if __name__ == '__main__':\n"
"    manager = MyManager()\n"
"    manager.start()\n"
"    maths = manager.Maths()\n"
"    print maths.add(4, 3)         # prints 7\n"
"    print maths.mul(7, 8)         # prints 56"
msgstr ""

#: ../../../library/multiprocessing.rst:1329
msgid "Using a remote manager"
msgstr ""

#: ../../../library/multiprocessing.rst:1331
msgid ""
"It is possible to run a manager server on one machine and have clients use "
"it from other machines (assuming that the firewalls involved allow it)."
msgstr ""

#: ../../../library/multiprocessing.rst:1334
msgid ""
"Running the following commands creates a server for a single shared queue "
"which remote clients can access::"
msgstr ""

#: ../../../library/multiprocessing.rst:1337
msgid ""
">>> from multiprocessing.managers import BaseManager\n"
">>> import Queue\n"
">>> queue = Queue.Queue()\n"
">>> class QueueManager(BaseManager): pass\n"
">>> QueueManager.register('get_queue', callable=lambda:queue)\n"
">>> m = QueueManager(address=('', 50000), authkey='abracadabra')\n"
">>> s = m.get_server()\n"
">>> s.serve_forever()"
msgstr ""

#: ../../../library/multiprocessing.rst:1346
msgid "One client can access the server as follows::"
msgstr ""

#: ../../../library/multiprocessing.rst:1348
msgid ""
">>> from multiprocessing.managers import BaseManager\n"
">>> class QueueManager(BaseManager): pass\n"
">>> QueueManager.register('get_queue')\n"
">>> m = QueueManager(address=('foo.bar.org', 50000), authkey='abracadabra')\n"
">>> m.connect()\n"
">>> queue = m.get_queue()\n"
">>> queue.put('hello')"
msgstr ""

#: ../../../library/multiprocessing.rst:1356
msgid "Another client can also use it::"
msgstr ""

#: ../../../library/multiprocessing.rst:1358
msgid ""
">>> from multiprocessing.managers import BaseManager\n"
">>> class QueueManager(BaseManager): pass\n"
">>> QueueManager.register('get_queue')\n"
">>> m = QueueManager(address=('foo.bar.org', 50000), authkey='abracadabra')\n"
">>> m.connect()\n"
">>> queue = m.get_queue()\n"
">>> queue.get()\n"
"'hello'"
msgstr ""

#: ../../../library/multiprocessing.rst:1367
msgid ""
"Local processes can also access that queue, using the code from above on the "
"client to access it remotely::"
msgstr ""

#: ../../../library/multiprocessing.rst:1370
msgid ""
">>> from multiprocessing import Process, Queue\n"
">>> from multiprocessing.managers import BaseManager\n"
">>> class Worker(Process):\n"
"...     def __init__(self, q):\n"
"...         self.q = q\n"
"...         super(Worker, self).__init__()\n"
"...     def run(self):\n"
"...         self.q.put('local hello')\n"
"...\n"
">>> queue = Queue()\n"
">>> w = Worker(queue)\n"
">>> w.start()\n"
">>> class QueueManager(BaseManager): pass\n"
"...\n"
">>> QueueManager.register('get_queue', callable=lambda: queue)\n"
">>> m = QueueManager(address=('', 50000), authkey='abracadabra')\n"
">>> s = m.get_server()\n"
">>> s.serve_forever()"
msgstr ""

#: ../../../library/multiprocessing.rst:1390
msgid "Proxy Objects"
msgstr ""

#: ../../../library/multiprocessing.rst:1392
msgid ""
"A proxy is an object which *refers* to a shared object which lives "
"(presumably) in a different process.  The shared object is said to be the "
"*referent* of the proxy.  Multiple proxy objects may have the same referent."
msgstr ""

#: ../../../library/multiprocessing.rst:1396
msgid ""
"A proxy object has methods which invoke corresponding methods of its "
"referent (although not every method of the referent will necessarily be "
"available through the proxy).  A proxy can usually be used in most of the "
"same ways that its referent can:"
msgstr ""

#: ../../../library/multiprocessing.rst:1401
msgid ""
">>> from multiprocessing import Manager\n"
">>> manager = Manager()\n"
">>> l = manager.list([i*i for i in range(10)])\n"
">>> print l\n"
"[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]\n"
">>> print repr(l)\n"
"<ListProxy object, typeid 'list' at 0x...>\n"
">>> l[4]\n"
"16\n"
">>> l[2:5]\n"
"[4, 9, 16]"
msgstr ""

#: ../../../library/multiprocessing.rst:1415
msgid ""
"Notice that applying :func:`str` to a proxy will return the representation "
"of the referent, whereas applying :func:`repr` will return the "
"representation of the proxy."
msgstr ""

#: ../../../library/multiprocessing.rst:1419
msgid ""
"An important feature of proxy objects is that they are picklable so they can "
"be passed between processes.  Note, however, that if a proxy is sent to the "
"corresponding manager's process then unpickling it will produce the referent "
"itself.  This means, for example, that one shared object can contain a "
"second:"
msgstr ""

#: ../../../library/multiprocessing.rst:1424
msgid ""
">>> a = manager.list()\n"
">>> b = manager.list()\n"
">>> a.append(b)         # referent of a now contains referent of b\n"
">>> print a, b\n"
"[[]] []\n"
">>> b.append('hello')\n"
">>> print a, b\n"
"[['hello']] ['hello']"
msgstr ""

#: ../../../library/multiprocessing.rst:1437
msgid ""
"The proxy types in :mod:`multiprocessing` do nothing to support comparisons "
"by value.  So, for instance, we have:"
msgstr ""

#: ../../../library/multiprocessing.rst:1440
msgid ""
">>> manager.list([1,2,3]) == [1,2,3]\n"
"False"
msgstr ""

#: ../../../library/multiprocessing.rst:1445
msgid ""
"One should just use a copy of the referent instead when making comparisons."
msgstr ""

#: ../../../library/multiprocessing.rst:1449
msgid "Proxy objects are instances of subclasses of :class:`BaseProxy`."
msgstr ""

#: ../../../library/multiprocessing.rst:1453
msgid "Call and return the result of a method of the proxy's referent."
msgstr ""

#: ../../../library/multiprocessing.rst:1455
msgid ""
"If ``proxy`` is a proxy whose referent is ``obj`` then the expression ::"
msgstr ""

#: ../../../library/multiprocessing.rst:1457
msgid "proxy._callmethod(methodname, args, kwds)"
msgstr ""

#: ../../../library/multiprocessing.rst:1459
msgid "will evaluate the expression ::"
msgstr ""

#: ../../../library/multiprocessing.rst:1461
msgid "getattr(obj, methodname)(*args, **kwds)"
msgstr ""

#: ../../../library/multiprocessing.rst:1463
msgid "in the manager's process."
msgstr ""

#: ../../../library/multiprocessing.rst:1465
msgid ""
"The returned value will be a copy of the result of the call or a proxy to a "
"new shared object -- see documentation for the *method_to_typeid* argument "
"of :meth:`BaseManager.register`."
msgstr ""

#: ../../../library/multiprocessing.rst:1469
msgid ""
"If an exception is raised by the call, then then is re-raised by :meth:"
"`_callmethod`.  If some other exception is raised in the manager's process "
"then this is converted into a :exc:`RemoteError` exception and is raised by :"
"meth:`_callmethod`."
msgstr ""

#: ../../../library/multiprocessing.rst:1474
msgid ""
"Note in particular that an exception will be raised if *methodname* has not "
"been *exposed*"
msgstr ""

#: ../../../library/multiprocessing.rst:1477
msgid "An example of the usage of :meth:`_callmethod`:"
msgstr ""

#: ../../../library/multiprocessing.rst:1479
msgid ""
">>> l = manager.list(range(10))\n"
">>> l._callmethod('__len__')\n"
"10\n"
">>> l._callmethod('__getslice__', (2, 7))   # equiv to `l[2:7]`\n"
"[2, 3, 4, 5, 6]\n"
">>> l._callmethod('__getitem__', (20,))     # equiv to `l[20]`\n"
"Traceback (most recent call last):\n"
"...\n"
"IndexError: list index out of range"
msgstr ""

#: ../../../library/multiprocessing.rst:1493
msgid "Return a copy of the referent."
msgstr ""

#: ../../../library/multiprocessing.rst:1495
msgid "If the referent is unpicklable then this will raise an exception."
msgstr ""

#: ../../../library/multiprocessing.rst:1499
msgid "Return a representation of the proxy object."
msgstr ""

#: ../../../library/multiprocessing.rst:1503
msgid "Return the representation of the referent."
msgstr ""

#: ../../../library/multiprocessing.rst:1507
msgid "Cleanup"
msgstr ""

#: ../../../library/multiprocessing.rst:1509
msgid ""
"A proxy object uses a weakref callback so that when it gets garbage "
"collected it deregisters itself from the manager which owns its referent."
msgstr ""

#: ../../../library/multiprocessing.rst:1512
msgid ""
"A shared object gets deleted from the manager process when there are no "
"longer any proxies referring to it."
msgstr ""

#: ../../../library/multiprocessing.rst:1517
msgid "Process Pools"
msgstr ""

#: ../../../library/multiprocessing.rst:1522
msgid ""
"One can create a pool of processes which will carry out tasks submitted to "
"it with the :class:`Pool` class."
msgstr ""

#: ../../../library/multiprocessing.rst:1527
msgid ""
"A process pool object which controls a pool of worker processes to which "
"jobs can be submitted.  It supports asynchronous results with timeouts and "
"callbacks and has a parallel map implementation."
msgstr ""

#: ../../../library/multiprocessing.rst:1531
msgid ""
"*processes* is the number of worker processes to use.  If *processes* is "
"``None`` then the number returned by :func:`cpu_count` is used.  If "
"*initializer* is not ``None`` then each worker process will call "
"``initializer(*initargs)`` when it starts."
msgstr ""

#: ../../../library/multiprocessing.rst:1538
msgid ""
"Equivalent of the :func:`apply` built-in function.  It blocks till the "
"result is ready.  Given this blocks, :meth:`apply_async` is better suited "
"for performing work in parallel. Additionally, the passed in function is "
"only executed in one of the workers of the pool."
msgstr ""

#: ../../../library/multiprocessing.rst:1545
msgid "A variant of the :meth:`apply` method which returns a result object."
msgstr ""

#: ../../../library/multiprocessing.rst:1547
#: ../../../library/multiprocessing.rst:1565
msgid ""
"If *callback* is specified then it should be a callable which accepts a "
"single argument.  When the result becomes ready *callback* is applied to it "
"(unless the call failed).  *callback* should complete immediately since "
"otherwise the thread which handles the results will get blocked."
msgstr ""

#: ../../../library/multiprocessing.rst:1554
msgid ""
"A parallel equivalent of the :func:`map` built-in function (it supports only "
"one *iterable* argument though).  It blocks till the result is ready."
msgstr ""

#: ../../../library/multiprocessing.rst:1557
msgid ""
"This method chops the iterable into a number of chunks which it submits to "
"the process pool as separate tasks.  The (approximate) size of these chunks "
"can be specified by setting *chunksize* to a positive integer."
msgstr ""

#: ../../../library/multiprocessing.rst:1563
msgid "A variant of the :meth:`.map` method which returns a result object."
msgstr ""

#: ../../../library/multiprocessing.rst:1572
msgid "An equivalent of :func:`itertools.imap`."
msgstr ""

#: ../../../library/multiprocessing.rst:1574
msgid ""
"The *chunksize* argument is the same as the one used by the :meth:`.map` "
"method.  For very long iterables using a large value for *chunksize* can "
"make make the job complete **much** faster than using the default value of "
"``1``."
msgstr ""

#: ../../../library/multiprocessing.rst:1579
msgid ""
"Also if *chunksize* is ``1`` then the :meth:`!next` method of the iterator "
"returned by the :meth:`imap` method has an optional *timeout* parameter: "
"``next(timeout)`` will raise :exc:`multiprocessing.TimeoutError` if the "
"result cannot be returned within *timeout* seconds."
msgstr ""

#: ../../../library/multiprocessing.rst:1586
msgid ""
"The same as :meth:`imap` except that the ordering of the results from the "
"returned iterator should be considered arbitrary.  (Only when there is only "
"one worker process is the order guaranteed to be \"correct\".)"
msgstr ""

#: ../../../library/multiprocessing.rst:1592
msgid ""
"Prevents any more tasks from being submitted to the pool.  Once all the "
"tasks have been completed the worker processes will exit."
msgstr ""

#: ../../../library/multiprocessing.rst:1597
msgid ""
"Stops the worker processes immediately without completing outstanding work.  "
"When the pool object is garbage collected :meth:`terminate` will be called "
"immediately."
msgstr ""

#: ../../../library/multiprocessing.rst:1603
msgid ""
"Wait for the worker processes to exit.  One must call :meth:`close` or :meth:"
"`terminate` before using :meth:`join`."
msgstr ""

#: ../../../library/multiprocessing.rst:1609
msgid ""
"The class of the result returned by :meth:`Pool.apply_async` and :meth:`Pool."
"map_async`."
msgstr ""

#: ../../../library/multiprocessing.rst:1614
msgid ""
"Return the result when it arrives.  If *timeout* is not ``None`` and the "
"result does not arrive within *timeout* seconds then :exc:`multiprocessing."
"TimeoutError` is raised.  If the remote call raised an exception then that "
"exception will be reraised by :meth:`get`."
msgstr ""

#: ../../../library/multiprocessing.rst:1621
msgid "Wait until the result is available or until *timeout* seconds pass."
msgstr ""

#: ../../../library/multiprocessing.rst:1625
msgid "Return whether the call has completed."
msgstr ""

#: ../../../library/multiprocessing.rst:1629
msgid ""
"Return whether the call completed without raising an exception.  Will raise :"
"exc:`AssertionError` if the result is not ready."
msgstr ""

#: ../../../library/multiprocessing.rst:1632
msgid "The following example demonstrates the use of a pool::"
msgstr ""

#: ../../../library/multiprocessing.rst:1634
msgid ""
"from multiprocessing import Pool\n"
"\n"
"def f(x):\n"
"    return x*x\n"
"\n"
"if __name__ == '__main__':\n"
"    pool = Pool(processes=4)              # start 4 worker processes\n"
"\n"
"    result = pool.apply_async(f, (10,))    # evaluate \"f(10)\" "
"asynchronously\n"
"    print result.get(timeout=1)           # prints \"100\" unless your "
"computer is *very* slow\n"
"\n"
"    print pool.map(f, range(10))          # prints \"[0, 1, 4,..., 81]\"\n"
"\n"
"    it = pool.imap(f, range(10))\n"
"    print it.next()                       # prints \"0\"\n"
"    print it.next()                       # prints \"1\"\n"
"    print it.next(timeout=1)              # prints \"4\" unless your "
"computer is *very* slow\n"
"\n"
"    import time\n"
"    result = pool.apply_async(time.sleep, (10,))\n"
"    print result.get(timeout=1)           # raises TimeoutError"
msgstr ""

#: ../../../library/multiprocessing.rst:1660
msgid "Listeners and Clients"
msgstr ""

#: ../../../library/multiprocessing.rst:1665
msgid ""
"Usually message passing between processes is done using queues or by using :"
"class:`Connection` objects returned by :func:`Pipe`."
msgstr ""

#: ../../../library/multiprocessing.rst:1668
msgid ""
"However, the :mod:`multiprocessing.connection` module allows some extra "
"flexibility.  It basically gives a high level message oriented API for "
"dealing with sockets or Windows named pipes, and also has support for "
"*digest authentication* using the :mod:`hmac` module."
msgstr ""

#: ../../../library/multiprocessing.rst:1676
msgid ""
"Send a randomly generated message to the other end of the connection and "
"wait for a reply."
msgstr ""

#: ../../../library/multiprocessing.rst:1679
msgid ""
"If the reply matches the digest of the message using *authkey* as the key "
"then a welcome message is sent to the other end of the connection.  "
"Otherwise :exc:`AuthenticationError` is raised."
msgstr ""

#: ../../../library/multiprocessing.rst:1685
msgid ""
"Receive a message, calculate the digest of the message using *authkey* as "
"the key, and then send the digest back."
msgstr ""

#: ../../../library/multiprocessing.rst:1688
msgid ""
"If a welcome message is not received, then :exc:`AuthenticationError` is "
"raised."
msgstr ""

#: ../../../library/multiprocessing.rst:1693
msgid ""
"Attempt to set up a connection to the listener which is using address "
"*address*, returning a :class:`~multiprocessing.Connection`."
msgstr ""

#: ../../../library/multiprocessing.rst:1696
msgid ""
"The type of the connection is determined by *family* argument, but this can "
"generally be omitted since it can usually be inferred from the format of "
"*address*. (See :ref:`multiprocessing-address-formats`)"
msgstr ""

#: ../../../library/multiprocessing.rst:1700
msgid ""
"If *authenticate* is ``True`` or *authkey* is a string then digest "
"authentication is used.  The key used for authentication will be either "
"*authkey* or ``current_process().authkey)`` if *authkey* is ``None``. If "
"authentication fails then :exc:`AuthenticationError` is raised.  See :ref:"
"`multiprocessing-auth-keys`."
msgstr ""

#: ../../../library/multiprocessing.rst:1708
msgid ""
"A wrapper for a bound socket or Windows named pipe which is 'listening' for "
"connections."
msgstr ""

#: ../../../library/multiprocessing.rst:1711
msgid ""
"*address* is the address to be used by the bound socket or named pipe of the "
"listener object."
msgstr ""

#: ../../../library/multiprocessing.rst:1716
msgid ""
"If an address of '0.0.0.0' is used, the address will not be a connectable "
"end point on Windows. If you require a connectable end-point, you should use "
"'127.0.0.1'."
msgstr ""

#: ../../../library/multiprocessing.rst:1720
msgid ""
"*family* is the type of socket (or named pipe) to use.  This can be one of "
"the strings ``'AF_INET'`` (for a TCP socket), ``'AF_UNIX'`` (for a Unix "
"domain socket) or ``'AF_PIPE'`` (for a Windows named pipe).  Of these only "
"the first is guaranteed to be available.  If *family* is ``None`` then the "
"family is inferred from the format of *address*.  If *address* is also "
"``None`` then a default is chosen.  This default is the family which is "
"assumed to be the fastest available.  See :ref:`multiprocessing-address-"
"formats`.  Note that if *family* is ``'AF_UNIX'`` and address is ``None`` "
"then the socket will be created in a private temporary directory created "
"using :func:`tempfile.mkstemp`."
msgstr ""

#: ../../../library/multiprocessing.rst:1731
msgid ""
"If the listener object uses a socket then *backlog* (1 by default) is passed "
"to the :meth:`listen` method of the socket once it has been bound."
msgstr ""

#: ../../../library/multiprocessing.rst:1734
msgid ""
"If *authenticate* is ``True`` (``False`` by default) or *authkey* is not "
"``None`` then digest authentication is used."
msgstr ""

#: ../../../library/multiprocessing.rst:1737
msgid ""
"If *authkey* is a string then it will be used as the authentication key; "
"otherwise it must be *None*."
msgstr ""

#: ../../../library/multiprocessing.rst:1740
msgid ""
"If *authkey* is ``None`` and *authenticate* is ``True`` then "
"``current_process().authkey`` is used as the authentication key.  If "
"*authkey* is ``None`` and *authenticate* is ``False`` then no authentication "
"is done.  If authentication fails then :exc:`AuthenticationError` is "
"raised.  See :ref:`multiprocessing-auth-keys`."
msgstr ""

#: ../../../library/multiprocessing.rst:1748
msgid ""
"Accept a connection on the bound socket or named pipe of the listener object "
"and return a :class:`Connection` object.  If authentication is attempted and "
"fails, then :exc:`AuthenticationError` is raised."
msgstr ""

#: ../../../library/multiprocessing.rst:1754
msgid ""
"Close the bound socket or named pipe of the listener object.  This is called "
"automatically when the listener is garbage collected.  However it is "
"advisable to call it explicitly."
msgstr ""

#: ../../../library/multiprocessing.rst:1758
msgid "Listener objects have the following read-only properties:"
msgstr ""

#: ../../../library/multiprocessing.rst:1762
msgid "The address which is being used by the Listener object."
msgstr ""

#: ../../../library/multiprocessing.rst:1766
msgid ""
"The address from which the last accepted connection came.  If this is "
"unavailable then it is ``None``."
msgstr ""

#: ../../../library/multiprocessing.rst:1770
msgid "The module defines two exceptions:"
msgstr ""

#: ../../../library/multiprocessing.rst:1774
msgid "Exception raised when there is an authentication error."
msgstr ""

#: ../../../library/multiprocessing.rst:1777
msgid "**Examples**"
msgstr ""

#: ../../../library/multiprocessing.rst:1779
msgid ""
"The following server code creates a listener which uses ``'secret "
"password'`` as an authentication key.  It then waits for a connection and "
"sends some data to the client::"
msgstr ""

#: ../../../library/multiprocessing.rst:1783
msgid ""
"from multiprocessing.connection import Listener\n"
"from array import array\n"
"\n"
"address = ('localhost', 6000)     # family is deduced to be 'AF_INET'\n"
"listener = Listener(address, authkey='secret password')\n"
"\n"
"conn = listener.accept()\n"
"print 'connection accepted from', listener.last_accepted\n"
"\n"
"conn.send([2.25, None, 'junk', float])\n"
"\n"
"conn.send_bytes('hello')\n"
"\n"
"conn.send_bytes(array('i', [42, 1729]))\n"
"\n"
"conn.close()\n"
"listener.close()"
msgstr ""

#: ../../../library/multiprocessing.rst:1801
msgid ""
"The following code connects to the server and receives some data from the "
"server::"
msgstr ""

#: ../../../library/multiprocessing.rst:1804
msgid ""
"from multiprocessing.connection import Client\n"
"from array import array\n"
"\n"
"address = ('localhost', 6000)\n"
"conn = Client(address, authkey='secret password')\n"
"\n"
"print conn.recv()                 # => [2.25, None, 'junk', float]\n"
"\n"
"print conn.recv_bytes()            # => 'hello'\n"
"\n"
"arr = array('i', [0, 0, 0, 0, 0])\n"
"print conn.recv_bytes_into(arr)     # => 8\n"
"print arr                         # => array('i', [42, 1729, 0, 0, 0])\n"
"\n"
"conn.close()"
msgstr ""

#: ../../../library/multiprocessing.rst:1824
msgid "Address Formats"
msgstr ""

#: ../../../library/multiprocessing.rst:1826
msgid ""
"An ``'AF_INET'`` address is a tuple of the form ``(hostname, port)`` where "
"*hostname* is a string and *port* is an integer."
msgstr ""

#: ../../../library/multiprocessing.rst:1829
msgid ""
"An ``'AF_UNIX'`` address is a string representing a filename on the "
"filesystem."
msgstr ""

#: ../../../library/multiprocessing.rst:1835
msgid "An ``'AF_PIPE'`` address is a string of the form"
msgstr ""

#: ../../../library/multiprocessing.rst:1833
msgid ""
":samp:`r'\\\\\\\\.\\\\pipe\\\\{PipeName}'`.  To use :func:`Client` to "
"connect to a named pipe on a remote computer called *ServerName* one should "
"use an address of the form :samp:`r'\\\\\\\\{ServerName}\\\\pipe\\"
"\\{PipeName}'` instead."
msgstr ""

#: ../../../library/multiprocessing.rst:1837
msgid ""
"Note that any string beginning with two backslashes is assumed by default to "
"be an ``'AF_PIPE'`` address rather than an ``'AF_UNIX'`` address."
msgstr ""

#: ../../../library/multiprocessing.rst:1844
msgid "Authentication keys"
msgstr ""

#: ../../../library/multiprocessing.rst:1846
msgid ""
"When one uses :meth:`Connection.recv`, the data received is automatically "
"unpickled.  Unfortunately unpickling data from an untrusted source is a "
"security risk.  Therefore :class:`Listener` and :func:`Client` use the :mod:"
"`hmac` module to provide digest authentication."
msgstr ""

#: ../../../library/multiprocessing.rst:1851
msgid ""
"An authentication key is a string which can be thought of as a password: "
"once a connection is established both ends will demand proof that the other "
"knows the authentication key.  (Demonstrating that both ends are using the "
"same key does **not** involve sending the key over the connection.)"
msgstr ""

#: ../../../library/multiprocessing.rst:1856
msgid ""
"If authentication is requested but do authentication key is specified then "
"the return value of ``current_process().authkey`` is used (see :class:"
"`~multiprocessing.Process`).  This value will automatically inherited by "
"any :class:`~multiprocessing.Process` object that the current process "
"creates. This means that (by default) all processes of a multi-process "
"program will share a single authentication key which can be used when "
"setting up connections between themselves."
msgstr ""

#: ../../../library/multiprocessing.rst:1864
msgid ""
"Suitable authentication keys can also be generated by using :func:`os."
"urandom`."
msgstr ""

#: ../../../library/multiprocessing.rst:1868
msgid "Logging"
msgstr ""

#: ../../../library/multiprocessing.rst:1870
msgid ""
"Some support for logging is available.  Note, however, that the :mod:"
"`logging` package does not use process shared locks so it is possible "
"(depending on the handler type) for messages from different processes to get "
"mixed up."
msgstr ""

#: ../../../library/multiprocessing.rst:1877
msgid ""
"Returns the logger used by :mod:`multiprocessing`.  If necessary, a new one "
"will be created."
msgstr ""

#: ../../../library/multiprocessing.rst:1880
msgid ""
"When first created the logger has level :data:`logging.NOTSET` and no "
"default handler. Messages sent to this logger will not by default propagate "
"to the root logger."
msgstr ""

#: ../../../library/multiprocessing.rst:1884
msgid ""
"Note that on Windows child processes will only inherit the level of the "
"parent process's logger -- any other customization of the logger will not be "
"inherited."
msgstr ""

#: ../../../library/multiprocessing.rst:1891
msgid ""
"This function performs a call to :func:`get_logger` but in addition to "
"returning the logger created by get_logger, it adds a handler which sends "
"output to :data:`sys.stderr` using format ``'[%(levelname)s/%(processName)s] "
"%(message)s'``."
msgstr ""

#: ../../../library/multiprocessing.rst:1896
msgid "Below is an example session with logging turned on::"
msgstr ""

#: ../../../library/multiprocessing.rst:1898
msgid ""
">>> import multiprocessing, logging\n"
">>> logger = multiprocessing.log_to_stderr()\n"
">>> logger.setLevel(logging.INFO)\n"
">>> logger.warning('doomed')\n"
"[WARNING/MainProcess] doomed\n"
">>> m = multiprocessing.Manager()\n"
"[INFO/SyncManager-...] child process calling self.run()\n"
"[INFO/SyncManager-...] created temp directory /.../pymp-...\n"
"[INFO/SyncManager-...] manager serving at '/.../listener-...'\n"
">>> del m\n"
"[INFO/MainProcess] sending shutdown message to manager\n"
"[INFO/SyncManager-...] manager exiting with exitcode 0"
msgstr ""

#: ../../../library/multiprocessing.rst:1911
msgid ""
"In addition to having these two logging functions, the multiprocessing also "
"exposes two additional logging level attributes. These are  :const:"
"`SUBWARNING` and :const:`SUBDEBUG`. The table below illustrates where theses "
"fit in the normal level hierarchy."
msgstr ""

#: ../../../library/multiprocessing.rst:1917
msgid "Level"
msgstr ""

#: ../../../library/multiprocessing.rst:1917
msgid "Numeric value"
msgstr ""

#: ../../../library/multiprocessing.rst:1919
msgid "``SUBWARNING``"
msgstr ""

#: ../../../library/multiprocessing.rst:1919
msgid "25"
msgstr ""

#: ../../../library/multiprocessing.rst:1921
msgid "``SUBDEBUG``"
msgstr ""

#: ../../../library/multiprocessing.rst:1921
msgid "5"
msgstr ""

#: ../../../library/multiprocessing.rst:1924
msgid "For a full table of logging levels, see the :mod:`logging` module."
msgstr ""

#: ../../../library/multiprocessing.rst:1926
msgid ""
"These additional logging levels are used primarily for certain debug "
"messages within the multiprocessing module. Below is the same example as "
"above, except with :const:`SUBDEBUG` enabled::"
msgstr ""

#: ../../../library/multiprocessing.rst:1930
msgid ""
">>> import multiprocessing, logging\n"
">>> logger = multiprocessing.log_to_stderr()\n"
">>> logger.setLevel(multiprocessing.SUBDEBUG)\n"
">>> logger.warning('doomed')\n"
"[WARNING/MainProcess] doomed\n"
">>> m = multiprocessing.Manager()\n"
"[INFO/SyncManager-...] child process calling self.run()\n"
"[INFO/SyncManager-...] created temp directory /.../pymp-...\n"
"[INFO/SyncManager-...] manager serving at '/.../pymp-djGBXN/listener-...'\n"
">>> del m\n"
"[SUBDEBUG/MainProcess] finalizer calling ...\n"
"[INFO/MainProcess] sending shutdown message to manager\n"
"[DEBUG/SyncManager-...] manager received shutdown message\n"
"[SUBDEBUG/SyncManager-...] calling <Finalize object, callback=unlink, ...\n"
"[SUBDEBUG/SyncManager-...] finalizer calling <built-in function unlink> ...\n"
"[SUBDEBUG/SyncManager-...] calling <Finalize object, dead>\n"
"[SUBDEBUG/SyncManager-...] finalizer calling <function rmtree at "
"0x5aa730> ...\n"
"[INFO/SyncManager-...] manager exiting with exitcode 0"
msgstr ""

#: ../../../library/multiprocessing.rst:1950
msgid "The :mod:`multiprocessing.dummy` module"
msgstr ""

#: ../../../library/multiprocessing.rst:1955
msgid ""
":mod:`multiprocessing.dummy` replicates the API of :mod:`multiprocessing` "
"but is no more than a wrapper around the :mod:`threading` module."
msgstr ""

#: ../../../library/multiprocessing.rst:1962
msgid "Programming guidelines"
msgstr ""

#: ../../../library/multiprocessing.rst:1964
msgid ""
"There are certain guidelines and idioms which should be adhered to when "
"using :mod:`multiprocessing`."
msgstr ""

#: ../../../library/multiprocessing.rst:1969
msgid "All platforms"
msgstr ""

#: ../../../library/multiprocessing.rst:1971
msgid "Avoid shared state"
msgstr ""

#: ../../../library/multiprocessing.rst:1973
msgid ""
"As far as possible one should try to avoid shifting large amounts of data "
"between processes."
msgstr ""

#: ../../../library/multiprocessing.rst:1976
msgid ""
"It is probably best to stick to using queues or pipes for communication "
"between processes rather than using the lower level synchronization "
"primitives from the :mod:`threading` module."
msgstr ""

#: ../../../library/multiprocessing.rst:1980
msgid "Picklability"
msgstr ""

#: ../../../library/multiprocessing.rst:1982
msgid "Ensure that the arguments to the methods of proxies are picklable."
msgstr ""

#: ../../../library/multiprocessing.rst:1984
msgid "Thread safety of proxies"
msgstr ""

#: ../../../library/multiprocessing.rst:1986
msgid ""
"Do not use a proxy object from more than one thread unless you protect it "
"with a lock."
msgstr ""

#: ../../../library/multiprocessing.rst:1989
msgid ""
"(There is never a problem with different processes using the *same* proxy.)"
msgstr ""

#: ../../../library/multiprocessing.rst:1991
msgid "Joining zombie processes"
msgstr ""

#: ../../../library/multiprocessing.rst:1993
msgid ""
"On Unix when a process finishes but has not been joined it becomes a zombie. "
"There should never be very many because each time a new process starts (or :"
"func:`active_children` is called) all completed processes which have not yet "
"been joined will be joined.  Also calling a finished process's :meth:"
"`Process.is_alive` will join the process.  Even so it is probably good "
"practice to explicitly join all the processes that you start."
msgstr ""

#: ../../../library/multiprocessing.rst:2000
msgid "Better to inherit than pickle/unpickle"
msgstr ""

#: ../../../library/multiprocessing.rst:2002
msgid ""
"On Windows many types from :mod:`multiprocessing` need to be picklable so "
"that child processes can use them.  However, one should generally avoid "
"sending shared objects to other processes using pipes or queues.  Instead "
"you should arrange the program so that a process which need access to a "
"shared resource created elsewhere can inherit it from an ancestor process."
msgstr ""

#: ../../../library/multiprocessing.rst:2008
msgid "Avoid terminating processes"
msgstr ""

#: ../../../library/multiprocessing.rst:2010
msgid ""
"Using the :meth:`Process.terminate` method to stop a process is liable to "
"cause any shared resources (such as locks, semaphores, pipes and queues) "
"currently being used by the process to become broken or unavailable to other "
"processes."
msgstr ""

#: ../../../library/multiprocessing.rst:2015
msgid ""
"Therefore it is probably best to only consider using :meth:`Process."
"terminate` on processes which never use any shared resources."
msgstr ""

#: ../../../library/multiprocessing.rst:2018
msgid "Joining processes that use queues"
msgstr ""

#: ../../../library/multiprocessing.rst:2020
msgid ""
"Bear in mind that a process that has put items in a queue will wait before "
"terminating until all the buffered items are fed by the \"feeder\" thread to "
"the underlying pipe.  (The child process can call the :meth:`Queue."
"cancel_join_thread` method of the queue to avoid this behaviour.)"
msgstr ""

#: ../../../library/multiprocessing.rst:2025
msgid ""
"This means that whenever you use a queue you need to make sure that all "
"items which have been put on the queue will eventually be removed before the "
"process is joined.  Otherwise you cannot be sure that processes which have "
"put items on the queue will terminate.  Remember also that non-daemonic "
"processes will be automatically be joined."
msgstr ""

#: ../../../library/multiprocessing.rst:2031
msgid "An example which will deadlock is the following::"
msgstr ""

#: ../../../library/multiprocessing.rst:2033
msgid ""
"from multiprocessing import Process, Queue\n"
"\n"
"def f(q):\n"
"    q.put('X' * 1000000)\n"
"\n"
"if __name__ == '__main__':\n"
"    queue = Queue()\n"
"    p = Process(target=f, args=(queue,))\n"
"    p.start()\n"
"    p.join()                    # this deadlocks\n"
"    obj = queue.get()"
msgstr ""

#: ../../../library/multiprocessing.rst:2045
msgid ""
"A fix here would be to swap the last two lines round (or simply remove the "
"``p.join()`` line)."
msgstr ""

#: ../../../library/multiprocessing.rst:2048
msgid "Explicitly pass resources to child processes"
msgstr ""

#: ../../../library/multiprocessing.rst:2050
msgid ""
"On Unix a child process can make use of a shared resource created in a "
"parent process using a global resource.  However, it is better to pass the "
"object as an argument to the constructor for the child process."
msgstr ""

#: ../../../library/multiprocessing.rst:2054
msgid ""
"Apart from making the code (potentially) compatible with Windows this also "
"ensures that as long as the child process is still alive the object will not "
"be garbage collected in the parent process.  This might be important if some "
"resource is freed when the object is garbage collected in the parent process."
msgstr ""

#: ../../../library/multiprocessing.rst:2060
msgid "So for instance ::"
msgstr ""

#: ../../../library/multiprocessing.rst:2062
msgid ""
"from multiprocessing import Process, Lock\n"
"\n"
"def f():\n"
"    ... do something using \"lock\" ...\n"
"\n"
"if __name__ == '__main__':\n"
"   lock = Lock()\n"
"   for i in range(10):\n"
"        Process(target=f).start()"
msgstr ""

#: ../../../library/multiprocessing.rst:2072
msgid "should be rewritten as ::"
msgstr ""

#: ../../../library/multiprocessing.rst:2074
msgid ""
"from multiprocessing import Process, Lock\n"
"\n"
"def f(l):\n"
"    ... do something using \"l\" ...\n"
"\n"
"if __name__ == '__main__':\n"
"   lock = Lock()\n"
"   for i in range(10):\n"
"        Process(target=f, args=(lock,)).start()"
msgstr ""

#: ../../../library/multiprocessing.rst:2084
msgid "Beware replacing sys.stdin with a \"file like object\""
msgstr ""

#: ../../../library/multiprocessing.rst:2086
msgid ":mod:`multiprocessing` originally unconditionally called::"
msgstr ""

#: ../../../library/multiprocessing.rst:2088
msgid "os.close(sys.stdin.fileno())"
msgstr ""

#: ../../../library/multiprocessing.rst:2090
msgid ""
"in the :meth:`multiprocessing.Process._bootstrap` method --- this resulted "
"in issues with processes-in-processes. This has been changed to::"
msgstr ""

#: ../../../library/multiprocessing.rst:2093
msgid ""
"sys.stdin.close()\n"
"sys.stdin = open(os.devnull)"
msgstr ""

#: ../../../library/multiprocessing.rst:2096
msgid ""
"Which solves the fundamental issue of processes colliding with each other "
"resulting in a bad file descriptor error, but introduces a potential danger "
"to applications which replace :func:`sys.stdin` with a \"file-like object\" "
"with output buffering.  This danger is that if multiple processes call :func:"
"`close()` on this file-like object, it could result in the same data being "
"flushed to the object multiple times, resulting in corruption."
msgstr ""

#: ../../../library/multiprocessing.rst:2103
msgid ""
"If you write a file-like object and implement your own caching, you can make "
"it fork-safe by storing the pid whenever you append to the cache, and "
"discarding the cache when the pid changes. For example::"
msgstr ""

#: ../../../library/multiprocessing.rst:2107
msgid ""
"@property\n"
"def cache(self):\n"
"    pid = os.getpid()\n"
"    if pid != self._pid:\n"
"        self._pid = pid\n"
"        self._cache = []\n"
"    return self._cache"
msgstr ""

#: ../../../library/multiprocessing.rst:2115
msgid ""
"For more information, see :issue:`5155`, :issue:`5313` and :issue:`5331`"
msgstr ""

#: ../../../library/multiprocessing.rst:2118
msgid "Windows"
msgstr ""

#: ../../../library/multiprocessing.rst:2120
msgid "Since Windows lacks :func:`os.fork` it has a few extra restrictions:"
msgstr ""

#: ../../../library/multiprocessing.rst:2122
msgid "More picklability"
msgstr ""

#: ../../../library/multiprocessing.rst:2124
msgid ""
"Ensure that all arguments to :meth:`Process.__init__` are picklable.  This "
"means, in particular, that bound or unbound methods cannot be used directly "
"as the ``target`` argument on Windows --- just define a function and use "
"that instead."
msgstr ""

#: ../../../library/multiprocessing.rst:2129
msgid ""
"Also, if you subclass :class:`Process` then make sure that instances will be "
"picklable when the :meth:`Process.start` method is called."
msgstr ""

#: ../../../library/multiprocessing.rst:2132
msgid "Global variables"
msgstr ""

#: ../../../library/multiprocessing.rst:2134
msgid ""
"Bear in mind that if code run in a child process tries to access a global "
"variable, then the value it sees (if any) may not be the same as the value "
"in the parent process at the time that :meth:`Process.start` was called."
msgstr ""

#: ../../../library/multiprocessing.rst:2138
msgid ""
"However, global variables which are just module level constants cause no "
"problems."
msgstr ""

#: ../../../library/multiprocessing.rst:2141
msgid "Safe importing of main module"
msgstr ""

#: ../../../library/multiprocessing.rst:2143
msgid ""
"Make sure that the main module can be safely imported by a new Python "
"interpreter without causing unintended side effects (such a starting a new "
"process)."
msgstr ""

#: ../../../library/multiprocessing.rst:2147
msgid ""
"For example, under Windows running the following module would fail with a :"
"exc:`RuntimeError`::"
msgstr ""

#: ../../../library/multiprocessing.rst:2150
msgid ""
"from multiprocessing import Process\n"
"\n"
"def foo():\n"
"    print 'hello'\n"
"\n"
"p = Process(target=foo)\n"
"p.start()"
msgstr ""

#: ../../../library/multiprocessing.rst:2158
msgid ""
"Instead one should protect the \"entry point\" of the program by using ``if "
"__name__ == '__main__':`` as follows::"
msgstr ""

#: ../../../library/multiprocessing.rst:2161
msgid ""
"from multiprocessing import Process, freeze_support\n"
"\n"
"def foo():\n"
"    print 'hello'\n"
"\n"
"if __name__ == '__main__':\n"
"    freeze_support()\n"
"    p = Process(target=foo)\n"
"    p.start()"
msgstr ""

#: ../../../library/multiprocessing.rst:2171
msgid ""
"(The ``freeze_support()`` line can be omitted if the program will be run "
"normally instead of frozen.)"
msgstr ""

#: ../../../library/multiprocessing.rst:2174
msgid ""
"This allows the newly spawned Python interpreter to safely import the module "
"and then run the module's ``foo()`` function."
msgstr ""

#: ../../../library/multiprocessing.rst:2177
msgid ""
"Similar restrictions apply if a pool or manager is created in the main "
"module."
msgstr ""

#: ../../../library/multiprocessing.rst:2184
msgid "Examples"
msgstr ""

#: ../../../library/multiprocessing.rst:2186
msgid "Demonstration of how to create and use customized managers and proxies:"
msgstr ""

#: ../../../library/multiprocessing.rst:2188
msgid ""
"#\n"
"# This module shows how to use arbitrary callables with a subclass of\n"
"# `BaseManager`.\n"
"#\n"
"# Copyright (c) 2006-2008, R Oudkerk\n"
"# All rights reserved.\n"
"#\n"
"\n"
"from multiprocessing import freeze_support\n"
"from multiprocessing.managers import BaseManager, BaseProxy\n"
"import operator\n"
"\n"
"##\n"
"\n"
"class Foo(object):\n"
"    def f(self):\n"
"        print 'you called Foo.f()'\n"
"    def g(self):\n"
"        print 'you called Foo.g()'\n"
"    def _h(self):\n"
"        print 'you called Foo._h()'\n"
"\n"
"# A simple generator function\n"
"def baz():\n"
"    for i in xrange(10):\n"
"        yield i*i\n"
"\n"
"# Proxy type for generator objects\n"
"class GeneratorProxy(BaseProxy):\n"
"    _exposed_ = ('next', '__next__')\n"
"    def __iter__(self):\n"
"        return self\n"
"    def next(self):\n"
"        return self._callmethod('next')\n"
"    def __next__(self):\n"
"        return self._callmethod('__next__')\n"
"\n"
"# Function to return the operator module\n"
"def get_operator_module():\n"
"    return operator\n"
"\n"
"##\n"
"\n"
"class MyManager(BaseManager):\n"
"    pass\n"
"\n"
"# register the Foo class; make `f()` and `g()` accessible via proxy\n"
"MyManager.register('Foo1', Foo)\n"
"\n"
"# register the Foo class; make `g()` and `_h()` accessible via proxy\n"
"MyManager.register('Foo2', Foo, exposed=('g', '_h'))\n"
"\n"
"# register the generator function baz; use `GeneratorProxy` to make proxies\n"
"MyManager.register('baz', baz, proxytype=GeneratorProxy)\n"
"\n"
"# register get_operator_module(); make public functions accessible via "
"proxy\n"
"MyManager.register('operator', get_operator_module)\n"
"\n"
"##\n"
"\n"
"def test():\n"
"    manager = MyManager()\n"
"    manager.start()\n"
"\n"
"    print '-' * 20\n"
"\n"
"    f1 = manager.Foo1()\n"
"    f1.f()\n"
"    f1.g()\n"
"    assert not hasattr(f1, '_h')\n"
"    assert sorted(f1._exposed_) == sorted(['f', 'g'])\n"
"\n"
"    print '-' * 20\n"
"\n"
"    f2 = manager.Foo2()\n"
"    f2.g()\n"
"    f2._h()\n"
"    assert not hasattr(f2, 'f')\n"
"    assert sorted(f2._exposed_) == sorted(['g', '_h'])\n"
"\n"
"    print '-' * 20\n"
"\n"
"    it = manager.baz()\n"
"    for i in it:\n"
"        print '<%d>' % i,\n"
"    print\n"
"\n"
"    print '-' * 20\n"
"\n"
"    op = manager.operator()\n"
"    print 'op.add(23, 45) =', op.add(23, 45)\n"
"    print 'op.pow(2, 94) =', op.pow(2, 94)\n"
"    print 'op.getslice(range(10), 2, 6) =', op.getslice(range(10), 2, 6)\n"
"    print 'op.repeat(range(5), 3) =', op.repeat(range(5), 3)\n"
"    print 'op._exposed_ =', op._exposed_\n"
"\n"
"##\n"
"\n"
"if __name__ == '__main__':\n"
"    freeze_support()\n"
"    test()\n"
msgstr ""

#: ../../../library/multiprocessing.rst:2191
msgid "Using :class:`Pool`:"
msgstr ""

#: ../../../library/multiprocessing.rst:2193
msgid ""
"#\n"
"# A test of `multiprocessing.Pool` class\n"
"#\n"
"# Copyright (c) 2006-2008, R Oudkerk\n"
"# All rights reserved.\n"
"#\n"
"\n"
"import multiprocessing\n"
"import time\n"
"import random\n"
"import sys\n"
"\n"
"#\n"
"# Functions used by test code\n"
"#\n"
"\n"
"def calculate(func, args):\n"
"    result = func(*args)\n"
"    return '%s says that %s%s = %s' % (\n"
"        multiprocessing.current_process().name,\n"
"        func.__name__, args, result\n"
"        )\n"
"\n"
"def calculatestar(args):\n"
"    return calculate(*args)\n"
"\n"
"def mul(a, b):\n"
"    time.sleep(0.5*random.random())\n"
"    return a * b\n"
"\n"
"def plus(a, b):\n"
"    time.sleep(0.5*random.random())\n"
"    return a + b\n"
"\n"
"def f(x):\n"
"    return 1.0 / (x-5.0)\n"
"\n"
"def pow3(x):\n"
"    return x**3\n"
"\n"
"def noop(x):\n"
"    pass\n"
"\n"
"#\n"
"# Test code\n"
"#\n"
"\n"
"def test():\n"
"    print 'cpu_count() = %d\\n' % multiprocessing.cpu_count()\n"
"\n"
"    #\n"
"    # Create pool\n"
"    #\n"
"\n"
"    PROCESSES = 4\n"
"    print 'Creating pool with %d processes\\n' % PROCESSES\n"
"    pool = multiprocessing.Pool(PROCESSES)\n"
"    print 'pool = %s' % pool\n"
"    print\n"
"\n"
"    #\n"
"    # Tests\n"
"    #\n"
"\n"
"    TASKS = [(mul, (i, 7)) for i in range(10)] + \\\n"
"            [(plus, (i, 8)) for i in range(10)]\n"
"\n"
"    results = [pool.apply_async(calculate, t) for t in TASKS]\n"
"    imap_it = pool.imap(calculatestar, TASKS)\n"
"    imap_unordered_it = pool.imap_unordered(calculatestar, TASKS)\n"
"\n"
"    print 'Ordered results using pool.apply_async():'\n"
"    for r in results:\n"
"        print '\\t', r.get()\n"
"    print\n"
"\n"
"    print 'Ordered results using pool.imap():'\n"
"    for x in imap_it:\n"
"        print '\\t', x\n"
"    print\n"
"\n"
"    print 'Unordered results using pool.imap_unordered():'\n"
"    for x in imap_unordered_it:\n"
"        print '\\t', x\n"
"    print\n"
"\n"
"    print 'Ordered results using pool.map() --- will block till complete:'\n"
"    for x in pool.map(calculatestar, TASKS):\n"
"        print '\\t', x\n"
"    print\n"
"\n"
"    #\n"
"    # Simple benchmarks\n"
"    #\n"
"\n"
"    N = 100000\n"
"    print 'def pow3(x): return x**3'\n"
"\n"
"    t = time.time()\n"
"    A = map(pow3, xrange(N))\n"
"    print '\\tmap(pow3, xrange(%d)):\\n\\t\\t%s seconds' % \\\n"
"          (N, time.time() - t)\n"
"\n"
"    t = time.time()\n"
"    B = pool.map(pow3, xrange(N))\n"
"    print '\\tpool.map(pow3, xrange(%d)):\\n\\t\\t%s seconds' % \\\n"
"          (N, time.time() - t)\n"
"\n"
"    t = time.time()\n"
"    C = list(pool.imap(pow3, xrange(N), chunksize=N//8))\n"
"    print '\\tlist(pool.imap(pow3, xrange(%d), chunksize=%d)):\\n\\t\\t%s' "
"\\\n"
"          ' seconds' % (N, N//8, time.time() - t)\n"
"\n"
"    assert A == B == C, (len(A), len(B), len(C))\n"
"    print\n"
"\n"
"    L = [None] * 1000000\n"
"    print 'def noop(x): pass'\n"
"    print 'L = [None] * 1000000'\n"
"\n"
"    t = time.time()\n"
"    A = map(noop, L)\n"
"    print '\\tmap(noop, L):\\n\\t\\t%s seconds' % \\\n"
"          (time.time() - t)\n"
"\n"
"    t = time.time()\n"
"    B = pool.map(noop, L)\n"
"    print '\\tpool.map(noop, L):\\n\\t\\t%s seconds' % \\\n"
"          (time.time() - t)\n"
"\n"
"    t = time.time()\n"
"    C = list(pool.imap(noop, L, chunksize=len(L)//8))\n"
"    print '\\tlist(pool.imap(noop, L, chunksize=%d)):\\n\\t\\t%s seconds' % "
"\\\n"
"          (len(L)//8, time.time() - t)\n"
"\n"
"    assert A == B == C, (len(A), len(B), len(C))\n"
"    print\n"
"\n"
"    del A, B, C, L\n"
"\n"
"    #\n"
"    # Test error handling\n"
"    #\n"
"\n"
"    print 'Testing error handling:'\n"
"\n"
"    try:\n"
"        print pool.apply(f, (5,))\n"
"    except ZeroDivisionError:\n"
"        print '\\tGot ZeroDivisionError as expected from pool.apply()'\n"
"    else:\n"
"        raise AssertionError('expected ZeroDivisionError')\n"
"\n"
"    try:\n"
"        print pool.map(f, range(10))\n"
"    except ZeroDivisionError:\n"
"        print '\\tGot ZeroDivisionError as expected from pool.map()'\n"
"    else:\n"
"        raise AssertionError('expected ZeroDivisionError')\n"
"\n"
"    try:\n"
"        print list(pool.imap(f, range(10)))\n"
"    except ZeroDivisionError:\n"
"        print '\\tGot ZeroDivisionError as expected from list(pool.imap())'\n"
"    else:\n"
"        raise AssertionError('expected ZeroDivisionError')\n"
"\n"
"    it = pool.imap(f, range(10))\n"
"    for i in range(10):\n"
"        try:\n"
"            x = it.next()\n"
"        except ZeroDivisionError:\n"
"            if i == 5:\n"
"                pass\n"
"        except StopIteration:\n"
"            break\n"
"        else:\n"
"            if i == 5:\n"
"                raise AssertionError('expected ZeroDivisionError')\n"
"\n"
"    assert i == 9\n"
"    print '\\tGot ZeroDivisionError as expected from IMapIterator.next()'\n"
"    print\n"
"\n"
"    #\n"
"    # Testing timeouts\n"
"    #\n"
"\n"
"    print 'Testing ApplyResult.get() with timeout:',\n"
"    res = pool.apply_async(calculate, TASKS[0])\n"
"    while 1:\n"
"        sys.stdout.flush()\n"
"        try:\n"
"            sys.stdout.write('\\n\\t%s' % res.get(0.02))\n"
"            break\n"
"        except multiprocessing.TimeoutError:\n"
"            sys.stdout.write('.')\n"
"    print\n"
"    print\n"
"\n"
"    print 'Testing IMapIterator.next() with timeout:',\n"
"    it = pool.imap(calculatestar, TASKS)\n"
"    while 1:\n"
"        sys.stdout.flush()\n"
"        try:\n"
"            sys.stdout.write('\\n\\t%s' % it.next(0.02))\n"
"        except StopIteration:\n"
"            break\n"
"        except multiprocessing.TimeoutError:\n"
"            sys.stdout.write('.')\n"
"    print\n"
"    print\n"
"\n"
"    #\n"
"    # Testing callback\n"
"    #\n"
"\n"
"    print 'Testing callback:'\n"
"\n"
"    A = []\n"
"    B = [56, 0, 1, 8, 27, 64, 125, 216, 343, 512, 729]\n"
"\n"
"    r = pool.apply_async(mul, (7, 8), callback=A.append)\n"
"    r.wait()\n"
"\n"
"    r = pool.map_async(pow3, range(10), callback=A.extend)\n"
"    r.wait()\n"
"\n"
"    if A == B:\n"
"        print '\\tcallbacks succeeded\\n'\n"
"    else:\n"
"        print '\\t*** callbacks failed\\n\\t\\t%s != %s\\n' % (A, B)\n"
"\n"
"    #\n"
"    # Check there are no outstanding tasks\n"
"    #\n"
"\n"
"    assert not pool._cache, 'cache = %r' % pool._cache\n"
"\n"
"    #\n"
"    # Check close() methods\n"
"    #\n"
"\n"
"    print 'Testing close():'\n"
"\n"
"    for worker in pool._pool:\n"
"        assert worker.is_alive()\n"
"\n"
"    result = pool.apply_async(time.sleep, [0.5])\n"
"    pool.close()\n"
"    pool.join()\n"
"\n"
"    assert result.get() is None\n"
"\n"
"    for worker in pool._pool:\n"
"        assert not worker.is_alive()\n"
"\n"
"    print '\\tclose() succeeded\\n'\n"
"\n"
"    #\n"
"    # Check terminate() method\n"
"    #\n"
"\n"
"    print 'Testing terminate():'\n"
"\n"
"    pool = multiprocessing.Pool(2)\n"
"    DELTA = 0.1\n"
"    ignore = pool.apply(pow3, [2])\n"
"    results = [pool.apply_async(time.sleep, [DELTA]) for i in range(100)]\n"
"    pool.terminate()\n"
"    pool.join()\n"
"\n"
"    for worker in pool._pool:\n"
"        assert not worker.is_alive()\n"
"\n"
"    print '\\tterminate() succeeded\\n'\n"
"\n"
"    #\n"
"    # Check garbage collection\n"
"    #\n"
"\n"
"    print 'Testing garbage collection:'\n"
"\n"
"    pool = multiprocessing.Pool(2)\n"
"    DELTA = 0.1\n"
"    processes = pool._pool\n"
"    ignore = pool.apply(pow3, [2])\n"
"    results = [pool.apply_async(time.sleep, [DELTA]) for i in range(100)]\n"
"\n"
"    results = pool = None\n"
"\n"
"    time.sleep(DELTA * 2)\n"
"\n"
"    for worker in processes:\n"
"        assert not worker.is_alive()\n"
"\n"
"    print '\\tgarbage collection succeeded\\n'\n"
"\n"
"\n"
"if __name__ == '__main__':\n"
"    multiprocessing.freeze_support()\n"
"\n"
"    assert len(sys.argv) in (1, 2)\n"
"\n"
"    if len(sys.argv) == 1 or sys.argv[1] == 'processes':\n"
"        print ' Using processes '.center(79, '-')\n"
"    elif sys.argv[1] == 'threads':\n"
"        print ' Using threads '.center(79, '-')\n"
"        import multiprocessing.dummy as multiprocessing\n"
"    else:\n"
"        print 'Usage:\\n\\t%s [processes | threads]' % sys.argv[0]\n"
"        raise SystemExit(2)\n"
"\n"
"    test()\n"
msgstr ""

#: ../../../library/multiprocessing.rst:2196
msgid "Synchronization types like locks, conditions and queues:"
msgstr ""

#: ../../../library/multiprocessing.rst:2198
msgid ""
"#\n"
"# A test file for the `multiprocessing` package\n"
"#\n"
"# Copyright (c) 2006-2008, R Oudkerk\n"
"# All rights reserved.\n"
"#\n"
"\n"
"import time, sys, random\n"
"from Queue import Empty\n"
"\n"
"import multiprocessing               # may get overwritten\n"
"\n"
"\n"
"#### TEST_VALUE\n"
"\n"
"def value_func(running, mutex):\n"
"    random.seed()\n"
"    time.sleep(random.random()*4)\n"
"\n"
"    mutex.acquire()\n"
"    print '\\n\\t\\t\\t' + str(multiprocessing.current_process()) + ' has "
"finished'\n"
"    running.value -= 1\n"
"    mutex.release()\n"
"\n"
"def test_value():\n"
"    TASKS = 10\n"
"    running = multiprocessing.Value('i', TASKS)\n"
"    mutex = multiprocessing.Lock()\n"
"\n"
"    for i in range(TASKS):\n"
"        p = multiprocessing.Process(target=value_func, args=(running, "
"mutex))\n"
"        p.start()\n"
"\n"
"    while running.value > 0:\n"
"        time.sleep(0.08)\n"
"        mutex.acquire()\n"
"        print running.value,\n"
"        sys.stdout.flush()\n"
"        mutex.release()\n"
"\n"
"    print\n"
"    print 'No more running processes'\n"
"\n"
"\n"
"#### TEST_QUEUE\n"
"\n"
"def queue_func(queue):\n"
"    for i in range(30):\n"
"        time.sleep(0.5 * random.random())\n"
"        queue.put(i*i)\n"
"    queue.put('STOP')\n"
"\n"
"def test_queue():\n"
"    q = multiprocessing.Queue()\n"
"\n"
"    p = multiprocessing.Process(target=queue_func, args=(q,))\n"
"    p.start()\n"
"\n"
"    o = None\n"
"    while o != 'STOP':\n"
"        try:\n"
"            o = q.get(timeout=0.3)\n"
"            print o,\n"
"            sys.stdout.flush()\n"
"        except Empty:\n"
"            print 'TIMEOUT'\n"
"\n"
"    print\n"
"\n"
"\n"
"#### TEST_CONDITION\n"
"\n"
"def condition_func(cond):\n"
"    cond.acquire()\n"
"    print '\\t' + str(cond)\n"
"    time.sleep(2)\n"
"    print '\\tchild is notifying'\n"
"    print '\\t' + str(cond)\n"
"    cond.notify()\n"
"    cond.release()\n"
"\n"
"def test_condition():\n"
"    cond = multiprocessing.Condition()\n"
"\n"
"    p = multiprocessing.Process(target=condition_func, args=(cond,))\n"
"    print cond\n"
"\n"
"    cond.acquire()\n"
"    print cond\n"
"    cond.acquire()\n"
"    print cond\n"
"\n"
"    p.start()\n"
"\n"
"    print 'main is waiting'\n"
"    cond.wait()\n"
"    print 'main has woken up'\n"
"\n"
"    print cond\n"
"    cond.release()\n"
"    print cond\n"
"    cond.release()\n"
"\n"
"    p.join()\n"
"    print cond\n"
"\n"
"\n"
"#### TEST_SEMAPHORE\n"
"\n"
"def semaphore_func(sema, mutex, running):\n"
"    sema.acquire()\n"
"\n"
"    mutex.acquire()\n"
"    running.value += 1\n"
"    print running.value, 'tasks are running'\n"
"    mutex.release()\n"
"\n"
"    random.seed()\n"
"    time.sleep(random.random()*2)\n"
"\n"
"    mutex.acquire()\n"
"    running.value -= 1\n"
"    print '%s has finished' % multiprocessing.current_process()\n"
"    mutex.release()\n"
"\n"
"    sema.release()\n"
"\n"
"def test_semaphore():\n"
"    sema = multiprocessing.Semaphore(3)\n"
"    mutex = multiprocessing.RLock()\n"
"    running = multiprocessing.Value('i', 0)\n"
"\n"
"    processes = [\n"
"        multiprocessing.Process(target=semaphore_func,\n"
"                                args=(sema, mutex, running))\n"
"        for i in range(10)\n"
"        ]\n"
"\n"
"    for p in processes:\n"
"        p.start()\n"
"\n"
"    for p in processes:\n"
"        p.join()\n"
"\n"
"\n"
"#### TEST_JOIN_TIMEOUT\n"
"\n"
"def join_timeout_func():\n"
"    print '\\tchild sleeping'\n"
"    time.sleep(5.5)\n"
"    print '\\n\\tchild terminating'\n"
"\n"
"def test_join_timeout():\n"
"    p = multiprocessing.Process(target=join_timeout_func)\n"
"    p.start()\n"
"\n"
"    print 'waiting for process to finish'\n"
"\n"
"    while 1:\n"
"        p.join(timeout=1)\n"
"        if not p.is_alive():\n"
"            break\n"
"        print '.',\n"
"        sys.stdout.flush()\n"
"\n"
"\n"
"#### TEST_EVENT\n"
"\n"
"def event_func(event):\n"
"    print '\\t%r is waiting' % multiprocessing.current_process()\n"
"    event.wait()\n"
"    print '\\t%r has woken up' % multiprocessing.current_process()\n"
"\n"
"def test_event():\n"
"    event = multiprocessing.Event()\n"
"\n"
"    processes = [multiprocessing.Process(target=event_func, args=(event,))\n"
"                 for i in range(5)]\n"
"\n"
"    for p in processes:\n"
"        p.start()\n"
"\n"
"    print 'main is sleeping'\n"
"    time.sleep(2)\n"
"\n"
"    print 'main is setting event'\n"
"    event.set()\n"
"\n"
"    for p in processes:\n"
"        p.join()\n"
"\n"
"\n"
"#### TEST_SHAREDVALUES\n"
"\n"
"def sharedvalues_func(values, arrays, shared_values, shared_arrays):\n"
"    for i in range(len(values)):\n"
"        v = values[i][1]\n"
"        sv = shared_values[i].value\n"
"        assert v == sv\n"
"\n"
"    for i in range(len(values)):\n"
"        a = arrays[i][1]\n"
"        sa = list(shared_arrays[i][:])\n"
"        assert a == sa\n"
"\n"
"    print 'Tests passed'\n"
"\n"
"def test_sharedvalues():\n"
"    values = [\n"
"        ('i', 10),\n"
"        ('h', -2),\n"
"        ('d', 1.25)\n"
"        ]\n"
"    arrays = [\n"
"        ('i', range(100)),\n"
"        ('d', [0.25 * i for i in range(100)]),\n"
"        ('H', range(1000))\n"
"        ]\n"
"\n"
"    shared_values = [multiprocessing.Value(id, v) for id, v in values]\n"
"    shared_arrays = [multiprocessing.Array(id, a) for id, a in arrays]\n"
"\n"
"    p = multiprocessing.Process(\n"
"        target=sharedvalues_func,\n"
"        args=(values, arrays, shared_values, shared_arrays)\n"
"        )\n"
"    p.start()\n"
"    p.join()\n"
"\n"
"    assert p.exitcode == 0\n"
"\n"
"\n"
"####\n"
"\n"
"def test(namespace=multiprocessing):\n"
"    global multiprocessing\n"
"\n"
"    multiprocessing = namespace\n"
"\n"
"    for func in [ test_value, test_queue, test_condition,\n"
"                  test_semaphore, test_join_timeout, test_event,\n"
"                  test_sharedvalues ]:\n"
"\n"
"        print '\\n\\t######## %s\\n' % func.__name__\n"
"        func()\n"
"\n"
"    ignore = multiprocessing.active_children()      # cleanup any old "
"processes\n"
"    if hasattr(multiprocessing, '_debug_info'):\n"
"        info = multiprocessing._debug_info()\n"
"        if info:\n"
"            print info\n"
"            raise ValueError('there should be no positive refcounts left')\n"
"\n"
"\n"
"if __name__ == '__main__':\n"
"    multiprocessing.freeze_support()\n"
"\n"
"    assert len(sys.argv) in (1, 2)\n"
"\n"
"    if len(sys.argv) == 1 or sys.argv[1] == 'processes':\n"
"        print ' Using processes '.center(79, '-')\n"
"        namespace = multiprocessing\n"
"    elif sys.argv[1] == 'manager':\n"
"        print ' Using processes and a manager '.center(79, '-')\n"
"        namespace = multiprocessing.Manager()\n"
"        namespace.Process = multiprocessing.Process\n"
"        namespace.current_process = multiprocessing.current_process\n"
"        namespace.active_children = multiprocessing.active_children\n"
"    elif sys.argv[1] == 'threads':\n"
"        print ' Using threads '.center(79, '-')\n"
"        import multiprocessing.dummy as namespace\n"
"    else:\n"
"        print 'Usage:\\n\\t%s [processes | manager | threads]' % sys."
"argv[0]\n"
"        raise SystemExit(2)\n"
"\n"
"    test(namespace)\n"
msgstr ""

#: ../../../library/multiprocessing.rst:2201
msgid ""
"An showing how to use queues to feed tasks to a collection of worker process "
"and collect the results:"
msgstr ""

#: ../../../library/multiprocessing.rst:2204
msgid ""
"#\n"
"# Simple example which uses a pool of workers to carry out some tasks.\n"
"#\n"
"# Notice that the results will probably not come out of the output\n"
"# queue in the same in the same order as the corresponding tasks were\n"
"# put on the input queue.  If it is important to get the results back\n"
"# in the original order then consider using `Pool.map()` or\n"
"# `Pool.imap()` (which will save on the amount of code needed anyway).\n"
"#\n"
"# Copyright (c) 2006-2008, R Oudkerk\n"
"# All rights reserved.\n"
"#\n"
"\n"
"import time\n"
"import random\n"
"\n"
"from multiprocessing import Process, Queue, current_process, freeze_support\n"
"\n"
"#\n"
"# Function run by worker processes\n"
"#\n"
"\n"
"def worker(input, output):\n"
"    for func, args in iter(input.get, 'STOP'):\n"
"        result = calculate(func, args)\n"
"        output.put(result)\n"
"\n"
"#\n"
"# Function used to calculate result\n"
"#\n"
"\n"
"def calculate(func, args):\n"
"    result = func(*args)\n"
"    return '%s says that %s%s = %s' % \\\n"
"        (current_process().name, func.__name__, args, result)\n"
"\n"
"#\n"
"# Functions referenced by tasks\n"
"#\n"
"\n"
"def mul(a, b):\n"
"    time.sleep(0.5*random.random())\n"
"    return a * b\n"
"\n"
"def plus(a, b):\n"
"    time.sleep(0.5*random.random())\n"
"    return a + b\n"
"\n"
"#\n"
"#\n"
"#\n"
"\n"
"def test():\n"
"    NUMBER_OF_PROCESSES = 4\n"
"    TASKS1 = [(mul, (i, 7)) for i in range(20)]\n"
"    TASKS2 = [(plus, (i, 8)) for i in range(10)]\n"
"\n"
"    # Create queues\n"
"    task_queue = Queue()\n"
"    done_queue = Queue()\n"
"\n"
"    # Submit tasks\n"
"    for task in TASKS1:\n"
"        task_queue.put(task)\n"
"\n"
"    # Start worker processes\n"
"    for i in range(NUMBER_OF_PROCESSES):\n"
"        Process(target=worker, args=(task_queue, done_queue)).start()\n"
"\n"
"    # Get and print results\n"
"    print 'Unordered results:'\n"
"    for i in range(len(TASKS1)):\n"
"        print '\\t', done_queue.get()\n"
"\n"
"    # Add more tasks using `put()`\n"
"    for task in TASKS2:\n"
"        task_queue.put(task)\n"
"\n"
"    # Get and print some more results\n"
"    for i in range(len(TASKS2)):\n"
"        print '\\t', done_queue.get()\n"
"\n"
"    # Tell child processes to stop\n"
"    for i in range(NUMBER_OF_PROCESSES):\n"
"        task_queue.put('STOP')\n"
"\n"
"\n"
"if __name__ == '__main__':\n"
"    freeze_support()\n"
"    test()\n"
msgstr ""

#: ../../../library/multiprocessing.rst:2207
msgid ""
"An example of how a pool of worker processes can each run a :class:"
"`SimpleHTTPServer.HttpServer` instance while sharing a single listening "
"socket."
msgstr ""

#: ../../../library/multiprocessing.rst:2211
msgid ""
"#\n"
"# Example where a pool of http servers share a single listening socket\n"
"#\n"
"# On Windows this module depends on the ability to pickle a socket\n"
"# object so that the worker processes can inherit a copy of the server\n"
"# object.  (We import `multiprocessing.reduction` to enable this pickling.)\n"
"#\n"
"# Not sure if we should synchronize access to `socket.accept()` method by\n"
"# using a process-shared lock -- does not seem to be necessary.\n"
"#\n"
"# Copyright (c) 2006-2008, R Oudkerk\n"
"# All rights reserved.\n"
"#\n"
"\n"
"import os\n"
"import sys\n"
"\n"
"from multiprocessing import Process, current_process, freeze_support\n"
"from BaseHTTPServer import HTTPServer\n"
"from SimpleHTTPServer import SimpleHTTPRequestHandler\n"
"\n"
"if sys.platform == 'win32':\n"
"    import multiprocessing.reduction    # make sockets pickable/inheritable\n"
"\n"
"\n"
"def note(format, *args):\n"
"    sys.stderr.write('[%s]\\t%s\\n' % (current_process().name, "
"format%args))\n"
"\n"
"\n"
"class RequestHandler(SimpleHTTPRequestHandler):\n"
"    # we override log_message() to show which process is handling the "
"request\n"
"    def log_message(self, format, *args):\n"
"        note(format, *args)\n"
"\n"
"def serve_forever(server):\n"
"    note('starting server')\n"
"    try:\n"
"        server.serve_forever()\n"
"    except KeyboardInterrupt:\n"
"        pass\n"
"\n"
"\n"
"def runpool(address, number_of_processes):\n"
"    # create a single server object -- children will each inherit a copy\n"
"    server = HTTPServer(address, RequestHandler)\n"
"\n"
"    # create child processes to act as workers\n"
"    for i in range(number_of_processes-1):\n"
"        Process(target=serve_forever, args=(server,)).start()\n"
"\n"
"    # main process also acts as a worker\n"
"    serve_forever(server)\n"
"\n"
"\n"
"def test():\n"
"    DIR = os.path.join(os.path.dirname(__file__), '..')\n"
"    ADDRESS = ('localhost', 8000)\n"
"    NUMBER_OF_PROCESSES = 4\n"
"\n"
"    print 'Serving at http://%s:%d using %d worker processes' % \\\n"
"          (ADDRESS[0], ADDRESS[1], NUMBER_OF_PROCESSES)\n"
"    print 'To exit press Ctrl-' + ['C', 'Break'][sys.platform=='win32']\n"
"\n"
"    os.chdir(DIR)\n"
"    runpool(ADDRESS, NUMBER_OF_PROCESSES)\n"
"\n"
"\n"
"if __name__ == '__main__':\n"
"    freeze_support()\n"
"    test()\n"
msgstr ""

#: ../../../library/multiprocessing.rst:2214
msgid ""
"Some simple benchmarks comparing :mod:`multiprocessing` with :mod:"
"`threading`:"
msgstr ""

#: ../../../library/multiprocessing.rst:2216
msgid ""
"#\n"
"# Simple benchmarks for the multiprocessing package\n"
"#\n"
"# Copyright (c) 2006-2008, R Oudkerk\n"
"# All rights reserved.\n"
"#\n"
"\n"
"import time, sys, multiprocessing, threading, Queue, gc\n"
"\n"
"if sys.platform == 'win32':\n"
"    _timer = time.clock\n"
"else:\n"
"    _timer = time.time\n"
"\n"
"delta = 1\n"
"\n"
"\n"
"#### TEST_QUEUESPEED\n"
"\n"
"def queuespeed_func(q, c, iterations):\n"
"    a = '0' * 256\n"
"    c.acquire()\n"
"    c.notify()\n"
"    c.release()\n"
"\n"
"    for i in xrange(iterations):\n"
"        q.put(a)\n"
"\n"
"    q.put('STOP')\n"
"\n"
"def test_queuespeed(Process, q, c):\n"
"    elapsed = 0\n"
"    iterations = 1\n"
"\n"
"    while elapsed < delta:\n"
"        iterations *= 2\n"
"\n"
"        p = Process(target=queuespeed_func, args=(q, c, iterations))\n"
"        c.acquire()\n"
"        p.start()\n"
"        c.wait()\n"
"        c.release()\n"
"\n"
"        result = None\n"
"        t = _timer()\n"
"\n"
"        while result != 'STOP':\n"
"            result = q.get()\n"
"\n"
"        elapsed = _timer() - t\n"
"\n"
"        p.join()\n"
"\n"
"    print iterations, 'objects passed through the queue in', elapsed, "
"'seconds'\n"
"    print 'average number/sec:', iterations/elapsed\n"
"\n"
"\n"
"#### TEST_PIPESPEED\n"
"\n"
"def pipe_func(c, cond, iterations):\n"
"    a = '0' * 256\n"
"    cond.acquire()\n"
"    cond.notify()\n"
"    cond.release()\n"
"\n"
"    for i in xrange(iterations):\n"
"        c.send(a)\n"
"\n"
"    c.send('STOP')\n"
"\n"
"def test_pipespeed():\n"
"    c, d = multiprocessing.Pipe()\n"
"    cond = multiprocessing.Condition()\n"
"    elapsed = 0\n"
"    iterations = 1\n"
"\n"
"    while elapsed < delta:\n"
"        iterations *= 2\n"
"\n"
"        p = multiprocessing.Process(target=pipe_func,\n"
"                                    args=(d, cond, iterations))\n"
"        cond.acquire()\n"
"        p.start()\n"
"        cond.wait()\n"
"        cond.release()\n"
"\n"
"        result = None\n"
"        t = _timer()\n"
"\n"
"        while result != 'STOP':\n"
"            result = c.recv()\n"
"\n"
"        elapsed = _timer() - t\n"
"        p.join()\n"
"\n"
"    print iterations, 'objects passed through connection in',"
"elapsed,'seconds'\n"
"    print 'average number/sec:', iterations/elapsed\n"
"\n"
"\n"
"#### TEST_SEQSPEED\n"
"\n"
"def test_seqspeed(seq):\n"
"    elapsed = 0\n"
"    iterations = 1\n"
"\n"
"    while elapsed < delta:\n"
"        iterations *= 2\n"
"\n"
"        t = _timer()\n"
"\n"
"        for i in xrange(iterations):\n"
"            a = seq[5]\n"
"\n"
"        elapsed = _timer()-t\n"
"\n"
"    print iterations, 'iterations in', elapsed, 'seconds'\n"
"    print 'average number/sec:', iterations/elapsed\n"
"\n"
"\n"
"#### TEST_LOCK\n"
"\n"
"def test_lockspeed(l):\n"
"    elapsed = 0\n"
"    iterations = 1\n"
"\n"
"    while elapsed < delta:\n"
"        iterations *= 2\n"
"\n"
"        t = _timer()\n"
"\n"
"        for i in xrange(iterations):\n"
"            l.acquire()\n"
"            l.release()\n"
"\n"
"        elapsed = _timer()-t\n"
"\n"
"    print iterations, 'iterations in', elapsed, 'seconds'\n"
"    print 'average number/sec:', iterations/elapsed\n"
"\n"
"\n"
"#### TEST_CONDITION\n"
"\n"
"def conditionspeed_func(c, N):\n"
"    c.acquire()\n"
"    c.notify()\n"
"\n"
"    for i in xrange(N):\n"
"        c.wait()\n"
"        c.notify()\n"
"\n"
"    c.release()\n"
"\n"
"def test_conditionspeed(Process, c):\n"
"    elapsed = 0\n"
"    iterations = 1\n"
"\n"
"    while elapsed < delta:\n"
"        iterations *= 2\n"
"\n"
"        c.acquire()\n"
"        p = Process(target=conditionspeed_func, args=(c, iterations))\n"
"        p.start()\n"
"\n"
"        c.wait()\n"
"\n"
"        t = _timer()\n"
"\n"
"        for i in xrange(iterations):\n"
"            c.notify()\n"
"            c.wait()\n"
"\n"
"        elapsed = _timer()-t\n"
"\n"
"        c.release()\n"
"        p.join()\n"
"\n"
"    print iterations * 2, 'waits in', elapsed, 'seconds'\n"
"    print 'average number/sec:', iterations * 2 / elapsed\n"
"\n"
"####\n"
"\n"
"def test():\n"
"    manager = multiprocessing.Manager()\n"
"\n"
"    gc.disable()\n"
"\n"
"    print '\\n\\t######## testing Queue.Queue\\n'\n"
"    test_queuespeed(threading.Thread, Queue.Queue(),\n"
"                    threading.Condition())\n"
"    print '\\n\\t######## testing multiprocessing.Queue\\n'\n"
"    test_queuespeed(multiprocessing.Process, multiprocessing.Queue(),\n"
"                    multiprocessing.Condition())\n"
"    print '\\n\\t######## testing Queue managed by server process\\n'\n"
"    test_queuespeed(multiprocessing.Process, manager.Queue(),\n"
"                    manager.Condition())\n"
"    print '\\n\\t######## testing multiprocessing.Pipe\\n'\n"
"    test_pipespeed()\n"
"\n"
"    print\n"
"\n"
"    print '\\n\\t######## testing list\\n'\n"
"    test_seqspeed(range(10))\n"
"    print '\\n\\t######## testing list managed by server process\\n'\n"
"    test_seqspeed(manager.list(range(10)))\n"
"    print '\\n\\t######## testing Array(\"i\", ..., lock=False)\\n'\n"
"    test_seqspeed(multiprocessing.Array('i', range(10), lock=False))\n"
"    print '\\n\\t######## testing Array(\"i\", ..., lock=True)\\n'\n"
"    test_seqspeed(multiprocessing.Array('i', range(10), lock=True))\n"
"\n"
"    print\n"
"\n"
"    print '\\n\\t######## testing threading.Lock\\n'\n"
"    test_lockspeed(threading.Lock())\n"
"    print '\\n\\t######## testing threading.RLock\\n'\n"
"    test_lockspeed(threading.RLock())\n"
"    print '\\n\\t######## testing multiprocessing.Lock\\n'\n"
"    test_lockspeed(multiprocessing.Lock())\n"
"    print '\\n\\t######## testing multiprocessing.RLock\\n'\n"
"    test_lockspeed(multiprocessing.RLock())\n"
"    print '\\n\\t######## testing lock managed by server process\\n'\n"
"    test_lockspeed(manager.Lock())\n"
"    print '\\n\\t######## testing rlock managed by server process\\n'\n"
"    test_lockspeed(manager.RLock())\n"
"\n"
"    print\n"
"\n"
"    print '\\n\\t######## testing threading.Condition\\n'\n"
"    test_conditionspeed(threading.Thread, threading.Condition())\n"
"    print '\\n\\t######## testing multiprocessing.Condition\\n'\n"
"    test_conditionspeed(multiprocessing.Process, multiprocessing."
"Condition())\n"
"    print '\\n\\t######## testing condition managed by a server process\\n'\n"
"    test_conditionspeed(multiprocessing.Process, manager.Condition())\n"
"\n"
"    gc.enable()\n"
"\n"
"if __name__ == '__main__':\n"
"    multiprocessing.freeze_support()\n"
"    test()\n"
msgstr ""

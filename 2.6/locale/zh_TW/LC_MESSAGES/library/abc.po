# SOME DESCRIPTIVE TITLE.
# Copyright (C) 1990-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 2.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-10 15:09+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../library/abc.rst:2
msgid ":mod:`abc` --- Abstract Base Classes"
msgstr ""

#: ../../../library/abc.rst:12
msgid ""
"This module provides the infrastructure for defining an :term:`abstract base "
"class` (ABCs) in Python, as outlined in :pep:`3119`; see the PEP for why "
"this was added to Python. (See also :pep:`3141` and the :mod:`numbers` "
"module regarding a type hierarchy for numbers based on ABCs.)"
msgstr ""

#: ../../../library/abc.rst:17
msgid ""
"The :mod:`collections` module has some concrete classes that derive from "
"ABCs; these can, of course, be further derived. In addition the :mod:"
"`collections` module has some ABCs that can be used to test whether a class "
"or instance provides a particular interface, for example, is it hashable or "
"a mapping."
msgstr ""

#: ../../../library/abc.rst:24
msgid "This module provides the following class:"
msgstr ""

#: ../../../library/abc.rst:28
msgid "Metaclass for defining Abstract Base Classes (ABCs)."
msgstr ""

#: ../../../library/abc.rst:30
msgid ""
"Use this metaclass to create an ABC.  An ABC can be subclassed directly, and "
"then acts as a mix-in class.  You can also register unrelated concrete "
"classes (even built-in classes) and unrelated ABCs as \"virtual subclasses\" "
"-- these and their descendants will be considered subclasses of the "
"registering ABC by the built-in :func:`issubclass` function, but the "
"registering ABC won't show up in their MRO (Method Resolution Order) nor "
"will method implementations defined by the registering ABC be callable (not "
"even via :func:`super`). [#]_"
msgstr ""

#: ../../../library/abc.rst:39
msgid ""
"Classes created with a metaclass of :class:`ABCMeta` have the following "
"method:"
msgstr ""

#: ../../../library/abc.rst:43
msgid ""
"Register *subclass* as a \"virtual subclass\" of this ABC. For example::"
msgstr ""

#: ../../../library/abc.rst:46
msgid ""
"from abc import ABCMeta\n"
"\n"
"class MyABC:\n"
"    __metaclass__ = ABCMeta\n"
"\n"
"MyABC.register(tuple)\n"
"\n"
"assert issubclass(tuple, MyABC)\n"
"assert isinstance((), MyABC)"
msgstr ""

#: ../../../library/abc.rst:56
msgid "You can also override this method in an abstract base class:"
msgstr ""

#: ../../../library/abc.rst:60
msgid "(Must be defined as a class method.)"
msgstr ""

#: ../../../library/abc.rst:62
msgid ""
"Check whether *subclass* is considered a subclass of this ABC.  This means "
"that you can customize the behavior of ``issubclass`` further without the "
"need to call :meth:`register` on every class you want to consider a subclass "
"of the ABC.  (This class method is called from the :meth:`__subclasscheck__` "
"method of the ABC.)"
msgstr ""

#: ../../../library/abc.rst:68
msgid ""
"This method should return ``True``, ``False`` or ``NotImplemented``.  If it "
"returns ``True``, the *subclass* is considered a subclass of this ABC. If it "
"returns ``False``, the *subclass* is not considered a subclass of this ABC, "
"even if it would normally be one.  If it returns ``NotImplemented``, the "
"subclass check is continued with the usual mechanism."
msgstr ""

#: ../../../library/abc.rst:78
msgid ""
"For a demonstration of these concepts, look at this example ABC definition::"
msgstr ""

#: ../../../library/abc.rst:80
msgid ""
"class Foo(object):\n"
"    def __getitem__(self, index):\n"
"        ...\n"
"    def __len__(self):\n"
"        ...\n"
"    def get_iterator(self):\n"
"        return iter(self)\n"
"\n"
"class MyIterable:\n"
"    __metaclass__ = ABCMeta\n"
"\n"
"    @abstractmethod\n"
"    def __iter__(self):\n"
"        while False:\n"
"            yield None\n"
"\n"
"    def get_iterator(self):\n"
"        return self.__iter__()\n"
"\n"
"    @classmethod\n"
"    def __subclasshook__(cls, C):\n"
"        if cls is MyIterable:\n"
"            if any(\"__iter__\" in B.__dict__ for B in C.__mro__):\n"
"                return True\n"
"        return NotImplemented\n"
"\n"
"MyIterable.register(Foo)"
msgstr ""

#: ../../../library/abc.rst:108
msgid ""
"The ABC ``MyIterable`` defines the standard iterable method, :meth:"
"`__iter__`, as an abstract method.  The implementation given here can still "
"be called from subclasses.  The :meth:`get_iterator` method is also part of "
"the ``MyIterable`` abstract base class, but it does not have to be "
"overridden in non-abstract derived classes."
msgstr ""

#: ../../../library/abc.rst:114
msgid ""
"The :meth:`__subclasshook__` class method defined here says that any class "
"that has an :meth:`__iter__` method in its :attr:`__dict__` (or in that of "
"one of its base classes, accessed via the :attr:`__mro__` list) is "
"considered a ``MyIterable`` too."
msgstr ""

#: ../../../library/abc.rst:119
msgid ""
"Finally, the last line makes ``Foo`` a virtual subclass of ``MyIterable``, "
"even though it does not define an :meth:`__iter__` method (it uses the old-"
"style iterable protocol, defined in terms of :meth:`__len__` and :meth:"
"`__getitem__`).  Note that this will not make ``get_iterator`` available as "
"a method of ``Foo``, so it is provided separately."
msgstr ""

#: ../../../library/abc.rst:126
msgid "It also provides the following decorators:"
msgstr ""

#: ../../../library/abc.rst:130
msgid "A decorator indicating abstract methods."
msgstr ""

#: ../../../library/abc.rst:132
msgid ""
"Using this decorator requires that the class's metaclass is :class:`ABCMeta` "
"or is derived from it. A class that has a metaclass derived from :class:"
"`ABCMeta` cannot be instantiated unless all of its abstract methods and "
"properties are overridden. The abstract methods can be called using any of "
"the normal 'super' call mechanisms."
msgstr ""

#: ../../../library/abc.rst:140
msgid ""
"Dynamically adding abstract methods to a class, or attempting to modify the "
"abstraction status of a method or class once it is created, are not "
"supported.  The :func:`abstractmethod` only affects subclasses derived using "
"regular inheritance; \"virtual subclasses\" registered with the ABC's :meth:"
"`register` method are not affected."
msgstr ""

#: ../../../library/abc.rst:146 ../../../library/abc.rst:175
msgid "Usage::"
msgstr ""

#: ../../../library/abc.rst:148
msgid ""
"class C:\n"
"    __metaclass__ = ABCMeta\n"
"    @abstractmethod\n"
"    def my_abstract_method(self, ...):\n"
"        ..."
msgstr ""

#: ../../../library/abc.rst:156
msgid ""
"Unlike Java abstract methods, these abstract methods may have an "
"implementation. This implementation can be called via the :func:`super` "
"mechanism from the class that overrides it.  This could be useful as an end-"
"point for a super-call in a framework that uses cooperative multiple-"
"inheritance."
msgstr ""

#: ../../../library/abc.rst:166
msgid ""
"A subclass of the built-in :func:`property`, indicating an abstract property."
msgstr ""

#: ../../../library/abc.rst:168
msgid ""
"Using this function requires that the class's metaclass is :class:`ABCMeta` "
"or is derived from it. A class that has a metaclass derived from :class:"
"`ABCMeta` cannot be instantiated unless all of its abstract methods and "
"properties are overridden. The abstract properties can be called using any "
"of the normal 'super' call mechanisms."
msgstr ""

#: ../../../library/abc.rst:177
msgid ""
"class C:\n"
"    __metaclass__ = ABCMeta\n"
"    @abstractproperty\n"
"    def my_abstract_property(self):\n"
"        ..."
msgstr ""

#: ../../../library/abc.rst:183
msgid ""
"This defines a read-only property; you can also define a read-write abstract "
"property using the 'long' form of property declaration::"
msgstr ""

#: ../../../library/abc.rst:186
msgid ""
"class C:\n"
"    __metaclass__ = ABCMeta\n"
"    def getx(self): ...\n"
"    def setx(self, value): ...\n"
"    x = abstractproperty(getx, setx)"
msgstr ""

#: ../../../library/abc.rst:194
msgid "Footnotes"
msgstr ""

#: ../../../library/abc.rst:195
msgid ""
"C++ programmers should note that Python's virtual base class concept is not "
"the same as C++'s."
msgstr ""

# SOME DESCRIPTIVE TITLE.
# Copyright (C) 1990-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 2.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-10 15:09+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../library/re.rst:3
msgid ":mod:`re` --- Regular expression operations"
msgstr ""

#: ../../../library/re.rst:11
msgid ""
"This module provides regular expression matching operations similar to those "
"found in Perl. Both patterns and strings to be searched can be Unicode "
"strings as well as 8-bit strings."
msgstr ""

#: ../../../library/re.rst:15
msgid ""
"Regular expressions use the backslash character (``'\\'``) to indicate "
"special forms or to allow special characters to be used without invoking "
"their special meaning.  This collides with Python's usage of the same "
"character for the same purpose in string literals; for example, to match a "
"literal backslash, one might have to write ``'\\\\\\\\'`` as the pattern "
"string, because the regular expression must be ``\\\\``, and each backslash "
"must be expressed as ``\\\\`` inside a regular Python string literal."
msgstr ""

#: ../../../library/re.rst:24
msgid ""
"The solution is to use Python's raw string notation for regular expression "
"patterns; backslashes are not handled in any special way in a string literal "
"prefixed with ``'r'``.  So ``r\"\\n\"`` is a two-character string containing "
"``'\\'`` and ``'n'``, while ``\"\\n\"`` is a one-character string containing "
"a newline.  Usually patterns will be expressed in Python code using this raw "
"string notation."
msgstr ""

#: ../../../library/re.rst:31
msgid ""
"It is important to note that most regular expression operations are "
"available as module-level functions and :class:`RegexObject` methods.  The "
"functions are shortcuts that don't require you to compile a regex object "
"first, but miss some fine-tuning parameters."
msgstr ""

#: ../../../library/re.rst:40
msgid "Mastering Regular Expressions"
msgstr ""

#: ../../../library/re.rst:39
msgid ""
"Book on regular expressions by Jeffrey Friedl, published by O'Reilly.  The "
"second edition of the book no longer covers Python at all, but the first "
"edition covered writing good regular expression patterns in great detail."
msgstr ""

#: ../../../library/re.rst:47
msgid "Regular Expression Syntax"
msgstr ""

#: ../../../library/re.rst:49
msgid ""
"A regular expression (or RE) specifies a set of strings that matches it; the "
"functions in this module let you check if a particular string matches a "
"given regular expression (or if a given regular expression matches a "
"particular string, which comes down to the same thing)."
msgstr ""

#: ../../../library/re.rst:54
msgid ""
"Regular expressions can be concatenated to form new regular expressions; if "
"*A* and *B* are both regular expressions, then *AB* is also a regular "
"expression. In general, if a string *p* matches *A* and another string *q* "
"matches *B*, the string *pq* will match AB.  This holds unless *A* or *B* "
"contain low precedence operations; boundary conditions between *A* and *B*; "
"or have numbered group references.  Thus, complex expressions can easily be "
"constructed from simpler primitive expressions like the ones described "
"here.  For details of the theory and implementation of regular expressions, "
"consult the Friedl book referenced above, or almost any textbook about "
"compiler construction."
msgstr ""

#: ../../../library/re.rst:64
msgid ""
"A brief explanation of the format of regular expressions follows.  For "
"further information and a gentler presentation, consult the :ref:`regex-"
"howto`."
msgstr ""

#: ../../../library/re.rst:67
msgid ""
"Regular expressions can contain both special and ordinary characters. Most "
"ordinary characters, like ``'A'``, ``'a'``, or ``'0'``, are the simplest "
"regular expressions; they simply match themselves.  You can concatenate "
"ordinary characters, so ``last`` matches the string ``'last'``.  (In the "
"rest of this section, we'll write RE's in ``this special style``, usually "
"without quotes, and strings to be matched ``'in single quotes'``.)"
msgstr ""

#: ../../../library/re.rst:74
msgid ""
"Some characters, like ``'|'`` or ``'('``, are special. Special characters "
"either stand for classes of ordinary characters, or affect how the regular "
"expressions around them are interpreted. Regular expression pattern strings "
"may not contain null bytes, but can specify the null byte using the "
"``\\number`` notation, e.g., ``'\\x00'``."
msgstr ""

#: ../../../library/re.rst:81
msgid "The special characters are:"
msgstr ""

#: ../../../library/re.rst:86
msgid "``'.'``"
msgstr ""

#: ../../../library/re.rst:84
msgid ""
"(Dot.)  In the default mode, this matches any character except a newline.  "
"If the :const:`DOTALL` flag has been specified, this matches any character "
"including a newline."
msgstr ""

#: ../../../library/re.rst:90
msgid "``'^'``"
msgstr ""

#: ../../../library/re.rst:89
msgid ""
"(Caret.)  Matches the start of the string, and in :const:`MULTILINE` mode "
"also matches immediately after each newline."
msgstr ""

#: ../../../library/re.rst:99
msgid "``'$'``"
msgstr ""

#: ../../../library/re.rst:93
msgid ""
"Matches the end of the string or just before the newline at the end of the "
"string, and in :const:`MULTILINE` mode also matches before a newline.  "
"``foo`` matches both 'foo' and 'foobar', while the regular expression "
"``foo$`` matches only 'foo'.  More interestingly, searching for ``foo.$`` in "
"``'foo1\\nfoo2\\n'`` matches 'foo2' normally, but 'foo1' in :const:"
"`MULTILINE` mode; searching for a single ``$`` in ``'foo\\n'`` will find two "
"(empty) matches: one just before the newline, and one at the end of the "
"string."
msgstr ""

#: ../../../library/re.rst:104
msgid "``'*'``"
msgstr ""

#: ../../../library/re.rst:102
msgid ""
"Causes the resulting RE to match 0 or more repetitions of the preceding RE, "
"as many repetitions as are possible.  ``ab*`` will match 'a', 'ab', or 'a' "
"followed by any number of 'b's."
msgstr ""

#: ../../../library/re.rst:109
msgid "``'+'``"
msgstr ""

#: ../../../library/re.rst:107
msgid ""
"Causes the resulting RE to match 1 or more repetitions of the preceding RE. "
"``ab+`` will match 'a' followed by any non-zero number of 'b's; it will not "
"match just 'a'."
msgstr ""

#: ../../../library/re.rst:113
msgid "``'?'``"
msgstr ""

#: ../../../library/re.rst:112
msgid ""
"Causes the resulting RE to match 0 or 1 repetitions of the preceding RE. "
"``ab?`` will match either 'a' or 'ab'."
msgstr ""

#: ../../../library/re.rst:122
msgid "``*?``, ``+?``, ``??``"
msgstr ""

#: ../../../library/re.rst:116
msgid ""
"The ``'*'``, ``'+'``, and ``'?'`` qualifiers are all :dfn:`greedy`; they "
"match as much text as possible.  Sometimes this behaviour isn't desired; if "
"the RE ``<.*>`` is matched against ``'<H1>title</H1>'``, it will match the "
"entire string, and not just ``'<H1>'``.  Adding ``'?'`` after the qualifier "
"makes it perform the match in :dfn:`non-greedy` or :dfn:`minimal` fashion; "
"as *few* characters as possible will be matched.  Using ``.*?`` in the "
"previous expression will match only ``'<H1>'``."
msgstr ""

#: ../../../library/re.rst:127
msgid "``{m}``"
msgstr ""

#: ../../../library/re.rst:125
msgid ""
"Specifies that exactly *m* copies of the previous RE should be matched; "
"fewer matches cause the entire RE not to match.  For example, ``a{6}`` will "
"match exactly six ``'a'`` characters, but not five."
msgstr ""

#: ../../../library/re.rst:136
msgid "``{m,n}``"
msgstr ""

#: ../../../library/re.rst:130
msgid ""
"Causes the resulting RE to match from *m* to *n* repetitions of the "
"preceding RE, attempting to match as many repetitions as possible.  For "
"example, ``a{3,5}`` will match from 3 to 5 ``'a'`` characters.  Omitting *m* "
"specifies a lower bound of zero,  and omitting *n* specifies an infinite "
"upper bound.  As an example, ``a{4,}b`` will match ``aaaab`` or a thousand "
"``'a'`` characters followed by a ``b``, but not ``aaab``. The comma may not "
"be omitted or the modifier would be confused with the previously described "
"form."
msgstr ""

#: ../../../library/re.rst:143
msgid "``{m,n}?``"
msgstr ""

#: ../../../library/re.rst:139
msgid ""
"Causes the resulting RE to match from *m* to *n* repetitions of the "
"preceding RE, attempting to match as *few* repetitions as possible.  This is "
"the non-greedy version of the previous qualifier.  For example, on the 6-"
"character string ``'aaaaaa'``, ``a{3,5}`` will match 5 ``'a'`` characters, "
"while ``a{3,5}?`` will only match 3 characters."
msgstr ""

#: ../../../library/re.rst:156
msgid "``'\\'``"
msgstr ""

#: ../../../library/re.rst:146
msgid ""
"Either escapes special characters (permitting you to match characters like "
"``'*'``, ``'?'``, and so forth), or signals a special sequence; special "
"sequences are discussed below."
msgstr ""

#: ../../../library/re.rst:150
msgid ""
"If you're not using a raw string to express the pattern, remember that "
"Python also uses the backslash as an escape sequence in string literals; if "
"the escape sequence isn't recognized by Python's parser, the backslash and "
"subsequent character are included in the resulting string.  However, if "
"Python would recognize the resulting sequence, the backslash should be "
"repeated twice.  This is complicated and hard to understand, so it's highly "
"recommended that you use raw strings for all but the simplest expressions."
msgstr ""

#: ../../../library/re.rst:182
msgid "``[]``"
msgstr ""

#: ../../../library/re.rst:159
msgid ""
"Used to indicate a set of characters.  Characters can be listed "
"individually, or a range of characters can be indicated by giving two "
"characters and separating them by a ``'-'``.  Special characters are not "
"active inside sets.  For example, ``[akm$]`` will match any of the "
"characters ``'a'``, ``'k'``, ``'m'``, or ``'$'``; ``[a-z]`` will match any "
"lowercase letter, and ``[a-zA-Z0-9]`` matches any letter or digit.  "
"Character classes such as ``\\w`` or ``\\S`` (defined below) are also "
"acceptable inside a range, although the characters they match depends on "
"whether :const:`LOCALE` or  :const:`UNICODE` mode is in force.  If you want "
"to include a ``']'`` or a ``'-'`` inside a set, precede it with a backslash, "
"or place it as the first character.  The pattern ``[]]`` will match ``']'``, "
"for example."
msgstr ""

#: ../../../library/re.rst:172
msgid ""
"You can match the characters not within a range by :dfn:`complementing` the "
"set. This is indicated by including a ``'^'`` as the first character of the "
"set; ``'^'`` elsewhere will simply match the ``'^'`` character.  For "
"example, ``[^5]`` will match any character except ``'5'``, and ``[^^]`` will "
"match any character except ``'^'``."
msgstr ""

#: ../../../library/re.rst:178
msgid ""
"Note that inside ``[]`` the special forms and special characters lose their "
"meanings and only the syntaxes described here are valid. For example, ``+``, "
"``*``, ``(``, ``)``, and so on are treated as literals inside ``[]``, and "
"backreferences cannot be used inside ``[]``."
msgstr ""

#: ../../../library/re.rst:193
msgid "``'|'``"
msgstr ""

#: ../../../library/re.rst:185
msgid ""
"``A|B``, where A and B can be arbitrary REs, creates a regular expression "
"that will match either A or B.  An arbitrary number of REs can be separated "
"by the ``'|'`` in this way.  This can be used inside groups (see below) as "
"well.  As the target string is scanned, REs separated by ``'|'`` are tried "
"from left to right. When one pattern completely matches, that branch is "
"accepted. This means that once ``A`` matches, ``B`` will not be tested "
"further, even if it would produce a longer overall match.  In other words, "
"the ``'|'`` operator is never greedy.  To match a literal ``'|'``, use ``\\|"
"``, or enclose it inside a character class, as in ``[|]``."
msgstr ""

#: ../../../library/re.rst:200
msgid "``(...)``"
msgstr ""

#: ../../../library/re.rst:196
msgid ""
"Matches whatever regular expression is inside the parentheses, and indicates "
"the start and end of a group; the contents of a group can be retrieved after "
"a match has been performed, and can be matched later in the string with the "
"``\\number`` special sequence, described below.  To match the literals "
"``'('`` or ``')'``, use ``\\(`` or ``\\)``, or enclose them inside a "
"character class: ``[(] [)]``."
msgstr ""

#: ../../../library/re.rst:207
msgid "``(?...)``"
msgstr ""

#: ../../../library/re.rst:203
msgid ""
"This is an extension notation (a ``'?'`` following a ``'('`` is not "
"meaningful otherwise).  The first character after the ``'?'`` determines "
"what the meaning and further syntax of the construct is. Extensions usually "
"do not create a new group; ``(?P<name>...)`` is the only exception to this "
"rule. Following are the currently supported extensions."
msgstr ""

#: ../../../library/re.rst:224
msgid "``(?iLmsux)``"
msgstr ""

#: ../../../library/re.rst:210
msgid ""
"(One or more letters from the set ``'i'``, ``'L'``, ``'m'``, ``'s'``, "
"``'u'``, ``'x'``.)  The group matches the empty string; the letters set the "
"corresponding flags: :const:`re.I` (ignore case), :const:`re.L` (locale "
"dependent), :const:`re.M` (multi-line), :const:`re.S` (dot matches all), :"
"const:`re.U` (Unicode dependent), and :const:`re.X` (verbose), for the "
"entire regular expression. (The flags are described in :ref:`contents-of-"
"module-re`.) This is useful if you wish to include the flags as part of the "
"regular expression, instead of passing a *flag* argument to the :func:`re."
"compile` function."
msgstr ""

#: ../../../library/re.rst:221
msgid ""
"Note that the ``(?x)`` flag changes how the expression is parsed. It should "
"be used first in the expression string, or after one or more whitespace "
"characters. If there are non-whitespace characters before the flag, the "
"results are undefined."
msgstr ""

#: ../../../library/re.rst:230
msgid "``(?:...)``"
msgstr ""

#: ../../../library/re.rst:227
msgid ""
"A non-grouping version of regular parentheses. Matches whatever regular "
"expression is inside the parentheses, but the substring matched by the group "
"*cannot* be retrieved after performing a match or referenced later in the "
"pattern."
msgstr ""

#: ../../../library/re.rst:245
msgid "``(?P<name>...)``"
msgstr ""

#: ../../../library/re.rst:233
msgid ""
"Similar to regular parentheses, but the substring matched by the group is "
"accessible within the rest of the regular expression via the symbolic group "
"name *name*.  Group names must be valid Python identifiers, and each group "
"name must be defined only once within a regular expression.  A symbolic "
"group is also a numbered group, just as if the group were not named.  So the "
"group named ``id`` in the example below can also be referenced as the "
"numbered group ``1``."
msgstr ""

#: ../../../library/re.rst:241
msgid ""
"For example, if the pattern is ``(?P<id>[a-zA-Z_]\\w*)``, the group can be "
"referenced by its name in arguments to methods of match objects, such as ``m."
"group('id')`` or ``m.end('id')``, and also by name in the regular expression "
"itself (using ``(?P=id)``) and replacement text given to ``.sub()`` (using "
"``\\g<id>``)."
msgstr ""

#: ../../../library/re.rst:248
msgid "``(?P=name)``"
msgstr ""

#: ../../../library/re.rst:248
msgid "Matches whatever text was matched by the earlier group named *name*."
msgstr ""

#: ../../../library/re.rst:251
msgid "``(?#...)``"
msgstr ""

#: ../../../library/re.rst:251
msgid "A comment; the contents of the parentheses are simply ignored."
msgstr ""

#: ../../../library/re.rst:256
msgid "``(?=...)``"
msgstr ""

#: ../../../library/re.rst:254
msgid ""
"Matches if ``...`` matches next, but doesn't consume any of the string.  "
"This is called a lookahead assertion.  For example, ``Isaac (?=Asimov)`` "
"will match ``'Isaac '`` only if it's followed by ``'Asimov'``."
msgstr ""

#: ../../../library/re.rst:261
msgid "``(?!...)``"
msgstr ""

#: ../../../library/re.rst:259
msgid ""
"Matches if ``...`` doesn't match next.  This is a negative lookahead "
"assertion. For example, ``Isaac (?!Asimov)`` will match ``'Isaac '`` only if "
"it's *not* followed by ``'Asimov'``."
msgstr ""

#: ../../../library/re.rst:283
msgid "``(?<=...)``"
msgstr ""

#: ../../../library/re.rst:264
msgid ""
"Matches if the current position in the string is preceded by a match for "
"``...`` that ends at the current position.  This is called a :dfn:`positive "
"lookbehind assertion`. ``(?<=abc)def`` will find a match in ``abcdef``, "
"since the lookbehind will back up 3 characters and check if the contained "
"pattern matches. The contained pattern must only match strings of some fixed "
"length, meaning that ``abc`` or ``a|b`` are allowed, but ``a*`` and ``a{3,4}"
"`` are not.  Note that patterns which start with positive lookbehind "
"assertions will never match at the beginning of the string being searched; "
"you will most likely want to use the :func:`search` function rather than "
"the :func:`match` function:"
msgstr ""

#: ../../../library/re.rst:279
msgid "This example looks for a word following a hyphen:"
msgstr ""

#: ../../../library/re.rst:290
msgid "``(?<!...)``"
msgstr ""

#: ../../../library/re.rst:286
msgid ""
"Matches if the current position in the string is not preceded by a match for "
"``...``.  This is called a :dfn:`negative lookbehind assertion`.  Similar to "
"positive lookbehind assertions, the contained pattern must only match "
"strings of some fixed length.  Patterns which start with negative lookbehind "
"assertions may match at the beginning of the string being searched."
msgstr ""

#: ../../../library/re.rst:299
msgid "``(?(id/name)yes-pattern|no-pattern)``"
msgstr ""

#: ../../../library/re.rst:293
msgid ""
"Will try to match with ``yes-pattern`` if the group with given *id* or "
"*name* exists, and with ``no-pattern`` if it doesn't. ``no-pattern`` is "
"optional and can be omitted. For example,  ``(<)?(\\w+@\\w+(?:\\.\\w+)+)(?"
"(1)>)`` is a poor email matching pattern, which will match with "
"``'<user@host.com>'`` as well as ``'user@host.com'``, but not with "
"``'<user@host.com'``."
msgstr ""

#: ../../../library/re.rst:301
msgid ""
"The special sequences consist of ``'\\'`` and a character from the list "
"below. If the ordinary character is not on the list, then the resulting RE "
"will match the second character.  For example, ``\\$`` matches the character "
"``'$'``."
msgstr ""

#: ../../../library/re.rst:313
msgid "``\\number``"
msgstr ""

#: ../../../library/re.rst:306
msgid ""
"Matches the contents of the group of the same number.  Groups are numbered "
"starting from 1.  For example, ``(.+) \\1`` matches ``'the the'`` or ``'55 "
"55'``, but not ``'the end'`` (note the space after the group).  This special "
"sequence can only be used to match one of the first 99 groups.  If the first "
"digit of *number* is 0, or *number* is 3 octal digits long, it will not be "
"interpreted as a group match, but as the character with octal value "
"*number*. Inside the ``'['`` and ``']'`` of a character class, all numeric "
"escapes are treated as characters."
msgstr ""

#: ../../../library/re.rst:316
msgid "``\\A``"
msgstr ""

#: ../../../library/re.rst:316
msgid "Matches only at the start of the string."
msgstr ""

#: ../../../library/re.rst:325
msgid "``\\b``"
msgstr ""

#: ../../../library/re.rst:319
msgid ""
"Matches the empty string, but only at the beginning or end of a word.  A "
"word is defined as a sequence of alphanumeric or underscore characters, so "
"the end of a word is indicated by whitespace or a non-alphanumeric, non-"
"underscore character. Note that  ``\\b`` is defined as the boundary between "
"``\\w`` and ``\\W``, so the precise set of characters deemed to be "
"alphanumeric depends on the values of the ``UNICODE`` and ``LOCALE`` flags.  "
"Inside a character range, ``\\b`` represents the backspace character, for "
"compatibility with Python's string literals."
msgstr ""

#: ../../../library/re.rst:330
msgid "``\\B``"
msgstr ""

#: ../../../library/re.rst:328
msgid ""
"Matches the empty string, but only when it is *not* at the beginning or end "
"of a word.  This is just the opposite of ``\\b``, so is also subject to the "
"settings of ``LOCALE`` and ``UNICODE``."
msgstr ""

#: ../../../library/re.rst:335
msgid "``\\d``"
msgstr ""

#: ../../../library/re.rst:333
msgid ""
"When the :const:`UNICODE` flag is not specified, matches any decimal digit; "
"this is equivalent to the set ``[0-9]``.  With :const:`UNICODE`, it will "
"match whatever is classified as a digit in the Unicode character properties "
"database."
msgstr ""

#: ../../../library/re.rst:341
msgid "``\\D``"
msgstr ""

#: ../../../library/re.rst:338
msgid ""
"When the :const:`UNICODE` flag is not specified, matches any non-digit "
"character; this is equivalent to the set  ``[^0-9]``.  With :const:"
"`UNICODE`, it will match  anything other than character marked as digits in "
"the Unicode character  properties database."
msgstr ""

#: ../../../library/re.rst:349
msgid "``\\s``"
msgstr ""

#: ../../../library/re.rst:344
msgid ""
"When the :const:`LOCALE` and :const:`UNICODE` flags are not specified, "
"matches any whitespace character; this is equivalent to the set "
"``[ \\t\\n\\r\\f\\v]``. With :const:`LOCALE`, it will match this set plus "
"whatever characters are defined as space for the current locale. If :const:"
"`UNICODE` is set, this will match the characters ``[ \\t\\n\\r\\f\\v]`` plus "
"whatever is classified as space in the Unicode character properties database."
msgstr ""

#: ../../../library/re.rst:357
msgid "``\\S``"
msgstr ""

#: ../../../library/re.rst:352
msgid ""
"When the :const:`LOCALE` and :const:`UNICODE` flags are not specified, "
"matches any non-whitespace character; this is equivalent to the set ``[^ "
"\\t\\n\\r\\f\\v]`` With :const:`LOCALE`, it will match any character not in "
"this set, and not defined as space in the current locale. If :const:"
"`UNICODE` is set, this will match anything other than ``[ \\t\\n\\r\\f\\v]`` "
"and characters marked as space in the Unicode character properties database."
msgstr ""

#: ../../../library/re.rst:365
msgid "``\\w``"
msgstr ""

#: ../../../library/re.rst:360
msgid ""
"When the :const:`LOCALE` and :const:`UNICODE` flags are not specified, "
"matches any alphanumeric character and the underscore; this is equivalent to "
"the set ``[a-zA-Z0-9_]``.  With :const:`LOCALE`, it will match the set "
"``[0-9_]`` plus whatever characters are defined as alphanumeric for the "
"current locale.  If :const:`UNICODE` is set, this will match the characters "
"``[0-9_]`` plus whatever is classified as alphanumeric in the Unicode "
"character properties database."
msgstr ""

#: ../../../library/re.rst:373
msgid "``\\W``"
msgstr ""

#: ../../../library/re.rst:368
msgid ""
"When the :const:`LOCALE` and :const:`UNICODE` flags are not specified, "
"matches any non-alphanumeric character; this is equivalent to the set ``[^a-"
"zA-Z0-9_]``. With :const:`LOCALE`, it will match any character not in the "
"set ``[0-9_]``, and not defined as alphanumeric for the current locale. If :"
"const:`UNICODE` is set, this will match anything other than ``[0-9_]`` and "
"characters marked as alphanumeric in the Unicode character properties "
"database."
msgstr ""

#: ../../../library/re.rst:376
msgid "``\\Z``"
msgstr ""

#: ../../../library/re.rst:376
msgid "Matches only at the end of the string."
msgstr ""

#: ../../../library/re.rst:378
msgid ""
"Most of the standard escapes supported by Python string literals are also "
"accepted by the regular expression parser::"
msgstr ""

#: ../../../library/re.rst:381
msgid ""
"\\a      \\b      \\f      \\n\n"
"\\r      \\t      \\v      \\x\n"
"\\\\"
msgstr ""

#: ../../../library/re.rst:385
msgid ""
"Octal escapes are included in a limited form: If the first digit is a 0, or "
"if there are three octal digits, it is considered an octal escape. "
"Otherwise, it is a group reference.  As for string literals, octal escapes "
"are always at most three digits in length."
msgstr ""

#: ../../../library/re.rst:394
msgid "Matching vs Searching"
msgstr ""

#: ../../../library/re.rst:399
msgid ""
"Python offers two different primitive operations based on regular "
"expressions: **match** checks for a match only at the beginning of the "
"string, while **search** checks for a match anywhere in the string (this is "
"what Perl does by default)."
msgstr ""

#: ../../../library/re.rst:404
msgid ""
"Note that match may differ from search even when using a regular expression "
"beginning with ``'^'``: ``'^'`` matches only at the start of the string, or "
"in :const:`MULTILINE` mode also immediately following a newline.  The "
"\"match\" operation succeeds only if the pattern matches at the start of the "
"string regardless of mode, or at the starting position given by the optional "
"*pos* argument regardless of whether a newline precedes it."
msgstr ""

#: ../../../library/re.rst:419
msgid "Module Contents"
msgstr ""

#: ../../../library/re.rst:421
msgid ""
"The module defines several functions, constants, and an exception. Some of "
"the functions are simplified versions of the full featured methods for "
"compiled regular expressions.  Most non-trivial applications always use the "
"compiled form."
msgstr ""

#: ../../../library/re.rst:429
msgid ""
"Compile a regular expression pattern into a regular expression object, which "
"can be used for matching using its :func:`match` and :func:`search` methods, "
"described below."
msgstr ""

#: ../../../library/re.rst:433
msgid ""
"The expression's behaviour can be modified by specifying a *flags* value. "
"Values can be any of the following variables, combined using bitwise OR (the "
"``|`` operator)."
msgstr ""

#: ../../../library/re.rst:437
msgid "The sequence ::"
msgstr ""

#: ../../../library/re.rst:439
msgid ""
"prog = re.compile(pattern)\n"
"result = prog.match(string)"
msgstr ""

#: ../../../library/re.rst:442
msgid "is equivalent to ::"
msgstr ""

#: ../../../library/re.rst:444
msgid "result = re.match(pattern, string)"
msgstr ""

#: ../../../library/re.rst:446
msgid ""
"but using :func:`re.compile` and saving the resulting regular expression "
"object for reuse is more efficient when the expression will be used several "
"times in a single program."
msgstr ""

#: ../../../library/re.rst:452
msgid ""
"The compiled versions of the most recent patterns passed to :func:`re."
"match`, :func:`re.search` or :func:`re.compile` are cached, so programs that "
"use only a few regular expressions at a time needn't worry about compiling "
"regular expressions."
msgstr ""

#: ../../../library/re.rst:461
msgid ""
"Perform case-insensitive matching; expressions like ``[A-Z]`` will match "
"lowercase letters, too.  This is not affected by the current locale."
msgstr ""

#: ../../../library/re.rst:468
msgid ""
"Make ``\\w``, ``\\W``, ``\\b``, ``\\B``, ``\\s`` and ``\\S`` dependent on "
"the current locale."
msgstr ""

#: ../../../library/re.rst:475
msgid ""
"When specified, the pattern character ``'^'`` matches at the beginning of "
"the string and at the beginning of each line (immediately following each "
"newline); and the pattern character ``'$'`` matches at the end of the string "
"and at the end of each line (immediately preceding each newline).  By "
"default, ``'^'`` matches only at the beginning of the string, and ``'$'`` "
"only at the end of the string and immediately before the newline (if any) at "
"the end of the string."
msgstr ""

#: ../../../library/re.rst:486
msgid ""
"Make the ``'.'`` special character match any character at all, including a "
"newline; without this flag, ``'.'`` will match anything *except* a newline."
msgstr ""

#: ../../../library/re.rst:493
msgid ""
"Make ``\\w``, ``\\W``, ``\\b``, ``\\B``, ``\\d``, ``\\D``, ``\\s`` and "
"``\\S`` dependent on the Unicode character properties database."
msgstr ""

#: ../../../library/re.rst:502
msgid ""
"This flag allows you to write regular expressions that look nicer. "
"Whitespace within the pattern is ignored, except when in a character class "
"or preceded by an unescaped backslash, and, when a line contains a ``'#'`` "
"neither in a character class or preceded by an unescaped backslash, all "
"characters from the leftmost such ``'#'`` through the end of the line are "
"ignored."
msgstr ""

#: ../../../library/re.rst:508
msgid ""
"That means that the two following regular expression objects that match a "
"decimal number are functionally equal::"
msgstr ""

#: ../../../library/re.rst:511
msgid ""
"a = re.compile(r\"\"\"\\d +  # the integral part\n"
"                   \\.    # the decimal point\n"
"                   \\d *  # some fractional digits\"\"\", re.X)\n"
"b = re.compile(r\"\\d+\\.\\d*\")"
msgstr ""

#: ../../../library/re.rst:519
msgid ""
"Scan through *string* looking for a location where the regular expression "
"*pattern* produces a match, and return a corresponding :class:`MatchObject` "
"instance. Return ``None`` if no position in the string matches the pattern; "
"note that this is different from finding a zero-length match at some point "
"in the string."
msgstr ""

#: ../../../library/re.rst:528
msgid ""
"If zero or more characters at the beginning of *string* match the regular "
"expression *pattern*, return a corresponding :class:`MatchObject` instance. "
"Return ``None`` if the string does not match the pattern; note that this is "
"different from a zero-length match."
msgstr ""

#: ../../../library/re.rst:535
msgid ""
"If you want to locate a match anywhere in *string*, use :func:`search` "
"instead."
msgstr ""

#: ../../../library/re.rst:541
msgid ""
"Split *string* by the occurrences of *pattern*.  If capturing parentheses "
"are used in *pattern*, then the text of all groups in the pattern are also "
"returned as part of the resulting list. If *maxsplit* is nonzero, at most "
"*maxsplit* splits occur, and the remainder of the string is returned as the "
"final element of the list.  (Incompatibility note: in the original Python "
"1.5 release, *maxsplit* was ignored.  This has been fixed in later releases.)"
msgstr ""

#: ../../../library/re.rst:555
msgid ""
"If there are capturing groups in the separator and it matches at the start "
"of the string, the result will start with an empty string.  The same holds "
"for the end of the string:"
msgstr ""

#: ../../../library/re.rst:562
msgid ""
"That way, separator components are always found at the same relative indices "
"within the result list (e.g., if there's one capturing group in the "
"separator, the 0th, the 2nd and so forth)."
msgstr ""

#: ../../../library/re.rst:566
msgid ""
"Note that *split* will never split a string on an empty pattern match. For "
"example:"
msgstr ""

#: ../../../library/re.rst:577
msgid ""
"Return all non-overlapping matches of *pattern* in *string*, as a list of "
"strings.  The *string* is scanned left-to-right, and matches are returned in "
"the order found.  If one or more groups are present in the pattern, return a "
"list of groups; this will be a list of tuples if the pattern has more than "
"one group.  Empty matches are included in the result unless they touch the "
"beginning of another match."
msgstr ""

#: ../../../library/re.rst:586 ../../../library/re.rst:600
msgid "Added the optional flags argument."
msgstr ""

#: ../../../library/re.rst:592
msgid ""
"Return an :term:`iterator` yielding :class:`MatchObject` instances over all "
"non-overlapping matches for the RE *pattern* in *string*.  The *string* is "
"scanned left-to-right, and matches are returned in the order found.  Empty "
"matches are included in the result unless they touch the beginning of "
"another match."
msgstr ""

#: ../../../library/re.rst:606
msgid ""
"Return the string obtained by replacing the leftmost non-overlapping "
"occurrences of *pattern* in *string* by the replacement *repl*.  If the "
"pattern isn't found, *string* is returned unchanged.  *repl* can be a string "
"or a function; if it is a string, any backslash escapes in it are "
"processed.  That is, ``\\n`` is converted to a single newline character, "
"``\\r`` is converted to a linefeed, and so forth.  Unknown escapes such as "
"``\\j`` are left alone.  Backreferences, such as ``\\6``, are replaced with "
"the substring matched by group 6 in the pattern. For example:"
msgstr ""

#: ../../../library/re.rst:620
msgid ""
"If *repl* is a function, it is called for every non-overlapping occurrence "
"of *pattern*.  The function takes a single match object argument, and "
"returns the replacement string.  For example:"
msgstr ""

#: ../../../library/re.rst:630
msgid ""
"The pattern may be a string or an RE object; if you need to specify regular "
"expression flags, you must use a RE object, or use embedded modifiers in a "
"pattern; for example, ``sub(\"(?i)b+\", \"x\", \"bbbb BBBB\")`` returns ``'x "
"x'``."
msgstr ""

#: ../../../library/re.rst:634
msgid ""
"The optional argument *count* is the maximum number of pattern occurrences "
"to be replaced; *count* must be a non-negative integer.  If omitted or zero, "
"all occurrences will be replaced. Empty matches for the pattern are replaced "
"only when not adjacent to a previous match, so ``sub('x*', '-', 'abc')`` "
"returns ``'-a-b-c-'``."
msgstr ""

#: ../../../library/re.rst:640
msgid ""
"In addition to character escapes and backreferences as described above, "
"``\\g<name>`` will use the substring matched by the group named ``name``, as "
"defined by the ``(?P<name>...)`` syntax. ``\\g<number>`` uses the "
"corresponding group number; ``\\g<2>`` is therefore equivalent to ``\\2``, "
"but isn't ambiguous in a replacement such as ``\\g<2>0``.  ``\\20`` would be "
"interpreted as a reference to group 20, not a reference to group 2 followed "
"by the literal character ``'0'``.  The backreference ``\\g<0>`` substitutes "
"in the entire substring matched by the RE."
msgstr ""

#: ../../../library/re.rst:652
msgid ""
"Perform the same operation as :func:`sub`, but return a tuple ``(new_string, "
"number_of_subs_made)``."
msgstr ""

#: ../../../library/re.rst:658
msgid ""
"Return *string* with all non-alphanumerics backslashed; this is useful if "
"you want to match an arbitrary literal string that may have regular "
"expression metacharacters in it."
msgstr ""

#: ../../../library/re.rst:665
msgid "Clear the regular expression cache."
msgstr ""

#: ../../../library/re.rst:670
msgid ""
"Exception raised when a string passed to one of the functions here is not a "
"valid regular expression (for example, it might contain unmatched "
"parentheses) or when some other error occurs during compilation or "
"matching.  It is never an error if a string contains no match for a pattern."
msgstr ""

#: ../../../library/re.rst:679
msgid "Regular Expression Objects"
msgstr ""

#: ../../../library/re.rst:683
msgid ""
"The :class:`RegexObject` class supports the following methods and attributes:"
msgstr ""

#: ../../../library/re.rst:687
msgid ""
"Scan through *string* looking for a location where this regular expression "
"produces a match, and return a corresponding :class:`MatchObject` instance. "
"Return ``None`` if no position in the string matches the pattern; note that "
"this is different from finding a zero-length match at some point in the "
"string."
msgstr ""

#: ../../../library/re.rst:692
msgid ""
"The optional second parameter *pos* gives an index in the string where the "
"search is to start; it defaults to ``0``.  This is not completely equivalent "
"to slicing the string; the ``'^'`` pattern character matches at the real "
"beginning of the string and at positions just after a newline, but not "
"necessarily at the index where the search is to start."
msgstr ""

#: ../../../library/re.rst:698
msgid ""
"The optional parameter *endpos* limits how far the string will be searched; "
"it will be as if the string is *endpos* characters long, so only the "
"characters from *pos* to ``endpos - 1`` will be searched for a match.  If "
"*endpos* is less than *pos*, no match will be found, otherwise, if *rx* is a "
"compiled regular expression object, ``rx.search(string, 0, 50)`` is "
"equivalent to ``rx.search(string[:50], 0)``."
msgstr ""

#: ../../../library/re.rst:713
msgid ""
"If zero or more characters at the *beginning* of *string* match this regular "
"expression, return a corresponding :class:`MatchObject` instance.  Return "
"``None`` if the string does not match the pattern; note that this is "
"different from a zero-length match."
msgstr ""

#: ../../../library/re.rst:718
msgid ""
"The optional *pos* and *endpos* parameters have the same meaning as for the :"
"meth:`~RegexObject.search` method."
msgstr ""

#: ../../../library/re.rst:723
msgid ""
"If you want to locate a match anywhere in *string*, use :meth:`~RegexObject."
"search` instead."
msgstr ""

#: ../../../library/re.rst:734
msgid "Identical to the :func:`split` function, using the compiled pattern."
msgstr ""

#: ../../../library/re.rst:739
msgid ""
"Similar to the :func:`findall` function, using the compiled pattern, but "
"also accepts optional *pos* and *endpos* parameters that limit the search "
"region like for :meth:`match`."
msgstr ""

#: ../../../library/re.rst:746
msgid ""
"Similar to the :func:`finditer` function, using the compiled pattern, but "
"also accepts optional *pos* and *endpos* parameters that limit the search "
"region like for :meth:`match`."
msgstr ""

#: ../../../library/re.rst:753
msgid "Identical to the :func:`sub` function, using the compiled pattern."
msgstr ""

#: ../../../library/re.rst:758
msgid "Identical to the :func:`subn` function, using the compiled pattern."
msgstr ""

#: ../../../library/re.rst:763
msgid ""
"The flags argument used when the RE object was compiled, or ``0`` if no "
"flags were provided."
msgstr ""

#: ../../../library/re.rst:769
msgid "The number of capturing groups in the pattern."
msgstr ""

#: ../../../library/re.rst:774
msgid ""
"A dictionary mapping any symbolic group names defined by ``(?P<id>)`` to "
"group numbers.  The dictionary is empty if no symbolic groups were used in "
"the pattern."
msgstr ""

#: ../../../library/re.rst:781
msgid "The pattern string from which the RE object was compiled."
msgstr ""

#: ../../../library/re.rst:787
msgid "Match Objects"
msgstr ""

#: ../../../library/re.rst:791
msgid ""
"Match Objects always have a boolean value of :const:`True`, so that you can "
"test whether e.g. :func:`match` resulted in a match with a simple if "
"statement.  They support the following methods and attributes:"
msgstr ""

#: ../../../library/re.rst:798
msgid ""
"Return the string obtained by doing backslash substitution on the template "
"string *template*, as done by the :meth:`~RegexObject.sub` method.  Escapes "
"such as ``\\n`` are converted to the appropriate characters, and numeric "
"backreferences (``\\1``, ``\\2``) and named backreferences (``\\g<1>``, "
"``\\g<name>``) are replaced by the contents of the corresponding group."
msgstr ""

#: ../../../library/re.rst:807
msgid ""
"Returns one or more subgroups of the match.  If there is a single argument, "
"the result is a single string; if there are multiple arguments, the result "
"is a tuple with one item per argument. Without arguments, *group1* defaults "
"to zero (the whole match is returned). If a *groupN* argument is zero, the "
"corresponding return value is the entire matching string; if it is in the "
"inclusive range [1..99], it is the string matching the corresponding "
"parenthesized group.  If a group number is negative or larger than the "
"number of groups defined in the pattern, an :exc:`IndexError` exception is "
"raised. If a group is contained in a part of the pattern that did not match, "
"the corresponding result is ``None``. If a group is contained in a part of "
"the pattern that matched multiple times, the last match is returned."
msgstr ""

#: ../../../library/re.rst:829
msgid ""
"If the regular expression uses the ``(?P<name>...)`` syntax, the *groupN* "
"arguments may also be strings identifying groups by their group name.  If a "
"string argument is not used as a group name in the pattern, an :exc:"
"`IndexError` exception is raised."
msgstr ""

#: ../../../library/re.rst:834
msgid "A moderately complicated example:"
msgstr ""

#: ../../../library/re.rst:842
msgid "Named groups can also be referred to by their index:"
msgstr ""

#: ../../../library/re.rst:849
msgid "If a group matches multiple times, only the last match is accessible:"
msgstr ""

#: ../../../library/re.rst:858
msgid ""
"Return a tuple containing all the subgroups of the match, from 1 up to "
"however many groups are in the pattern.  The *default* argument is used for "
"groups that did not participate in the match; it defaults to ``None``.  "
"(Incompatibility note: in the original Python 1.5 release, if the tuple was "
"one element long, a string would be returned instead.  In later versions "
"(from 1.5.1 on), a singleton tuple is returned in such cases.)"
msgstr ""

#: ../../../library/re.rst:865
msgid "For example:"
msgstr ""

#: ../../../library/re.rst:871
msgid ""
"If we make the decimal place and everything after it optional, not all "
"groups might participate in the match.  These groups will default to "
"``None`` unless the *default* argument is given:"
msgstr ""

#: ../../../library/re.rst:884
msgid ""
"Return a dictionary containing all the *named* subgroups of the match, keyed "
"by the subgroup name.  The *default* argument is used for groups that did "
"not participate in the match; it defaults to ``None``.  For example:"
msgstr ""

#: ../../../library/re.rst:896
msgid ""
"Return the indices of the start and end of the substring matched by *group*; "
"*group* defaults to zero (meaning the whole matched substring). Return "
"``-1`` if *group* exists but did not contribute to the match.  For a match "
"object *m*, and a group *g* that did contribute to the match, the substring "
"matched by group *g* (equivalent to ``m.group(g)``) is ::"
msgstr ""

#: ../../../library/re.rst:902
msgid "m.string[m.start(g):m.end(g)]"
msgstr ""

#: ../../../library/re.rst:904
msgid ""
"Note that ``m.start(group)`` will equal ``m.end(group)`` if *group* matched "
"a null string.  For example, after ``m = re.search('b(c?)', 'cba')``, ``m."
"start(0)`` is 1, ``m.end(0)`` is 2, ``m.start(1)`` and ``m.end(1)`` are both "
"2, and ``m.start(2)`` raises an :exc:`IndexError` exception."
msgstr ""

#: ../../../library/re.rst:909
msgid "An example that will remove *remove_this* from email addresses:"
msgstr ""

#: ../../../library/re.rst:919
msgid ""
"For :class:`MatchObject` *m*, return the 2-tuple ``(m.start(group), m."
"end(group))``. Note that if *group* did not contribute to the match, this is "
"``(-1, -1)``.  *group* defaults to zero, the entire match."
msgstr ""

#: ../../../library/re.rst:926
msgid ""
"The value of *pos* which was passed to the :meth:`~RegexObject.search` or :"
"meth:`~RegexObject.match` method of the :class:`RegexObject`.  This is the "
"index into the string at which the RE engine started looking for a match."
msgstr ""

#: ../../../library/re.rst:933
msgid ""
"The value of *endpos* which was passed to the :meth:`~RegexObject.search` "
"or :meth:`~RegexObject.match` method of the :class:`RegexObject`.  This is "
"the index into the string beyond which the RE engine will not go."
msgstr ""

#: ../../../library/re.rst:940
msgid ""
"The integer index of the last matched capturing group, or ``None`` if no "
"group was matched at all. For example, the expressions ``(a)b``, ``((a)"
"(b))``, and ``((ab))`` will have ``lastindex == 1`` if applied to the string "
"``'ab'``, while the expression ``(a)(b)`` will have ``lastindex == 2``, if "
"applied to the same string."
msgstr ""

#: ../../../library/re.rst:949
msgid ""
"The name of the last matched capturing group, or ``None`` if the group "
"didn't have a name, or if no group was matched at all."
msgstr ""

#: ../../../library/re.rst:955
msgid ""
"The regular expression object whose :meth:`~RegexObject.match` or :meth:"
"`~RegexObject.search` method produced this :class:`MatchObject` instance."
msgstr ""

#: ../../../library/re.rst:962
msgid ""
"The string passed to :meth:`~RegexObject.match` or :meth:`~RegexObject."
"search`."
msgstr ""

#: ../../../library/re.rst:967
msgid "Examples"
msgstr ""

#: ../../../library/re.rst:971
msgid "Checking For a Pair"
msgstr ""

#: ../../../library/re.rst:973
msgid ""
"In this example, we'll use the following helper function to display match "
"objects a little more gracefully:"
msgstr ""

#: ../../../library/re.rst:976
msgid ""
"def displaymatch(match):\n"
"    if match is None:\n"
"        return None\n"
"    return '<Match: %r, groups=%r>' % (match.group(), match.groups())"
msgstr ""

#: ../../../library/re.rst:983
msgid ""
"Suppose you are writing a poker program where a player's hand is represented "
"as a 5-character string with each character representing a card, \"a\" for "
"ace, \"k\" for king, \"q\" for queen, j for jack, \"0\" for 10, and \"1\" "
"through \"9\" representing the card with that value."
msgstr ""

#: ../../../library/re.rst:988
msgid "To see if a given string is a valid hand, one could do the following:"
msgstr ""

#: ../../../library/re.rst:998
msgid ""
"That last hand, ``\"727ak\"``, contained a pair, or two of the same valued "
"cards. To match this with a regular expression, one could use backreferences "
"as such:"
msgstr ""

#: ../../../library/re.rst:1008
msgid ""
"To find out what card the pair consists of, one could use the :meth:"
"`~MatchObject.group` method of :class:`MatchObject` in the following manner:"
msgstr ""

#: ../../../library/re.rst:1012
msgid ""
">>> pair.match(\"717ak\").group(1)\n"
"'7'\n"
"\n"
"# Error because re.match() returns None, which doesn't have a group() "
"method:\n"
">>> pair.match(\"718ak\").group(1)\n"
"Traceback (most recent call last):\n"
"  File \"<pyshell#23>\", line 1, in <module>\n"
"    re.match(r\".*(.).*\\1\", \"718ak\").group(1)\n"
"AttributeError: 'NoneType' object has no attribute 'group'\n"
"\n"
">>> pair.match(\"354aa\").group(1)\n"
"'a'"
msgstr ""

#: ../../../library/re.rst:1029
msgid "Simulating scanf()"
msgstr ""

#: ../../../library/re.rst:1033
msgid ""
"Python does not currently have an equivalent to :cfunc:`scanf`.  Regular "
"expressions are generally more powerful, though also more verbose, than :"
"cfunc:`scanf` format strings.  The table below offers some more-or-less "
"equivalent mappings between :cfunc:`scanf` format tokens and regular "
"expressions."
msgstr ""

#: ../../../library/re.rst:1040
msgid ":cfunc:`scanf` Token"
msgstr ""

#: ../../../library/re.rst:1040
msgid "Regular Expression"
msgstr ""

#: ../../../library/re.rst:1042
msgid "``%c``"
msgstr ""

#: ../../../library/re.rst:1042
msgid "``.``"
msgstr ""

#: ../../../library/re.rst:1044
msgid "``%5c``"
msgstr ""

#: ../../../library/re.rst:1044
msgid "``.{5}``"
msgstr ""

#: ../../../library/re.rst:1046
msgid "``%d``"
msgstr ""

#: ../../../library/re.rst:1046
msgid "``[-+]?\\d+``"
msgstr ""

#: ../../../library/re.rst:1048
msgid "``%e``, ``%E``, ``%f``, ``%g``"
msgstr ""

#: ../../../library/re.rst:1048
msgid "``[-+]?(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?``"
msgstr ""

#: ../../../library/re.rst:1050
msgid "``%i``"
msgstr ""

#: ../../../library/re.rst:1050
msgid "``[-+]?(0[xX][\\dA-Fa-f]+|0[0-7]*|\\d+)``"
msgstr ""

#: ../../../library/re.rst:1052
msgid "``%o``"
msgstr ""

#: ../../../library/re.rst:1052
msgid "``0[0-7]*``"
msgstr ""

#: ../../../library/re.rst:1054
msgid "``%s``"
msgstr ""

#: ../../../library/re.rst:1054
msgid "``\\S+``"
msgstr ""

#: ../../../library/re.rst:1056
msgid "``%u``"
msgstr ""

#: ../../../library/re.rst:1056
msgid "``\\d+``"
msgstr ""

#: ../../../library/re.rst:1058
msgid "``%x``, ``%X``"
msgstr ""

#: ../../../library/re.rst:1058
msgid "``0[xX][\\dA-Fa-f]+``"
msgstr ""

#: ../../../library/re.rst:1061
msgid "To extract the filename and numbers from a string like ::"
msgstr ""

#: ../../../library/re.rst:1063
msgid "/usr/sbin/sendmail - 0 errors, 4 warnings"
msgstr ""

#: ../../../library/re.rst:1065
msgid "you would use a :cfunc:`scanf` format like ::"
msgstr ""

#: ../../../library/re.rst:1067
msgid "%s - %d errors, %d warnings"
msgstr ""

#: ../../../library/re.rst:1069
msgid "The equivalent regular expression would be ::"
msgstr ""

#: ../../../library/re.rst:1071
msgid "(\\S+) - (\\d+) errors, (\\d+) warnings"
msgstr ""

#: ../../../library/re.rst:1075
msgid "Avoiding recursion"
msgstr ""

#: ../../../library/re.rst:1077
msgid ""
"If you create regular expressions that require the engine to perform a lot "
"of recursion, you may encounter a :exc:`RuntimeError` exception with the "
"message ``maximum recursion limit`` exceeded. For example, ::"
msgstr ""

#: ../../../library/re.rst:1081
msgid ""
">>> s = 'Begin ' + 1000*'a very long string ' + 'end'\n"
">>> re.match('Begin (\\w| )*? end', s).end()\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in ?\n"
"  File \"/usr/local/lib/python2.5/re.py\", line 132, in match\n"
"    return _compile(pattern, flags).match(string)\n"
"RuntimeError: maximum recursion limit exceeded"
msgstr ""

#: ../../../library/re.rst:1089
msgid "You can often restructure your regular expression to avoid recursion."
msgstr ""

#: ../../../library/re.rst:1091
msgid ""
"Starting with Python 2.3, simple uses of the ``*?`` pattern are special-"
"cased to avoid recursion.  Thus, the above regular expression can avoid "
"recursion by being recast as ``Begin [a-zA-Z0-9_ ]*?end``.  As a further "
"benefit, such regular expressions will run faster than their recursive "
"equivalents."
msgstr ""

#: ../../../library/re.rst:1098
msgid "search() vs. match()"
msgstr ""

#: ../../../library/re.rst:1100
msgid ""
"In a nutshell, :func:`match` only attempts to match a pattern at the "
"beginning of a string where :func:`search` will match a pattern anywhere in "
"a string. For example:"
msgstr ""

#: ../../../library/re.rst:1110
msgid ""
"The following applies only to regular expression objects like those created "
"with ``re.compile(\"pattern\")``, not the primitives ``re.match(pattern, "
"string)`` or ``re.search(pattern, string)``."
msgstr ""

#: ../../../library/re.rst:1114
msgid ""
":func:`match` has an optional second parameter that gives an index in the "
"string where the search is to start::"
msgstr ""

#: ../../../library/re.rst:1117
msgid ""
">>> pattern = re.compile(\"o\")\n"
">>> pattern.match(\"dog\")      # No match as \"o\" is not at the start of "
"\"dog.\"\n"
"\n"
"# Equivalent to the above expression as 0 is the default starting index:\n"
">>> pattern.match(\"dog\", 0)\n"
"\n"
"# Match as \"o\" is the 2nd character of \"dog\" (index 0 is the first):\n"
">>> pattern.match(\"dog\", 1)\n"
"<_sre.SRE_Match object at ...>\n"
">>> pattern.match(\"dog\", 2)   # No match as \"o\" is not the 3rd character "
"of \"dog.\""
msgstr ""

#: ../../../library/re.rst:1130
msgid "Making a Phonebook"
msgstr ""

#: ../../../library/re.rst:1132
msgid ""
":func:`split` splits a string into a list delimited by the passed pattern.  "
"The method is invaluable for converting textual data into data structures "
"that can be easily read and modified by Python as demonstrated in the "
"following example that creates a phonebook."
msgstr ""

#: ../../../library/re.rst:1137
msgid ""
"First, here is the input.  Normally it may come from a file, here we are "
"using triple-quoted string syntax:"
msgstr ""

#: ../../../library/re.rst:1148
msgid ""
"The entries are separated by one or more newlines. Now we convert the string "
"into a list with each nonempty line having its own entry:"
msgstr ""

#: ../../../library/re.rst:1151
msgid ""
">>> entries = re.split(\"\\n+\", input)\n"
">>> entries\n"
"['Ross McFluff: 834.345.1254 155 Elm Street',\n"
"'Ronald Heathmore: 892.345.3428 436 Finley Avenue',\n"
"'Frank Burger: 925.541.7625 662 South Dogwood Way',\n"
"'Heather Albrecht: 548.326.4584 919 Park Place']"
msgstr ""

#: ../../../library/re.rst:1161
msgid ""
"Finally, split each entry into a list with first name, last name, telephone "
"number, and address.  We use the ``maxsplit`` parameter of :func:`split` "
"because the address has spaces, our splitting pattern, in it:"
msgstr ""

#: ../../../library/re.rst:1165
msgid ""
">>> [re.split(\":? \", entry, 3) for entry in entries]\n"
"[['Ross', 'McFluff', '834.345.1254', '155 Elm Street'],\n"
"['Ronald', 'Heathmore', '892.345.3428', '436 Finley Avenue'],\n"
"['Frank', 'Burger', '925.541.7625', '662 South Dogwood Way'],\n"
"['Heather', 'Albrecht', '548.326.4584', '919 Park Place']]"
msgstr ""

#: ../../../library/re.rst:1174
msgid ""
"The ``:?`` pattern matches the colon after the last name, so that it does "
"not occur in the result list.  With a ``maxsplit`` of ``4``, we could "
"separate the house number from the street name:"
msgstr ""

#: ../../../library/re.rst:1178
msgid ""
">>> [re.split(\":? \", entry, 4) for entry in entries]\n"
"[['Ross', 'McFluff', '834.345.1254', '155', 'Elm Street'],\n"
"['Ronald', 'Heathmore', '892.345.3428', '436', 'Finley Avenue'],\n"
"['Frank', 'Burger', '925.541.7625', '662', 'South Dogwood Way'],\n"
"['Heather', 'Albrecht', '548.326.4584', '919', 'Park Place']]"
msgstr ""

#: ../../../library/re.rst:1189
msgid "Text Munging"
msgstr ""

#: ../../../library/re.rst:1191
msgid ""
":func:`sub` replaces every occurrence of a pattern with a string or the "
"result of a function.  This example demonstrates using :func:`sub` with a "
"function to \"munge\" text, or randomize the order of all the characters in "
"each word of a sentence except for the first and last characters::"
msgstr ""

#: ../../../library/re.rst:1196
msgid ""
">>> def repl(m):\n"
"...   inner_word = list(m.group(2))\n"
"...   random.shuffle(inner_word)\n"
"...   return m.group(1) + \"\".join(inner_word) + m.group(3)\n"
">>> text = \"Professor Abdolmalek, please report your absences promptly.\"\n"
">>> re.sub(r\"(\\w)(\\w+)(\\w)\", repl, text)\n"
"'Poefsrosr Aealmlobdk, pslaee reorpt your abnseces plmrptoy.'\n"
">>> re.sub(r\"(\\w)(\\w+)(\\w)\", repl, text)\n"
"'Pofsroser Aodlambelk, plasee reoprt yuor asnebces potlmrpy.'"
msgstr ""

#: ../../../library/re.rst:1208
msgid "Finding all Adverbs"
msgstr ""

#: ../../../library/re.rst:1210
msgid ""
":func:`findall` matches *all* occurrences of a pattern, not just the first "
"one as :func:`search` does.  For example, if one was a writer and wanted to "
"find all of the adverbs in some text, he or she might use :func:`findall` in "
"the following manner:"
msgstr ""

#: ../../../library/re.rst:1221
msgid "Finding all Adverbs and their Positions"
msgstr ""

#: ../../../library/re.rst:1223
msgid ""
"If one wants more information about all matches of a pattern than the "
"matched text, :func:`finditer` is useful as it provides instances of :class:"
"`MatchObject` instead of strings.  Continuing with the previous example, if "
"one was a writer who wanted to find all of the adverbs *and their positions* "
"in some text, he or she would use :func:`finditer` in the following manner:"
msgstr ""

#: ../../../library/re.rst:1237
msgid "Raw String Notation"
msgstr ""

#: ../../../library/re.rst:1239
msgid ""
"Raw string notation (``r\"text\"``) keeps regular expressions sane.  Without "
"it, every backslash (``'\\'``) in a regular expression would have to be "
"prefixed with another one to escape it.  For example, the two following "
"lines of code are functionally identical:"
msgstr ""

#: ../../../library/re.rst:1249
msgid ""
"When one wants to match a literal backslash, it must be escaped in the "
"regular expression.  With raw string notation, this means ``r\"\\\\\"``.  "
"Without raw string notation, one must use ``\"\\\\\\\\\"``, making the "
"following lines of code functionally identical:"
msgstr ""

#: ../../../library/re.rst:1031
msgid "scanf()"
msgstr ""

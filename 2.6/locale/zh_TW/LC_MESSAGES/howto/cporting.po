# SOME DESCRIPTIVE TITLE.
# Copyright (C) 1990-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 2.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-10 15:09+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../howto/cporting.rst:5
msgid "Porting Extension Modules to 3.0"
msgstr ""

#: ../../../howto/cporting.rst:0
msgid "author"
msgstr ""

#: ../../../howto/cporting.rst:7
msgid "Benjamin Peterson"
msgstr ""

#: ../../../howto/cporting.rst:None
msgid "Abstract"
msgstr ""

#: ../../../howto/cporting.rst:12
msgid ""
"Although changing the C-API was not one of Python 3.0's objectives, the many "
"Python level changes made leaving 2.x's API intact impossible.  In fact, "
"some changes such as :func:`int` and :func:`long` unification are more "
"obvious on the C level.  This document endeavors to document "
"incompatibilities and how they can be worked around."
msgstr ""

#: ../../../howto/cporting.rst:20
msgid "Conditional compilation"
msgstr ""

#: ../../../howto/cporting.rst:22
msgid ""
"The easiest way to compile only some code for 3.0 is to check if :cmacro:"
"`PY_MAJOR_VERSION` is greater than or equal to 3. ::"
msgstr ""

#: ../../../howto/cporting.rst:25
msgid ""
"#if PY_MAJOR_VERSION >= 3\n"
"#define IS_PY3K\n"
"#endif"
msgstr ""

#: ../../../howto/cporting.rst:29
msgid ""
"API functions that are not present can be aliased to their equivalents "
"within conditional blocks."
msgstr ""

#: ../../../howto/cporting.rst:34
msgid "Changes to Object APIs"
msgstr ""

#: ../../../howto/cporting.rst:36
msgid ""
"Python 3.0 merged together some types with similar functions while cleanly "
"separating others."
msgstr ""

#: ../../../howto/cporting.rst:41
msgid "str/unicode Unification"
msgstr ""

#: ../../../howto/cporting.rst:44
msgid ""
"Python 3.0's :func:`str` (``PyString_*`` functions in C) type is equivalent "
"to 2.x's :func:`unicode` (``PyUnicode_*``).  The old 8-bit string type has "
"become :func:`bytes`.  Python 2.6 and later provide a compatibility header, :"
"file:`bytesobject.h`, mapping ``PyBytes`` names to ``PyString`` ones.  For "
"best compatibility with 3.0, :ctype:`PyUnicode` should be used for textual "
"data and :ctype:`PyBytes` for binary data.  It's also important to remember "
"that :ctype:`PyBytes` and :ctype:`PyUnicode` in 3.0 are not interchangeable "
"like :ctype:`PyString` and :ctype:`PyString` are in 2.x.  The following "
"example shows best practices with regards to :ctype:`PyUnicode`, :ctype:"
"`PyString`, and :ctype:`PyBytes`. ::"
msgstr ""

#: ../../../howto/cporting.rst:55
msgid ""
"#include \"stdlib.h\"\n"
"#include \"Python.h\"\n"
"#include \"bytesobject.h\"\n"
"\n"
"/* text example */\n"
"static PyObject *\n"
"say_hello(PyObject *self, PyObject *args) {\n"
"    PyObject *name, *result;\n"
"\n"
"    if (!PyArg_ParseTuple(args, \"U:say_hello\", &name))\n"
"        return NULL;\n"
"\n"
"    result = PyUnicode_FromFormat(\"Hello, %S!\", name);\n"
"    return result;\n"
"}\n"
"\n"
"/* just a forward */\n"
"static char * do_encode(PyObject *);\n"
"\n"
"/* bytes example */\n"
"static PyObject *\n"
"encode_object(PyObject *self, PyObject *args) {\n"
"    char *encoded;\n"
"    PyObject *result, *myobj;\n"
"\n"
"    if (!PyArg_ParseTuple(args, \"O:encode_object\", &myobj))\n"
"        return NULL;\n"
"\n"
"    encoded = do_encode(myobj);\n"
"    if (encoded == NULL)\n"
"        return NULL;\n"
"    result = PyBytes_FromString(encoded);\n"
"    free(encoded);\n"
"    return result;\n"
"}"
msgstr ""

#: ../../../howto/cporting.rst:93
msgid "long/int Unification"
msgstr ""

#: ../../../howto/cporting.rst:95
msgid ""
"In Python 3.0, there is only one integer type.  It is called :func:`int` on "
"the Python level, but actually corresponds to 2.x's :func:`long` type.  In "
"the C-API, ``PyInt_*`` functions are replaced by their ``PyLong_*`` "
"neighbors.  The best course of action here is using the ``PyInt_*`` "
"functions aliased to ``PyLong_*`` found in :file:`intobject.h`.  The "
"abstract ``PyNumber_*`` APIs can also be used in some cases. ::"
msgstr ""

#: ../../../howto/cporting.rst:102
msgid ""
"#include \"Python.h\"\n"
"#include \"intobject.h\"\n"
"\n"
"static PyObject *\n"
"add_ints(PyObject *self, PyObject *args) {\n"
"    int one, two;\n"
"    PyObject *result;\n"
"\n"
"    if (!PyArg_ParseTuple(args, \"ii:add_ints\", &one, &two))\n"
"        return NULL;\n"
"\n"
"    return PyInt_FromLong(one + two);\n"
"}"
msgstr ""

#: ../../../howto/cporting.rst:119
msgid "Module initialization and state"
msgstr ""

#: ../../../howto/cporting.rst:121
msgid ""
"Python 3.0 has a revamped extension module initialization system.  (See :pep:"
"`3121`.)  Instead of storing module state in globals, they should be stored "
"in an interpreter specific structure.  Creating modules that act correctly "
"in both 2.x and 3.0 is tricky.  The following simple example demonstrates "
"how. ::"
msgstr ""

#: ../../../howto/cporting.rst:126
msgid ""
"#include \"Python.h\"\n"
"\n"
"struct module_state {\n"
"    PyObject *error;\n"
"};\n"
"\n"
"#if PY_MAJOR_VERSION >= 3\n"
"#define GETSTATE(m) ((struct module_state*)PyModule_GetState(m))\n"
"#else\n"
"#define GETSTATE(m) (&_state)\n"
"static struct module_state _state;\n"
"#endif\n"
"\n"
"static PyObject *\n"
"error_out(PyObject *m) {\n"
"    struct module_state *st = GETSTATE(m);\n"
"    PyErr_SetString(st->error, \"something bad happened\");\n"
"    return NULL;\n"
"}\n"
"\n"
"static PyMethodDef myextension_methods[] = {\n"
"    {\"error_out\", (PyCFunction)error_out, METH_NOARGS, NULL},\n"
"    {NULL, NULL}\n"
"};\n"
"\n"
"#if PY_MAJOR_VERSION >= 3\n"
"\n"
"static int myextension_traverse(PyObject *m, visitproc visit, void *arg) {\n"
"    Py_VISIT(GETSTATE(m)->error);\n"
"    return 0;\n"
"}\n"
"\n"
"static int myextension_clear(PyObject *m) {\n"
"    Py_CLEAR(GETSTATE(m)->error);\n"
"    return 0;\n"
"}\n"
"\n"
"\n"
"static struct PyModuleDef moduledef = {\n"
"        PyModuleDef_HEAD_INIT,\n"
"        \"myextension\",\n"
"        NULL,\n"
"        sizeof(struct module_state),\n"
"        myextension_methods,\n"
"        NULL,\n"
"        myextension_traverse,\n"
"        myextension_clear,\n"
"        NULL\n"
"};\n"
"\n"
"#define INITERROR return NULL\n"
"\n"
"PyObject *\n"
"PyInit_myextension(void)\n"
"\n"
"#else\n"
"#define INITERROR return\n"
"\n"
"void\n"
"initmyextension(void)\n"
"#endif\n"
"{\n"
"#if PY_MAJOR_VERSION >= 3\n"
"    PyObject *module = PyModule_Create(&moduledef);\n"
"#else\n"
"    PyObject *module = Py_InitModule(\"myextension\", myextension_methods);\n"
"#endif\n"
"\n"
"    if (module == NULL)\n"
"        INITERROR;\n"
"    struct module_state *st = GETSTATE(module);\n"
"\n"
"    st->error = PyErr_NewException(\"myextension.Error\", NULL, NULL);\n"
"    if (st->error == NULL) {\n"
"        Py_DECREF(module);\n"
"        INITERROR;\n"
"    }\n"
"\n"
"#if PY_MAJOR_VERSION >= 3\n"
"    return module;\n"
"#endif\n"
"}"
msgstr ""

#: ../../../howto/cporting.rst:211
msgid "Other options"
msgstr ""

#: ../../../howto/cporting.rst:213
msgid ""
"If you are writing a new extension module, you might consider `Cython "
"<http://www.cython.org>`_.  It translates a Python-like language to C.  The "
"extension modules it creates are compatible with Python 3.x and 2.x."
msgstr ""

# SOME DESCRIPTIVE TITLE.
# Copyright (C) 1990-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 2.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-10 15:09+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../library/timeit.rst:3
msgid ":mod:`timeit` --- Measure execution time of small code snippets"
msgstr ""

#: ../../../library/timeit.rst:15
msgid ""
"This module provides a simple way to time small bits of Python code. It has "
"both command line as well as callable interfaces.  It avoids a number of "
"common traps for measuring execution times.  See also Tim Peters' "
"introduction to the \"Algorithms\" chapter in the Python Cookbook, published "
"by O'Reilly."
msgstr ""

#: ../../../library/timeit.rst:20
msgid "The module defines the following public class:"
msgstr ""

#: ../../../library/timeit.rst:25
msgid "Class for timing execution speed of small code snippets."
msgstr ""

#: ../../../library/timeit.rst:27
msgid ""
"The constructor takes a statement to be timed, an additional statement used "
"for setup, and a timer function.  Both statements default to ``'pass'``; the "
"timer function is platform-dependent (see the module doc string).  *stmt* "
"and *setup* may also contain multiple statements separated by ``;`` or "
"newlines, as long as they don't contain multi-line string literals."
msgstr ""

#: ../../../library/timeit.rst:33
msgid ""
"To measure the execution time of the first statement, use the :meth:`timeit` "
"method.  The :meth:`repeat` method is a convenience to call :meth:`timeit` "
"multiple times and return a list of results."
msgstr ""

#: ../../../library/timeit.rst:37
msgid ""
"The *stmt* and *setup* parameters can now also take objects that are "
"callable without arguments. This will embed calls to them in a timer "
"function that will then be executed by :meth:`timeit`.  Note that the timing "
"overhead is a little larger in this case because of the extra function calls."
msgstr ""

#: ../../../library/timeit.rst:46
msgid "Helper to print a traceback from the timed code."
msgstr ""

#: ../../../library/timeit.rst:48
msgid "Typical use::"
msgstr ""

#: ../../../library/timeit.rst:50
msgid ""
"t = Timer(...)       # outside the try/except\n"
"try:\n"
"    t.timeit(...)    # or t.repeat(...)\n"
"except:\n"
"    t.print_exc()"
msgstr ""

#: ../../../library/timeit.rst:56
msgid ""
"The advantage over the standard traceback is that source lines in the "
"compiled template will be displayed. The optional *file* argument directs "
"where the traceback is sent; it defaults to ``sys.stderr``."
msgstr ""

#: ../../../library/timeit.rst:63
msgid "Call :meth:`timeit` a few times."
msgstr ""

#: ../../../library/timeit.rst:65
msgid ""
"This is a convenience function that calls the :meth:`timeit` repeatedly, "
"returning a list of results.  The first argument specifies how many times to "
"call :meth:`timeit`.  The second argument specifies the *number* argument "
"for :func:`timeit`."
msgstr ""

#: ../../../library/timeit.rst:72
msgid ""
"It's tempting to calculate mean and standard deviation from the result "
"vector and report these.  However, this is not very useful.  In a typical "
"case, the lowest value gives a lower bound for how fast your machine can run "
"the given code snippet; higher values in the result vector are typically not "
"caused by variability in Python's speed, but by other processes interfering "
"with your timing accuracy.  So the :func:`min` of the result is probably the "
"only number you should be interested in.  After that, you should look at the "
"entire vector and apply common sense rather than statistics."
msgstr ""

#: ../../../library/timeit.rst:84
msgid ""
"Time *number* executions of the main statement. This executes the setup "
"statement once, and then returns the time it takes to execute the main "
"statement a number of times, measured in seconds as a float.  The argument "
"is the number of times through the loop, defaulting to one million.  The "
"main statement, the setup statement and the timer function to be used are "
"passed to the constructor."
msgstr ""

#: ../../../library/timeit.rst:92
msgid ""
"By default, :meth:`timeit` temporarily turns off :term:`garbage collection` "
"during the timing.  The advantage of this approach is that it makes "
"independent timings more comparable.  This disadvantage is that GC may be an "
"important component of the performance of the function being measured. If "
"so, GC can be re-enabled as the first statement in the *setup* string. For "
"example::"
msgstr ""

#: ../../../library/timeit.rst:99
msgid "timeit.Timer('for i in xrange(10): oct(i)', 'gc.enable()').timeit()"
msgstr ""

#: ../../../library/timeit.rst:101
msgid ""
"Starting with version 2.6, the module also defines two convenience functions:"
msgstr ""

#: ../../../library/timeit.rst:106
msgid ""
"Create a :class:`Timer` instance with the given statement, setup code and "
"timer function and run its :meth:`repeat` method with the given repeat count "
"and *number* executions."
msgstr ""

#: ../../../library/timeit.rst:115
msgid ""
"Create a :class:`Timer` instance with the given statement, setup code and "
"timer function and run its :meth:`timeit` method with *number* executions."
msgstr ""

#: ../../../library/timeit.rst:122
msgid "Command Line Interface"
msgstr ""

#: ../../../library/timeit.rst:124
msgid ""
"When called as a program from the command line, the following form is used::"
msgstr ""

#: ../../../library/timeit.rst:126
msgid "python -m timeit [-n N] [-r N] [-s S] [-t] [-c] [-h] [statement ...]"
msgstr ""

#: ../../../library/timeit.rst:128
msgid "where the following options are understood:"
msgstr ""

#: ../../../library/timeit.rst:131
msgid "-n N/:option:`--number=N`"
msgstr ""

#: ../../../library/timeit.rst:131
msgid "how many times to execute 'statement'"
msgstr ""

#: ../../../library/timeit.rst:134
msgid "-r N/:option:`--repeat=N`"
msgstr ""

#: ../../../library/timeit.rst:134
msgid "how many times to repeat the timer (default 3)"
msgstr ""

#: ../../../library/timeit.rst:137
msgid "-s S/:option:`--setup=S`"
msgstr ""

#: ../../../library/timeit.rst:137
msgid "statement to be executed once initially (default ``'pass'``)"
msgstr ""

#: ../../../library/timeit.rst:140
msgid "-t/:option:`--time`"
msgstr ""

#: ../../../library/timeit.rst:140
msgid "use :func:`time.time` (default on all platforms but Windows)"
msgstr ""

#: ../../../library/timeit.rst:143
msgid "-c/:option:`--clock`"
msgstr ""

#: ../../../library/timeit.rst:143
msgid "use :func:`time.clock` (default on Windows)"
msgstr ""

#: ../../../library/timeit.rst:146
msgid "-v/:option:`--verbose`"
msgstr ""

#: ../../../library/timeit.rst:146
msgid "print raw timing results; repeat for more digits precision"
msgstr ""

#: ../../../library/timeit.rst:149
msgid "-h/:option:`--help`"
msgstr ""

#: ../../../library/timeit.rst:149
msgid "print a short usage message and exit"
msgstr ""

#: ../../../library/timeit.rst:151
msgid ""
"A multi-line statement may be given by specifying each line as a separate "
"statement argument; indented lines are possible by enclosing an argument in "
"quotes and using leading spaces.  Multiple :option:`-s` options are treated "
"similarly."
msgstr ""

#: ../../../library/timeit.rst:156
msgid ""
"If :option:`-n` is not given, a suitable number of loops is calculated by "
"trying successive powers of 10 until the total time is at least 0.2 seconds."
msgstr ""

#: ../../../library/timeit.rst:159
msgid ""
"The default timer function is platform dependent.  On Windows, :func:`time."
"clock` has microsecond granularity but :func:`time.time`'s granularity is "
"1/60th of a second; on Unix, :func:`time.clock` has 1/100th of a second "
"granularity and :func:`time.time` is much more precise.  On either platform, "
"the default timer functions measure wall clock time, not the CPU time. This "
"means that other processes running on the same computer may interfere with "
"the timing.  The best thing to do when accurate timing is necessary is to "
"repeat the timing a few times and use the best time.  The :option:`-r` "
"option is good for this; the default of 3 repetitions is probably enough in "
"most cases.  On Unix, you can use :func:`time.clock` to measure CPU time."
msgstr ""

#: ../../../library/timeit.rst:172
msgid ""
"There is a certain baseline overhead associated with executing a pass "
"statement. The code here doesn't try to hide it, but you should be aware of "
"it.  The baseline overhead can be measured by invoking the program without "
"arguments."
msgstr ""

#: ../../../library/timeit.rst:176
msgid ""
"The baseline overhead differs between Python versions!  Also, to fairly "
"compare older Python versions to Python 2.3, you may want to use Python's :"
"option:`-O` option for the older versions to avoid timing ``SET_LINENO`` "
"instructions."
msgstr ""

#: ../../../library/timeit.rst:182
msgid "Examples"
msgstr ""

#: ../../../library/timeit.rst:184
msgid ""
"Here are two example sessions (one using the command line, one using the "
"module interface) that compare the cost of using :func:`hasattr` vs. :"
"keyword:`try`/:keyword:`except` to test for missing and present object "
"attributes. ::"
msgstr ""

#: ../../../library/timeit.rst:189
msgid ""
"% timeit.py 'try:' '  str.__nonzero__' 'except AttributeError:' '  pass'\n"
"100000 loops, best of 3: 15.7 usec per loop\n"
"% timeit.py 'if hasattr(str, \"__nonzero__\"): pass'\n"
"100000 loops, best of 3: 4.26 usec per loop\n"
"% timeit.py 'try:' '  int.__nonzero__' 'except AttributeError:' '  pass'\n"
"1000000 loops, best of 3: 1.43 usec per loop\n"
"% timeit.py 'if hasattr(int, \"__nonzero__\"): pass'\n"
"100000 loops, best of 3: 2.23 usec per loop"
msgstr ""

#: ../../../library/timeit.rst:200
msgid ""
">>> import timeit\n"
">>> s = \"\"\"\\\n"
"... try:\n"
"...     str.__nonzero__\n"
"... except AttributeError:\n"
"...     pass\n"
"... \"\"\"\n"
">>> t = timeit.Timer(stmt=s)\n"
">>> print \"%.2f usec/pass\" % (1000000 * t.timeit(number=100000)/100000)\n"
"17.09 usec/pass\n"
">>> s = \"\"\"\\\n"
"... if hasattr(str, '__nonzero__'): pass\n"
"... \"\"\"\n"
">>> t = timeit.Timer(stmt=s)\n"
">>> print \"%.2f usec/pass\" % (1000000 * t.timeit(number=100000)/100000)\n"
"4.85 usec/pass\n"
">>> s = \"\"\"\\\n"
"... try:\n"
"...     int.__nonzero__\n"
"... except AttributeError:\n"
"...     pass\n"
"... \"\"\"\n"
">>> t = timeit.Timer(stmt=s)\n"
">>> print \"%.2f usec/pass\" % (1000000 * t.timeit(number=100000)/100000)\n"
"1.97 usec/pass\n"
">>> s = \"\"\"\\\n"
"... if hasattr(int, '__nonzero__'): pass\n"
"... \"\"\"\n"
">>> t = timeit.Timer(stmt=s)\n"
">>> print \"%.2f usec/pass\" % (1000000 * t.timeit(number=100000)/100000)\n"
"3.15 usec/pass"
msgstr ""

#: ../../../library/timeit.rst:232
msgid ""
"To give the :mod:`timeit` module access to functions you define, you can "
"pass a ``setup`` parameter which contains an import statement::"
msgstr ""

#: ../../../library/timeit.rst:235
msgid ""
"def test():\n"
"    \"Stupid test function\"\n"
"    L = []\n"
"    for i in range(100):\n"
"        L.append(i)\n"
"\n"
"if __name__=='__main__':\n"
"    from timeit import Timer\n"
"    t = Timer(\"test()\", \"from __main__ import test\")\n"
"    print t.timeit()"
msgstr ""

#: ../../../library/timeit.rst:11
msgid "Benchmarking"
msgstr ""

#: ../../../library/timeit.rst:11
msgid "Performance"
msgstr ""

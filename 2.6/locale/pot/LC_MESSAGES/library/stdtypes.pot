# SOME DESCRIPTIVE TITLE.
# Copyright (C) 1990-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 2.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-11 04:42+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../library/stdtypes.rst:8
msgid "Built-in Types"
msgstr ""

#: ../../../library/stdtypes.rst:10
msgid ""
"The following sections describe the standard types that are built into the "
"interpreter."
msgstr ""

#: ../../../library/stdtypes.rst:15
msgid ""
"Historically (until release 2.2), Python's built-in types have differed from "
"user-defined types because it was not possible to use the built-in types as "
"the basis for object-oriented inheritance. This limitation no longer exists."
msgstr ""

#: ../../../library/stdtypes.rst:22
msgid ""
"The principal built-in types are numerics, sequences, mappings, files, "
"classes, instances and exceptions."
msgstr ""

#: ../../../library/stdtypes.rst:27
msgid ""
"Some operations are supported by several object types; in particular, "
"practically all objects can be compared, tested for truth value, and "
"converted to a string (with the :func:`repr` function or the slightly "
"different :func:`str` function).  The latter function is implicitly used "
"when an object is written by the :func:`print` function."
msgstr ""

#: ../../../library/stdtypes.rst:37
msgid "Truth Value Testing"
msgstr ""

#: ../../../library/stdtypes.rst:46
msgid ""
"Any object can be tested for truth value, for use in an :keyword:`if` or :"
"keyword:`while` condition or as operand of the Boolean operations below. The "
"following values are considered false:"
msgstr ""

#: ../../../library/stdtypes.rst:52
msgid "``None``"
msgstr ""

#: ../../../library/stdtypes.rst:56
msgid "``False``"
msgstr ""

#: ../../../library/stdtypes.rst:58
msgid "zero of any numeric type, for example, ``0``, ``0L``, ``0.0``, ``0j``."
msgstr ""

#: ../../../library/stdtypes.rst:60
msgid "any empty sequence, for example, ``''``, ``()``, ``[]``."
msgstr ""

#: ../../../library/stdtypes.rst:62
msgid "any empty mapping, for example, ``{}``."
msgstr ""

#: ../../../library/stdtypes.rst:64
msgid ""
"instances of user-defined classes, if the class defines a :meth:"
"`__nonzero__` or :meth:`__len__` method, when that method returns the "
"integer zero or :class:`bool` value ``False``. [#]_"
msgstr ""

#: ../../../library/stdtypes.rst:70
msgid ""
"All other values are considered true --- so objects of many types are always "
"true."
msgstr ""

#: ../../../library/stdtypes.rst:79
msgid ""
"Operations and built-in functions that have a Boolean result always return "
"``0`` or ``False`` for false and ``1`` or ``True`` for true, unless "
"otherwise stated. (Important exception: the Boolean operations ``or`` and "
"``and`` always return one of their operands.)"
msgstr ""

#: ../../../library/stdtypes.rst:88
msgid "Boolean Operations --- :keyword:`and`, :keyword:`or`, :keyword:`not`"
msgstr ""

#: ../../../library/stdtypes.rst:92
msgid "These are the Boolean operations, ordered by ascending priority:"
msgstr ""

#: ../../../library/stdtypes.rst:95 ../../../library/stdtypes.rst:153
#: ../../../library/stdtypes.rst:286 ../../../library/stdtypes.rst:384
#: ../../../library/stdtypes.rst:427 ../../../library/stdtypes.rst:667
#: ../../../library/stdtypes.rst:1466
msgid "Operation"
msgstr ""

#: ../../../library/stdtypes.rst:95 ../../../library/stdtypes.rst:286
#: ../../../library/stdtypes.rst:384 ../../../library/stdtypes.rst:427
#: ../../../library/stdtypes.rst:667 ../../../library/stdtypes.rst:1466
msgid "Result"
msgstr ""

#: ../../../library/stdtypes.rst:95 ../../../library/stdtypes.rst:153
#: ../../../library/stdtypes.rst:286 ../../../library/stdtypes.rst:384
#: ../../../library/stdtypes.rst:427 ../../../library/stdtypes.rst:667
#: ../../../library/stdtypes.rst:1333 ../../../library/stdtypes.rst:1466
msgid "Notes"
msgstr ""

#: ../../../library/stdtypes.rst:97
msgid "``x or y``"
msgstr ""

#: ../../../library/stdtypes.rst:97
msgid "if *x* is false, then *y*, else *x*"
msgstr ""

#: ../../../library/stdtypes.rst:97 ../../../library/stdtypes.rst:165
#: ../../../library/stdtypes.rst:294 ../../../library/stdtypes.rst:669
#: ../../../library/stdtypes.rst:672 ../../../library/stdtypes.rst:1339
#: ../../../library/stdtypes.rst:1477
msgid "\\(1)"
msgstr ""

#: ../../../library/stdtypes.rst:100
msgid "``x and y``"
msgstr ""

#: ../../../library/stdtypes.rst:100
msgid "if *x* is false, then *x*, else *y*"
msgstr ""

#: ../../../library/stdtypes.rst:100 ../../../library/stdtypes.rst:308
#: ../../../library/stdtypes.rst:310 ../../../library/stdtypes.rst:678
#: ../../../library/stdtypes.rst:1343 ../../../library/stdtypes.rst:1345
#: ../../../library/stdtypes.rst:1483
msgid "\\(2)"
msgstr ""

#: ../../../library/stdtypes.rst:103
msgid "``not x``"
msgstr ""

#: ../../../library/stdtypes.rst:103
msgid "if *x* is false, then ``True``, else ``False``"
msgstr ""

#: ../../../library/stdtypes.rst:103 ../../../library/stdtypes.rst:305
#: ../../../library/stdtypes.rst:681 ../../../library/stdtypes.rst:1347
#: ../../../library/stdtypes.rst:1349 ../../../library/stdtypes.rst:1351
#: ../../../library/stdtypes.rst:1353 ../../../library/stdtypes.rst:1486
msgid "\\(3)"
msgstr ""

#: ../../../library/stdtypes.rst:112 ../../../library/stdtypes.rst:172
#: ../../../library/stdtypes.rst:332 ../../../library/stdtypes.rst:445
#: ../../../library/stdtypes.rst:715 ../../../library/stdtypes.rst:1376
#: ../../../library/stdtypes.rst:1527
msgid "Notes:"
msgstr ""

#: ../../../library/stdtypes.rst:115
msgid ""
"This is a short-circuit operator, so it only evaluates the second argument "
"if the first one is :const:`False`."
msgstr ""

#: ../../../library/stdtypes.rst:119
msgid ""
"This is a short-circuit operator, so it only evaluates the second argument "
"if the first one is :const:`True`."
msgstr ""

#: ../../../library/stdtypes.rst:123
msgid ""
"``not`` has a lower priority than non-Boolean operators, so ``not a == b`` "
"is interpreted as ``not (a == b)``, and ``a == not b`` is a syntax error."
msgstr ""

#: ../../../library/stdtypes.rst:130
msgid "Comparisons"
msgstr ""

#: ../../../library/stdtypes.rst:144
msgid ""
"Comparison operations are supported by all objects.  They all have the same "
"priority (which is higher than that of the Boolean operations). Comparisons "
"can be chained arbitrarily; for example, ``x < y <= z`` is equivalent to ``x "
"< y and y <= z``, except that *y* is evaluated only once (but in both cases "
"*z* is not evaluated at all when ``x < y`` is found to be false)."
msgstr ""

#: ../../../library/stdtypes.rst:150
msgid "This table summarizes the comparison operations:"
msgstr ""

#: ../../../library/stdtypes.rst:153 ../../../library/stdtypes.rst:1310
#: ../../../library/stdtypes.rst:1333
msgid "Meaning"
msgstr ""

#: ../../../library/stdtypes.rst:155
msgid "``<``"
msgstr ""

#: ../../../library/stdtypes.rst:155
msgid "strictly less than"
msgstr ""

#: ../../../library/stdtypes.rst:157
msgid "``<=``"
msgstr ""

#: ../../../library/stdtypes.rst:157
msgid "less than or equal"
msgstr ""

#: ../../../library/stdtypes.rst:159
msgid "``>``"
msgstr ""

#: ../../../library/stdtypes.rst:159
msgid "strictly greater than"
msgstr ""

#: ../../../library/stdtypes.rst:161
msgid "``>=``"
msgstr ""

#: ../../../library/stdtypes.rst:161
msgid "greater than or equal"
msgstr ""

#: ../../../library/stdtypes.rst:163
msgid "``==``"
msgstr ""

#: ../../../library/stdtypes.rst:163
msgid "equal"
msgstr ""

#: ../../../library/stdtypes.rst:165
msgid "``!=``"
msgstr ""

#: ../../../library/stdtypes.rst:165
msgid "not equal"
msgstr ""

#: ../../../library/stdtypes.rst:167
msgid "``is``"
msgstr ""

#: ../../../library/stdtypes.rst:167
msgid "object identity"
msgstr ""

#: ../../../library/stdtypes.rst:169
msgid "``is not``"
msgstr ""

#: ../../../library/stdtypes.rst:169
msgid "negated object identity"
msgstr ""

#: ../../../library/stdtypes.rst:175
msgid ""
"``!=`` can also be written ``<>``, but this is an obsolete usage kept for "
"backwards compatibility only. New code should always use ``!=``."
msgstr ""

#: ../../../library/stdtypes.rst:183
msgid ""
"Objects of different types, except different numeric types and different "
"string types, never compare equal; such objects are ordered consistently but "
"arbitrarily (so that sorting a heterogeneous array yields a consistent "
"result). Furthermore, some types (for example, file objects) support only a "
"degenerate notion of comparison where any two objects of that type are "
"unequal.  Again, such objects are ordered arbitrarily but consistently. The "
"``<``, ``<=``, ``>`` and ``>=`` operators will raise a :exc:`TypeError` "
"exception when any operand is a complex number."
msgstr ""

#: ../../../library/stdtypes.rst:194
msgid ""
"Instances of a class normally compare as non-equal unless the class defines "
"the :meth:`__cmp__` method.  Refer to :ref:`customization`) for information "
"on the use of this method to effect object comparisons."
msgstr ""

#: ../../../library/stdtypes.rst:200
msgid ""
"Objects of different types except numbers are ordered by their type names; "
"objects of the same types that don't support proper comparison are ordered "
"by their address."
msgstr ""

#: ../../../library/stdtypes.rst:208
msgid ""
"Two more operations with the same syntactic priority, ``in`` and ``not in``, "
"are supported only by sequence types (below)."
msgstr ""

#: ../../../library/stdtypes.rst:215
msgid ""
"Numeric Types --- :class:`int`, :class:`float`, :class:`long`, :class:"
"`complex`"
msgstr ""

#: ../../../library/stdtypes.rst:226
msgid ""
"There are four distinct numeric types: :dfn:`plain integers`, :dfn:`long "
"integers`,  :dfn:`floating point numbers`, and :dfn:`complex numbers`. In "
"addition, Booleans are a subtype of plain integers. Plain integers (also "
"just called :dfn:`integers`) are implemented using :ctype:`long` in C, which "
"gives them at least 32 bits of precision (``sys.maxint`` is always set to "
"the maximum plain integer value for the current platform, the minimum value "
"is ``-sys.maxint - 1``).  Long integers have unlimited precision. Floating "
"point numbers are implemented using :ctype:`double` in C. All bets on their "
"precision are off unless you happen to know the machine you are working with."
msgstr ""

#: ../../../library/stdtypes.rst:236
msgid ""
"Complex numbers have a real and imaginary part, which are each implemented "
"using :ctype:`double` in C.  To extract these parts from a complex number "
"*z*, use ``z.real`` and ``z.imag``."
msgstr ""

#: ../../../library/stdtypes.rst:249
msgid ""
"Numbers are created by numeric literals or as the result of built-in "
"functions and operators.  Unadorned integer literals (including binary, hex, "
"and octal numbers) yield plain integers unless the value they denote is too "
"large to be represented as a plain integer, in which case they yield a long "
"integer. Integer literals with an ``'L'`` or ``'l'`` suffix yield long "
"integers (``'L'`` is preferred because ``1l`` looks too much like eleven!).  "
"Numeric literals containing a decimal point or an exponent sign yield "
"floating point numbers. Appending ``'j'`` or ``'J'`` to a numeric literal "
"yields a complex number with a zero real part. A complex numeric literal is "
"the sum of a real and an imaginary part."
msgstr ""

#: ../../../library/stdtypes.rst:274
msgid ""
"Python fully supports mixed arithmetic: when a binary arithmetic operator "
"has operands of different numeric types, the operand with the \"narrower\" "
"type is widened to that of the other, where plain integer is narrower than "
"long integer is narrower than floating point is narrower than complex. "
"Comparisons between numbers of mixed type use the same rule. [#]_ The "
"constructors :func:`int`, :func:`long`, :func:`float`, and :func:`complex` "
"can be used to produce numbers of a specific type."
msgstr ""

#: ../../../library/stdtypes.rst:282
msgid ""
"All built-in numeric types support the following operations. See :ref:"
"`power` and later sections for the operators' priorities."
msgstr ""

#: ../../../library/stdtypes.rst:288
msgid "``x + y``"
msgstr ""

#: ../../../library/stdtypes.rst:288
msgid "sum of *x* and *y*"
msgstr ""

#: ../../../library/stdtypes.rst:290
msgid "``x - y``"
msgstr ""

#: ../../../library/stdtypes.rst:290
msgid "difference of *x* and *y*"
msgstr ""

#: ../../../library/stdtypes.rst:292
msgid "``x * y``"
msgstr ""

#: ../../../library/stdtypes.rst:292
msgid "product of *x* and *y*"
msgstr ""

#: ../../../library/stdtypes.rst:294
msgid "``x / y``"
msgstr ""

#: ../../../library/stdtypes.rst:294
msgid "quotient of *x* and *y*"
msgstr ""

#: ../../../library/stdtypes.rst:296
msgid "``x // y``"
msgstr ""

#: ../../../library/stdtypes.rst:296
msgid "(floored) quotient of *x* and *y*"
msgstr ""

#: ../../../library/stdtypes.rst:296
msgid "(4)(5)"
msgstr ""

#: ../../../library/stdtypes.rst:299
msgid "``x % y``"
msgstr ""

#: ../../../library/stdtypes.rst:299
msgid "remainder of ``x / y``"
msgstr ""

#: ../../../library/stdtypes.rst:299 ../../../library/stdtypes.rst:1355
#: ../../../library/stdtypes.rst:1359 ../../../library/stdtypes.rst:1492
#: ../../../library/stdtypes.rst:1501
msgid "\\(4)"
msgstr ""

#: ../../../library/stdtypes.rst:301
msgid "``-x``"
msgstr ""

#: ../../../library/stdtypes.rst:301
msgid "*x* negated"
msgstr ""

#: ../../../library/stdtypes.rst:303
msgid "``+x``"
msgstr ""

#: ../../../library/stdtypes.rst:303
msgid "*x* unchanged"
msgstr ""

#: ../../../library/stdtypes.rst:305
msgid "``abs(x)``"
msgstr ""

#: ../../../library/stdtypes.rst:305
msgid "absolute value or magnitude of *x*"
msgstr ""

#: ../../../library/stdtypes.rst:308
msgid "``int(x)``"
msgstr ""

#: ../../../library/stdtypes.rst:308
msgid "*x* converted to integer"
msgstr ""

#: ../../../library/stdtypes.rst:310
msgid "``long(x)``"
msgstr ""

#: ../../../library/stdtypes.rst:310
msgid "*x* converted to long integer"
msgstr ""

#: ../../../library/stdtypes.rst:312
msgid "``float(x)``"
msgstr ""

#: ../../../library/stdtypes.rst:312
msgid "*x* converted to floating point"
msgstr ""

#: ../../../library/stdtypes.rst:312 ../../../library/stdtypes.rst:675
#: ../../../library/stdtypes.rst:1369 ../../../library/stdtypes.rst:1498
msgid "\\(6)"
msgstr ""

#: ../../../library/stdtypes.rst:314
msgid "``complex(re,im)``"
msgstr ""

#: ../../../library/stdtypes.rst:314
msgid ""
"a complex number with real part *re*, imaginary part *im*. *im* defaults to "
"zero."
msgstr ""

#: ../../../library/stdtypes.rst:318
msgid "``c.conjugate()``"
msgstr ""

#: ../../../library/stdtypes.rst:318
msgid "conjugate of the complex number *c*. (Identity on real numbers)"
msgstr ""

#: ../../../library/stdtypes.rst:321
msgid "``divmod(x, y)``"
msgstr ""

#: ../../../library/stdtypes.rst:321
msgid "the pair ``(x // y, x % y)``"
msgstr ""

#: ../../../library/stdtypes.rst:321 ../../../library/stdtypes.rst:683
msgid "(3)(4)"
msgstr ""

#: ../../../library/stdtypes.rst:323
msgid "``pow(x, y)``"
msgstr ""

#: ../../../library/stdtypes.rst:323 ../../../library/stdtypes.rst:325
msgid "*x* to the power *y*"
msgstr ""

#: ../../../library/stdtypes.rst:323
msgid "(3)(7)"
msgstr ""

#: ../../../library/stdtypes.rst:325
msgid "``x ** y``"
msgstr ""

#: ../../../library/stdtypes.rst:325 ../../../library/stdtypes.rst:1341
#: ../../../library/stdtypes.rst:1503
msgid "\\(7)"
msgstr ""

#: ../../../library/stdtypes.rst:339
msgid ""
"For (plain or long) integer division, the result is an integer. The result "
"is always rounded towards minus infinity: 1/2 is 0, (-1)/2 is -1, 1/(-2) is "
"-1, and (-1)/(-2) is 0.  Note that the result is a long integer if either "
"operand is a long integer, regardless of the numeric value."
msgstr ""

#: ../../../library/stdtypes.rst:352
msgid ""
"Conversion from floats using :func:`int` or :func:`long` truncates toward "
"zero like the related function, :func:`math.trunc`.  Use the function :func:"
"`math.floor` to round downward and :func:`math.ceil` to round upward."
msgstr ""

#: ../../../library/stdtypes.rst:358
msgid "See :ref:`built-in-funcs` for a full description."
msgstr ""

#: ../../../library/stdtypes.rst:361
msgid "Complex floor division operator, modulo operator, and :func:`divmod`."
msgstr ""

#: ../../../library/stdtypes.rst:363
msgid "Instead convert to float using :func:`abs` if appropriate."
msgstr ""

#: ../../../library/stdtypes.rst:367
msgid ""
"Also referred to as integer division.  The resultant value is a whole "
"integer, though the result's type is not necessarily int."
msgstr ""

#: ../../../library/stdtypes.rst:371
msgid ""
"float also accepts the strings \"nan\" and \"inf\" with an optional prefix "
"\"+\" or \"-\" for Not a Number (NaN) and positive or negative infinity."
msgstr ""

#: ../../../library/stdtypes.rst:377
msgid ""
"Python defines ``pow(0, 0)`` and ``0 ** 0`` to be ``1``, as is common for "
"programming languages."
msgstr ""

#: ../../../library/stdtypes.rst:380
msgid ""
"All :class:`numbers.Real` types (:class:`int`, :class:`long`, and :class:"
"`float`) also include the following operations:"
msgstr ""

#: ../../../library/stdtypes.rst:386
msgid "``math.trunc(x)``"
msgstr ""

#: ../../../library/stdtypes.rst:386
msgid "*x* truncated to Integral"
msgstr ""

#: ../../../library/stdtypes.rst:388
msgid "``round(x[, n])``"
msgstr ""

#: ../../../library/stdtypes.rst:388
msgid ""
"*x* rounded to n digits, rounding half to even. If n is omitted, it defaults "
"to 0."
msgstr ""

#: ../../../library/stdtypes.rst:392
msgid "``math.floor(x)``"
msgstr ""

#: ../../../library/stdtypes.rst:392
msgid "the greatest integral float <= *x*"
msgstr ""

#: ../../../library/stdtypes.rst:394
msgid "``math.ceil(x)``"
msgstr ""

#: ../../../library/stdtypes.rst:394
msgid "the least integral float >= *x*"
msgstr ""

#: ../../../library/stdtypes.rst:403
msgid "Bit-string Operations on Integer Types"
msgstr ""

#: ../../../library/stdtypes.rst:415
msgid ""
"Plain and long integer types support additional operations that make sense "
"only for bit-strings.  Negative numbers are treated as their 2's complement "
"value (for long integers, this assumes a sufficiently large number of bits "
"that no overflow occurs during the operation)."
msgstr ""

#: ../../../library/stdtypes.rst:420
msgid ""
"The priorities of the binary bitwise operations are all lower than the "
"numeric operations and higher than the comparisons; the unary operation "
"``~`` has the same priority as the other unary numeric operations (``+`` and "
"``-``)."
msgstr ""

#: ../../../library/stdtypes.rst:424
msgid ""
"This table lists the bit-string operations sorted in ascending priority:"
msgstr ""

#: ../../../library/stdtypes.rst:429
msgid "``x | y``"
msgstr ""

#: ../../../library/stdtypes.rst:429
msgid "bitwise :dfn:`or` of *x* and *y*"
msgstr ""

#: ../../../library/stdtypes.rst:432
msgid "``x ^ y``"
msgstr ""

#: ../../../library/stdtypes.rst:432
msgid "bitwise :dfn:`exclusive or` of *x* and *y*"
msgstr ""

#: ../../../library/stdtypes.rst:435
msgid "``x & y``"
msgstr ""

#: ../../../library/stdtypes.rst:435
msgid "bitwise :dfn:`and` of *x* and *y*"
msgstr ""

#: ../../../library/stdtypes.rst:438
msgid "``x << n``"
msgstr ""

#: ../../../library/stdtypes.rst:438
msgid "*x* shifted left by *n* bits"
msgstr ""

#: ../../../library/stdtypes.rst:438
msgid "(1)(2)"
msgstr ""

#: ../../../library/stdtypes.rst:440
msgid "``x >> n``"
msgstr ""

#: ../../../library/stdtypes.rst:440
msgid "*x* shifted right by *n* bits"
msgstr ""

#: ../../../library/stdtypes.rst:440
msgid "(1)(3)"
msgstr ""

#: ../../../library/stdtypes.rst:442
msgid "``~x``"
msgstr ""

#: ../../../library/stdtypes.rst:442
msgid "the bits of *x* inverted"
msgstr ""

#: ../../../library/stdtypes.rst:448
msgid ""
"Negative shift counts are illegal and cause a :exc:`ValueError` to be raised."
msgstr ""

#: ../../../library/stdtypes.rst:451
msgid ""
"A left shift by *n* bits is equivalent to multiplication by ``pow(2, n)``.  "
"A long integer is returned if the result exceeds the range of plain integers."
msgstr ""

#: ../../../library/stdtypes.rst:455
msgid "A right shift by *n* bits is equivalent to division by ``pow(2, n)``."
msgstr ""

#: ../../../library/stdtypes.rst:459
msgid "Additional Methods on Float"
msgstr ""

#: ../../../library/stdtypes.rst:461
msgid "The float type has some additional methods."
msgstr ""

#: ../../../library/stdtypes.rst:465
msgid ""
"Return a pair of integers whose ratio is exactly equal to the original float "
"and with a positive denominator.  Raises :exc:`OverflowError` on infinities "
"and a :exc:`ValueError` on NaNs."
msgstr ""

#: ../../../library/stdtypes.rst:472
msgid ""
"Two methods support conversion to and from hexadecimal strings.  Since "
"Python's floats are stored internally as binary numbers, converting a float "
"to or from a *decimal* string usually involves a small rounding error.  In "
"contrast, hexadecimal strings allow exact representation and specification "
"of floating-point numbers.  This can be useful when debugging, and in "
"numerical work."
msgstr ""

#: ../../../library/stdtypes.rst:483
msgid ""
"Return a representation of a floating-point number as a hexadecimal string.  "
"For finite floating-point numbers, this representation will always include a "
"leading ``0x`` and a trailing ``p`` and exponent."
msgstr ""

#: ../../../library/stdtypes.rst:493
msgid ""
"Class method to return the float represented by a hexadecimal string *s*.  "
"The string *s* may have leading and trailing whitespace."
msgstr ""

#: ../../../library/stdtypes.rst:500
msgid ""
"Note that :meth:`float.hex` is an instance method, while :meth:`float."
"fromhex` is a class method."
msgstr ""

#: ../../../library/stdtypes.rst:503
msgid "A hexadecimal string takes the form::"
msgstr ""

#: ../../../library/stdtypes.rst:507
msgid ""
"where the optional ``sign`` may by either ``+`` or ``-``, ``integer`` and "
"``fraction`` are strings of hexadecimal digits, and ``exponent`` is a "
"decimal integer with an optional leading sign.  Case is not significant, and "
"there must be at least one hexadecimal digit in either the integer or the "
"fraction.  This syntax is similar to the syntax specified in section 6.4.4.2 "
"of the C99 standard, and also to the syntax used in Java 1.5 onwards.  In "
"particular, the output of :meth:`float.hex` is usable as a hexadecimal "
"floating-point literal in C or Java code, and hexadecimal strings produced "
"by C's ``%a`` format character or Java's ``Double.toHexString`` are accepted "
"by :meth:`float.fromhex`."
msgstr ""

#: ../../../library/stdtypes.rst:520
msgid ""
"Note that the exponent is written in decimal rather than hexadecimal, and "
"that it gives the power of 2 by which to multiply the coefficient. For "
"example, the hexadecimal string ``0x3.a7p10`` represents the floating-point "
"number ``(3 + 10./16 + 7./16**2) * 2.0**10``, or ``3740.0``::"
msgstr ""

#: ../../../library/stdtypes.rst:530
msgid ""
"Applying the reverse conversion to ``3740.0`` gives a different hexadecimal "
"string representing the same number::"
msgstr ""

#: ../../../library/stdtypes.rst:540
msgid "Iterator Types"
msgstr ""

#: ../../../library/stdtypes.rst:550
msgid ""
"Python supports a concept of iteration over containers.  This is implemented "
"using two distinct methods; these are used to allow user-defined classes to "
"support iteration.  Sequences, described below in more detail, always "
"support the iteration methods."
msgstr ""

#: ../../../library/stdtypes.rst:555
msgid ""
"One method needs to be defined for container objects to provide iteration "
"support:"
msgstr ""

#: ../../../library/stdtypes.rst:562
msgid ""
"Return an iterator object.  The object is required to support the iterator "
"protocol described below.  If a container supports different types of "
"iteration, additional methods can be provided to specifically request "
"iterators for those iteration types.  (An example of an object supporting "
"multiple forms of iteration would be a tree structure which supports both "
"breadth-first and depth-first traversal.)  This method corresponds to the :"
"attr:`tp_iter` slot of the type structure for Python objects in the Python/C "
"API."
msgstr ""

#: ../../../library/stdtypes.rst:571
msgid ""
"The iterator objects themselves are required to support the following two "
"methods, which together form the :dfn:`iterator protocol`:"
msgstr ""

#: ../../../library/stdtypes.rst:577
msgid ""
"Return the iterator object itself.  This is required to allow both "
"containers and iterators to be used with the :keyword:`for` and :keyword:"
"`in` statements. This method corresponds to the :attr:`tp_iter` slot of the "
"type structure for Python objects in the Python/C API."
msgstr ""

#: ../../../library/stdtypes.rst:585
msgid ""
"Return the next item from the container.  If there are no further items, "
"raise the :exc:`StopIteration` exception.  This method corresponds to the :"
"attr:`tp_iternext` slot of the type structure for Python objects in the "
"Python/C API."
msgstr ""

#: ../../../library/stdtypes.rst:590
msgid ""
"Python defines several iterator objects to support iteration over general "
"and specific sequence types, dictionaries, and other more specialized "
"forms.  The specific types are not important beyond their implementation of "
"the iterator protocol."
msgstr ""

#: ../../../library/stdtypes.rst:595
msgid ""
"The intention of the protocol is that once an iterator's :meth:`next` method "
"raises :exc:`StopIteration`, it will continue to do so on subsequent calls. "
"Implementations that do not obey this property are deemed broken.  (This "
"constraint was added in Python 2.3; in Python 2.2, various iterators are "
"broken according to this rule.)"
msgstr ""

#: ../../../library/stdtypes.rst:605
msgid "Generator Types"
msgstr ""

#: ../../../library/stdtypes.rst:607
msgid ""
"Python's :term:`generator`\\s provide a convenient way to implement the "
"iterator protocol.  If a container object's :meth:`__iter__` method is "
"implemented as a generator, it will automatically return an iterator object "
"(technically, a generator object) supplying the :meth:`__iter__` and :meth:"
"`next` methods.  More information about generators can be found in :ref:`the "
"documentation for the yield expression <yieldexpr>`."
msgstr ""

#: ../../../library/stdtypes.rst:618
msgid ""
"Sequence Types --- :class:`str`, :class:`unicode`, :class:`list`, :class:"
"`tuple`, :class:`buffer`, :class:`xrange`"
msgstr ""

#: ../../../library/stdtypes.rst:620
msgid ""
"There are six sequence types: strings, Unicode strings, lists, tuples, "
"buffers, and xrange objects."
msgstr ""

#: ../../../library/stdtypes.rst:623
msgid ""
"For other containers see the built in :class:`dict` and :class:`set` "
"classes, and the :mod:`collections` module."
msgstr ""

#: ../../../library/stdtypes.rst:636
msgid ""
"String literals are written in single or double quotes: ``'xyzzy'``, "
"``\"frobozz\"``.  See :ref:`strings` for more about string literals. Unicode "
"strings are much like strings, but are specified in the syntax using a "
"preceding ``'u'`` character: ``u'abc'``, ``u\"def\"``. In addition to the "
"functionality described here, there are also string-specific methods "
"described in the :ref:`string-methods` section. Lists are constructed with "
"square brackets, separating items with commas: ``[a, b, c]``. Tuples are "
"constructed by the comma operator (not within square brackets), with or "
"without enclosing parentheses, but an empty tuple must have the enclosing "
"parentheses, such as ``a, b, c`` or ``()``.  A single item tuple must have a "
"trailing comma, such as ``(d,)``."
msgstr ""

#: ../../../library/stdtypes.rst:648
msgid ""
"Buffer objects are not directly supported by Python syntax, but can be "
"created by calling the built-in function :func:`buffer`.  They don't support "
"concatenation or repetition."
msgstr ""

#: ../../../library/stdtypes.rst:652
msgid ""
"Objects of type xrange are similar to buffers in that there is no specific "
"syntax to create them, but they are created using the :func:`xrange` "
"function.  They don't support slicing, concatenation or repetition, and "
"using ``in``, ``not in``, :func:`min` or :func:`max` on them is inefficient."
msgstr ""

#: ../../../library/stdtypes.rst:657
msgid ""
"Most sequence types support the following operations.  The ``in`` and ``not "
"in`` operations have the same priorities as the comparison operations.  The "
"``+`` and ``*`` operations have the same priority as the corresponding "
"numeric operations. [#]_ Additional methods are provided for :ref:`typesseq-"
"mutable`."
msgstr ""

#: ../../../library/stdtypes.rst:662
msgid ""
"This table lists the sequence operations sorted in ascending priority "
"(operations in the same box have the same priority).  In the table, *s* and "
"*t* are sequences of the same type; *n*, *i* and *j* are integers:"
msgstr ""

#: ../../../library/stdtypes.rst:669
msgid "``x in s``"
msgstr ""

#: ../../../library/stdtypes.rst:669
msgid "``True`` if an item of *s* is equal to *x*, else ``False``"
msgstr ""

#: ../../../library/stdtypes.rst:672
msgid "``x not in s``"
msgstr ""

#: ../../../library/stdtypes.rst:672
msgid "``False`` if an item of *s* is equal to *x*, else ``True``"
msgstr ""

#: ../../../library/stdtypes.rst:675
msgid "``s + t``"
msgstr ""

#: ../../../library/stdtypes.rst:675
msgid "the concatenation of *s* and *t*"
msgstr ""

#: ../../../library/stdtypes.rst:678
msgid "``s * n, n * s``"
msgstr ""

#: ../../../library/stdtypes.rst:678
msgid "*n* shallow copies of *s* concatenated"
msgstr ""

#: ../../../library/stdtypes.rst:681
msgid "``s[i]``"
msgstr ""

#: ../../../library/stdtypes.rst:681
msgid "*i*'th item of *s*, origin 0"
msgstr ""

#: ../../../library/stdtypes.rst:683
msgid "``s[i:j]``"
msgstr ""

#: ../../../library/stdtypes.rst:683
msgid "slice of *s* from *i* to *j*"
msgstr ""

#: ../../../library/stdtypes.rst:685
msgid "``s[i:j:k]``"
msgstr ""

#: ../../../library/stdtypes.rst:685
msgid "slice of *s* from *i* to *j* with step *k*"
msgstr ""

#: ../../../library/stdtypes.rst:685
msgid "(3)(5)"
msgstr ""

#: ../../../library/stdtypes.rst:688
msgid "``len(s)``"
msgstr ""

#: ../../../library/stdtypes.rst:688
msgid "length of *s*"
msgstr ""

#: ../../../library/stdtypes.rst:690
msgid "``min(s)``"
msgstr ""

#: ../../../library/stdtypes.rst:690
msgid "smallest item of *s*"
msgstr ""

#: ../../../library/stdtypes.rst:692
msgid "``max(s)``"
msgstr ""

#: ../../../library/stdtypes.rst:692
msgid "largest item of *s*"
msgstr ""

#: ../../../library/stdtypes.rst:695
msgid ""
"Sequence types also support comparisons. In particular, tuples and lists are "
"compared lexicographically by comparing corresponding elements. This means "
"that to compare equal, every element must compare equal and the two "
"sequences must be of the same type and have the same length. (For full "
"details see :ref:`comparisons` in the language reference.)"
msgstr ""

#: ../../../library/stdtypes.rst:718
msgid ""
"When *s* is a string or Unicode string object the ``in`` and ``not in`` "
"operations act like a substring test.  In Python versions before 2.3, *x* "
"had to be a string of length 1. In Python 2.3 and beyond, *x* may be a "
"string of any length."
msgstr ""

#: ../../../library/stdtypes.rst:724
msgid ""
"Values of *n* less than ``0`` are treated as ``0`` (which yields an empty "
"sequence of the same type as *s*).  Note also that the copies are shallow; "
"nested structures are not copied.  This often haunts new Python programmers; "
"consider:"
msgstr ""

#: ../../../library/stdtypes.rst:736
msgid ""
"What has happened is that ``[[]]`` is a one-element list containing an empty "
"list, so all three elements of ``[[]] * 3`` are (pointers to) this single "
"empty list.  Modifying any of the elements of ``lists`` modifies this single "
"list. You can create a list of different lists this way:"
msgstr ""

#: ../../../library/stdtypes.rst:749
msgid ""
"If *i* or *j* is negative, the index is relative to the end of the string: "
"``len(s) + i`` or ``len(s) + j`` is substituted.  But note that ``-0`` is "
"still ``0``."
msgstr ""

#: ../../../library/stdtypes.rst:754
msgid ""
"The slice of *s* from *i* to *j* is defined as the sequence of items with "
"index *k* such that ``i <= k < j``.  If *i* or *j* is greater than "
"``len(s)``, use ``len(s)``.  If *i* is omitted or ``None``, use ``0``.  If "
"*j* is omitted or ``None``, use ``len(s)``.  If *i* is greater than or equal "
"to *j*, the slice is empty."
msgstr ""

#: ../../../library/stdtypes.rst:761
msgid ""
"The slice of *s* from *i* to *j* with step *k* is defined as the sequence of "
"items with index  ``x = i + n*k`` such that ``0 <= n < (j-i)/k``.  In other "
"words, the indices are ``i``, ``i+k``, ``i+2*k``, ``i+3*k`` and so on, "
"stopping when *j* is reached (but never including *j*).  If *i* or *j* is "
"greater than ``len(s)``, use ``len(s)``.  If *i* or *j* are omitted or "
"``None``, they become \"end\" values (which end depends on the sign of "
"*k*).  Note, *k* cannot be zero. If *k* is ``None``, it is treated like "
"``1``."
msgstr ""

#: ../../../library/stdtypes.rst:772
msgid ""
"If *s* and *t* are both strings, some Python implementations such as CPython "
"can usually perform an in-place optimization for assignments of the form ``s "
"= s + t`` or ``s += t``.  When applicable, this optimization makes quadratic "
"run-time much less likely.  This optimization is both version and "
"implementation dependent.  For performance sensitive code, it is preferable "
"to use the :meth:`str.join` method which assures consistent linear "
"concatenation performance across versions and implementations."
msgstr ""

#: ../../../library/stdtypes.rst:780
msgid "Formerly, string concatenation never occurred in-place."
msgstr ""

#: ../../../library/stdtypes.rst:787
msgid "String Methods"
msgstr ""

#: ../../../library/stdtypes.rst:791
msgid ""
"Below are listed the string methods which both 8-bit strings and Unicode "
"objects support. Note that none of these methods take keyword arguments."
msgstr ""

#: ../../../library/stdtypes.rst:794
msgid ""
"In addition, Python's strings support the sequence type methods described in "
"the :ref:`typesseq` section. To output formatted strings use template "
"strings or the ``%`` operator described in the :ref:`string-formatting` "
"section. Also, see the :mod:`re` module for string functions based on "
"regular expressions."
msgstr ""

#: ../../../library/stdtypes.rst:802
msgid ""
"Return a copy of the string with its first character capitalized and the "
"rest lowercased."
msgstr ""

#: ../../../library/stdtypes.rst:805 ../../../library/stdtypes.rst:917
#: ../../../library/stdtypes.rst:925 ../../../library/stdtypes.rst:933
#: ../../../library/stdtypes.rst:941 ../../../library/stdtypes.rst:949
#: ../../../library/stdtypes.rst:958 ../../../library/stdtypes.rst:966
#: ../../../library/stdtypes.rst:990 ../../../library/stdtypes.rst:1151
#: ../../../library/stdtypes.rst:1179 ../../../library/stdtypes.rst:1213
msgid "For 8-bit strings, this method is locale-dependent."
msgstr ""

#: ../../../library/stdtypes.rst:810
msgid ""
"Return centered in a string of length *width*. Padding is done using the "
"specified *fillchar* (default is a space)."
msgstr ""

#: ../../../library/stdtypes.rst:813 ../../../library/stdtypes.rst:982
#: ../../../library/stdtypes.rst:1045
msgid "Support for the *fillchar* argument."
msgstr ""

#: ../../../library/stdtypes.rst:819
msgid ""
"Return the number of non-overlapping occurrences of substring *sub* in the "
"range [*start*, *end*].  Optional arguments *start* and *end* are "
"interpreted as in slice notation."
msgstr ""

#: ../../../library/stdtypes.rst:826
msgid ""
"Decodes the string using the codec registered for *encoding*. *encoding* "
"defaults to the default string encoding.  *errors* may be given to set a "
"different error handling scheme.  The default is ``'strict'``, meaning that "
"encoding errors raise :exc:`UnicodeError`.  Other possible values are "
"``'ignore'``, ``'replace'`` and any other name registered via :func:`codecs."
"register_error`, see section :ref:`codec-base-classes`."
msgstr ""

#: ../../../library/stdtypes.rst:835
msgid "Support for other error handling schemes added."
msgstr ""

#: ../../../library/stdtypes.rst:841
msgid ""
"Return an encoded version of the string.  Default encoding is the current "
"default string encoding.  *errors* may be given to set a different error "
"handling scheme.  The default for *errors* is ``'strict'``, meaning that "
"encoding errors raise a :exc:`UnicodeError`.  Other possible values are "
"``'ignore'``, ``'replace'``, ``'xmlcharrefreplace'``, ``'backslashreplace'`` "
"and any other name registered via :func:`codecs.register_error`, see "
"section :ref:`codec-base-classes`. For a list of possible encodings, see "
"section :ref:`standard-encodings`."
msgstr ""

#: ../../../library/stdtypes.rst:852
msgid ""
"Support for ``'xmlcharrefreplace'`` and ``'backslashreplace'`` and other "
"error handling schemes added."
msgstr ""

#: ../../../library/stdtypes.rst:859
msgid ""
"Return ``True`` if the string ends with the specified *suffix*, otherwise "
"return ``False``.  *suffix* can also be a tuple of suffixes to look for.  "
"With optional *start*, test beginning at that position.  With optional "
"*end*, stop comparing at that position."
msgstr ""

#: ../../../library/stdtypes.rst:864
msgid "Accept tuples as *suffix*."
msgstr ""

#: ../../../library/stdtypes.rst:870
msgid ""
"Return a copy of the string where all tab characters are replaced by one or "
"more spaces, depending on the current column and the given tab size.  The "
"column number is reset to zero after each newline occurring in the string. "
"If *tabsize* is not given, a tab size of ``8`` characters is assumed.  This "
"doesn't understand other non-printing characters or escape sequences."
msgstr ""

#: ../../../library/stdtypes.rst:879
msgid ""
"Return the lowest index in the string where substring *sub* is found, such "
"that *sub* is contained in the slice ``s[start:end]``.  Optional arguments "
"*start* and *end* are interpreted as in slice notation.  Return ``-1`` if "
"*sub* is not found."
msgstr ""

#: ../../../library/stdtypes.rst:887
msgid ""
"Perform a string formatting operation.  The string on which this method is "
"called can contain literal text or replacement fields delimited by braces "
"``{}``.  Each replacement field contains either the numeric index of a "
"positional argument, or the name of a keyword argument.  Returns a copy of "
"the string where each replacement field is replaced with the string value of "
"the corresponding argument."
msgstr ""

#: ../../../library/stdtypes.rst:897
msgid ""
"See :ref:`formatstrings` for a description of the various formatting options "
"that can be specified in format strings."
msgstr ""

#: ../../../library/stdtypes.rst:900
msgid ""
"This method of string formatting is the new standard in Python 3.0, and "
"should be preferred to the ``%`` formatting described in :ref:`string-"
"formatting` in new code."
msgstr ""

#: ../../../library/stdtypes.rst:909
msgid ""
"Like :meth:`find`, but raise :exc:`ValueError` when the substring is not "
"found."
msgstr ""

#: ../../../library/stdtypes.rst:914
msgid ""
"Return true if all characters in the string are alphanumeric and there is at "
"least one character, false otherwise."
msgstr ""

#: ../../../library/stdtypes.rst:922
msgid ""
"Return true if all characters in the string are alphabetic and there is at "
"least one character, false otherwise."
msgstr ""

#: ../../../library/stdtypes.rst:930
msgid ""
"Return true if all characters in the string are digits and there is at least "
"one character, false otherwise."
msgstr ""

#: ../../../library/stdtypes.rst:938
msgid ""
"Return true if all cased characters in the string are lowercase and there is "
"at least one cased character, false otherwise."
msgstr ""

#: ../../../library/stdtypes.rst:946
msgid ""
"Return true if there are only whitespace characters in the string and there "
"is at least one character, false otherwise."
msgstr ""

#: ../../../library/stdtypes.rst:954
msgid ""
"Return true if the string is a titlecased string and there is at least one "
"character, for example uppercase characters may only follow uncased "
"characters and lowercase characters only cased ones.  Return false otherwise."
msgstr ""

#: ../../../library/stdtypes.rst:963
msgid ""
"Return true if all cased characters in the string are uppercase and there is "
"at least one cased character, false otherwise."
msgstr ""

#: ../../../library/stdtypes.rst:971
msgid ""
"Return a string which is the concatenation of the strings in the :term:"
"`iterable` *iterable*.  The separator between elements is the string "
"providing this method."
msgstr ""

#: ../../../library/stdtypes.rst:978
msgid ""
"Return the string left justified in a string of length *width*. Padding is "
"done using the specified *fillchar* (default is a space).  The original "
"string is returned if *width* is less than ``len(s)``."
msgstr ""

#: ../../../library/stdtypes.rst:988
msgid "Return a copy of the string converted to lowercase."
msgstr ""

#: ../../../library/stdtypes.rst:995
msgid ""
"Return a copy of the string with leading characters removed.  The *chars* "
"argument is a string specifying the set of characters to be removed.  If "
"omitted or ``None``, the *chars* argument defaults to removing whitespace.  "
"The *chars* argument is not a prefix; rather, all combinations of its values "
"are stripped:"
msgstr ""

#: ../../../library/stdtypes.rst:1005 ../../../library/stdtypes.rst:1082
#: ../../../library/stdtypes.rst:1142
msgid "Support for the *chars* argument."
msgstr ""

#: ../../../library/stdtypes.rst:1011
msgid ""
"Split the string at the first occurrence of *sep*, and return a 3-tuple "
"containing the part before the separator, the separator itself, and the part "
"after the separator.  If the separator is not found, return a 3-tuple "
"containing the string itself, followed by two empty strings."
msgstr ""

#: ../../../library/stdtypes.rst:1021
msgid ""
"Return a copy of the string with all occurrences of substring *old* replaced "
"by *new*.  If the optional argument *count* is given, only the first *count* "
"occurrences are replaced."
msgstr ""

#: ../../../library/stdtypes.rst:1028
msgid ""
"Return the highest index in the string where substring *sub* is found, such "
"that *sub* is contained within ``s[start:end]``.  Optional arguments *start* "
"and *end* are interpreted as in slice notation.  Return ``-1`` on failure."
msgstr ""

#: ../../../library/stdtypes.rst:1035
msgid ""
"Like :meth:`rfind` but raises :exc:`ValueError` when the substring *sub* is "
"not found."
msgstr ""

#: ../../../library/stdtypes.rst:1041
msgid ""
"Return the string right justified in a string of length *width*. Padding is "
"done using the specified *fillchar* (default is a space). The original "
"string is returned if *width* is less than ``len(s)``."
msgstr ""

#: ../../../library/stdtypes.rst:1051
msgid ""
"Split the string at the last occurrence of *sep*, and return a 3-tuple "
"containing the part before the separator, the separator itself, and the part "
"after the separator.  If the separator is not found, return a 3-tuple "
"containing two empty strings, followed by the string itself."
msgstr ""

#: ../../../library/stdtypes.rst:1061
msgid ""
"Return a list of the words in the string, using *sep* as the delimiter "
"string. If *maxsplit* is given, at most *maxsplit* splits are done, the "
"*rightmost* ones.  If *sep* is not specified or ``None``, any whitespace "
"string is a separator.  Except for splitting from the right, :meth:`rsplit` "
"behaves like :meth:`split` which is described in detail below."
msgstr ""

#: ../../../library/stdtypes.rst:1072
msgid ""
"Return a copy of the string with trailing characters removed.  The *chars* "
"argument is a string specifying the set of characters to be removed.  If "
"omitted or ``None``, the *chars* argument defaults to removing whitespace.  "
"The *chars* argument is not a suffix; rather, all combinations of its values "
"are stripped:"
msgstr ""

#: ../../../library/stdtypes.rst:1088
msgid ""
"Return a list of the words in the string, using *sep* as the delimiter "
"string.  If *maxsplit* is given, at most *maxsplit* splits are done (thus, "
"the list will have at most ``maxsplit+1`` elements).  If *maxsplit* is not "
"specified, then there is no limit on the number of splits (all possible "
"splits are made)."
msgstr ""

#: ../../../library/stdtypes.rst:1094
msgid ""
"If *sep* is given, consecutive delimiters are not grouped together and are "
"deemed to delimit empty strings (for example, ``'1,,2'.split(',')`` returns "
"``['1', '', '2']``).  The *sep* argument may consist of multiple characters "
"(for example, ``'1<>2<>3'.split('<>')`` returns ``['1', '2', '3']``). "
"Splitting an empty string with a specified separator returns ``['']``."
msgstr ""

#: ../../../library/stdtypes.rst:1100
msgid ""
"If *sep* is not specified or is ``None``, a different splitting algorithm is "
"applied: runs of consecutive whitespace are regarded as a single separator, "
"and the result will contain no empty strings at the start or end if the "
"string has leading or trailing whitespace.  Consequently, splitting an empty "
"string or a string consisting of just whitespace with a ``None`` separator "
"returns ``[]``."
msgstr ""

#: ../../../library/stdtypes.rst:1107
msgid ""
"For example, ``' 1  2   3  '.split()`` returns ``['1', '2', '3']``, and ``'  "
"1  2   3  '.split(None, 1)`` returns ``['1', '2   3  ']``."
msgstr ""

#: ../../../library/stdtypes.rst:1113
msgid ""
"Return a list of the lines in the string, breaking at line boundaries.  Line "
"breaks are not included in the resulting list unless *keepends* is given and "
"true."
msgstr ""

#: ../../../library/stdtypes.rst:1120
msgid ""
"Return ``True`` if string starts with the *prefix*, otherwise return "
"``False``. *prefix* can also be a tuple of prefixes to look for.  With "
"optional *start*, test string beginning at that position.  With optional "
"*end*, stop comparing string at that position."
msgstr ""

#: ../../../library/stdtypes.rst:1125
msgid "Accept tuples as *prefix*."
msgstr ""

#: ../../../library/stdtypes.rst:1131
msgid ""
"Return a copy of the string with the leading and trailing characters "
"removed. The *chars* argument is a string specifying the set of characters "
"to be removed. If omitted or ``None``, the *chars* argument defaults to "
"removing whitespace. The *chars* argument is not a prefix or suffix; rather, "
"all combinations of its values are stripped:"
msgstr ""

#: ../../../library/stdtypes.rst:1148
msgid ""
"Return a copy of the string with uppercase characters converted to lowercase "
"and vice versa."
msgstr ""

#: ../../../library/stdtypes.rst:1156
msgid ""
"Return a titlecased version of the string where words start with an "
"uppercase character and the remaining characters are lowercase."
msgstr ""

#: ../../../library/stdtypes.rst:1159
msgid ""
"The algorithm uses a simple language-independent definition of a word as "
"groups of consecutive letters.  The definition works in many contexts but it "
"means that apostrophes in contractions and possessives form word boundaries, "
"which may not be the desired result::"
msgstr ""

#: ../../../library/stdtypes.rst:1167
msgid ""
"A workaround for apostrophes can be constructed using regular expressions::"
msgstr ""

#: ../../../library/stdtypes.rst:1184
msgid ""
"Return a copy of the string where all characters occurring in the optional "
"argument *deletechars* are removed, and the remaining characters have been "
"mapped through the given translation table, which must be a string of length "
"256."
msgstr ""

#: ../../../library/stdtypes.rst:1189
msgid ""
"You can use the :func:`~string.maketrans` helper function in the :mod:"
"`string` module to create a translation table. For string objects, set the "
"*table* argument to ``None`` for translations that only delete characters:"
msgstr ""

#: ../../../library/stdtypes.rst:1196
msgid "Support for a ``None`` *table* argument."
msgstr ""

#: ../../../library/stdtypes.rst:1199
msgid ""
"For Unicode objects, the :meth:`translate` method does not accept the "
"optional *deletechars* argument.  Instead, it returns a copy of the *s* "
"where all characters have been mapped through the given translation table "
"which must be a mapping of Unicode ordinals to Unicode ordinals, Unicode "
"strings or ``None``. Unmapped characters are left untouched. Characters "
"mapped to ``None`` are deleted.  Note, a more flexible approach is to create "
"a custom character mapping codec using the :mod:`codecs` module (see :mod:"
"`encodings.cp1251` for an example)."
msgstr ""

#: ../../../library/stdtypes.rst:1211
msgid "Return a copy of the string converted to uppercase."
msgstr ""

#: ../../../library/stdtypes.rst:1218
msgid ""
"Return the numeric string left filled with zeros in a string of length "
"*width*.  A sign prefix is handled correctly.  The original string is "
"returned if *width* is less than ``len(s)``."
msgstr ""

#: ../../../library/stdtypes.rst:1225
msgid "The following methods are present only on unicode objects:"
msgstr ""

#: ../../../library/stdtypes.rst:1229
msgid ""
"Return ``True`` if there are only numeric characters in S, ``False`` "
"otherwise. Numeric characters include digit characters, and all characters "
"that have the Unicode numeric value property, e.g. U+2155, VULGAR FRACTION "
"ONE FIFTH."
msgstr ""

#: ../../../library/stdtypes.rst:1236
msgid ""
"Return ``True`` if there are only decimal characters in S, ``False`` "
"otherwise. Decimal characters include digit characters, and all characters "
"that that can be used to form decimal-radix numbers, e.g. U+0660, ARABIC-"
"INDIC DIGIT ZERO."
msgstr ""

#: ../../../library/stdtypes.rst:1245
msgid "String Formatting Operations"
msgstr ""

#: ../../../library/stdtypes.rst:1257
msgid ""
"String and Unicode objects have one unique built-in operation: the ``%`` "
"operator (modulo).  This is also known as the string *formatting* or "
"*interpolation* operator.  Given ``format % values`` (where *format* is a "
"string or Unicode object), ``%`` conversion specifications in *format* are "
"replaced with zero or more elements of *values*.  The effect is similar to "
"the using :cfunc:`sprintf` in the C language.  If *format* is a Unicode "
"object, or if any of the objects being converted using the ``%s`` conversion "
"are Unicode objects, the result will also be a Unicode object."
msgstr ""

#: ../../../library/stdtypes.rst:1266
msgid ""
"If *format* requires a single argument, *values* may be a single non-tuple "
"object. [#]_  Otherwise, *values* must be a tuple with exactly the number of "
"items specified by the format string, or a single mapping object (for "
"example, a dictionary)."
msgstr ""

#: ../../../library/stdtypes.rst:1271
msgid ""
"A conversion specifier contains two or more characters and has the following "
"components, which must occur in this order:"
msgstr ""

#: ../../../library/stdtypes.rst:1274
msgid "The ``'%'`` character, which marks the start of the specifier."
msgstr ""

#: ../../../library/stdtypes.rst:1276
msgid ""
"Mapping key (optional), consisting of a parenthesised sequence of characters "
"(for example, ``(somename)``)."
msgstr ""

#: ../../../library/stdtypes.rst:1279
msgid ""
"Conversion flags (optional), which affect the result of some conversion "
"types."
msgstr ""

#: ../../../library/stdtypes.rst:1282
msgid ""
"Minimum field width (optional).  If specified as an ``'*'`` (asterisk), the "
"actual width is read from the next element of the tuple in *values*, and the "
"object to convert comes after the minimum field width and optional precision."
msgstr ""

#: ../../../library/stdtypes.rst:1286
msgid ""
"Precision (optional), given as a ``'.'`` (dot) followed by the precision.  "
"If specified as ``'*'`` (an asterisk), the actual width is read from the "
"next element of the tuple in *values*, and the value to convert comes after "
"the precision."
msgstr ""

#: ../../../library/stdtypes.rst:1291
msgid "Length modifier (optional)."
msgstr ""

#: ../../../library/stdtypes.rst:1293
msgid "Conversion type."
msgstr ""

#: ../../../library/stdtypes.rst:1295
msgid ""
"When the right argument is a dictionary (or other mapping type), then the "
"formats in the string *must* include a parenthesised mapping key into that "
"dictionary inserted immediately after the ``'%'`` character. The mapping key "
"selects the value to be formatted from the mapping.  For example:"
msgstr ""

#: ../../../library/stdtypes.rst:1304
msgid ""
"In this case no ``*`` specifiers may occur in a format (since they require a "
"sequential parameter list)."
msgstr ""

#: ../../../library/stdtypes.rst:1307
msgid "The conversion flag characters are:"
msgstr ""

#: ../../../library/stdtypes.rst:1310
msgid "Flag"
msgstr ""

#: ../../../library/stdtypes.rst:1312
msgid "``'#'``"
msgstr ""

#: ../../../library/stdtypes.rst:1312
msgid ""
"The value conversion will use the \"alternate form\" (where defined below)."
msgstr ""

#: ../../../library/stdtypes.rst:1315
msgid "``'0'``"
msgstr ""

#: ../../../library/stdtypes.rst:1315
msgid "The conversion will be zero padded for numeric values."
msgstr ""

#: ../../../library/stdtypes.rst:1317
msgid "``'-'``"
msgstr ""

#: ../../../library/stdtypes.rst:1317
msgid ""
"The converted value is left adjusted (overrides the ``'0'`` conversion if "
"both are given)."
msgstr ""

#: ../../../library/stdtypes.rst:1320
msgid "``' '``"
msgstr ""

#: ../../../library/stdtypes.rst:1320
msgid ""
"(a space) A blank should be left before a positive number (or empty string) "
"produced by a signed conversion."
msgstr ""

#: ../../../library/stdtypes.rst:1323
msgid "``'+'``"
msgstr ""

#: ../../../library/stdtypes.rst:1323
msgid ""
"A sign character (``'+'`` or ``'-'``) will precede the conversion (overrides "
"a \"space\" flag)."
msgstr ""

#: ../../../library/stdtypes.rst:1327
msgid ""
"A length modifier (``h``, ``l``, or ``L``) may be present, but is ignored as "
"it is not necessary for Python -- so e.g. ``%ld`` is identical to ``%d``."
msgstr ""

#: ../../../library/stdtypes.rst:1330
msgid "The conversion types are:"
msgstr ""

#: ../../../library/stdtypes.rst:1333
msgid "Conversion"
msgstr ""

#: ../../../library/stdtypes.rst:1335
msgid "``'d'``"
msgstr ""

#: ../../../library/stdtypes.rst:1335 ../../../library/stdtypes.rst:1337
msgid "Signed integer decimal."
msgstr ""

#: ../../../library/stdtypes.rst:1337
msgid "``'i'``"
msgstr ""

#: ../../../library/stdtypes.rst:1339
msgid "``'o'``"
msgstr ""

#: ../../../library/stdtypes.rst:1339
msgid "Signed octal value."
msgstr ""

#: ../../../library/stdtypes.rst:1341
msgid "``'u'``"
msgstr ""

#: ../../../library/stdtypes.rst:1341
msgid "Obsolete type -- it is identical to ``'d'``."
msgstr ""

#: ../../../library/stdtypes.rst:1343
msgid "``'x'``"
msgstr ""

#: ../../../library/stdtypes.rst:1343
msgid "Signed hexadecimal (lowercase)."
msgstr ""

#: ../../../library/stdtypes.rst:1345
msgid "``'X'``"
msgstr ""

#: ../../../library/stdtypes.rst:1345
msgid "Signed hexadecimal (uppercase)."
msgstr ""

#: ../../../library/stdtypes.rst:1347
msgid "``'e'``"
msgstr ""

#: ../../../library/stdtypes.rst:1347
msgid "Floating point exponential format (lowercase)."
msgstr ""

#: ../../../library/stdtypes.rst:1349
msgid "``'E'``"
msgstr ""

#: ../../../library/stdtypes.rst:1349
msgid "Floating point exponential format (uppercase)."
msgstr ""

#: ../../../library/stdtypes.rst:1351
msgid "``'f'``"
msgstr ""

#: ../../../library/stdtypes.rst:1351 ../../../library/stdtypes.rst:1353
msgid "Floating point decimal format."
msgstr ""

#: ../../../library/stdtypes.rst:1353
msgid "``'F'``"
msgstr ""

#: ../../../library/stdtypes.rst:1355
msgid "``'g'``"
msgstr ""

#: ../../../library/stdtypes.rst:1355
msgid ""
"Floating point format. Uses lowercase exponential format if exponent is less "
"than -4 or not less than precision, decimal format otherwise."
msgstr ""

#: ../../../library/stdtypes.rst:1359
msgid "``'G'``"
msgstr ""

#: ../../../library/stdtypes.rst:1359
msgid ""
"Floating point format. Uses uppercase exponential format if exponent is less "
"than -4 or not less than precision, decimal format otherwise."
msgstr ""

#: ../../../library/stdtypes.rst:1363
msgid "``'c'``"
msgstr ""

#: ../../../library/stdtypes.rst:1363
msgid "Single character (accepts integer or single character string)."
msgstr ""

#: ../../../library/stdtypes.rst:1366
msgid "``'r'``"
msgstr ""

#: ../../../library/stdtypes.rst:1366
msgid "String (converts any Python object using :func:`repr`)."
msgstr ""

#: ../../../library/stdtypes.rst:1366 ../../../library/stdtypes.rst:1496
msgid "\\(5)"
msgstr ""

#: ../../../library/stdtypes.rst:1369
msgid "``'s'``"
msgstr ""

#: ../../../library/stdtypes.rst:1369
msgid "String (converts any Python object using :func:`str`)."
msgstr ""

#: ../../../library/stdtypes.rst:1372
msgid "``'%'``"
msgstr ""

#: ../../../library/stdtypes.rst:1372
msgid "No argument is converted, results in a ``'%'`` character in the result."
msgstr ""

#: ../../../library/stdtypes.rst:1379
msgid ""
"The alternate form causes a leading zero (``'0'``) to be inserted between "
"left-hand padding and the formatting of the number if the leading character "
"of the result is not already a zero."
msgstr ""

#: ../../../library/stdtypes.rst:1384
msgid ""
"The alternate form causes a leading ``'0x'`` or ``'0X'`` (depending on "
"whether the ``'x'`` or ``'X'`` format was used) to be inserted between left-"
"hand padding and the formatting of the number if the leading character of "
"the result is not already a zero."
msgstr ""

#: ../../../library/stdtypes.rst:1390
msgid ""
"The alternate form causes the result to always contain a decimal point, even "
"if no digits follow it."
msgstr ""

#: ../../../library/stdtypes.rst:1393
msgid ""
"The precision determines the number of digits after the decimal point and "
"defaults to 6."
msgstr ""

#: ../../../library/stdtypes.rst:1397
msgid ""
"The alternate form causes the result to always contain a decimal point, and "
"trailing zeroes are not removed as they would otherwise be."
msgstr ""

#: ../../../library/stdtypes.rst:1400
msgid ""
"The precision determines the number of significant digits before and after "
"the decimal point and defaults to 6."
msgstr ""

#: ../../../library/stdtypes.rst:1404
msgid "The ``%r`` conversion was added in Python 2.0."
msgstr ""

#: ../../../library/stdtypes.rst:1406 ../../../library/stdtypes.rst:1412
msgid "The precision determines the maximal number of characters used."
msgstr ""

#: ../../../library/stdtypes.rst:1409
msgid ""
"If the object or format provided is a :class:`unicode` string, the resulting "
"string will also be :class:`unicode`."
msgstr ""

#: ../../../library/stdtypes.rst:1415
msgid "See :pep:`237`."
msgstr ""

#: ../../../library/stdtypes.rst:1417
msgid ""
"Since Python strings have an explicit length, ``%s`` conversions do not "
"assume that ``'\\0'`` is the end of the string."
msgstr ""

#: ../../../library/stdtypes.rst:1422
msgid ""
"For safety reasons, floating point precisions are clipped to 50; ``%f`` "
"conversions for numbers whose absolute value is over 1e50 are replaced by "
"``%g`` conversions. [#]_  All other errors raise exceptions."
msgstr ""

#: ../../../library/stdtypes.rst:1430
msgid ""
"Additional string operations are defined in standard modules :mod:`string` "
"and :mod:`re`."
msgstr ""

#: ../../../library/stdtypes.rst:1437
msgid "XRange Type"
msgstr ""

#: ../../../library/stdtypes.rst:1441
msgid ""
"The :class:`xrange` type is an immutable sequence which is commonly used for "
"looping.  The advantage of the :class:`xrange` type is that an :class:"
"`xrange` object will always take the same amount of memory, no matter the "
"size of the range it represents.  There are no consistent performance "
"advantages."
msgstr ""

#: ../../../library/stdtypes.rst:1446
msgid ""
"XRange objects have very little behavior: they only support indexing, "
"iteration, and the :func:`len` function."
msgstr ""

#: ../../../library/stdtypes.rst:1453
msgid "Mutable Sequence Types"
msgstr ""

#: ../../../library/stdtypes.rst:1459
msgid ""
"List objects support additional operations that allow in-place modification "
"of the object. Other mutable sequence types (when added to the language) "
"should also support these operations. Strings and tuples are immutable "
"sequence types: such objects cannot be modified once created. The following "
"operations are defined on mutable sequence types (where *x* is an arbitrary "
"object):"
msgstr ""

#: ../../../library/stdtypes.rst:1468
msgid "``s[i] = x``"
msgstr ""

#: ../../../library/stdtypes.rst:1468
msgid "item *i* of *s* is replaced by *x*"
msgstr ""

#: ../../../library/stdtypes.rst:1471
msgid "``s[i:j] = t``"
msgstr ""

#: ../../../library/stdtypes.rst:1471
msgid ""
"slice of *s* from *i* to *j* is replaced by the contents of the iterable *t*"
msgstr ""

#: ../../../library/stdtypes.rst:1475
msgid "``del s[i:j]``"
msgstr ""

#: ../../../library/stdtypes.rst:1475
msgid "same as ``s[i:j] = []``"
msgstr ""

#: ../../../library/stdtypes.rst:1477
msgid "``s[i:j:k] = t``"
msgstr ""

#: ../../../library/stdtypes.rst:1477
msgid "the elements of ``s[i:j:k]`` are replaced by those of *t*"
msgstr ""

#: ../../../library/stdtypes.rst:1480
msgid "``del s[i:j:k]``"
msgstr ""

#: ../../../library/stdtypes.rst:1480
msgid "removes the elements of ``s[i:j:k]`` from the list"
msgstr ""

#: ../../../library/stdtypes.rst:1483
msgid "``s.append(x)``"
msgstr ""

#: ../../../library/stdtypes.rst:1483
msgid "same as ``s[len(s):len(s)] = [x]``"
msgstr ""

#: ../../../library/stdtypes.rst:1486
msgid "``s.extend(x)``"
msgstr ""

#: ../../../library/stdtypes.rst:1486
msgid "same as ``s[len(s):len(s)] = x``"
msgstr ""

#: ../../../library/stdtypes.rst:1489
msgid "``s.count(x)``"
msgstr ""

#: ../../../library/stdtypes.rst:1489
msgid "return number of *i*'s for which ``s[i] == x``"
msgstr ""

#: ../../../library/stdtypes.rst:1492
msgid "``s.index(x[, i[, j]])``"
msgstr ""

#: ../../../library/stdtypes.rst:1492
msgid "return smallest *k* such that ``s[k] == x`` and ``i <= k < j``"
msgstr ""

#: ../../../library/stdtypes.rst:1496
msgid "``s.insert(i, x)``"
msgstr ""

#: ../../../library/stdtypes.rst:1496
msgid "same as ``s[i:i] = [x]``"
msgstr ""

#: ../../../library/stdtypes.rst:1498
msgid "``s.pop([i])``"
msgstr ""

#: ../../../library/stdtypes.rst:1498
msgid "same as ``x = s[i]; del s[i]; return x``"
msgstr ""

#: ../../../library/stdtypes.rst:1501
msgid "``s.remove(x)``"
msgstr ""

#: ../../../library/stdtypes.rst:1501
msgid "same as ``del s[s.index(x)]``"
msgstr ""

#: ../../../library/stdtypes.rst:1503
msgid "``s.reverse()``"
msgstr ""

#: ../../../library/stdtypes.rst:1503
msgid "reverses the items of *s* in place"
msgstr ""

#: ../../../library/stdtypes.rst:1506
msgid "``s.sort([cmp[, key[, reverse]]])``"
msgstr ""

#: ../../../library/stdtypes.rst:1506
msgid "sort the items of *s* in place"
msgstr ""

#: ../../../library/stdtypes.rst:1506
msgid "(7)(8)(9)(10)"
msgstr ""

#: ../../../library/stdtypes.rst:1530
msgid "*t* must have the same length as the slice it is  replacing."
msgstr ""

#: ../../../library/stdtypes.rst:1533
msgid ""
"The C implementation of Python has historically accepted multiple parameters "
"and implicitly joined them into a tuple; this no longer works in Python "
"2.0.  Use of this misfeature has been deprecated since Python 1.4."
msgstr ""

#: ../../../library/stdtypes.rst:1538
msgid "*x* can be any iterable object."
msgstr ""

#: ../../../library/stdtypes.rst:1541
msgid ""
"Raises :exc:`ValueError` when *x* is not found in *s*. When a negative index "
"is passed as the second or third parameter to the :meth:`index` method, the "
"list length is added, as for slice indices.  If it is still negative, it is "
"truncated to zero, as for slice indices."
msgstr ""

#: ../../../library/stdtypes.rst:1546
msgid ""
"Previously, :meth:`index` didn't have arguments for specifying start and "
"stop positions."
msgstr ""

#: ../../../library/stdtypes.rst:1551
msgid ""
"When a negative index is passed as the first parameter to the :meth:`insert` "
"method, the list length is added, as for slice indices.  If it is still "
"negative, it is truncated to zero, as for slice indices."
msgstr ""

#: ../../../library/stdtypes.rst:1555
msgid "Previously, all negative indices were truncated to zero."
msgstr ""

#: ../../../library/stdtypes.rst:1559
msgid ""
"The :meth:`pop` method is only supported by the list and array types.  The "
"optional argument *i* defaults to ``-1``, so that by default the last item "
"is removed and returned."
msgstr ""

#: ../../../library/stdtypes.rst:1564
msgid ""
"The :meth:`sort` and :meth:`reverse` methods modify the list in place for "
"economy of space when sorting or reversing a large list.  To remind you that "
"they operate by side effect, they don't return the sorted or reversed list."
msgstr ""

#: ../../../library/stdtypes.rst:1569
msgid ""
"The :meth:`sort` method takes optional arguments for controlling the "
"comparisons."
msgstr ""

#: ../../../library/stdtypes.rst:1572
msgid ""
"*cmp* specifies a custom comparison function of two arguments (list items) "
"which should return a negative, zero or positive number depending on whether "
"the first argument is considered smaller than, equal to, or larger than the "
"second argument: ``cmp=lambda x,y: cmp(x.lower(), y.lower())``.  The default "
"value is ``None``."
msgstr ""

#: ../../../library/stdtypes.rst:1578
msgid ""
"*key* specifies a function of one argument that is used to extract a "
"comparison key from each list element: ``key=str.lower``.  The default value "
"is ``None``."
msgstr ""

#: ../../../library/stdtypes.rst:1581
msgid ""
"*reverse* is a boolean value.  If set to ``True``, then the list elements "
"are sorted as if each comparison were reversed."
msgstr ""

#: ../../../library/stdtypes.rst:1584
msgid ""
"In general, the *key* and *reverse* conversion processes are much faster "
"than specifying an equivalent *cmp* function.  This is because *cmp* is "
"called multiple times for each list element while *key* and *reverse* touch "
"each element only once."
msgstr ""

#: ../../../library/stdtypes.rst:1589
msgid "Support for ``None`` as an equivalent to omitting *cmp* was added."
msgstr ""

#: ../../../library/stdtypes.rst:1592
msgid "Support for *key* and *reverse* was added."
msgstr ""

#: ../../../library/stdtypes.rst:1596
msgid ""
"Starting with Python 2.3, the :meth:`sort` method is guaranteed to be "
"stable.  A sort is stable if it guarantees not to change the relative order "
"of elements that compare equal --- this is helpful for sorting in multiple "
"passes (for example, sort by department, then by salary grade)."
msgstr ""

#: ../../../library/stdtypes.rst:1604
msgid ""
"While a list is being sorted, the effect of attempting to mutate, or even "
"inspect, the list is undefined.  The C implementation of Python 2.3 and "
"newer makes the list appear empty for the duration, and raises :exc:"
"`ValueError` if it can detect that the list has been mutated during a sort."
msgstr ""

#: ../../../library/stdtypes.rst:1614
msgid "Set Types --- :class:`set`, :class:`frozenset`"
msgstr ""

#: ../../../library/stdtypes.rst:1618
msgid ""
"A :dfn:`set` object is an unordered collection of distinct :term:`hashable` "
"objects. Common uses include membership testing, removing duplicates from a "
"sequence, and computing mathematical operations such as intersection, union, "
"difference, and symmetric difference. (For other containers see the built "
"in :class:`dict`, :class:`list`, and :class:`tuple` classes, and the :mod:"
"`collections` module.)"
msgstr ""

#: ../../../library/stdtypes.rst:1628
msgid ""
"Like other collections, sets support ``x in set``, ``len(set)``, and ``for x "
"in set``.  Being an unordered collection, sets do not record element "
"position or order of insertion.  Accordingly, sets do not support indexing, "
"slicing, or other sequence-like behavior."
msgstr ""

#: ../../../library/stdtypes.rst:1633
msgid ""
"There are currently two built-in set types, :class:`set` and :class:"
"`frozenset`. The :class:`set` type is mutable --- the contents can be "
"changed using methods like :meth:`add` and :meth:`remove`.  Since it is "
"mutable, it has no hash value and cannot be used as either a dictionary key "
"or as an element of another set. The :class:`frozenset` type is immutable "
"and :term:`hashable` --- its contents cannot be altered after it is created; "
"it can therefore be used as a dictionary key or as an element of another set."
msgstr ""

#: ../../../library/stdtypes.rst:1641
msgid "The constructors for both classes work the same:"
msgstr ""

#: ../../../library/stdtypes.rst:1646
msgid ""
"Return a new set or frozenset object whose elements are taken from "
"*iterable*.  The elements of a set must be hashable.  To represent sets of "
"sets, the inner sets must be :class:`frozenset` objects.  If *iterable* is "
"not specified, a new empty set is returned."
msgstr ""

#: ../../../library/stdtypes.rst:1651
msgid ""
"Instances of :class:`set` and :class:`frozenset` provide the following "
"operations:"
msgstr ""

#: ../../../library/stdtypes.rst:1656
msgid "Return the cardinality of set *s*."
msgstr ""

#: ../../../library/stdtypes.rst:1660
msgid "Test *x* for membership in *s*."
msgstr ""

#: ../../../library/stdtypes.rst:1664
msgid "Test *x* for non-membership in *s*."
msgstr ""

#: ../../../library/stdtypes.rst:1668
msgid ""
"Return True if the set has no elements in common with *other*.  Sets are "
"disjoint if and only if their intersection is the empty set."
msgstr ""

#: ../../../library/stdtypes.rst:1676
msgid "Test whether every element in the set is in *other*."
msgstr ""

#: ../../../library/stdtypes.rst:1680
msgid ""
"Test whether the set is a true subset of *other*, that is, ``set <= other "
"and set != other``."
msgstr ""

#: ../../../library/stdtypes.rst:1686
msgid "Test whether every element in *other* is in the set."
msgstr ""

#: ../../../library/stdtypes.rst:1690
msgid ""
"Test whether the set is a true superset of *other*, that is, ``set >= other "
"and set != other``."
msgstr ""

#: ../../../library/stdtypes.rst:1696
msgid "Return a new set with elements from the set and all others."
msgstr ""

#: ../../../library/stdtypes.rst:1698 ../../../library/stdtypes.rst:1706
#: ../../../library/stdtypes.rst:1714 ../../../library/stdtypes.rst:1768
#: ../../../library/stdtypes.rst:1776 ../../../library/stdtypes.rst:1784
msgid "Accepts multiple input iterables."
msgstr ""

#: ../../../library/stdtypes.rst:1704
msgid "Return a new set with elements common to the set and all others."
msgstr ""

#: ../../../library/stdtypes.rst:1712
msgid "Return a new set with elements in the set that are not in the others."
msgstr ""

#: ../../../library/stdtypes.rst:1720
msgid ""
"Return a new set with elements in either the set or *other* but not both."
msgstr ""

#: ../../../library/stdtypes.rst:1724
msgid "Return a new set with a shallow copy of *s*."
msgstr ""

#: ../../../library/stdtypes.rst:1727
msgid ""
"Note, the non-operator versions of :meth:`union`, :meth:`intersection`, :"
"meth:`difference`, and :meth:`symmetric_difference`, :meth:`issubset`, and :"
"meth:`issuperset` methods will accept any iterable as an argument.  In "
"contrast, their operator based counterparts require their arguments to be "
"sets.  This precludes error-prone constructions like ``set('abc') & 'cbs'`` "
"in favor of the more readable ``set('abc').intersection('cbs')``."
msgstr ""

#: ../../../library/stdtypes.rst:1734
msgid ""
"Both :class:`set` and :class:`frozenset` support set to set comparisons. Two "
"sets are equal if and only if every element of each set is contained in the "
"other (each is a subset of the other). A set is less than another set if and "
"only if the first set is a proper subset of the second set (is a subset, but "
"is not equal). A set is greater than another set if and only if the first "
"set is a proper superset of the second set (is a superset, but is not equal)."
msgstr ""

#: ../../../library/stdtypes.rst:1741
msgid ""
"Instances of :class:`set` are compared to instances of :class:`frozenset` "
"based on their members.  For example, ``set('abc') == frozenset('abc')`` "
"returns ``True`` and so does ``set('abc') in set([frozenset('abc')])``."
msgstr ""

#: ../../../library/stdtypes.rst:1745
msgid ""
"The subset and equality comparisons do not generalize to a complete ordering "
"function.  For example, any two disjoint sets are not equal and are not "
"subsets of each other, so *all* of the following return ``False``: ``a<b``, "
"``a==b``, or ``a>b``. Accordingly, sets do not implement the :meth:`__cmp__` "
"method."
msgstr ""

#: ../../../library/stdtypes.rst:1751
msgid ""
"Since sets only define partial ordering (subset relationships), the output "
"of the :meth:`list.sort` method is undefined for lists of sets."
msgstr ""

#: ../../../library/stdtypes.rst:1754
msgid "Set elements, like dictionary keys, must be :term:`hashable`."
msgstr ""

#: ../../../library/stdtypes.rst:1756
msgid ""
"Binary operations that mix :class:`set` instances with :class:`frozenset` "
"return the type of the first operand.  For example: ``frozenset('ab') | "
"set('bc')`` returns an instance of :class:`frozenset`."
msgstr ""

#: ../../../library/stdtypes.rst:1760
msgid ""
"The following table lists operations available for :class:`set` that do not "
"apply to immutable instances of :class:`frozenset`:"
msgstr ""

#: ../../../library/stdtypes.rst:1766
msgid "Update the set, adding elements from all others."
msgstr ""

#: ../../../library/stdtypes.rst:1774
msgid "Update the set, keeping only elements found in it and all others."
msgstr ""

#: ../../../library/stdtypes.rst:1782
msgid "Update the set, removing elements found in others."
msgstr ""

#: ../../../library/stdtypes.rst:1790
msgid ""
"Update the set, keeping only elements found in either set, but not in both."
msgstr ""

#: ../../../library/stdtypes.rst:1794
msgid "Add element *elem* to the set."
msgstr ""

#: ../../../library/stdtypes.rst:1798
msgid ""
"Remove element *elem* from the set.  Raises :exc:`KeyError` if *elem* is not "
"contained in the set."
msgstr ""

#: ../../../library/stdtypes.rst:1803
msgid "Remove element *elem* from the set if it is present."
msgstr ""

#: ../../../library/stdtypes.rst:1807
msgid ""
"Remove and return an arbitrary element from the set.  Raises :exc:`KeyError` "
"if the set is empty."
msgstr ""

#: ../../../library/stdtypes.rst:1812
msgid "Remove all elements from the set."
msgstr ""

#: ../../../library/stdtypes.rst:1815
msgid ""
"Note, the non-operator versions of the :meth:`update`, :meth:"
"`intersection_update`, :meth:`difference_update`, and :meth:"
"`symmetric_difference_update` methods will accept any iterable as an "
"argument."
msgstr ""

#: ../../../library/stdtypes.rst:1820
msgid ""
"Note, the *elem* argument to the :meth:`__contains__`, :meth:`remove`, and :"
"meth:`discard` methods may be a set.  To support searching for an equivalent "
"frozenset, the *elem* set is temporarily mutated during the search and then "
"restored.  During the search, the *elem* set should not be read or mutated "
"since it does not have a meaningful value."
msgstr ""

#: ../../../library/stdtypes.rst:1829
msgid ":ref:`comparison-to-builtin-set`"
msgstr ""

#: ../../../library/stdtypes.rst:1830
msgid "Differences between the :mod:`sets` module and the built-in set types."
msgstr ""

#: ../../../library/stdtypes.rst:1836
msgid "Mapping Types --- :class:`dict`"
msgstr ""

#: ../../../library/stdtypes.rst:1846
msgid ""
"A :dfn:`mapping` object maps :term:`hashable` values to arbitrary objects. "
"Mappings are mutable objects.  There is currently only one standard mapping "
"type, the :dfn:`dictionary`.  (For other containers see the built in :class:"
"`list`, :class:`set`, and :class:`tuple` classes, and the :mod:`collections` "
"module.)"
msgstr ""

#: ../../../library/stdtypes.rst:1852
msgid ""
"A dictionary's keys are *almost* arbitrary values.  Values that are not :"
"term:`hashable`, that is, values containing lists, dictionaries or other "
"mutable types (that are compared by value rather than by object identity) "
"may not be used as keys.  Numeric types used for keys obey the normal rules "
"for numeric comparison: if two numbers compare equal (such as ``1`` and "
"``1.0``) then they can be used interchangeably to index the same dictionary "
"entry.  (Note however, that since computers store floating-point numbers as "
"approximations it is usually unwise to use them as dictionary keys.)"
msgstr ""

#: ../../../library/stdtypes.rst:1861
msgid ""
"Dictionaries can be created by placing a comma-separated list of ``key: "
"value`` pairs within braces, for example: ``{'jack': 4098, 'sjoerd': 4127}`` "
"or ``{4098: 'jack', 4127: 'sjoerd'}``, or by the :class:`dict` constructor."
msgstr ""

#: ../../../library/stdtypes.rst:1867
msgid ""
"Return a new dictionary initialized from an optional positional argument or "
"from a set of keyword arguments. If no arguments are given, return a new "
"empty dictionary. If the positional argument *arg* is a mapping object, "
"return a dictionary mapping the same keys to the same values as does the "
"mapping object. Otherwise the positional argument must be a sequence, a "
"container that supports iteration, or an iterator object.  The elements of "
"the argument must each also be of one of those kinds, and each must in turn "
"contain exactly two objects. The first is used as a key in the new "
"dictionary, and the second as the key's value.  If a given key is seen more "
"than once, the last value associated with it is retained in the new "
"dictionary."
msgstr ""

#: ../../../library/stdtypes.rst:1878
msgid ""
"If keyword arguments are given, the keywords themselves with their "
"associated values are added as items to the dictionary. If a key is "
"specified both in the positional argument and as a keyword argument, the "
"value associated with the keyword is retained in the dictionary. For "
"example, these all return a dictionary equal to ``{\"one\": 2, \"two\": 3}``:"
msgstr ""

#: ../../../library/stdtypes.rst:1884
msgid "``dict(one=2, two=3)``"
msgstr ""

#: ../../../library/stdtypes.rst:1886
msgid "``dict({'one': 2, 'two': 3})``"
msgstr ""

#: ../../../library/stdtypes.rst:1888
msgid "``dict(zip(('one', 'two'), (2, 3)))``"
msgstr ""

#: ../../../library/stdtypes.rst:1890
msgid "``dict([['two', 3], ['one', 2]])``"
msgstr ""

#: ../../../library/stdtypes.rst:1892
msgid ""
"The first example only works for keys that are valid Python identifiers; the "
"others work with any valid keys."
msgstr ""

#: ../../../library/stdtypes.rst:1897
msgid "Support for building a dictionary from keyword arguments added."
msgstr ""

#: ../../../library/stdtypes.rst:1901
msgid ""
"These are the operations that dictionaries support (and therefore, custom "
"mapping types should support too):"
msgstr ""

#: ../../../library/stdtypes.rst:1906
msgid "Return the number of items in the dictionary *d*."
msgstr ""

#: ../../../library/stdtypes.rst:1910
msgid ""
"Return the item of *d* with key *key*.  Raises a :exc:`KeyError` if *key* is "
"not in the map."
msgstr ""

#: ../../../library/stdtypes.rst:1913
msgid ""
"If a subclass of dict defines a method :meth:`__missing__`, if the key *key* "
"is not present, the ``d[key]`` operation calls that method with the key "
"*key* as argument.  The ``d[key]`` operation then returns or raises whatever "
"is returned or raised by the ``__missing__(key)`` call if the key is not "
"present. No other operations or methods invoke :meth:`__missing__`. If :meth:"
"`__missing__` is not defined, :exc:`KeyError` is raised.  :meth:"
"`__missing__` must be a method; it cannot be an instance variable. For an "
"example, see :class:`collections.defaultdict`."
msgstr ""

#: ../../../library/stdtypes.rst:1926
msgid "Set ``d[key]`` to *value*."
msgstr ""

#: ../../../library/stdtypes.rst:1930
msgid ""
"Remove ``d[key]`` from *d*.  Raises a :exc:`KeyError` if *key* is not in the "
"map."
msgstr ""

#: ../../../library/stdtypes.rst:1935
msgid "Return ``True`` if *d* has a key *key*, else ``False``."
msgstr ""

#: ../../../library/stdtypes.rst:1941
msgid "Equivalent to ``not key in d``."
msgstr ""

#: ../../../library/stdtypes.rst:1947
msgid ""
"Return an iterator over the keys of the dictionary.  This is a shortcut for :"
"meth:`iterkeys`."
msgstr ""

#: ../../../library/stdtypes.rst:1952
msgid "Remove all items from the dictionary."
msgstr ""

#: ../../../library/stdtypes.rst:1956
msgid "Return a shallow copy of the dictionary."
msgstr ""

#: ../../../library/stdtypes.rst:1960
msgid "Create a new dictionary with keys from *seq* and values set to *value*."
msgstr ""

#: ../../../library/stdtypes.rst:1962
msgid ""
":func:`fromkeys` is a class method that returns a new dictionary. *value* "
"defaults to ``None``."
msgstr ""

#: ../../../library/stdtypes.rst:1969
msgid ""
"Return the value for *key* if *key* is in the dictionary, else *default*. If "
"*default* is not given, it defaults to ``None``, so that this method never "
"raises a :exc:`KeyError`."
msgstr ""

#: ../../../library/stdtypes.rst:1975
msgid ""
"Test for the presence of *key* in the dictionary.  :meth:`has_key` is "
"deprecated in favor of ``key in d``."
msgstr ""

#: ../../../library/stdtypes.rst:1980
msgid "Return a copy of the dictionary's list of ``(key, value)`` pairs."
msgstr ""

#: ../../../library/stdtypes.rst:1984
msgid ""
"Keys and values are listed in an arbitrary order which is non-random, varies "
"across Python implementations, and depends on the dictionary's history of "
"insertions and deletions."
msgstr ""

#: ../../../library/stdtypes.rst:1988
msgid ""
"If :meth:`items`, :meth:`keys`, :meth:`values`, :meth:`iteritems`, :meth:"
"`iterkeys`, and :meth:`itervalues` are called with no intervening "
"modifications to the dictionary, the lists will directly correspond.  This "
"allows the creation of ``(value, key)`` pairs using :func:`zip`: ``pairs = "
"zip(d.values(), d.keys())``.  The same relationship holds for the :meth:"
"`iterkeys` and :meth:`itervalues` methods: ``pairs = zip(d.itervalues(), d."
"iterkeys())`` provides the same value for ``pairs``. Another way to create "
"the same list is ``pairs = [(v, k) for (k, v) in d.iteritems()]``."
msgstr ""

#: ../../../library/stdtypes.rst:2000
msgid ""
"Return an iterator over the dictionary's ``(key, value)`` pairs.  See the "
"note for :meth:`dict.items`."
msgstr ""

#: ../../../library/stdtypes.rst:2003
msgid ""
"Using :meth:`iteritems` while adding or deleting entries in the dictionary "
"may raise a :exc:`RuntimeError` or fail to iterate over all entries."
msgstr ""

#: ../../../library/stdtypes.rst:2010
msgid ""
"Return an iterator over the dictionary's keys.  See the note for :meth:`dict."
"items`."
msgstr ""

#: ../../../library/stdtypes.rst:2013
msgid ""
"Using :meth:`iterkeys` while adding or deleting entries in the dictionary "
"may raise a :exc:`RuntimeError` or fail to iterate over all entries."
msgstr ""

#: ../../../library/stdtypes.rst:2020
msgid ""
"Return an iterator over the dictionary's values.  See the note for :meth:"
"`dict.items`."
msgstr ""

#: ../../../library/stdtypes.rst:2023
msgid ""
"Using :meth:`itervalues` while adding or deleting entries in the dictionary "
"may raise a :exc:`RuntimeError` or fail to iterate over all entries."
msgstr ""

#: ../../../library/stdtypes.rst:2031
msgid ""
"Return a copy of the dictionary's list of keys.  See the note for :meth:"
"`dict.items`."
msgstr ""

#: ../../../library/stdtypes.rst:2036
msgid ""
"If *key* is in the dictionary, remove it and return its value, else return "
"*default*.  If *default* is not given and *key* is not in the dictionary, a :"
"exc:`KeyError` is raised."
msgstr ""

#: ../../../library/stdtypes.rst:2044
msgid ""
"Remove and return an arbitrary ``(key, value)`` pair from the dictionary."
msgstr ""

#: ../../../library/stdtypes.rst:2046
msgid ""
":func:`popitem` is useful to destructively iterate over a dictionary, as "
"often used in set algorithms.  If the dictionary is empty, calling :func:"
"`popitem` raises a :exc:`KeyError`."
msgstr ""

#: ../../../library/stdtypes.rst:2052
msgid ""
"If *key* is in the dictionary, return its value.  If not, insert *key* with "
"a value of *default* and return *default*.  *default* defaults to ``None``."
msgstr ""

#: ../../../library/stdtypes.rst:2058
msgid ""
"Update the dictionary with the key/value pairs from *other*, overwriting "
"existing keys.  Return ``None``."
msgstr ""

#: ../../../library/stdtypes.rst:2061
msgid ""
":func:`update` accepts either another dictionary object or an iterable of "
"key/value pairs (as a tuple or other iterable of length two).  If keyword "
"arguments are specified, the dictionary is then updated with those key/value "
"pairs: ``d.update(red=1, blue=2)``."
msgstr ""

#: ../../../library/stdtypes.rst:2066
msgid ""
"Allowed the argument to be an iterable of key/value pairs and allowed "
"keyword arguments."
msgstr ""

#: ../../../library/stdtypes.rst:2072
msgid ""
"Return a copy of the dictionary's list of values.  See the note for :meth:"
"`dict.items`."
msgstr ""

#: ../../../library/stdtypes.rst:2079
msgid "File Objects"
msgstr ""

#: ../../../library/stdtypes.rst:2087
msgid ""
"File objects are implemented using C's ``stdio`` package and can be created "
"with the built-in :func:`open` function.  File objects are also returned by "
"some other built-in functions and methods, such as :func:`os.popen` and :"
"func:`os.fdopen` and the :meth:`makefile` method of socket objects. "
"Temporary files can be created using the :mod:`tempfile` module, and high-"
"level file operations such as copying, moving, and deleting files and "
"directories can be achieved with the :mod:`shutil` module."
msgstr ""

#: ../../../library/stdtypes.rst:2096
msgid ""
"When a file operation fails for an I/O-related reason, the exception :exc:"
"`IOError` is raised.  This includes situations where the operation is not "
"defined for some reason, like :meth:`seek` on a tty device or writing a file "
"opened for reading."
msgstr ""

#: ../../../library/stdtypes.rst:2101
msgid "Files have the following methods:"
msgstr ""

#: ../../../library/stdtypes.rst:2106
msgid ""
"Close the file.  A closed file cannot be read or written any more. Any "
"operation which requires that the file be open will raise a :exc:"
"`ValueError` after the file has been closed.  Calling :meth:`close` more "
"than once is allowed."
msgstr ""

#: ../../../library/stdtypes.rst:2110
msgid ""
"As of Python 2.5, you can avoid having to call this method explicitly if you "
"use the :keyword:`with` statement.  For example, the following code will "
"automatically close *f* when the :keyword:`with` block is exited::"
msgstr ""

#: ../../../library/stdtypes.rst:2120
msgid ""
"In older versions of Python, you would have needed to do this to get the "
"same effect::"
msgstr ""

#: ../../../library/stdtypes.rst:2132
msgid ""
"Not all \"file-like\" types in Python support use as a context manager for "
"the :keyword:`with` statement.  If your code is intended to work with any "
"file-like object, you can use the function :func:`contextlib.closing` "
"instead of using the object directly."
msgstr ""

#: ../../../library/stdtypes.rst:2140
msgid ""
"Flush the internal buffer, like ``stdio``'s :cfunc:`fflush`.  This may be a "
"no-op on some file-like objects."
msgstr ""

#: ../../../library/stdtypes.rst:2145
msgid ""
":meth:`flush` does not necessarily write the file's data to disk.  Use :meth:"
"`flush` followed by :func:`os.fsync` to ensure this behavior."
msgstr ""

#: ../../../library/stdtypes.rst:2155
msgid ""
"Return the integer \"file descriptor\" that is used by the underlying "
"implementation to request I/O operations from the operating system.  This "
"can be useful for other, lower level interfaces that use file descriptors, "
"such as the :mod:`fcntl` module or :func:`os.read` and friends."
msgstr ""

#: ../../../library/stdtypes.rst:2162
msgid ""
"File-like objects which do not have a real file descriptor should *not* "
"provide this method!"
msgstr ""

#: ../../../library/stdtypes.rst:2168
msgid ""
"Return ``True`` if the file is connected to a tty(-like) device, else "
"``False``."
msgstr ""

#: ../../../library/stdtypes.rst:2172
msgid ""
"If a file-like object is not associated with a real file, this method should "
"*not* be implemented."
msgstr ""

#: ../../../library/stdtypes.rst:2178
msgid ""
"A file object is its own iterator, for example ``iter(f)`` returns *f* "
"(unless *f* is closed).  When a file is used as an iterator, typically in a :"
"keyword:`for` loop (for example, ``for line in f: print line``), the :meth:`."
"next` method is called repeatedly.  This method returns the next input line, "
"or raises :exc:`StopIteration` when EOF is hit when the file is open for "
"reading (behavior is undefined when the file is open for writing).  In order "
"to make a :keyword:`for` loop the most efficient way of looping over the "
"lines of a file (a very common operation), the :meth:`next` method uses a "
"hidden read-ahead buffer.  As a consequence of using a read-ahead buffer, "
"combining :meth:`.next` with other file methods (like :meth:`readline`) does "
"not work right.  However, using :meth:`seek` to reposition the file to an "
"absolute position will flush the read-ahead buffer."
msgstr ""

#: ../../../library/stdtypes.rst:2196
msgid ""
"Read at most *size* bytes from the file (less if the read hits EOF before "
"obtaining *size* bytes).  If the *size* argument is negative or omitted, "
"read all data until EOF is reached.  The bytes are returned as a string "
"object.  An empty string is returned when EOF is encountered immediately.  "
"(For certain files, like ttys, it makes sense to continue reading after an "
"EOF is hit.)  Note that this method may call the underlying C function :"
"cfunc:`fread` more than once in an effort to acquire as close to *size* "
"bytes as possible. Also note that when in non-blocking mode, less data than "
"was requested may be returned, even if no *size* parameter was given."
msgstr ""

#: ../../../library/stdtypes.rst:2207
msgid ""
"This function is simply a wrapper for the underlying :cfunc:`fread` C "
"function, and will behave the same in corner cases, such as whether the EOF "
"value is cached."
msgstr ""

#: ../../../library/stdtypes.rst:2214
msgid ""
"Read one entire line from the file.  A trailing newline character is kept in "
"the string (but may be absent when a file ends with an incomplete line). "
"[#]_  If the *size* argument is present and non-negative, it is a maximum "
"byte count (including the trailing newline) and an incomplete line may be "
"returned. An empty string is returned *only* when EOF is encountered "
"immediately."
msgstr ""

#: ../../../library/stdtypes.rst:2222
msgid ""
"Unlike ``stdio``'s :cfunc:`fgets`, the returned string contains null "
"characters (``'\\0'``) if they occurred in the input."
msgstr ""

#: ../../../library/stdtypes.rst:2228
msgid ""
"Read until EOF using :meth:`readline` and return a list containing the lines "
"thus read.  If the optional *sizehint* argument is present, instead of "
"reading up to EOF, whole lines totalling approximately *sizehint* bytes "
"(possibly after rounding up to an internal buffer size) are read.  Objects "
"implementing a file-like interface may choose to ignore *sizehint* if it "
"cannot be implemented, or cannot be implemented efficiently."
msgstr ""

#: ../../../library/stdtypes.rst:2238
msgid "This method returns the same thing as ``iter(f)``."
msgstr ""

#: ../../../library/stdtypes.rst:2242
msgid "Use ``for line in file`` instead."
msgstr ""

#: ../../../library/stdtypes.rst:2248
msgid ""
"Set the file's current position, like ``stdio``'s :cfunc:`fseek`. The "
"*whence* argument is optional and defaults to  ``os.SEEK_SET`` or ``0`` "
"(absolute file positioning); other values are ``os.SEEK_CUR`` or ``1`` (seek "
"relative to the current position) and ``os.SEEK_END`` or ``2``  (seek "
"relative to the file's end).  There is no return value."
msgstr ""

#: ../../../library/stdtypes.rst:2254
msgid ""
"For example, ``f.seek(2, os.SEEK_CUR)`` advances the position by two and ``f."
"seek(-3, os.SEEK_END)`` sets the position to the third to last."
msgstr ""

#: ../../../library/stdtypes.rst:2257
msgid ""
"Note that if the file is opened for appending (mode ``'a'`` or ``'a+'``), "
"any :meth:`seek` operations will be undone at the next write.  If the file "
"is only opened for writing in append mode (mode ``'a'``), this method is "
"essentially a no-op, but it remains useful for files opened in append mode "
"with reading enabled (mode ``'a+'``).  If the file is opened in text mode "
"(without ``'b'``), only offsets returned by :meth:`tell` are legal.  Use of "
"other offsets causes undefined behavior."
msgstr ""

#: ../../../library/stdtypes.rst:2265
msgid "Note that not all file objects are seekable."
msgstr ""

#: ../../../library/stdtypes.rst:2267
msgid "Passing float values as offset has been deprecated."
msgstr ""

#: ../../../library/stdtypes.rst:2273
msgid "Return the file's current position, like ``stdio``'s :cfunc:`ftell`."
msgstr ""

#: ../../../library/stdtypes.rst:2277
msgid ""
"On Windows, :meth:`tell` can return illegal values (after an :cfunc:`fgets`) "
"when reading files with Unix-style line-endings. Use binary mode (``'rb'``) "
"to circumvent this problem."
msgstr ""

#: ../../../library/stdtypes.rst:2284
msgid ""
"Truncate the file's size.  If the optional *size* argument is present, the "
"file is truncated to (at most) that size.  The size defaults to the current "
"position. The current file position is not changed.  Note that if a "
"specified size exceeds the file's current size, the result is platform-"
"dependent:  possibilities include that the file may remain unchanged, "
"increase to the specified size as if zero-filled, or increase to the "
"specified size with undefined new content. Availability:  Windows, many Unix "
"variants."
msgstr ""

#: ../../../library/stdtypes.rst:2295
msgid ""
"Write a string to the file.  There is no return value.  Due to buffering, "
"the string may not actually show up in the file until the :meth:`flush` or :"
"meth:`close` method is called."
msgstr ""

#: ../../../library/stdtypes.rst:2302
msgid ""
"Write a sequence of strings to the file.  The sequence can be any iterable "
"object producing strings, typically a list of strings. There is no return "
"value. (The name is intended to match :meth:`readlines`; :meth:`writelines` "
"does not add line separators.)"
msgstr ""

#: ../../../library/stdtypes.rst:2307
msgid ""
"Files support the iterator protocol.  Each iteration returns the same result "
"as ``file.readline()``, and iteration ends when the :meth:`readline` method "
"returns an empty string."
msgstr ""

#: ../../../library/stdtypes.rst:2311
msgid ""
"File objects also offer a number of other interesting attributes. These are "
"not required for file-like objects, but should be implemented if they make "
"sense for the particular object."
msgstr ""

#: ../../../library/stdtypes.rst:2318
msgid ""
"bool indicating the current state of the file object.  This is a read-only "
"attribute; the :meth:`close` method changes the value. It may not be "
"available on all file-like objects."
msgstr ""

#: ../../../library/stdtypes.rst:2325
msgid ""
"The encoding that this file uses. When Unicode strings are written to a "
"file, they will be converted to byte strings using this encoding. In "
"addition, when the file is connected to a terminal, the attribute gives the "
"encoding that the terminal is likely to use (that  information might be "
"incorrect if the user has misconfigured the  terminal). The attribute is "
"read-only and may not be present on all file-like objects. It may also be "
"``None``, in which case the file uses the system default encoding for "
"converting Unicode strings."
msgstr ""

#: ../../../library/stdtypes.rst:2338
msgid "The Unicode error handler used along with the encoding."
msgstr ""

#: ../../../library/stdtypes.rst:2345
msgid ""
"The I/O mode for the file.  If the file was created using the :func:`open` "
"built-in function, this will be the value of the *mode* parameter.  This is "
"a read-only attribute and may not be present on all file-like objects."
msgstr ""

#: ../../../library/stdtypes.rst:2352
msgid ""
"If the file object was created using :func:`open`, the name of the file. "
"Otherwise, some string that indicates the source of the file object, of the "
"form ``<...>``.  This is a read-only attribute and may not be present on all "
"file-like objects."
msgstr ""

#: ../../../library/stdtypes.rst:2360
msgid ""
"If Python was built with the :option:`--with-universal-newlines` option to :"
"program:`configure` (the default) this read-only attribute exists, and for "
"files opened in universal newline read mode it keeps track of the types of "
"newlines encountered while reading the file. The values it can take are "
"``'\\r'``, ``'\\n'``, ``'\\r\\n'``, ``None`` (unknown, no newlines read yet) "
"or a tuple containing all the newline types seen, to indicate that multiple "
"newline conventions were encountered. For files not opened in universal "
"newline read mode the value of this attribute will be ``None``."
msgstr ""

#: ../../../library/stdtypes.rst:2372
msgid ""
"Boolean that indicates whether a space character needs to be printed before "
"another value when using the :keyword:`print` statement. Classes that are "
"trying to simulate a file object should also have a writable :attr:"
"`softspace` attribute, which should be initialized to zero.  This will be "
"automatic for most classes implemented in Python (care may be needed for "
"objects that override attribute access); types implemented in C will have to "
"provide a writable :attr:`softspace` attribute."
msgstr ""

#: ../../../library/stdtypes.rst:2382
msgid ""
"This attribute is not used to control the :keyword:`print` statement, but to "
"allow the implementation of :keyword:`print` to keep track of its internal "
"state."
msgstr ""

#: ../../../library/stdtypes.rst:2390
msgid "Context Manager Types"
msgstr ""

#: ../../../library/stdtypes.rst:2399
msgid ""
"Python's :keyword:`with` statement supports the concept of a runtime context "
"defined by a context manager.  This is implemented using two separate "
"methods that allow user-defined classes to define a runtime context that is "
"entered before the statement body is executed and exited when the statement "
"ends."
msgstr ""

#: ../../../library/stdtypes.rst:2404
msgid ""
"The :dfn:`context management protocol` consists of a pair of methods that "
"need to be provided for a context manager object to define a runtime context:"
msgstr ""

#: ../../../library/stdtypes.rst:2410
msgid ""
"Enter the runtime context and return either this object or another object "
"related to the runtime context. The value returned by this method is bound "
"to the identifier in the :keyword:`as` clause of :keyword:`with` statements "
"using this context manager."
msgstr ""

#: ../../../library/stdtypes.rst:2415
msgid ""
"An example of a context manager that returns itself is a file object. File "
"objects return themselves from __enter__() to allow :func:`open` to be used "
"as the context expression in a :keyword:`with` statement."
msgstr ""

#: ../../../library/stdtypes.rst:2419
msgid ""
"An example of a context manager that returns a related object is the one "
"returned by :func:`decimal.localcontext`. These managers set the active "
"decimal context to a copy of the original decimal context and then return "
"the copy. This allows changes to be made to the current decimal context in "
"the body of the :keyword:`with` statement without affecting code outside "
"the :keyword:`with` statement."
msgstr ""

#: ../../../library/stdtypes.rst:2429
msgid ""
"Exit the runtime context and return a Boolean flag indicating if any "
"exception that occurred should be suppressed. If an exception occurred while "
"executing the body of the :keyword:`with` statement, the arguments contain "
"the exception type, value and traceback information. Otherwise, all three "
"arguments are ``None``."
msgstr ""

#: ../../../library/stdtypes.rst:2434
msgid ""
"Returning a true value from this method will cause the :keyword:`with` "
"statement to suppress the exception and continue execution with the "
"statement immediately following the :keyword:`with` statement. Otherwise the "
"exception continues propagating after this method has finished executing. "
"Exceptions that occur during execution of this method will replace any "
"exception that occurred in the body of the :keyword:`with` statement."
msgstr ""

#: ../../../library/stdtypes.rst:2441
msgid ""
"The exception passed in should never be reraised explicitly - instead, this "
"method should return a false value to indicate that the method completed "
"successfully and does not want to suppress the raised exception. This allows "
"context management code (such as ``contextlib.nested``) to easily detect "
"whether or not an :meth:`__exit__` method has actually failed."
msgstr ""

#: ../../../library/stdtypes.rst:2447
msgid ""
"Python defines several context managers to support easy thread "
"synchronisation, prompt closure of files or other objects, and simpler "
"manipulation of the active decimal arithmetic context. The specific types "
"are not treated specially beyond their implementation of the context "
"management protocol. See the :mod:`contextlib` module for some examples."
msgstr ""

#: ../../../library/stdtypes.rst:2453
msgid ""
"Python's :term:`generator`\\s and the ``contextlib.contextmanager`` :term:"
"`decorator` provide a convenient way to implement these protocols.  If a "
"generator function is decorated with the ``contextlib.contextmanager`` "
"decorator, it will return a context manager implementing the necessary :meth:"
"`__enter__` and :meth:`__exit__` methods, rather than the iterator produced "
"by an undecorated generator function."
msgstr ""

#: ../../../library/stdtypes.rst:2460
msgid ""
"Note that there is no specific slot for any of these methods in the type "
"structure for Python objects in the Python/C API. Extension types wanting to "
"define these methods must provide them as a normal Python accessible method. "
"Compared to the overhead of setting up the runtime context, the overhead of "
"a single class dictionary lookup is negligible."
msgstr ""

#: ../../../library/stdtypes.rst:2470
msgid "Other Built-in Types"
msgstr ""

#: ../../../library/stdtypes.rst:2472
msgid ""
"The interpreter supports several other kinds of objects. Most of these "
"support only one or two operations."
msgstr ""

#: ../../../library/stdtypes.rst:2479
msgid "Modules"
msgstr ""

#: ../../../library/stdtypes.rst:2481
msgid ""
"The only special operation on a module is attribute access: ``m.name``, "
"where *m* is a module and *name* accesses a name defined in *m*'s symbol "
"table. Module attributes can be assigned to.  (Note that the :keyword:"
"`import` statement is not, strictly speaking, an operation on a module "
"object; ``import foo`` does not require a module object named *foo* to "
"exist, rather it requires an (external) *definition* for a module named "
"*foo* somewhere.)"
msgstr ""

#: ../../../library/stdtypes.rst:2488
msgid ""
"A special member of every module is :attr:`__dict__`. This is the dictionary "
"containing the module's symbol table. Modifying this dictionary will "
"actually change the module's symbol table, but direct assignment to the :"
"attr:`__dict__` attribute is not possible (you can write ``m.__dict__['a'] = "
"1``, which defines ``m.a`` to be ``1``, but you can't write ``m.__dict__ = {}"
"``).  Modifying :attr:`__dict__` directly is not recommended."
msgstr ""

#: ../../../library/stdtypes.rst:2495
msgid ""
"Modules built into the interpreter are written like this: ``<module "
"'sys' (built-in)>``.  If loaded from a file, they are written as ``<module "
"'os' from '/usr/local/lib/pythonX.Y/os.pyc'>``."
msgstr ""

#: ../../../library/stdtypes.rst:2503
msgid "Classes and Class Instances"
msgstr ""

#: ../../../library/stdtypes.rst:2505
msgid "See :ref:`objects` and :ref:`class` for these."
msgstr ""

#: ../../../library/stdtypes.rst:2511
msgid "Functions"
msgstr ""

#: ../../../library/stdtypes.rst:2513
msgid ""
"Function objects are created by function definitions.  The only operation on "
"a function object is to call it: ``func(argument-list)``."
msgstr ""

#: ../../../library/stdtypes.rst:2516
msgid ""
"There are really two flavors of function objects: built-in functions and "
"user-defined functions.  Both support the same operation (to call the "
"function), but the implementation is different, hence the different object "
"types."
msgstr ""

#: ../../../library/stdtypes.rst:2520
msgid "See :ref:`function` for more information."
msgstr ""

#: ../../../library/stdtypes.rst:2526
msgid "Methods"
msgstr ""

#: ../../../library/stdtypes.rst:2530
msgid ""
"Methods are functions that are called using the attribute notation. There "
"are two flavors: built-in methods (such as :meth:`append` on lists) and "
"class instance methods.  Built-in methods are described with the types that "
"support them."
msgstr ""

#: ../../../library/stdtypes.rst:2535
msgid ""
"The implementation adds two special read-only attributes to class instance "
"methods: ``m.im_self`` is the object on which the method operates, and ``m."
"im_func`` is the function implementing the method.  Calling ``m(arg-1, "
"arg-2, ..., arg-n)`` is completely equivalent to calling ``m.im_func(m."
"im_self, arg-1, arg-2, ..., arg-n)``."
msgstr ""

#: ../../../library/stdtypes.rst:2541
msgid ""
"Class instance methods are either *bound* or *unbound*, referring to whether "
"the method was accessed through an instance or a class, respectively.  When "
"a method is unbound, its ``im_self`` attribute will be ``None`` and if "
"called, an explicit ``self`` object must be passed as the first argument.  "
"In this case, ``self`` must be an instance of the unbound method's class (or "
"a subclass of that class), otherwise a :exc:`TypeError` is raised."
msgstr ""

#: ../../../library/stdtypes.rst:2548
msgid ""
"Like function objects, methods objects support getting arbitrary attributes. "
"However, since method attributes are actually stored on the underlying "
"function object (``meth.im_func``), setting method attributes on either "
"bound or unbound methods is disallowed.  Attempting to set a method "
"attribute results in a :exc:`TypeError` being raised.  In order to set a "
"method attribute, you need to explicitly set it on the underlying function "
"object::"
msgstr ""

#: ../../../library/stdtypes.rst:2562 ../../../library/stdtypes.rst:2590
msgid "See :ref:`types` for more information."
msgstr ""

#: ../../../library/stdtypes.rst:2568
msgid "Code Objects"
msgstr ""

#: ../../../library/stdtypes.rst:2576
msgid ""
"Code objects are used by the implementation to represent \"pseudo-compiled\" "
"executable Python code such as a function body. They differ from function "
"objects because they don't contain a reference to their global execution "
"environment.  Code objects are returned by the built-in :func:`compile` "
"function and can be extracted from function objects through their :attr:"
"`func_code` attribute. See also the :mod:`code` module."
msgstr ""

#: ../../../library/stdtypes.rst:2587
msgid ""
"A code object can be executed or evaluated by passing it (instead of a "
"source string) to the :keyword:`exec` statement or the built-in :func:`eval` "
"function."
msgstr ""

#: ../../../library/stdtypes.rst:2596
msgid "Type Objects"
msgstr ""

#: ../../../library/stdtypes.rst:2602
msgid ""
"Type objects represent the various object types.  An object's type is "
"accessed by the built-in function :func:`type`.  There are no special "
"operations on types.  The standard module :mod:`types` defines names for all "
"standard built-in types."
msgstr ""

#: ../../../library/stdtypes.rst:2607
msgid "Types are written like this: ``<type 'int'>``."
msgstr ""

#: ../../../library/stdtypes.rst:2613
msgid "The Null Object"
msgstr ""

#: ../../../library/stdtypes.rst:2615
msgid ""
"This object is returned by functions that don't explicitly return a value.  "
"It supports no special operations.  There is exactly one null object, named "
"``None`` (a built-in name)."
msgstr ""

#: ../../../library/stdtypes.rst:2619
msgid "It is written as ``None``."
msgstr ""

#: ../../../library/stdtypes.rst:2625
msgid "The Ellipsis Object"
msgstr ""

#: ../../../library/stdtypes.rst:2627
msgid ""
"This object is used by extended slice notation (see :ref:`slicings`).  It "
"supports no special operations.  There is exactly one ellipsis object, "
"named :const:`Ellipsis` (a built-in name)."
msgstr ""

#: ../../../library/stdtypes.rst:2631
msgid "It is written as ``Ellipsis``."
msgstr ""

#: ../../../library/stdtypes.rst:2635
msgid "Boolean Values"
msgstr ""

#: ../../../library/stdtypes.rst:2637
msgid ""
"Boolean values are the two constant objects ``False`` and ``True``.  They "
"are used to represent truth values (although other values can also be "
"considered false or true).  In numeric contexts (for example when used as "
"the argument to an arithmetic operator), they behave like the integers 0 and "
"1, respectively. The built-in function :func:`bool` can be used to cast any "
"value to a Boolean, if the value can be interpreted as a truth value (see "
"section Truth Value Testing above)."
msgstr ""

#: ../../../library/stdtypes.rst:2650
msgid "They are written as ``False`` and ``True``, respectively."
msgstr ""

#: ../../../library/stdtypes.rst:2656
msgid "Internal Objects"
msgstr ""

#: ../../../library/stdtypes.rst:2658
msgid ""
"See :ref:`types` for this information.  It describes stack frame objects, "
"traceback objects, and slice objects."
msgstr ""

#: ../../../library/stdtypes.rst:2665
msgid "Special Attributes"
msgstr ""

#: ../../../library/stdtypes.rst:2667
msgid ""
"The implementation adds a few special read-only attributes to several object "
"types, where they are relevant.  Some of these are not reported by the :func:"
"`dir` built-in function."
msgstr ""

#: ../../../library/stdtypes.rst:2674
msgid ""
"A dictionary or other mapping object used to store an object's (writable) "
"attributes."
msgstr ""

#: ../../../library/stdtypes.rst:2680 ../../../library/stdtypes.rst:2687
msgid ""
"Use the built-in function :func:`dir` to get a list of an object's "
"attributes. This attribute is no longer available."
msgstr ""

#: ../../../library/stdtypes.rst:2694
msgid "The class to which a class instance belongs."
msgstr ""

#: ../../../library/stdtypes.rst:2699
msgid "The tuple of base classes of a class object."
msgstr ""

#: ../../../library/stdtypes.rst:2704
msgid "The name of the class or type."
msgstr ""

#: ../../../library/stdtypes.rst:2707
msgid ""
"The following attributes are only supported by :term:`new-style class`\\ es."
msgstr ""

#: ../../../library/stdtypes.rst:2711
msgid ""
"This attribute is a tuple of classes that are considered when looking for "
"base classes during method resolution."
msgstr ""

#: ../../../library/stdtypes.rst:2717
msgid ""
"This method can be overridden by a metaclass to customize the method "
"resolution order for its instances.  It is called at class instantiation, "
"and its result is stored in :attr:`__mro__`."
msgstr ""

#: ../../../library/stdtypes.rst:2724
msgid ""
"Each new-style class keeps a list of weak references to its immediate "
"subclasses.  This method returns a list of all those references still alive. "
"Example::"
msgstr ""

#: ../../../library/stdtypes.rst:2733
msgid "Footnotes"
msgstr ""

#: ../../../library/stdtypes.rst:2734
msgid ""
"Additional information on these special methods may be found in the Python "
"Reference Manual (:ref:`customization`)."
msgstr ""

#: ../../../library/stdtypes.rst:2737
msgid ""
"As a consequence, the list ``[1, 2]`` is considered equal to ``[1.0, 2.0]``, "
"and similarly for tuples."
msgstr ""

#: ../../../library/stdtypes.rst:2740
msgid "They must have since the parser can't tell the type of the operands."
msgstr ""

#: ../../../library/stdtypes.rst:2742
msgid ""
"To format only a tuple you should therefore provide a singleton tuple whose "
"only element is the tuple to be formatted."
msgstr ""

#: ../../../library/stdtypes.rst:2745
msgid ""
"These numbers are fairly arbitrary.  They are intended to avoid printing "
"endless strings of meaningless digits without hampering correct use and "
"without having to know the exact precision of floating point values on a "
"particular machine."
msgstr ""

#: ../../../library/stdtypes.rst:2749
msgid ""
"The advantage of leaving the newline on is that returning an empty string is "
"then an unambiguous EOF indication.  It is also possible (in cases where it "
"might matter, for example, if you want to make an exact copy of a file while "
"scanning its lines) to tell whether the last line of a file ended in a "
"newline or not (yes this happens!)."
msgstr ""

#: ../../../library/stdtypes.rst:20
msgid "built-in"
msgstr ""

#: ../../../library/stdtypes.rst:20 ../../../library/stdtypes.rst:328
#: ../../../library/stdtypes.rst:405 ../../../library/stdtypes.rst:702
#: ../../../library/stdtypes.rst:1455 ../../../library/stdtypes.rst:1510
#: ../../../library/stdtypes.rst:1838 ../../../library/stdtypes.rst:2598
msgid "types"
msgstr ""

#: ../../../library/stdtypes.rst:25
msgid "print"
msgstr ""

#: ../../../library/stdtypes.rst:39
msgid "if"
msgstr ""

#: ../../../library/stdtypes.rst:39
msgid "while"
msgstr ""

#: ../../../library/stdtypes.rst:39
msgid "truth"
msgstr ""

#: ../../../library/stdtypes.rst:39
msgid "value"
msgstr ""

#: ../../../library/stdtypes.rst:39 ../../../library/stdtypes.rst:90
#: ../../../library/stdtypes.rst:217 ../../../library/stdtypes.rst:2645
msgid "Boolean"
msgstr ""

#: ../../../library/stdtypes.rst:39 ../../../library/stdtypes.rst:90
#: ../../../library/stdtypes.rst:405
msgid "operations"
msgstr ""

#: ../../../library/stdtypes.rst:39
msgid "false"
msgstr ""

#: ../../../library/stdtypes.rst:50
msgid "None (Built-in object)"
msgstr ""

#: ../../../library/stdtypes.rst:54
msgid "False (Built-in object)"
msgstr ""

#: ../../../library/stdtypes.rst:68
msgid "true"
msgstr ""

#: ../../../library/stdtypes.rst:73 ../../../library/stdtypes.rst:107
msgid "or"
msgstr ""

#: ../../../library/stdtypes.rst:73 ../../../library/stdtypes.rst:107
msgid "and"
msgstr ""

#: ../../../library/stdtypes.rst:73 ../../../library/stdtypes.rst:2645
msgid "False"
msgstr ""

#: ../../../library/stdtypes.rst:73 ../../../library/stdtypes.rst:2645
msgid "True"
msgstr ""

#: ../../../library/stdtypes.rst:107
msgid "not"
msgstr ""

#: ../../../library/stdtypes.rst:132
msgid "chaining"
msgstr ""

#: ../../../library/stdtypes.rst:132
msgid "comparisons"
msgstr ""

#: ../../../library/stdtypes.rst:132
msgid "comparison"
msgstr ""

#: ../../../library/stdtypes.rst:132
msgid "=="
msgstr ""

#: ../../../library/stdtypes.rst:132
msgid "<"
msgstr ""

#: ../../../library/stdtypes.rst:132
msgid "<="
msgstr ""

#: ../../../library/stdtypes.rst:132
msgid ">"
msgstr ""

#: ../../../library/stdtypes.rst:132
msgid ">="
msgstr ""

#: ../../../library/stdtypes.rst:132
msgid "!="
msgstr ""

#: ../../../library/stdtypes.rst:132
msgid "is"
msgstr ""

#: ../../../library/stdtypes.rst:132
msgid "is not"
msgstr ""

#: ../../../library/stdtypes.rst:179 ../../../library/stdtypes.rst:217
#: ../../../library/stdtypes.rst:240 ../../../library/stdtypes.rst:328
#: ../../../library/stdtypes.rst:345
msgid "numeric"
msgstr ""

#: ../../../library/stdtypes.rst:179
msgid "objects"
msgstr ""

#: ../../../library/stdtypes.rst:179
msgid "comparing"
msgstr ""

#: ../../../library/stdtypes.rst:192
msgid "__cmp__() (instance method)"
msgstr ""

#: ../../../library/stdtypes.rst:204 ../../../library/stdtypes.rst:702
msgid "in"
msgstr ""

#: ../../../library/stdtypes.rst:204 ../../../library/stdtypes.rst:702
msgid "not in"
msgstr ""

#: ../../../library/stdtypes.rst:217 ../../../library/stdtypes.rst:240
#: ../../../library/stdtypes.rst:335 ../../../library/stdtypes.rst:405
msgid "integer"
msgstr ""

#: ../../../library/stdtypes.rst:217
msgid "long integer"
msgstr ""

#: ../../../library/stdtypes.rst:217 ../../../library/stdtypes.rst:240
msgid "floating point"
msgstr ""

#: ../../../library/stdtypes.rst:217 ../../../library/stdtypes.rst:240
msgid "complex number"
msgstr ""

#: ../../../library/stdtypes.rst:217
msgid "C"
msgstr ""

#: ../../../library/stdtypes.rst:217
msgid "language"
msgstr ""

#: ../../../library/stdtypes.rst:240
msgid "literals"
msgstr ""

#: ../../../library/stdtypes.rst:240 ../../../library/stdtypes.rst:260
#: ../../../library/stdtypes.rst:335
msgid "long"
msgstr ""

#: ../../../library/stdtypes.rst:240
msgid "hexadecimal"
msgstr ""

#: ../../../library/stdtypes.rst:240
msgid "octal"
msgstr ""

#: ../../../library/stdtypes.rst:260
msgid "arithmetic"
msgstr ""

#: ../../../library/stdtypes.rst:260
msgid "int"
msgstr ""

#: ../../../library/stdtypes.rst:260
msgid "float"
msgstr ""

#: ../../../library/stdtypes.rst:260
msgid "complex"
msgstr ""

#: ../../../library/stdtypes.rst:260
msgid "+"
msgstr ""

#: ../../../library/stdtypes.rst:260
msgid "-"
msgstr ""

#: ../../../library/stdtypes.rst:260
msgid "*"
msgstr ""

#: ../../../library/stdtypes.rst:260
msgid "/"
msgstr ""

#: ../../../library/stdtypes.rst:260
msgid "//"
msgstr ""

#: ../../../library/stdtypes.rst:260
msgid "%"
msgstr ""

#: ../../../library/stdtypes.rst:260
msgid "**"
msgstr ""

#: ../../../library/stdtypes.rst:328 ../../../library/stdtypes.rst:405
#: ../../../library/stdtypes.rst:702 ../../../library/stdtypes.rst:1510
#: ../../../library/stdtypes.rst:1838
msgid "operations on"
msgstr ""

#: ../../../library/stdtypes.rst:328
msgid "conjugate() (complex number method)"
msgstr ""

#: ../../../library/stdtypes.rst:335
msgid "division"
msgstr ""

#: ../../../library/stdtypes.rst:345
msgid "math"
msgstr ""

#: ../../../library/stdtypes.rst:345
msgid "floor() (in module math)"
msgstr ""

#: ../../../library/stdtypes.rst:345
msgid "ceil() (in module math)"
msgstr ""

#: ../../../library/stdtypes.rst:345
msgid "trunc() (in module math)"
msgstr ""

#: ../../../library/stdtypes.rst:345
msgid "conversions"
msgstr ""

#: ../../../library/stdtypes.rst:405
msgid "bit-string"
msgstr ""

#: ../../../library/stdtypes.rst:405
msgid "shifting"
msgstr ""

#: ../../../library/stdtypes.rst:405
msgid "masking"
msgstr ""

#: ../../../library/stdtypes.rst:405
msgid "^"
msgstr ""

#: ../../../library/stdtypes.rst:405
msgid "&"
msgstr ""

#: ../../../library/stdtypes.rst:405
msgid "<<"
msgstr ""

#: ../../../library/stdtypes.rst:405
msgid ">>"
msgstr ""

#: ../../../library/stdtypes.rst:544
msgid "iterator protocol"
msgstr ""

#: ../../../library/stdtypes.rst:544 ../../../library/stdtypes.rst:2394
msgid "protocol"
msgstr ""

#: ../../../library/stdtypes.rst:544
msgid "iterator"
msgstr ""

#: ../../../library/stdtypes.rst:544 ../../../library/stdtypes.rst:627
#: ../../../library/stdtypes.rst:702 ../../../library/stdtypes.rst:1455
#: ../../../library/stdtypes.rst:1510
msgid "sequence"
msgstr ""

#: ../../../library/stdtypes.rst:544
msgid "iteration"
msgstr ""

#: ../../../library/stdtypes.rst:544
msgid "container"
msgstr ""

#: ../../../library/stdtypes.rst:544
msgid "iteration over"
msgstr ""

#: ../../../library/stdtypes.rst:627 ../../../library/stdtypes.rst:789
#: ../../../library/stdtypes.rst:1247 ../../../library/stdtypes.rst:1426
msgid "string"
msgstr ""

#: ../../../library/stdtypes.rst:627
msgid "Unicode"
msgstr ""

#: ../../../library/stdtypes.rst:627
msgid "tuple"
msgstr ""

#: ../../../library/stdtypes.rst:627 ../../../library/stdtypes.rst:1455
#: ../../../library/stdtypes.rst:1510
msgid "list"
msgstr ""

#: ../../../library/stdtypes.rst:627
msgid "buffer"
msgstr ""

#: ../../../library/stdtypes.rst:627 ../../../library/stdtypes.rst:1439
msgid "xrange"
msgstr ""

#: ../../../library/stdtypes.rst:702 ../../../library/stdtypes.rst:1838
msgid "len"
msgstr ""

#: ../../../library/stdtypes.rst:702
msgid "min"
msgstr ""

#: ../../../library/stdtypes.rst:702
msgid "max"
msgstr ""

#: ../../../library/stdtypes.rst:702
msgid "concatenation"
msgstr ""

#: ../../../library/stdtypes.rst:702
msgid "operation"
msgstr ""

#: ../../../library/stdtypes.rst:702
msgid "repetition"
msgstr ""

#: ../../../library/stdtypes.rst:702 ../../../library/stdtypes.rst:1510
msgid "subscript"
msgstr ""

#: ../../../library/stdtypes.rst:702 ../../../library/stdtypes.rst:1510
msgid "slice"
msgstr ""

#: ../../../library/stdtypes.rst:702 ../../../library/stdtypes.rst:1510
msgid "extended slice"
msgstr ""

#: ../../../library/stdtypes.rst:789
msgid "methods"
msgstr ""

#: ../../../library/stdtypes.rst:1247
msgid "formatting, string (%)"
msgstr ""

#: ../../../library/stdtypes.rst:1247
msgid "interpolation, string (%)"
msgstr ""

#: ../../../library/stdtypes.rst:1247
msgid "formatting"
msgstr ""

#: ../../../library/stdtypes.rst:1247
msgid "interpolation"
msgstr ""

#: ../../../library/stdtypes.rst:1247
msgid "printf-style formatting"
msgstr ""

#: ../../../library/stdtypes.rst:1247
msgid "sprintf-style formatting"
msgstr ""

#: ../../../library/stdtypes.rst:1247
msgid "% formatting"
msgstr ""

#: ../../../library/stdtypes.rst:1247
msgid "% interpolation"
msgstr ""

#: ../../../library/stdtypes.rst:1426
msgid "re"
msgstr ""

#: ../../../library/stdtypes.rst:1455
msgid "mutable"
msgstr ""

#: ../../../library/stdtypes.rst:1510 ../../../library/stdtypes.rst:1838
#: ../../../library/stdtypes.rst:2598
msgid "type"
msgstr ""

#: ../../../library/stdtypes.rst:1510
msgid "assignment"
msgstr ""

#: ../../../library/stdtypes.rst:1510 ../../../library/stdtypes.rst:1838
msgid "del"
msgstr ""

#: ../../../library/stdtypes.rst:1510
msgid "append() (list method)"
msgstr ""

#: ../../../library/stdtypes.rst:1510
msgid "extend() (list method)"
msgstr ""

#: ../../../library/stdtypes.rst:1510
msgid "count() (list method)"
msgstr ""

#: ../../../library/stdtypes.rst:1510
msgid "index() (list method)"
msgstr ""

#: ../../../library/stdtypes.rst:1510
msgid "insert() (list method)"
msgstr ""

#: ../../../library/stdtypes.rst:1510
msgid "pop() (list method)"
msgstr ""

#: ../../../library/stdtypes.rst:1510
msgid "remove() (list method)"
msgstr ""

#: ../../../library/stdtypes.rst:1510
msgid "reverse() (list method)"
msgstr ""

#: ../../../library/stdtypes.rst:1510
msgid "sort() (list method)"
msgstr ""

#: ../../../library/stdtypes.rst:1616
msgid "set"
msgstr ""

#: ../../../library/stdtypes.rst:1838
msgid "mapping"
msgstr ""

#: ../../../library/stdtypes.rst:1838
msgid "dictionary"
msgstr ""

#: ../../../library/stdtypes.rst:2081 ../../../library/stdtypes.rst:2151
msgid "file"
msgstr ""

#: ../../../library/stdtypes.rst:2081
msgid "os"
msgstr ""

#: ../../../library/stdtypes.rst:2081
msgid "socket"
msgstr ""

#: ../../../library/stdtypes.rst:2151
msgid "descriptor"
msgstr ""

#: ../../../library/stdtypes.rst:2151
msgid "fcntl"
msgstr ""

#: ../../../library/stdtypes.rst:2394
msgid "context manager"
msgstr ""

#: ../../../library/stdtypes.rst:2394
msgid "context management protocol"
msgstr ""

#: ../../../library/stdtypes.rst:2394
msgid "context management"
msgstr ""

#: ../../../library/stdtypes.rst:2528
msgid "method"
msgstr ""

#: ../../../library/stdtypes.rst:2570
msgid "code"
msgstr ""

#: ../../../library/stdtypes.rst:2572
msgid "compile"
msgstr ""

#: ../../../library/stdtypes.rst:2572
msgid "func_code (function object attribute)"
msgstr ""

#: ../../../library/stdtypes.rst:2583
msgid "exec"
msgstr ""

#: ../../../library/stdtypes.rst:2583
msgid "eval"
msgstr ""

#: ../../../library/stdtypes.rst:2645
msgid "values"
msgstr ""

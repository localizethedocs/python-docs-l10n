# SOME DESCRIPTIVE TITLE.
# Copyright (C) 1990-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 2.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-10 15:09+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../library/bisect.rst:3
msgid ":mod:`bisect` --- Array bisection algorithm"
msgstr ""

#: ../../../library/bisect.rst:10
msgid ""
"This module provides support for maintaining a list in sorted order without "
"having to sort the list after each insertion.  For long lists of items with "
"expensive comparison operations, this can be an improvement over the more "
"common approach.  The module is called :mod:`bisect` because it uses a basic "
"bisection algorithm to do its work.  The source code may be most useful as a "
"working example of the algorithm (the boundary conditions are already "
"right!)."
msgstr ""

#: ../../../library/bisect.rst:17
msgid "The following functions are provided:"
msgstr ""

#: ../../../library/bisect.rst:22
msgid ""
"Locate the proper insertion point for *item* in *list* to maintain sorted "
"order. The parameters *lo* and *hi* may be used to specify a subset of the "
"list which should be considered; by default the entire list is used.  If "
"*item* is already present in *list*, the insertion point will be before (to "
"the left of) any existing entries.  The return value is suitable for use as "
"the first parameter to ``list.insert()``.  This assumes that *list* is "
"already sorted."
msgstr ""

#: ../../../library/bisect.rst:34
msgid ""
"Similar to :func:`bisect_left`, but returns an insertion point which comes "
"after (to the right of) any existing entries of *item* in *list*."
msgstr ""

#: ../../../library/bisect.rst:42
msgid "Alias for :func:`bisect_right`."
msgstr ""

#: ../../../library/bisect.rst:47
msgid ""
"Insert *item* in *list* in sorted order.  This is equivalent to ``list."
"insert(bisect.bisect_left(list, item, lo, hi), item)``.  This assumes that "
"*list* is already sorted."
msgstr ""

#: ../../../library/bisect.rst:56
msgid ""
"Similar to :func:`insort_left`, but inserting *item* in *list* after any "
"existing entries of *item*."
msgstr ""

#: ../../../library/bisect.rst:64
msgid "Alias for :func:`insort_right`."
msgstr ""

#: ../../../library/bisect.rst:68
msgid "Examples"
msgstr ""

#: ../../../library/bisect.rst:72
msgid ""
"The :func:`bisect` function is generally useful for categorizing numeric "
"data. This example uses :func:`bisect` to look up a letter grade for an exam "
"total (say) based on a set of ordered numeric breakpoints: 85 and up is an "
"'A', 75..84 is a 'B', etc."
msgstr ""

#: ../../../library/bisect.rst:88
msgid ""
"Unlike the :func:`sorted` function, it does not make sense for the :func:"
"`bisect` functions to have *key* or *reversed* arguments because that would "
"lead to an inefficent design (successive calls to bisect functions would not "
"\"remember\" all of the previous key lookups)."
msgstr ""

#: ../../../library/bisect.rst:93
msgid ""
"Instead, it is better to search a list of precomputed keys to find the index "
"of the record in question::"
msgstr ""

#: ../../../library/bisect.rst:96
msgid ""
">>> data = [('red', 5), ('blue', 1), ('yellow', 8), ('black', 0)]\n"
">>> data.sort(key=lambda r: r[1])\n"
">>> keys = [r[1] for r in data]         # precomputed list of keys\n"
">>> data[bisect_left(keys, 0)]\n"
"('black', 0)\n"
">>> data[bisect_left(keys, 1)]\n"
"('blue', 1)\n"
">>> data[bisect_left(keys, 5)]\n"
"('red', 5)\n"
">>> data[bisect_left(keys, 8)]\n"
"('yellow', 8)"
msgstr ""

# SOME DESCRIPTIVE TITLE.
# Copyright (C) 1990-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 2.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-10 15:09+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../library/collections.rst:3
msgid ":mod:`collections` --- High-performance container datatypes"
msgstr ""

#: ../../../library/collections.rst:18
msgid ""
"This module implements high-performance container datatypes.  Currently, "
"there are two datatypes, :class:`deque` and :class:`defaultdict`, and one "
"datatype factory function, :func:`namedtuple`."
msgstr ""

#: ../../../library/collections.rst:22
msgid "Added :class:`defaultdict`."
msgstr ""

#: ../../../library/collections.rst:25
msgid "Added :func:`namedtuple`."
msgstr ""

#: ../../../library/collections.rst:28
msgid ""
"The specialized containers provided in this module provide alternatives to "
"Python's general purpose built-in containers, :class:`dict`, :class:`list`, :"
"class:`set`, and :class:`tuple`."
msgstr ""

#: ../../../library/collections.rst:32
msgid ""
"Besides the containers provided here, the optional :mod:`bsddb` module "
"offers the ability to create in-memory or file based ordered dictionaries "
"with string keys using the :meth:`bsddb.btopen` method."
msgstr ""

#: ../../../library/collections.rst:36
msgid ""
"In addition to containers, the collections module provides some ABCs "
"(abstract base classes) that can be used to test whether a class provides a "
"particular interface, for example, is it hashable or a mapping."
msgstr ""

#: ../../../library/collections.rst:41
msgid "Added abstract base classes."
msgstr ""

#: ../../../library/collections.rst:45
msgid "ABCs - abstract base classes"
msgstr ""

#: ../../../library/collections.rst:47
msgid "The collections module offers the following ABCs:"
msgstr ""

#: ../../../library/collections.rst:50
msgid "ABC"
msgstr ""

#: ../../../library/collections.rst:50
msgid "Inherits"
msgstr ""

#: ../../../library/collections.rst:50
msgid "Abstract Methods"
msgstr ""

#: ../../../library/collections.rst:50
msgid "Mixin Methods"
msgstr ""

#: ../../../library/collections.rst:52
msgid ":class:`Container`"
msgstr ""

#: ../../../library/collections.rst:52
msgid "``__contains__``"
msgstr ""

#: ../../../library/collections.rst:53
msgid ":class:`Hashable`"
msgstr ""

#: ../../../library/collections.rst:53
msgid "``__hash__``"
msgstr ""

#: ../../../library/collections.rst:54 ../../../library/collections.rst:55
msgid ":class:`Iterable`"
msgstr ""

#: ../../../library/collections.rst:54 ../../../library/collections.rst:55
msgid "``__iter__``"
msgstr ""

#: ../../../library/collections.rst:55
msgid ":class:`Iterator`"
msgstr ""

#: ../../../library/collections.rst:55
msgid "``next``"
msgstr ""

#: ../../../library/collections.rst:56 ../../../library/collections.rst:84
msgid ":class:`Sized`"
msgstr ""

#: ../../../library/collections.rst:56 ../../../library/collections.rst:84
msgid "``__len__``"
msgstr ""

#: ../../../library/collections.rst:57
msgid ":class:`Callable`"
msgstr ""

#: ../../../library/collections.rst:57
msgid "``__call__``"
msgstr ""

#: ../../../library/collections.rst:59 ../../../library/collections.rst:63
msgid ":class:`Sequence`"
msgstr ""

#: ../../../library/collections.rst:59 ../../../library/collections.rst:67
#: ../../../library/collections.rst:75
msgid ":class:`Sized`, :class:`Iterable`, :class:`Container`"
msgstr ""

#: ../../../library/collections.rst:59 ../../../library/collections.rst:75
msgid "``__getitem__``"
msgstr ""

#: ../../../library/collections.rst:59
msgid ""
"``__contains__``. ``__iter__``, ``__reversed__``. ``index``, and ``count``"
msgstr ""

#: ../../../library/collections.rst:63
msgid ":class:`MutableSequence`"
msgstr ""

#: ../../../library/collections.rst:63
msgid "``__setitem__`` ``__delitem__``, and ``insert``"
msgstr ""

#: ../../../library/collections.rst:63
msgid ""
"Inherited Sequence methods and ``append``, ``reverse``, ``extend``, ``pop``, "
"``remove``, and ``__iadd__``"
msgstr ""

#: ../../../library/collections.rst:67 ../../../library/collections.rst:71
msgid ":class:`Set`"
msgstr ""

#: ../../../library/collections.rst:67
msgid ""
"``__le__``, ``__lt__``, ``__eq__``, ``__ne__``, ``__gt__``, ``__ge__``, "
"``__and__``, ``__or__`` ``__sub__``, ``__xor__``, and ``isdisjoint``"
msgstr ""

#: ../../../library/collections.rst:71
msgid ":class:`MutableSet`"
msgstr ""

#: ../../../library/collections.rst:71
msgid "``add`` and ``discard``"
msgstr ""

#: ../../../library/collections.rst:71
msgid ""
"Inherited Set methods and ``clear``, ``pop``, ``remove``, ``__ior__``, "
"``__iand__``, ``__ixor__``, and ``__isub__``"
msgstr ""

#: ../../../library/collections.rst:75 ../../../library/collections.rst:79
msgid ":class:`Mapping`"
msgstr ""

#: ../../../library/collections.rst:75
msgid ""
"``__contains__``, ``keys``, ``items``, ``values``, ``get``, ``__eq__``, and "
"``__ne__``"
msgstr ""

#: ../../../library/collections.rst:79
msgid ":class:`MutableMapping`"
msgstr ""

#: ../../../library/collections.rst:79
msgid "``__setitem__`` and ``__delitem__``"
msgstr ""

#: ../../../library/collections.rst:79
msgid ""
"Inherited Mapping methods and ``pop``, ``popitem``, ``clear``, ``update``, "
"and ``setdefault``"
msgstr ""

#: ../../../library/collections.rst:84 ../../../library/collections.rst:89
msgid ":class:`MappingView`"
msgstr ""

#: ../../../library/collections.rst:85
msgid ":class:`KeysView`"
msgstr ""

#: ../../../library/collections.rst:85 ../../../library/collections.rst:87
msgid ":class:`MappingView`, :class:`Set`"
msgstr ""

#: ../../../library/collections.rst:85 ../../../library/collections.rst:87
#: ../../../library/collections.rst:89
msgid "``__contains__``, ``__iter__``"
msgstr ""

#: ../../../library/collections.rst:87
msgid ":class:`ItemsView`"
msgstr ""

#: ../../../library/collections.rst:89
msgid ":class:`ValuesView`"
msgstr ""

#: ../../../library/collections.rst:92
msgid ""
"These ABCs allow us to ask classes or instances if they provide particular "
"functionality, for example::"
msgstr ""

#: ../../../library/collections.rst:95
msgid ""
"size = None\n"
"if isinstance(myvar, collections.Sized):\n"
"    size = len(myvar)"
msgstr ""

#: ../../../library/collections.rst:99
msgid ""
"Several of the ABCs are also useful as mixins that make it easier to develop "
"classes supporting container APIs.  For example, to write a class supporting "
"the full :class:`Set` API, it only necessary to supply the three underlying "
"abstract methods: :meth:`__contains__`, :meth:`__iter__`, and :meth:"
"`__len__`. The ABC supplies the remaining methods such as :meth:`__and__` "
"and :meth:`isdisjoint` ::"
msgstr ""

#: ../../../library/collections.rst:106
msgid ""
"class ListBasedSet(collections.Set):\n"
"     ''' Alternate set implementation favoring space over speed\n"
"         and not requiring the set elements to be hashable. '''\n"
"     def __init__(self, iterable):\n"
"         self.elements = lst = []\n"
"         for value in iterable:\n"
"             if value not in lst:\n"
"                 lst.append(value)\n"
"     def __iter__(self):\n"
"         return iter(self.elements)\n"
"     def __contains__(self, value):\n"
"         return value in self.elements\n"
"     def __len__(self):\n"
"         return len(self.elements)\n"
"\n"
"s1 = ListBasedSet('abcdef')\n"
"s2 = ListBasedSet('defghi')\n"
"overlap = s1 & s2            # The __and__() method is supported "
"automatically"
msgstr ""

#: ../../../library/collections.rst:125
msgid "Notes on using :class:`Set` and :class:`MutableSet` as a mixin:"
msgstr ""

#: ../../../library/collections.rst:128
msgid ""
"Since some set operations create new sets, the default mixin methods need a "
"way to create new instances from an iterable. The class constructor is "
"assumed to have a signature in the form ``ClassName(iterable)``. That "
"assumption is factored-out to an internal classmethod called :meth:"
"`_from_iterable` which calls ``cls(iterable)`` to produce a new set. If the :"
"class:`Set` mixin is being used in a class with a different constructor "
"signature, you will need to override :meth:`from_iterable` with a "
"classmethod that can construct new instances from an iterable argument."
msgstr ""

#: ../../../library/collections.rst:139
msgid ""
"To override the comparisons (presumably for speed, as the semantics are "
"fixed), redefine :meth:`__le__` and then the other operations will "
"automatically follow suit."
msgstr ""

#: ../../../library/collections.rst:144
msgid ""
"The :class:`Set` mixin provides a :meth:`_hash` method to compute a hash "
"value for the set; however, :meth:`__hash__` is not defined because not all "
"sets are hashable or immutable.  To add set hashabilty using mixins, inherit "
"from both :meth:`Set` and :meth:`Hashable`, then define ``__hash__ = Set."
"_hash``."
msgstr ""

#: ../../../library/collections.rst:152
msgid ""
"`OrderedSet recipe <http://code.activestate.com/recipes/576694/>`_ for an "
"example built on :class:`MutableSet`."
msgstr ""

#: ../../../library/collections.rst:155
msgid "For more about ABCs, see the :mod:`abc` module and :pep:`3119`."
msgstr ""

#: ../../../library/collections.rst:159
msgid ":class:`deque` objects"
msgstr ""

#: ../../../library/collections.rst:163
msgid ""
"Returns a new deque object initialized left-to-right (using :meth:`append`) "
"with data from *iterable*.  If *iterable* is not specified, the new deque is "
"empty."
msgstr ""

#: ../../../library/collections.rst:166
msgid ""
"Deques are a generalization of stacks and queues (the name is pronounced "
"\"deck\" and is short for \"double-ended queue\").  Deques support thread-"
"safe, memory efficient appends and pops from either side of the deque with "
"approximately the same O(1) performance in either direction."
msgstr ""

#: ../../../library/collections.rst:171
msgid ""
"Though :class:`list` objects support similar operations, they are optimized "
"for fast fixed-length operations and incur O(n) memory movement costs for "
"``pop(0)`` and ``insert(0, v)`` operations which change both the size and "
"position of the underlying data representation."
msgstr ""

#: ../../../library/collections.rst:178
msgid ""
"If *maxlen* is not specified or is *None*, deques may grow to an arbitrary "
"length.  Otherwise, the deque is bounded to the specified maximum length.  "
"Once a bounded length deque is full, when new items are added, a "
"corresponding number of items are discarded from the opposite end.  Bounded "
"length deques provide functionality similar to the ``tail`` filter in Unix. "
"They are also useful for tracking transactions and other pools of data where "
"only the most recent activity is of interest."
msgstr ""

#: ../../../library/collections.rst:186
msgid "Added *maxlen* parameter."
msgstr ""

#: ../../../library/collections.rst:189
msgid "Deque objects support the following methods:"
msgstr ""

#: ../../../library/collections.rst:194
msgid "Add *x* to the right side of the deque."
msgstr ""

#: ../../../library/collections.rst:199
msgid "Add *x* to the left side of the deque."
msgstr ""

#: ../../../library/collections.rst:204
msgid "Remove all elements from the deque leaving it with length 0."
msgstr ""

#: ../../../library/collections.rst:209
msgid ""
"Extend the right side of the deque by appending elements from the iterable "
"argument."
msgstr ""

#: ../../../library/collections.rst:215
msgid ""
"Extend the left side of the deque by appending elements from *iterable*. "
"Note, the series of left appends results in reversing the order of elements "
"in the iterable argument."
msgstr ""

#: ../../../library/collections.rst:222
msgid ""
"Remove and return an element from the right side of the deque. If no "
"elements are present, raises an :exc:`IndexError`."
msgstr ""

#: ../../../library/collections.rst:228
msgid ""
"Remove and return an element from the left side of the deque. If no elements "
"are present, raises an :exc:`IndexError`."
msgstr ""

#: ../../../library/collections.rst:234
msgid ""
"Removed the first occurrence of *value*.  If not found, raises a :exc:"
"`ValueError`."
msgstr ""

#: ../../../library/collections.rst:242
msgid ""
"Rotate the deque *n* steps to the right.  If *n* is negative, rotate to the "
"left.  Rotating one step to the right is equivalent to: ``d.appendleft(d."
"pop())``."
msgstr ""

#: ../../../library/collections.rst:247
msgid ""
"In addition to the above, deques support iteration, pickling, ``len(d)``, "
"``reversed(d)``, ``copy.copy(d)``, ``copy.deepcopy(d)``, membership testing "
"with the :keyword:`in` operator, and subscript references such as "
"``d[-1]``.  Indexed access is O(1) at both ends but slows to O(n) in the "
"middle.  For fast random access, use lists instead."
msgstr ""

#: ../../../library/collections.rst:253 ../../../library/collections.rst:503
msgid "Example:"
msgstr ""

#: ../../../library/collections.rst:255
msgid ""
">>> from collections import deque\n"
">>> d = deque('ghi')                 # make a new deque with three items\n"
">>> for elem in d:                   # iterate over the deque's elements\n"
"...     print elem.upper()\n"
"G\n"
"H\n"
"I\n"
"\n"
">>> d.append('j')                    # add a new entry to the right side\n"
">>> d.appendleft('f')                # add a new entry to the left side\n"
">>> d                                # show the representation of the deque\n"
"deque(['f', 'g', 'h', 'i', 'j'])\n"
"\n"
">>> d.pop()                          # return and remove the rightmost item\n"
"'j'\n"
">>> d.popleft()                      # return and remove the leftmost item\n"
"'f'\n"
">>> list(d)                          # list the contents of the deque\n"
"['g', 'h', 'i']\n"
">>> d[0]                             # peek at leftmost item\n"
"'g'\n"
">>> d[-1]                            # peek at rightmost item\n"
"'i'\n"
"\n"
">>> list(reversed(d))                # list the contents of a deque in "
"reverse\n"
"['i', 'h', 'g']\n"
">>> 'h' in d                         # search the deque\n"
"True\n"
">>> d.extend('jkl')                  # add multiple elements at once\n"
">>> d\n"
"deque(['g', 'h', 'i', 'j', 'k', 'l'])\n"
">>> d.rotate(1)                      # right rotation\n"
">>> d\n"
"deque(['l', 'g', 'h', 'i', 'j', 'k'])\n"
">>> d.rotate(-1)                     # left rotation\n"
">>> d\n"
"deque(['g', 'h', 'i', 'j', 'k', 'l'])\n"
"\n"
">>> deque(reversed(d))               # make a new deque in reverse order\n"
"deque(['l', 'k', 'j', 'i', 'h', 'g'])\n"
">>> d.clear()                        # empty the deque\n"
">>> d.pop()                          # cannot pop from an empty deque\n"
"Traceback (most recent call last):\n"
"  File \"<pyshell#6>\", line 1, in -toplevel-\n"
"    d.pop()\n"
"IndexError: pop from an empty deque\n"
"\n"
">>> d.extendleft('abc')              # extendleft() reverses the input "
"order\n"
">>> d\n"
"deque(['c', 'b', 'a'])"
msgstr ""

#: ../../../library/collections.rst:310
msgid ":class:`deque` Recipes"
msgstr ""

#: ../../../library/collections.rst:312
msgid "This section shows various approaches to working with deques."
msgstr ""

#: ../../../library/collections.rst:314
msgid ""
"Bounded length deques provide functionality similar to the ``tail`` filter "
"in Unix::"
msgstr ""

#: ../../../library/collections.rst:317
msgid ""
"def tail(filename, n=10):\n"
"    'Return the last n lines of a file'\n"
"    return deque(open(filename), n)"
msgstr ""

#: ../../../library/collections.rst:321
msgid ""
"Another approach to using deques is to maintain a sequence of recently added "
"elements by appending to the right and popping to the left::"
msgstr ""

#: ../../../library/collections.rst:324
msgid ""
"def moving_average(iterable, n=3):\n"
"    # moving_average([40, 30, 50, 46, 39, 44]) --> 40.0 42.0 45.0 43.0\n"
"    # http://en.wikipedia.org/wiki/Moving_average\n"
"    it = iter(iterable)\n"
"    d = deque(itertools.islice(it, n-1))\n"
"    d.appendleft(0)\n"
"    s = sum(d)\n"
"    for elem in it:\n"
"        s += elem - d.popleft()\n"
"        d.append(elem)\n"
"        yield s / float(n)"
msgstr ""

#: ../../../library/collections.rst:336
msgid ""
"The :meth:`rotate` method provides a way to implement :class:`deque` slicing "
"and deletion.  For example, a pure Python implementation of ``del d[n]`` "
"relies on the :meth:`rotate` method to position elements to be popped::"
msgstr ""

#: ../../../library/collections.rst:340
msgid ""
"def delete_nth(d, n):\n"
"    d.rotate(-n)\n"
"    d.popleft()\n"
"    d.rotate(n)"
msgstr ""

#: ../../../library/collections.rst:345
msgid ""
"To implement :class:`deque` slicing, use a similar approach applying :meth:"
"`rotate` to bring a target element to the left side of the deque. Remove old "
"entries with :meth:`popleft`, add new entries with :meth:`extend`, and then "
"reverse the rotation. With minor variations on that approach, it is easy to "
"implement Forth style stack manipulations such as ``dup``, ``drop``, "
"``swap``, ``over``, ``pick``, ``rot``, and ``roll``."
msgstr ""

#: ../../../library/collections.rst:355
msgid ":class:`defaultdict` objects"
msgstr ""

#: ../../../library/collections.rst:359
msgid ""
"Returns a new dictionary-like object.  :class:`defaultdict` is a subclass of "
"the built-in :class:`dict` class.  It overrides one method and adds one "
"writable instance variable.  The remaining functionality is the same as for "
"the :class:`dict` class and is not documented here."
msgstr ""

#: ../../../library/collections.rst:364
msgid ""
"The first argument provides the initial value for the :attr:"
"`default_factory` attribute; it defaults to ``None``. All remaining "
"arguments are treated the same as if they were passed to the :class:`dict` "
"constructor, including keyword arguments."
msgstr ""

#: ../../../library/collections.rst:371
msgid ""
":class:`defaultdict` objects support the following method in addition to the "
"standard :class:`dict` operations:"
msgstr ""

#: ../../../library/collections.rst:377
msgid ""
"If the :attr:`default_factory` attribute is ``None``, this raises a :exc:"
"`KeyError` exception with the *key* as argument."
msgstr ""

#: ../../../library/collections.rst:380
msgid ""
"If :attr:`default_factory` is not ``None``, it is called without arguments "
"to provide a default value for the given *key*, this value is inserted in "
"the dictionary for the *key*, and returned."
msgstr ""

#: ../../../library/collections.rst:384
msgid ""
"If calling :attr:`default_factory` raises an exception this exception is "
"propagated unchanged."
msgstr ""

#: ../../../library/collections.rst:387
msgid ""
"This method is called by the :meth:`__getitem__` method of the :class:`dict` "
"class when the requested key is not found; whatever it returns or raises is "
"then returned or raised by :meth:`__getitem__`."
msgstr ""

#: ../../../library/collections.rst:392
msgid ":class:`defaultdict` objects support the following instance variable:"
msgstr ""

#: ../../../library/collections.rst:397
msgid ""
"This attribute is used by the :meth:`__missing__` method; it is initialized "
"from the first argument to the constructor, if present, or to ``None``, if "
"absent."
msgstr ""

#: ../../../library/collections.rst:403
msgid ":class:`defaultdict` Examples"
msgstr ""

#: ../../../library/collections.rst:405
msgid ""
"Using :class:`list` as the :attr:`default_factory`, it is easy to group a "
"sequence of key-value pairs into a dictionary of lists:"
msgstr ""

#: ../../../library/collections.rst:416
msgid ""
"When each key is encountered for the first time, it is not already in the "
"mapping; so an entry is automatically created using the :attr:"
"`default_factory` function which returns an empty :class:`list`.  The :meth:"
"`list.append` operation then attaches the value to the new list.  When keys "
"are encountered again, the look-up proceeds normally (returning the list for "
"that key) and the :meth:`list.append` operation adds another value to the "
"list. This technique is simpler and faster than an equivalent technique "
"using :meth:`dict.setdefault`:"
msgstr ""

#: ../../../library/collections.rst:431
msgid ""
"Setting the :attr:`default_factory` to :class:`int` makes the :class:"
"`defaultdict` useful for counting (like a bag or multiset in other "
"languages):"
msgstr ""

#: ../../../library/collections.rst:443
msgid ""
"When a letter is first encountered, it is missing from the mapping, so the :"
"attr:`default_factory` function calls :func:`int` to supply a default count "
"of zero.  The increment operation then builds up the count for each letter."
msgstr ""

#: ../../../library/collections.rst:447
msgid ""
"The function :func:`int` which always returns zero is just a special case of "
"constant functions.  A faster and more flexible way to create constant "
"functions is to use :func:`itertools.repeat` which can supply any constant "
"value (not just zero):"
msgstr ""

#: ../../../library/collections.rst:459
msgid ""
"Setting the :attr:`default_factory` to :class:`set` makes the :class:"
"`defaultdict` useful for building a dictionary of sets:"
msgstr ""

#: ../../../library/collections.rst:472
msgid ":func:`namedtuple` Factory Function for Tuples with Named Fields"
msgstr ""

#: ../../../library/collections.rst:474
msgid ""
"Named tuples assign meaning to each position in a tuple and allow for more "
"readable, self-documenting code.  They can be used wherever regular tuples "
"are used, and they add the ability to access fields by name instead of "
"position index."
msgstr ""

#: ../../../library/collections.rst:480
msgid ""
"Returns a new tuple subclass named *typename*.  The new subclass is used to "
"create tuple-like objects that have fields accessible by attribute lookup as "
"well as being indexable and iterable.  Instances of the subclass also have a "
"helpful docstring (with typename and field_names) and a helpful :meth:"
"`__repr__` method which lists the tuple contents in a ``name=value`` format."
msgstr ""

#: ../../../library/collections.rst:486
msgid ""
"The *field_names* are a single string with each fieldname separated by "
"whitespace and/or commas, for example ``'x y'`` or ``'x, y'``.  "
"Alternatively, *field_names* can be a sequence of strings such as ``['x', "
"'y']``."
msgstr ""

#: ../../../library/collections.rst:490
msgid ""
"Any valid Python identifier may be used for a fieldname except for names "
"starting with an underscore.  Valid identifiers consist of letters, digits, "
"and underscores but do not start with a digit or underscore and cannot be a :"
"mod:`keyword` such as *class*, *for*, *return*, *global*, *pass*, *print*, "
"or *raise*."
msgstr ""

#: ../../../library/collections.rst:496
msgid ""
"If *verbose* is true, the class definition is printed just before being "
"built."
msgstr ""

#: ../../../library/collections.rst:498
msgid ""
"Named tuple instances do not have per-instance dictionaries, so they are "
"lightweight and require no more memory than regular tuples."
msgstr ""

#: ../../../library/collections.rst:505
msgid ""
">>> Point = namedtuple('Point', 'x y')\n"
">>> p = Point(11, y=22)     # instantiate with positional or keyword "
"arguments\n"
">>> p[0] + p[1]             # indexable like the plain tuple (11, 22)\n"
"33\n"
">>> x, y = p                # unpack like a regular tuple\n"
">>> x, y\n"
"(11, 22)\n"
">>> p.x + p.y               # fields also accessible by name\n"
"33\n"
">>> p                       # readable __repr__ with a name=value style\n"
"Point(x=11, y=22)\n"
"\n"
">>> Point = namedtuple('Point', 'x y', verbose=True) # show the class "
"definition\n"
"class Point(tuple):\n"
"        'Point(x, y)'\n"
"\n"
"        __slots__ = ()\n"
"\n"
"        _fields = ('x', 'y')\n"
"\n"
"        def __new__(_cls, x, y):\n"
"            return _tuple.__new__(_cls, (x, y))\n"
"\n"
"        @classmethod\n"
"        def _make(cls, iterable, new=tuple.__new__, len=len):\n"
"            'Make a new Point object from a sequence or iterable'\n"
"            result = new(cls, iterable)\n"
"            if len(result) != 2:\n"
"                raise TypeError('Expected 2 arguments, got %d' % "
"len(result))\n"
"            return result\n"
"\n"
"        def __repr__(self):\n"
"            return 'Point(x=%r, y=%r)' % self\n"
"\n"
"        def _asdict(t):\n"
"            'Return a new dict which maps field names to their values'\n"
"            return {'x': t[0], 'y': t[1]}\n"
"\n"
"        def _replace(_self, **kwds):\n"
"            'Return a new Point object replacing specified fields with new "
"values'\n"
"            result = _self._make(map(kwds.pop, ('x', 'y'), _self))\n"
"            if kwds:\n"
"                raise ValueError('Got unexpected field names: %r' % kwds."
"keys())\n"
"            return result\n"
"\n"
"        def __getnewargs__(self):\n"
"            return tuple(self)\n"
"\n"
"        x = _property(_itemgetter(0))\n"
"        y = _property(_itemgetter(1))"
msgstr ""

#: ../../../library/collections.rst:559
msgid ""
"Named tuples are especially useful for assigning field names to result "
"tuples returned by the :mod:`csv` or :mod:`sqlite3` modules::"
msgstr ""

#: ../../../library/collections.rst:562
msgid ""
"EmployeeRecord = namedtuple('EmployeeRecord', 'name, age, title, department, "
"paygrade')\n"
"\n"
"import csv\n"
"for emp in map(EmployeeRecord._make, csv.reader(open(\"employees.csv\", "
"\"rb\"))):\n"
"    print emp.name, emp.title\n"
"\n"
"import sqlite3\n"
"conn = sqlite3.connect('/companydata')\n"
"cursor = conn.cursor()\n"
"cursor.execute('SELECT name, age, title, department, paygrade FROM "
"employees')\n"
"for emp in map(EmployeeRecord._make, cursor.fetchall()):\n"
"    print emp.name, emp.title"
msgstr ""

#: ../../../library/collections.rst:575
msgid ""
"In addition to the methods inherited from tuples, named tuples support three "
"additional methods and one attribute.  To prevent conflicts with field "
"names, the method and attribute names start with an underscore."
msgstr ""

#: ../../../library/collections.rst:581
msgid ""
"Class method that makes a new instance from an existing sequence or iterable."
msgstr ""

#: ../../../library/collections.rst:583
msgid ""
">>> t = [11, 22]\n"
">>> Point._make(t)\n"
"Point(x=11, y=22)"
msgstr ""

#: ../../../library/collections.rst:591
msgid ""
"Return a new dict which maps field names to their corresponding values::"
msgstr ""

#: ../../../library/collections.rst:593
msgid ""
">>> p._asdict()\n"
"{'x': 11, 'y': 22}"
msgstr ""

#: ../../../library/collections.rst:598
msgid ""
"Return a new instance of the named tuple replacing specified fields with new "
"values::"
msgstr ""

#: ../../../library/collections.rst:601
msgid ""
">>> p = Point(x=11, y=22)\n"
">>> p._replace(x=33)\n"
"Point(x=33, y=22)\n"
"\n"
">>> for partnum, record in inventory.items():\n"
"...     inventory[partnum] = record._replace(price=newprices[partnum], "
"timestamp=time.now())"
msgstr ""

#: ../../../library/collections.rst:610
msgid ""
"Tuple of strings listing the field names.  Useful for introspection and for "
"creating new named tuple types from existing named tuples."
msgstr ""

#: ../../../library/collections.rst:613
msgid ""
">>> p._fields            # view the field names\n"
"('x', 'y')\n"
"\n"
">>> Color = namedtuple('Color', 'red green blue')\n"
">>> Pixel = namedtuple('Pixel', Point._fields + Color._fields)\n"
">>> Pixel(11, 22, 128, 255, 0)\n"
"Pixel(x=11, y=22, red=128, green=255, blue=0)"
msgstr ""

#: ../../../library/collections.rst:623
msgid ""
"To retrieve a field whose name is stored in a string, use the :func:"
"`getattr` function:"
msgstr ""

#: ../../../library/collections.rst:629
msgid ""
"To convert a dictionary to a named tuple, use the double-star-operator (as "
"described in :ref:`tut-unpacking-arguments`):"
msgstr ""

#: ../../../library/collections.rst:636
msgid ""
"Since a named tuple is a regular Python class, it is easy to add or change "
"functionality with a subclass.  Here is how to add a calculated field and a "
"fixed-width print format:"
msgstr ""

#: ../../../library/collections.rst:653
msgid ""
"The subclass shown above sets ``__slots__`` to an empty tuple.  This helps "
"keep memory requirements low by preventing the creation of instance "
"dictionaries."
msgstr ""

#: ../../../library/collections.rst:656
msgid ""
"Subclassing is not useful for adding new, stored fields.  Instead, simply "
"create a new named tuple type from the :attr:`_fields` attribute:"
msgstr ""

#: ../../../library/collections.rst:661
msgid ""
"Default values can be implemented by using :meth:`_replace` to customize a "
"prototype instance:"
msgstr ""

#: ../../../library/collections.rst:668
msgid ""
"Enumerated constants can be implemented with named tuples, but it is simpler "
"and more efficient to use a simple class declaration:"
msgstr ""

#: ../../../library/collections.rst:679
msgid ""
"`Named tuple recipe <http://code.activestate.com/recipes/500261/>`_ adapted "
"for Python 2.4."
msgstr ""

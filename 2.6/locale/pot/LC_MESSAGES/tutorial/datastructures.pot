# SOME DESCRIPTIVE TITLE.
# Copyright (C) 1990-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 2.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-11 04:42+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../tutorial/datastructures.rst:5
msgid "Data Structures"
msgstr ""

#: ../../../tutorial/datastructures.rst:7
msgid ""
"This chapter describes some things you've learned about already in more "
"detail, and adds some new things as well."
msgstr ""

#: ../../../tutorial/datastructures.rst:14
msgid "More on Lists"
msgstr ""

#: ../../../tutorial/datastructures.rst:16
msgid ""
"The list data type has some more methods.  Here are all of the methods of "
"list objects:"
msgstr ""

#: ../../../tutorial/datastructures.rst:23
msgid "Add an item to the end of the list; equivalent to ``a[len(a):] = [x]``."
msgstr ""

#: ../../../tutorial/datastructures.rst:29
msgid ""
"Extend the list by appending all the items in the given list; equivalent to "
"``a[len(a):] = L``."
msgstr ""

#: ../../../tutorial/datastructures.rst:36
msgid ""
"Insert an item at a given position.  The first argument is the index of the "
"element before which to insert, so ``a.insert(0, x)`` inserts at the front "
"of the list, and ``a.insert(len(a), x)`` is equivalent to ``a.append(x)``."
msgstr ""

#: ../../../tutorial/datastructures.rst:44
msgid ""
"Remove the first item from the list whose value is *x*. It is an error if "
"there is no such item."
msgstr ""

#: ../../../tutorial/datastructures.rst:51
msgid ""
"Remove the item at the given position in the list, and return it.  If no "
"index is specified, ``a.pop()`` removes and returns the last item in the "
"list.  (The square brackets around the *i* in the method signature denote "
"that the parameter is optional, not that you should type square brackets at "
"that position.  You will see this notation frequently in the Python Library "
"Reference.)"
msgstr ""

#: ../../../tutorial/datastructures.rst:61
msgid ""
"Return the index in the list of the first item whose value is *x*. It is an "
"error if there is no such item."
msgstr ""

#: ../../../tutorial/datastructures.rst:68
msgid "Return the number of times *x* appears in the list."
msgstr ""

#: ../../../tutorial/datastructures.rst:74
msgid "Sort the items of the list, in place."
msgstr ""

#: ../../../tutorial/datastructures.rst:80
msgid "Reverse the elements of the list, in place."
msgstr ""

#: ../../../tutorial/datastructures.rst:82
msgid "An example that uses most of the list methods::"
msgstr ""

#: ../../../tutorial/datastructures.rst:107
msgid "Using Lists as Stacks"
msgstr ""

#: ../../../tutorial/datastructures.rst:112
msgid ""
"The list methods make it very easy to use a list as a stack, where the last "
"element added is the first element retrieved (\"last-in, first-out\").  To "
"add an item to the top of the stack, use :meth:`append`.  To retrieve an "
"item from the top of the stack, use :meth:`pop` without an explicit index.  "
"For example::"
msgstr ""

#: ../../../tutorial/datastructures.rst:137
msgid "Using Lists as Queues"
msgstr ""

#: ../../../tutorial/datastructures.rst:141
msgid ""
"It is also possible to use a list as a queue, where the first element added "
"is the first element retrieved (\"first-in, first-out\"); however, lists are "
"not efficient for this purpose.  While appends and pops from the end of list "
"are fast, doing inserts or pops from the beginning of a list is slow "
"(because all of the other elements have to be shifted by one)."
msgstr ""

#: ../../../tutorial/datastructures.rst:147
msgid ""
"To implement a queue, use :class:`collections.deque` which was designed to "
"have fast appends and pops from both ends.  For example::"
msgstr ""

#: ../../../tutorial/datastructures.rst:165
msgid "Functional Programming Tools"
msgstr ""

#: ../../../tutorial/datastructures.rst:167
msgid ""
"There are three built-in functions that are very useful when used with "
"lists: :func:`filter`, :func:`map`, and :func:`reduce`."
msgstr ""

#: ../../../tutorial/datastructures.rst:170
msgid ""
"``filter(function, sequence)`` returns a sequence consisting of those items "
"from the sequence for which ``function(item)`` is true. If *sequence* is a :"
"class:`string` or :class:`tuple`, the result will be of the same type; "
"otherwise, it is always a :class:`list`. For example, to compute some "
"primes::"
msgstr ""

#: ../../../tutorial/datastructures.rst:180
msgid ""
"``map(function, sequence)`` calls ``function(item)`` for each of the "
"sequence's items and returns a list of the return values.  For example, to "
"compute some cubes::"
msgstr ""

#: ../../../tutorial/datastructures.rst:189
msgid ""
"More than one sequence may be passed; the function must then have as many "
"arguments as there are sequences and is called with the corresponding item "
"from each sequence (or ``None`` if some sequence is shorter than another).  "
"For example::"
msgstr ""

#: ../../../tutorial/datastructures.rst:200
msgid ""
"``reduce(function, sequence)`` returns a single value constructed by calling "
"the binary function *function* on the first two items of the sequence, then "
"on the result and the next item, and so on.  For example, to compute the sum "
"of the numbers 1 through 10::"
msgstr ""

#: ../../../tutorial/datastructures.rst:210
msgid ""
"If there's only one item in the sequence, its value is returned; if the "
"sequence is empty, an exception is raised."
msgstr ""

#: ../../../tutorial/datastructures.rst:213
msgid ""
"A third argument can be passed to indicate the starting value.  In this case "
"the starting value is returned for an empty sequence, and the function is "
"first applied to the starting value and the first sequence item, then to the "
"result and the next item, and so on.  For example, ::"
msgstr ""

#: ../../../tutorial/datastructures.rst:227
msgid ""
"Don't use this example's definition of :func:`sum`: since summing numbers is "
"such a common need, a built-in function ``sum(sequence)`` is already "
"provided, and works exactly like this."
msgstr ""

#: ../../../tutorial/datastructures.rst:235
msgid "List Comprehensions"
msgstr ""

#: ../../../tutorial/datastructures.rst:237
msgid ""
"List comprehensions provide a concise way to create lists without resorting "
"to use of :func:`map`, :func:`filter` and/or :keyword:`lambda`. The "
"resulting list definition tends often to be clearer than lists built using "
"those constructs. Each list comprehension consists of an expression followed "
"by a :keyword:`for` clause, then zero or more :keyword:`for` or :keyword:"
"`if` clauses.  The result will be a list resulting from evaluating the "
"expression in the context of the :keyword:`for` and :keyword:`if` clauses "
"which follow it.  If the expression would evaluate to a tuple, it must be "
"parenthesized. ::"
msgstr ""

#: ../../../tutorial/datastructures.rst:274
msgid ""
"List comprehensions are much more flexible than :func:`map` and can be "
"applied to complex expressions and nested functions::"
msgstr ""

#: ../../../tutorial/datastructures.rst:282
msgid "Nested List Comprehensions"
msgstr ""

#: ../../../tutorial/datastructures.rst:284
msgid ""
"If you've got the stomach for it, list comprehensions can be nested. They "
"are a powerful tool but -- like all powerful tools -- they need to be used "
"carefully, if at all."
msgstr ""

#: ../../../tutorial/datastructures.rst:288
msgid ""
"Consider the following example of a 3x3 matrix held as a list containing "
"three lists, one list per row::"
msgstr ""

#: ../../../tutorial/datastructures.rst:297
msgid ""
"Now, if you wanted to swap rows and columns, you could use a list "
"comprehension::"
msgstr ""

#: ../../../tutorial/datastructures.rst:303
msgid "Special care has to be taken for the *nested* list comprehension:"
msgstr ""

#: ../../../tutorial/datastructures.rst:305
msgid ""
"To avoid apprehension when nesting list comprehensions, read from right to "
"left."
msgstr ""

#: ../../../tutorial/datastructures.rst:308
msgid "A more verbose version of this snippet shows the flow explicitly::"
msgstr ""

#: ../../../tutorial/datastructures.rst:315
msgid ""
"In real world, you should prefer built-in functions to complex flow "
"statements. The :func:`zip` function would do a great job for this use case::"
msgstr ""

#: ../../../tutorial/datastructures.rst:321
msgid ""
"See :ref:`tut-unpacking-arguments` for details on the asterisk in this line."
msgstr ""

#: ../../../tutorial/datastructures.rst:326
msgid "The :keyword:`del` statement"
msgstr ""

#: ../../../tutorial/datastructures.rst:328
msgid ""
"There is a way to remove an item from a list given its index instead of its "
"value: the :keyword:`del` statement.  This differs from the :meth:`pop` "
"method which returns a value.  The :keyword:`del` statement can also be used "
"to remove slices from a list or clear the entire list (which we did earlier "
"by assignment of an empty list to the slice).  For example::"
msgstr ""

#: ../../../tutorial/datastructures.rst:345
msgid ":keyword:`del` can also be used to delete entire variables::"
msgstr ""

#: ../../../tutorial/datastructures.rst:349
msgid ""
"Referencing the name ``a`` hereafter is an error (at least until another "
"value is assigned to it).  We'll find other uses for :keyword:`del` later."
msgstr ""

#: ../../../tutorial/datastructures.rst:356
msgid "Tuples and Sequences"
msgstr ""

#: ../../../tutorial/datastructures.rst:358
msgid ""
"We saw that lists and strings have many common properties, such as indexing "
"and slicing operations.  They are two examples of *sequence* data types "
"(see :ref:`typesseq`).  Since Python is an evolving language, other sequence "
"data types may be added.  There is also another standard sequence data type: "
"the *tuple*."
msgstr ""

#: ../../../tutorial/datastructures.rst:364
msgid ""
"A tuple consists of a number of values separated by commas, for instance::"
msgstr ""

#: ../../../tutorial/datastructures.rst:376
msgid ""
"As you see, on output tuples are always enclosed in parentheses, so that "
"nested tuples are interpreted correctly; they may be input with or without "
"surrounding parentheses, although often parentheses are necessary anyway (if "
"the tuple is part of a larger expression)."
msgstr ""

#: ../../../tutorial/datastructures.rst:381
msgid ""
"Tuples have many uses.  For example: (x, y) coordinate pairs, employee "
"records from a database, etc.  Tuples, like strings, are immutable: it is "
"not possible to assign to the individual items of a tuple (you can simulate "
"much of the same effect with slicing and concatenation, though).  It is also "
"possible to create tuples which contain mutable objects, such as lists."
msgstr ""

#: ../../../tutorial/datastructures.rst:387
msgid ""
"A special problem is the construction of tuples containing 0 or 1 items: the "
"syntax has some extra quirks to accommodate these.  Empty tuples are "
"constructed by an empty pair of parentheses; a tuple with one item is "
"constructed by following a value with a comma (it is not sufficient to "
"enclose a single value in parentheses). Ugly, but effective.  For example::"
msgstr ""

#: ../../../tutorial/datastructures.rst:402
msgid ""
"The statement ``t = 12345, 54321, 'hello!'`` is an example of *tuple "
"packing*: the values ``12345``, ``54321`` and ``'hello!'`` are packed "
"together in a tuple. The reverse operation is also possible::"
msgstr ""

#: ../../../tutorial/datastructures.rst:408
msgid ""
"This is called, appropriately enough, *sequence unpacking* and works for any "
"sequence on the right-hand side.  Sequence unpacking requires the list of "
"variables on the left to have the same number of elements as the length of "
"the sequence.  Note that multiple assignment is really just a combination of "
"tuple packing and sequence unpacking."
msgstr ""

#: ../../../tutorial/datastructures.rst:420
msgid "Sets"
msgstr ""

#: ../../../tutorial/datastructures.rst:422
msgid ""
"Python also includes a data type for *sets*.  A set is an unordered "
"collection with no duplicate elements.  Basic uses include membership "
"testing and eliminating duplicate entries.  Set objects also support "
"mathematical operations like union, intersection, difference, and symmetric "
"difference."
msgstr ""

#: ../../../tutorial/datastructures.rst:427
msgid "Here is a brief demonstration::"
msgstr ""

#: ../../../tutorial/datastructures.rst:457
msgid "Dictionaries"
msgstr ""

#: ../../../tutorial/datastructures.rst:459
msgid ""
"Another useful data type built into Python is the *dictionary* (see :ref:"
"`typesmapping`). Dictionaries are sometimes found in other languages as "
"\"associative memories\" or \"associative arrays\".  Unlike sequences, which "
"are indexed by a range of numbers, dictionaries are indexed by *keys*, which "
"can be any immutable type; strings and numbers can always be keys.  Tuples "
"can be used as keys if they contain only strings, numbers, or tuples; if a "
"tuple contains any mutable object either directly or indirectly, it cannot "
"be used as a key. You can't use lists as keys, since lists can be modified "
"in place using index assignments, slice assignments, or methods like :meth:"
"`append` and :meth:`extend`."
msgstr ""

#: ../../../tutorial/datastructures.rst:470
msgid ""
"It is best to think of a dictionary as an unordered set of *key: value* "
"pairs, with the requirement that the keys are unique (within one "
"dictionary). A pair of braces creates an empty dictionary: ``{}``. Placing a "
"comma-separated list of key:value pairs within the braces adds initial key:"
"value pairs to the dictionary; this is also the way dictionaries are written "
"on output."
msgstr ""

#: ../../../tutorial/datastructures.rst:476
msgid ""
"The main operations on a dictionary are storing a value with some key and "
"extracting the value given the key.  It is also possible to delete a key:"
"value pair with ``del``. If you store using a key that is already in use, "
"the old value associated with that key is forgotten.  It is an error to "
"extract a value using a non-existent key."
msgstr ""

#: ../../../tutorial/datastructures.rst:482
msgid ""
"The :meth:`keys` method of a dictionary object returns a list of all the "
"keys used in the dictionary, in arbitrary order (if you want it sorted, just "
"apply the :meth:`sort` method to the list of keys).  To check whether a "
"single key is in the dictionary, use the :keyword:`in` keyword."
msgstr ""

#: ../../../tutorial/datastructures.rst:487
msgid "Here is a small example using a dictionary::"
msgstr ""

#: ../../../tutorial/datastructures.rst:504
msgid ""
"The :func:`dict` constructor builds dictionaries directly from lists of key-"
"value pairs stored as tuples.  When the pairs form a pattern, list "
"comprehensions can compactly specify the key-value list. ::"
msgstr ""

#: ../../../tutorial/datastructures.rst:513
msgid ""
"Later in the tutorial, we will learn about Generator Expressions which are "
"even better suited for the task of supplying key-values pairs to the :func:"
"`dict` constructor."
msgstr ""

#: ../../../tutorial/datastructures.rst:517
msgid ""
"When the keys are simple strings, it is sometimes easier to specify pairs "
"using keyword arguments::"
msgstr ""

#: ../../../tutorial/datastructures.rst:527
msgid "Looping Techniques"
msgstr ""

#: ../../../tutorial/datastructures.rst:529
msgid ""
"When looping through dictionaries, the key and corresponding value can be "
"retrieved at the same time using the :meth:`iteritems` method. ::"
msgstr ""

#: ../../../tutorial/datastructures.rst:539
msgid ""
"When looping through a sequence, the position index and corresponding value "
"can be retrieved at the same time using the :func:`enumerate` function. ::"
msgstr ""

#: ../../../tutorial/datastructures.rst:549
msgid ""
"To loop over two or more sequences at the same time, the entries can be "
"paired with the :func:`zip` function. ::"
msgstr ""

#: ../../../tutorial/datastructures.rst:561
msgid ""
"To loop over a sequence in reverse, first specify the sequence in a forward "
"direction and then call the :func:`reversed` function. ::"
msgstr ""

#: ../../../tutorial/datastructures.rst:573
msgid ""
"To loop over a sequence in sorted order, use the :func:`sorted` function "
"which returns a new sorted list while leaving the source unaltered. ::"
msgstr ""

#: ../../../tutorial/datastructures.rst:589
msgid "More on Conditions"
msgstr ""

#: ../../../tutorial/datastructures.rst:591
msgid ""
"The conditions used in ``while`` and ``if`` statements can contain any "
"operators, not just comparisons."
msgstr ""

#: ../../../tutorial/datastructures.rst:594
msgid ""
"The comparison operators ``in`` and ``not in`` check whether a value occurs "
"(does not occur) in a sequence.  The operators ``is`` and ``is not`` compare "
"whether two objects are really the same object; this only matters for "
"mutable objects like lists.  All comparison operators have the same "
"priority, which is lower than that of all numerical operators."
msgstr ""

#: ../../../tutorial/datastructures.rst:600
msgid ""
"Comparisons can be chained.  For example, ``a < b == c`` tests whether ``a`` "
"is less than ``b`` and moreover ``b`` equals ``c``."
msgstr ""

#: ../../../tutorial/datastructures.rst:603
msgid ""
"Comparisons may be combined using the Boolean operators ``and`` and ``or``, "
"and the outcome of a comparison (or of any other Boolean expression) may be "
"negated with ``not``.  These have lower priorities than comparison "
"operators; between them, ``not`` has the highest priority and ``or`` the "
"lowest, so that ``A and not B or C`` is equivalent to ``(A and (not B)) or "
"C``. As always, parentheses can be used to express the desired composition."
msgstr ""

#: ../../../tutorial/datastructures.rst:610
msgid ""
"The Boolean operators ``and`` and ``or`` are so-called *short-circuit* "
"operators: their arguments are evaluated from left to right, and evaluation "
"stops as soon as the outcome is determined.  For example, if ``A`` and ``C`` "
"are true but ``B`` is false, ``A and B and C`` does not evaluate the "
"expression ``C``.  When used as a general value and not as a Boolean, the "
"return value of a short-circuit operator is the last evaluated argument."
msgstr ""

#: ../../../tutorial/datastructures.rst:617
msgid ""
"It is possible to assign the result of a comparison or other Boolean "
"expression to a variable.  For example, ::"
msgstr ""

#: ../../../tutorial/datastructures.rst:625
msgid ""
"Note that in Python, unlike C, assignment cannot occur inside expressions. C "
"programmers may grumble about this, but it avoids a common class of problems "
"encountered in C programs: typing ``=`` in an expression when ``==`` was "
"intended."
msgstr ""

#: ../../../tutorial/datastructures.rst:634
msgid "Comparing Sequences and Other Types"
msgstr ""

#: ../../../tutorial/datastructures.rst:636
msgid ""
"Sequence objects may be compared to other objects with the same sequence "
"type. The comparison uses *lexicographical* ordering: first the first two "
"items are compared, and if they differ this determines the outcome of the "
"comparison; if they are equal, the next two items are compared, and so on, "
"until either sequence is exhausted. If two items to be compared are "
"themselves sequences of the same type, the lexicographical comparison is "
"carried out recursively.  If all items of two sequences compare equal, the "
"sequences are considered equal. If one sequence is an initial sub-sequence "
"of the other, the shorter sequence is the smaller (lesser) one.  "
"Lexicographical ordering for strings uses the ASCII ordering for individual "
"characters.  Some examples of comparisons between sequences of the same "
"type::"
msgstr ""

#: ../../../tutorial/datastructures.rst:656
msgid ""
"Note that comparing objects of different types is legal.  The outcome is "
"deterministic but arbitrary: the types are ordered by their name. Thus, a "
"list is always smaller than a string, a string is always smaller than a "
"tuple, etc. [#]_ Mixed numeric types are compared according to their numeric "
"value, so 0 equals 0.0, etc."
msgstr ""

#: ../../../tutorial/datastructures.rst:664
msgid "Footnotes"
msgstr ""

#: ../../../tutorial/datastructures.rst:665
msgid ""
"The rules for comparing objects of different types should not be relied "
"upon; they may change in a future version of the language."
msgstr ""

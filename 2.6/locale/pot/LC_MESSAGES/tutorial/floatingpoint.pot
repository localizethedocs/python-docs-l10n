# SOME DESCRIPTIVE TITLE.
# Copyright (C) 1990-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 2.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-10 15:09+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../tutorial/floatingpoint.rst:5
msgid "Floating Point Arithmetic:  Issues and Limitations"
msgstr ""

#: ../../../tutorial/floatingpoint.rst:10
msgid ""
"Floating-point numbers are represented in computer hardware as base 2 "
"(binary) fractions.  For example, the decimal fraction ::"
msgstr ""

#: ../../../tutorial/floatingpoint.rst:13
msgid "0.125"
msgstr ""

#: ../../../tutorial/floatingpoint.rst:15
msgid ""
"has value 1/10 + 2/100 + 5/1000, and in the same way the binary fraction ::"
msgstr ""

#: ../../../tutorial/floatingpoint.rst:17
msgid "0.001"
msgstr ""

#: ../../../tutorial/floatingpoint.rst:19
msgid ""
"has value 0/2 + 0/4 + 1/8.  These two fractions have identical values, the "
"only real difference being that the first is written in base 10 fractional "
"notation, and the second in base 2."
msgstr ""

#: ../../../tutorial/floatingpoint.rst:23
msgid ""
"Unfortunately, most decimal fractions cannot be represented exactly as "
"binary fractions.  A consequence is that, in general, the decimal floating-"
"point numbers you enter are only approximated by the binary floating-point "
"numbers actually stored in the machine."
msgstr ""

#: ../../../tutorial/floatingpoint.rst:28
msgid ""
"The problem is easier to understand at first in base 10.  Consider the "
"fraction 1/3.  You can approximate that as a base 10 fraction::"
msgstr ""

#: ../../../tutorial/floatingpoint.rst:31
msgid "0.3"
msgstr ""

#: ../../../tutorial/floatingpoint.rst:33
#: ../../../tutorial/floatingpoint.rst:37
msgid "or, better, ::"
msgstr ""

#: ../../../tutorial/floatingpoint.rst:35
msgid "0.33"
msgstr ""

#: ../../../tutorial/floatingpoint.rst:39
msgid "0.333"
msgstr ""

#: ../../../tutorial/floatingpoint.rst:41
msgid ""
"and so on.  No matter how many digits you're willing to write down, the "
"result will never be exactly 1/3, but will be an increasingly better "
"approximation of 1/3."
msgstr ""

#: ../../../tutorial/floatingpoint.rst:45
msgid ""
"In the same way, no matter how many base 2 digits you're willing to use, the "
"decimal value 0.1 cannot be represented exactly as a base 2 fraction.  In "
"base 2, 1/10 is the infinitely repeating fraction ::"
msgstr ""

#: ../../../tutorial/floatingpoint.rst:49
msgid "0.0001100110011001100110011001100110011001100110011..."
msgstr ""

#: ../../../tutorial/floatingpoint.rst:51
msgid ""
"Stop at any finite number of bits, and you get an approximation.  This is "
"why you see things like::"
msgstr ""

#: ../../../tutorial/floatingpoint.rst:54
#: ../../../tutorial/floatingpoint.rst:97
#: ../../../tutorial/floatingpoint.rst:153
msgid ""
">>> 0.1\n"
"0.10000000000000001"
msgstr ""

#: ../../../tutorial/floatingpoint.rst:57
msgid ""
"On most machines today, that is what you'll see if you enter 0.1 at a Python "
"prompt.  You may not, though, because the number of bits used by the "
"hardware to store floating-point values can vary across machines, and Python "
"only prints a decimal approximation to the true decimal value of the binary "
"approximation stored by the machine.  On most machines, if Python were to "
"print the true decimal value of the binary approximation stored for 0.1, it "
"would have to display ::"
msgstr ""

#: ../../../tutorial/floatingpoint.rst:65
msgid ""
">>> 0.1\n"
"0.1000000000000000055511151231257827021181583404541015625"
msgstr ""

#: ../../../tutorial/floatingpoint.rst:68
msgid ""
"instead!  The Python prompt uses the built-in :func:`repr` function to "
"obtain a string version of everything it displays.  For floats, "
"``repr(float)`` rounds the true decimal value to 17 significant digits, "
"giving ::"
msgstr ""

#: ../../../tutorial/floatingpoint.rst:72
msgid "0.10000000000000001"
msgstr ""

#: ../../../tutorial/floatingpoint.rst:74
msgid ""
"``repr(float)`` produces 17 significant digits because it turns out that's "
"enough (on most machines) so that ``eval(repr(x)) == x`` exactly for all "
"finite floats *x*, but rounding to 16 digits is not enough to make that true."
msgstr ""

#: ../../../tutorial/floatingpoint.rst:78
msgid ""
"Note that this is in the very nature of binary floating-point: this is not a "
"bug in Python, and it is not a bug in your code either.  You'll see the same "
"kind of thing in all languages that support your hardware's floating-point "
"arithmetic (although some languages may not *display* the difference by "
"default, or in all output modes)."
msgstr ""

#: ../../../tutorial/floatingpoint.rst:84
msgid ""
"Python's built-in :func:`str` function produces only 12 significant digits, "
"and you may wish to use that instead.  It's unusual for ``eval(str(x))`` to "
"reproduce *x*, but the output may be more pleasant to look at::"
msgstr ""

#: ../../../tutorial/floatingpoint.rst:88
msgid ""
">>> print str(0.1)\n"
"0.1"
msgstr ""

#: ../../../tutorial/floatingpoint.rst:91
msgid ""
"It's important to realize that this is, in a real sense, an illusion: the "
"value in the machine is not exactly 1/10, you're simply rounding the "
"*display* of the true machine value."
msgstr ""

#: ../../../tutorial/floatingpoint.rst:95
msgid "Other surprises follow from this one.  For example, after seeing ::"
msgstr ""

#: ../../../tutorial/floatingpoint.rst:100
msgid ""
"you may be tempted to use the :func:`round` function to chop it back to the "
"single digit you expect.  But that makes no difference::"
msgstr ""

#: ../../../tutorial/floatingpoint.rst:103
msgid ""
">>> round(0.1, 1)\n"
"0.10000000000000001"
msgstr ""

#: ../../../tutorial/floatingpoint.rst:106
msgid ""
"The problem is that the binary floating-point value stored for \"0.1\" was "
"already the best possible binary approximation to 1/10, so trying to round "
"it again can't make it better:  it was already as good as it gets."
msgstr ""

#: ../../../tutorial/floatingpoint.rst:110
msgid ""
"Another consequence is that since 0.1 is not exactly 1/10, summing ten "
"values of 0.1 may not yield exactly 1.0, either::"
msgstr ""

#: ../../../tutorial/floatingpoint.rst:113
msgid ""
">>> sum = 0.0\n"
">>> for i in range(10):\n"
"...     sum += 0.1\n"
"...\n"
">>> sum\n"
"0.99999999999999989"
msgstr ""

#: ../../../tutorial/floatingpoint.rst:120
msgid ""
"Binary floating-point arithmetic holds many surprises like this.  The "
"problem with \"0.1\" is explained in precise detail below, in the "
"\"Representation Error\" section.  See `The Perils of Floating Point <http://"
"www.lahey.com/float.htm>`_ for a more complete account of other common "
"surprises."
msgstr ""

#: ../../../tutorial/floatingpoint.rst:125
msgid ""
"As that says near the end, \"there are no easy answers.\"  Still, don't be "
"unduly wary of floating-point!  The errors in Python float operations are "
"inherited from the floating-point hardware, and on most machines are on the "
"order of no more than 1 part in 2\\*\\*53 per operation.  That's more than "
"adequate for most tasks, but you do need to keep in mind that it's not "
"decimal arithmetic, and that every float operation can suffer a new rounding "
"error."
msgstr ""

#: ../../../tutorial/floatingpoint.rst:132
msgid ""
"While pathological cases do exist, for most casual use of floating-point "
"arithmetic you'll see the result you expect in the end if you simply round "
"the display of your final results to the number of decimal digits you "
"expect. :func:`str` usually suffices, and for finer control see the :meth:"
"`str.format` method's format specifiers in :ref:`formatstrings`."
msgstr ""

#: ../../../tutorial/floatingpoint.rst:142
msgid "Representation Error"
msgstr ""

#: ../../../tutorial/floatingpoint.rst:144
msgid ""
"This section explains the \"0.1\" example in detail, and shows how you can "
"perform an exact analysis of cases like this yourself.  Basic familiarity "
"with binary floating-point representation is assumed."
msgstr ""

#: ../../../tutorial/floatingpoint.rst:148
msgid ""
":dfn:`Representation error` refers to the fact that some (most, actually) "
"decimal fractions cannot be represented exactly as binary (base 2) "
"fractions. This is the chief reason why Python (or Perl, C, C++, Java, "
"Fortran, and many others) often won't display the exact decimal number you "
"expect::"
msgstr ""

#: ../../../tutorial/floatingpoint.rst:156
msgid ""
"Why is that?  1/10 is not exactly representable as a binary fraction. Almost "
"all machines today (November 2000) use IEEE-754 floating point arithmetic, "
"and almost all platforms map Python floats to IEEE-754 \"double "
"precision\".  754 doubles contain 53 bits of precision, so on input the "
"computer strives to convert 0.1 to the closest fraction it can of the form "
"*J*/2**\\ *N* where *J* is an integer containing exactly 53 bits.  "
"Rewriting ::"
msgstr ""

#: ../../../tutorial/floatingpoint.rst:163
msgid "1 / 10 ~= J / (2**N)"
msgstr ""

#: ../../../tutorial/floatingpoint.rst:165
msgid "as ::"
msgstr ""

#: ../../../tutorial/floatingpoint.rst:167
msgid "J ~= 2**N / 10"
msgstr ""

#: ../../../tutorial/floatingpoint.rst:169
msgid ""
"and recalling that *J* has exactly 53 bits (is ``>= 2**52`` but ``< "
"2**53``), the best value for *N* is 56::"
msgstr ""

#: ../../../tutorial/floatingpoint.rst:172
msgid ""
">>> 2**52\n"
"4503599627370496L\n"
">>> 2**53\n"
"9007199254740992L\n"
">>> 2**56/10\n"
"7205759403792793L"
msgstr ""

#: ../../../tutorial/floatingpoint.rst:179
msgid ""
"That is, 56 is the only value for *N* that leaves *J* with exactly 53 bits.  "
"The best possible value for *J* is then that quotient rounded::"
msgstr ""

#: ../../../tutorial/floatingpoint.rst:182
msgid ""
">>> q, r = divmod(2**56, 10)\n"
">>> r\n"
"6L"
msgstr ""

#: ../../../tutorial/floatingpoint.rst:186
msgid ""
"Since the remainder is more than half of 10, the best approximation is "
"obtained by rounding up::"
msgstr ""

#: ../../../tutorial/floatingpoint.rst:189
msgid ""
">>> q+1\n"
"7205759403792794L"
msgstr ""

#: ../../../tutorial/floatingpoint.rst:192
msgid ""
"Therefore the best possible approximation to 1/10 in 754 double precision is "
"that over 2\\*\\*56, or ::"
msgstr ""

#: ../../../tutorial/floatingpoint.rst:195
msgid "7205759403792794 / 72057594037927936"
msgstr ""

#: ../../../tutorial/floatingpoint.rst:197
msgid ""
"Note that since we rounded up, this is actually a little bit larger than "
"1/10; if we had not rounded up, the quotient would have been a little bit "
"smaller than 1/10.  But in no case can it be *exactly* 1/10!"
msgstr ""

#: ../../../tutorial/floatingpoint.rst:201
msgid ""
"So the computer never \"sees\" 1/10:  what it sees is the exact fraction "
"given above, the best 754 double approximation it can get::"
msgstr ""

#: ../../../tutorial/floatingpoint.rst:204
msgid ""
">>> .1 * 2**56\n"
"7205759403792794.0"
msgstr ""

#: ../../../tutorial/floatingpoint.rst:207
msgid ""
"If we multiply that fraction by 10\\*\\*30, we can see the (truncated) value "
"of its 30 most significant decimal digits::"
msgstr ""

#: ../../../tutorial/floatingpoint.rst:210
msgid ""
">>> 7205759403792794 * 10**30 / 2**56\n"
"100000000000000005551115123125L"
msgstr ""

#: ../../../tutorial/floatingpoint.rst:213
msgid ""
"meaning that the exact number stored in the computer is approximately equal "
"to the decimal value 0.100000000000000005551115123125.  Rounding that to 17 "
"significant digits gives the 0.10000000000000001 that Python displays (well, "
"will display on any 754-conforming platform that does best-possible input "
"and output conversions in its C library --- yours may not!)."
msgstr ""
